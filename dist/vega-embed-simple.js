var mL = Object.defineProperty;
var yL = (e, t, n) => t in e ? mL(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var bL = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var e_ = (e, t, n) => yL(e, typeof t != "symbol" ? t + "" : t, n);
var The = bL((yge, YE) => {
  /*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2022 Joachim Wester
   * MIT licensed
   */
  var vL = /* @__PURE__ */ function() {
    var e = function(t, n) {
      return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
        i.__proto__ = r;
      } || function(i, r) {
        for (var o in r) r.hasOwnProperty(o) && (i[o] = r[o]);
      }, e(t, n);
    };
    return function(t, n) {
      e(t, n);
      function i() {
        this.constructor = t;
      }
      t.prototype = n === null ? Object.create(n) : (i.prototype = n.prototype, new i());
    };
  }(), xL = Object.prototype.hasOwnProperty;
  function b1(e, t) {
    return xL.call(e, t);
  }
  function v1(e) {
    if (Array.isArray(e)) {
      for (var t = new Array(e.length), n = 0; n < t.length; n++)
        t[n] = "" + n;
      return t;
    }
    if (Object.keys)
      return Object.keys(e);
    var i = [];
    for (var r in e)
      b1(e, r) && i.push(r);
    return i;
  }
  function Mn(e) {
    switch (typeof e) {
      case "object":
        return JSON.parse(JSON.stringify(e));
      case "undefined":
        return null;
      default:
        return e;
    }
  }
  function x1(e) {
    for (var t = 0, n = e.length, i; t < n; ) {
      if (i = e.charCodeAt(t), i >= 48 && i <= 57) {
        t++;
        continue;
      }
      return !1;
    }
    return !0;
  }
  function Es(e) {
    return e.indexOf("/") === -1 && e.indexOf("~") === -1 ? e : e.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function kC(e) {
    return e.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  function w1(e) {
    if (e === void 0)
      return !0;
    if (e) {
      if (Array.isArray(e)) {
        for (var t = 0, n = e.length; t < n; t++)
          if (w1(e[t]))
            return !0;
      } else if (typeof e == "object") {
        for (var i = v1(e), r = i.length, o = 0; o < r; o++)
          if (w1(e[i[o]]))
            return !0;
      }
    }
    return !1;
  }
  function t_(e, t) {
    var n = [e];
    for (var i in t) {
      var r = typeof t[i] == "object" ? JSON.stringify(t[i], null, 2) : t[i];
      typeof r < "u" && n.push(i + ": " + r);
    }
    return n.join(`
`);
  }
  var AC = (
    /** @class */
    function(e) {
      vL(t, e);
      function t(n, i, r, o, s) {
        var a = this.constructor, u = e.call(this, t_(n, { name: i, index: r, operation: o, tree: s })) || this;
        return u.name = i, u.index = r, u.operation = o, u.tree = s, Object.setPrototypeOf(u, a.prototype), u.message = t_(n, { name: i, index: r, operation: o, tree: s }), u;
      }
      return t;
    }(Error)
  ), Ye = AC, wL = Mn, Wa = {
    add: function(e, t, n) {
      return e[t] = this.value, { newDocument: n };
    },
    remove: function(e, t, n) {
      var i = e[t];
      return delete e[t], { newDocument: n, removed: i };
    },
    replace: function(e, t, n) {
      var i = e[t];
      return e[t] = this.value, { newDocument: n, removed: i };
    },
    move: function(e, t, n) {
      var i = uh(n, this.path);
      i && (i = Mn(i));
      var r = Os(n, { op: "remove", path: this.from }).removed;
      return Os(n, { op: "add", path: this.path, value: r }), { newDocument: n, removed: i };
    },
    copy: function(e, t, n) {
      var i = uh(n, this.from);
      return Os(n, { op: "add", path: this.path, value: Mn(i) }), { newDocument: n };
    },
    test: function(e, t, n) {
      return { newDocument: n, test: Sc(e[t], this.value) };
    },
    _get: function(e, t, n) {
      return this.value = e[t], { newDocument: n };
    }
  }, EL = {
    add: function(e, t, n) {
      return x1(t) ? e.splice(t, 0, this.value) : e[t] = this.value, { newDocument: n, index: t };
    },
    remove: function(e, t, n) {
      var i = e.splice(t, 1);
      return { newDocument: n, removed: i[0] };
    },
    replace: function(e, t, n) {
      var i = e[t];
      return e[t] = this.value, { newDocument: n, removed: i };
    },
    move: Wa.move,
    copy: Wa.copy,
    test: Wa.test,
    _get: Wa._get
  };
  function uh(e, t) {
    if (t == "")
      return e;
    var n = { op: "_get", path: t };
    return Os(e, n), n.value;
  }
  function Os(e, t, n, i, r, o) {
    if (n === void 0 && (n = !1), i === void 0 && (i = !0), r === void 0 && (r = !0), o === void 0 && (o = 0), n && (typeof n == "function" ? n(t, 0, e, t.path) : lh(t, 0)), t.path === "") {
      var s = { newDocument: e };
      if (t.op === "add")
        return s.newDocument = t.value, s;
      if (t.op === "replace")
        return s.newDocument = t.value, s.removed = e, s;
      if (t.op === "move" || t.op === "copy")
        return s.newDocument = uh(e, t.from), t.op === "move" && (s.removed = e), s;
      if (t.op === "test") {
        if (s.test = Sc(e, t.value), s.test === !1)
          throw new Ye("Test operation failed", "TEST_OPERATION_FAILED", o, t, e);
        return s.newDocument = e, s;
      } else {
        if (t.op === "remove")
          return s.removed = e, s.newDocument = null, s;
        if (t.op === "_get")
          return t.value = e, s;
        if (n)
          throw new Ye("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", o, t, e);
        return s;
      }
    } else {
      i || (e = Mn(e));
      var a = t.path || "", u = a.split("/"), l = e, c = 1, f = u.length, d = void 0, h = void 0, g = void 0;
      for (typeof n == "function" ? g = n : g = lh; ; ) {
        if (h = u[c], h && h.indexOf("~") != -1 && (h = kC(h)), r && (h == "__proto__" || h == "prototype" && c > 0 && u[c - 1] == "constructor"))
          throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
        if (n && d === void 0 && (l[h] === void 0 ? d = u.slice(0, c).join("/") : c == f - 1 && (d = t.path), d !== void 0 && g(t, 0, e, d)), c++, Array.isArray(l)) {
          if (h === "-")
            h = l.length;
          else {
            if (n && !x1(h))
              throw new Ye("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", o, t, e);
            x1(h) && (h = ~~h);
          }
          if (c >= f) {
            if (n && t.op === "add" && h > l.length)
              throw new Ye("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", o, t, e);
            var s = EL[t.op].call(t, l, h, e);
            if (s.test === !1)
              throw new Ye("Test operation failed", "TEST_OPERATION_FAILED", o, t, e);
            return s;
          }
        } else if (c >= f) {
          var s = Wa[t.op].call(t, l, h, e);
          if (s.test === !1)
            throw new Ye("Test operation failed", "TEST_OPERATION_FAILED", o, t, e);
          return s;
        }
        if (l = l[h], n && c < f && (!l || typeof l != "object"))
          throw new Ye("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", o, t, e);
      }
    }
  }
  function Ug(e, t, n, i, r) {
    if (i === void 0 && (i = !0), r === void 0 && (r = !0), n && !Array.isArray(t))
      throw new Ye("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    i || (e = Mn(e));
    for (var o = new Array(t.length), s = 0, a = t.length; s < a; s++)
      o[s] = Os(e, t[s], n, !0, r, s), e = o[s].newDocument;
    return o.newDocument = e, o;
  }
  function _L(e, t, n) {
    var i = Os(e, t);
    if (i.test === !1)
      throw new Ye("Test operation failed", "TEST_OPERATION_FAILED", n, t, e);
    return i.newDocument;
  }
  function lh(e, t, n, i) {
    if (typeof e != "object" || e === null || Array.isArray(e))
      throw new Ye("Operation is not an object", "OPERATION_NOT_AN_OBJECT", t, e, n);
    if (Wa[e.op]) {
      if (typeof e.path != "string")
        throw new Ye("Operation `path` property is not a string", "OPERATION_PATH_INVALID", t, e, n);
      if (e.path.indexOf("/") !== 0 && e.path.length > 0)
        throw new Ye('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", t, e, n);
      if ((e.op === "move" || e.op === "copy") && typeof e.from != "string")
        throw new Ye("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", t, e, n);
      if ((e.op === "add" || e.op === "replace" || e.op === "test") && e.value === void 0)
        throw new Ye("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", t, e, n);
      if ((e.op === "add" || e.op === "replace" || e.op === "test") && w1(e.value))
        throw new Ye("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", t, e, n);
      if (n) {
        if (e.op == "add") {
          var r = e.path.split("/").length, o = i.split("/").length;
          if (r !== o + 1 && r !== o)
            throw new Ye("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", t, e, n);
        } else if (e.op === "replace" || e.op === "remove" || e.op === "_get") {
          if (e.path !== i)
            throw new Ye("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", t, e, n);
        } else if (e.op === "move" || e.op === "copy") {
          var s = { op: "_get", path: e.from, value: void 0 }, a = CC([s], n);
          if (a && a.name === "OPERATION_PATH_UNRESOLVABLE")
            throw new Ye("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", t, e, n);
        }
      }
    } else throw new Ye("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", t, e, n);
  }
  function CC(e, t, n) {
    try {
      if (!Array.isArray(e))
        throw new Ye("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
      if (t)
        Ug(Mn(t), Mn(e), n || !0);
      else {
        n = n || lh;
        for (var i = 0; i < e.length; i++)
          n(e[i], i, t, void 0);
      }
    } catch (r) {
      if (r instanceof Ye)
        return r;
      throw r;
    }
  }
  function Sc(e, t) {
    if (e === t)
      return !0;
    if (e && t && typeof e == "object" && typeof t == "object") {
      var n = Array.isArray(e), i = Array.isArray(t), r, o, s;
      if (n && i) {
        if (o = e.length, o != t.length)
          return !1;
        for (r = o; r-- !== 0; )
          if (!Sc(e[r], t[r]))
            return !1;
        return !0;
      }
      if (n != i)
        return !1;
      var a = Object.keys(e);
      if (o = a.length, o !== Object.keys(t).length)
        return !1;
      for (r = o; r-- !== 0; )
        if (!t.hasOwnProperty(a[r]))
          return !1;
      for (r = o; r-- !== 0; )
        if (s = a[r], !Sc(e[s], t[s]))
          return !1;
      return !0;
    }
    return e !== e && t !== t;
  }
  const SL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    JsonPatchError: Ye,
    _areEquals: Sc,
    applyOperation: Os,
    applyPatch: Ug,
    applyReducer: _L,
    deepClone: wL,
    getValueByPointer: uh,
    validate: CC,
    validator: lh
  }, Symbol.toStringTag, { value: "Module" }));
  /*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2021 Joachim Wester
   * MIT license
   */
  var Db = /* @__PURE__ */ new WeakMap(), $L = (
    /** @class */
    /* @__PURE__ */ function() {
      function e(t) {
        this.observers = /* @__PURE__ */ new Map(), this.obj = t;
      }
      return e;
    }()
  ), kL = (
    /** @class */
    /* @__PURE__ */ function() {
      function e(t, n) {
        this.callback = t, this.observer = n;
      }
      return e;
    }()
  );
  function AL(e) {
    return Db.get(e);
  }
  function CL(e, t) {
    return e.observers.get(t);
  }
  function FL(e, t) {
    e.observers.delete(t.callback);
  }
  function ML(e, t) {
    t.unobserve();
  }
  function TL(e, t) {
    var n = [], i, r = AL(e);
    if (!r)
      r = new $L(e), Db.set(e, r);
    else {
      var o = CL(r, t);
      i = o && o.observer;
    }
    if (i)
      return i;
    if (i = {}, r.value = Mn(e), t) {
      i.callback = t, i.next = null;
      var s = function() {
        E1(i);
      }, a = function() {
        clearTimeout(i.next), i.next = setTimeout(s);
      };
      typeof window < "u" && (window.addEventListener("mouseup", a), window.addEventListener("keyup", a), window.addEventListener("mousedown", a), window.addEventListener("keydown", a), window.addEventListener("change", a));
    }
    return i.patches = n, i.object = e, i.unobserve = function() {
      E1(i), clearTimeout(i.next), FL(r, i), typeof window < "u" && (window.removeEventListener("mouseup", a), window.removeEventListener("keyup", a), window.removeEventListener("mousedown", a), window.removeEventListener("keydown", a), window.removeEventListener("change", a));
    }, r.observers.set(t, new kL(t, i)), i;
  }
  function E1(e, t) {
    t === void 0 && (t = !1);
    var n = Db.get(e.object);
    Nb(n.value, e.object, e.patches, "", t), e.patches.length && Ug(n.value, e.patches);
    var i = e.patches;
    return i.length > 0 && (e.patches = [], e.callback && e.callback(i)), i;
  }
  function Nb(e, t, n, i, r) {
    if (t !== e) {
      typeof t.toJSON == "function" && (t = t.toJSON());
      for (var o = v1(t), s = v1(e), a = !1, u = s.length - 1; u >= 0; u--) {
        var l = s[u], c = e[l];
        if (b1(t, l) && !(t[l] === void 0 && c !== void 0 && Array.isArray(t) === !1)) {
          var f = t[l];
          typeof c == "object" && c != null && typeof f == "object" && f != null && Array.isArray(c) === Array.isArray(f) ? Nb(c, f, n, i + "/" + Es(l), r) : c !== f && (r && n.push({ op: "test", path: i + "/" + Es(l), value: Mn(c) }), n.push({ op: "replace", path: i + "/" + Es(l), value: Mn(f) }));
        } else Array.isArray(e) === Array.isArray(t) ? (r && n.push({ op: "test", path: i + "/" + Es(l), value: Mn(c) }), n.push({ op: "remove", path: i + "/" + Es(l) }), a = !0) : (r && n.push({ op: "test", path: i, value: e }), n.push({ op: "replace", path: i, value: t }));
      }
      if (!(!a && o.length == s.length))
        for (var u = 0; u < o.length; u++) {
          var l = o[u];
          !b1(e, l) && t[l] !== void 0 && n.push({ op: "add", path: i + "/" + Es(l), value: Mn(t[l]) });
        }
    }
  }
  function DL(e, t, n) {
    n === void 0 && (n = !1);
    var i = [];
    return Nb(e, t, i, "", n), i;
  }
  const NL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    compare: DL,
    generate: E1,
    observe: TL,
    unobserve: ML
  }, Symbol.toStringTag, { value: "Module" }));
  Object.assign({}, SL, NL, {
    JsonPatchError: AC,
    deepClone: Mn,
    escapePathComponent: Es,
    unescapePathComponent: kC
  });
  function OL(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
  }
  var RL = /("(?:[^\\"]|\\.)*")|[:,]/g, LL = function(t, n) {
    var i, r, o;
    return n = n || {}, i = JSON.stringify(
      [1],
      void 0,
      n.indent === void 0 ? 2 : n.indent
    ).slice(2, -3), r = i === "" ? 1 / 0 : n.maxLength === void 0 ? 80 : n.maxLength, o = n.replacer, function s(a, u, l) {
      var c, f, d, h, g, p, m, y, b, v, x, w;
      if (a && typeof a.toJSON == "function" && (a = a.toJSON()), x = JSON.stringify(a, o), x === void 0)
        return x;
      if (m = r - u.length - l, x.length <= m && (b = x.replace(
        RL,
        function(_, E) {
          return E || _ + " ";
        }
      ), b.length <= m))
        return b;
      if (o != null && (a = JSON.parse(x), o = void 0), typeof a == "object" && a !== null) {
        if (y = u + i, d = [], f = 0, Array.isArray(a))
          for (v = "[", c = "]", m = a.length; f < m; f++)
            d.push(
              s(a[f], y, f === m - 1 ? 0 : 1) || "null"
            );
        else
          for (v = "{", c = "}", p = Object.keys(a), m = p.length; f < m; f++)
            h = p[f], g = JSON.stringify(h) + ": ", w = s(
              a[h],
              y,
              g.length + (f === m - 1 ? 0 : 1)
            ), w !== void 0 && d.push(g + w);
        if (d.length > 0)
          return [v, i + d.join(`,
` + y), c].join(
            `
` + u
          );
      }
      return x;
    }(t, "", 0);
  };
  const Vm = /* @__PURE__ */ OL(LL);
  function Sn(e, t, n) {
    return e.fields = t || [], e.fname = n, e;
  }
  function Je(e) {
    return e == null ? null : e.fname;
  }
  function Ut(e) {
    return e == null ? null : e.fields;
  }
  function FC(e) {
    return e.length === 1 ? PL(e[0]) : IL(e);
  }
  const PL = (e) => function(t) {
    return t[e];
  }, IL = (e) => {
    const t = e.length;
    return function(n) {
      for (let i = 0; i < t; ++i)
        n = n[e[i]];
      return n;
    };
  };
  function R(e) {
    throw Error(e);
  }
  function fr(e) {
    const t = [], n = e.length;
    let i = null, r = 0, o = "", s, a, u;
    e = e + "";
    function l() {
      t.push(o + e.substring(s, a)), o = "", s = a + 1;
    }
    for (s = a = 0; a < n; ++a)
      if (u = e[a], u === "\\")
        o += e.substring(s, a++), s = a;
      else if (u === i)
        l(), i = null, r = -1;
      else {
        if (i)
          continue;
        s === r && u === '"' || s === r && u === "'" ? (s = a + 1, i = u) : u === "." && !r ? a > s ? l() : s = a + 1 : u === "[" ? (a > s && l(), r = s = a + 1) : u === "]" && (r || R("Access path missing open bracket: " + e), r > 0 && l(), r = 0, s = a + 1);
      }
    return r && R("Access path missing closing bracket: " + e), i && R("Access path missing closing quote: " + e), a > s && (a++, l()), t;
  }
  function Kn(e, t, n) {
    const i = fr(e);
    return e = i.length === 1 ? i[0] : e, Sn((n && n.get || FC)(i), [e], t || e);
  }
  const tf = Kn("id"), Ht = Sn((e) => e, [], "identity"), bo = Sn(() => 0, [], "zero"), qu = Sn(() => 1, [], "one"), Jn = Sn(() => !0, [], "true"), lo = Sn(() => !1, [], "false");
  function zL(e, t, n) {
    const i = [t].concat([].slice.call(n));
    console[e].apply(console, i);
  }
  const MC = 0, Ob = 1, Rb = 2, TC = 3, DC = 4;
  function Lb(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : zL, i = e || MC;
    return {
      level(r) {
        return arguments.length ? (i = +r, this) : i;
      },
      error() {
        return i >= Ob && n(t || "error", "ERROR", arguments), this;
      },
      warn() {
        return i >= Rb && n(t || "warn", "WARN", arguments), this;
      },
      info() {
        return i >= TC && n(t || "log", "INFO", arguments), this;
      },
      debug() {
        return i >= DC && n(t || "log", "DEBUG", arguments), this;
      }
    };
  }
  var P = Array.isArray;
  function Y(e) {
    return e === Object(e);
  }
  const n_ = (e) => e !== "__proto__";
  function Wu() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return t.reduce((i, r) => {
      for (const o in r)
        if (o === "signals")
          i.signals = BL(i.signals, r.signals);
        else {
          const s = o === "legend" ? {
            layout: 1
          } : o === "style" ? !0 : null;
          Hu(i, o, r[o], s);
        }
      return i;
    }, {});
  }
  function Hu(e, t, n, i) {
    if (!n_(t)) return;
    let r, o;
    if (Y(n) && !P(n)) {
      o = Y(e[t]) ? e[t] : e[t] = {};
      for (r in n)
        i && (i === !0 || i[r]) ? Hu(o, r, n[r]) : n_(r) && (o[r] = n[r]);
    } else
      e[t] = n;
  }
  function BL(e, t) {
    if (e == null) return t;
    const n = {}, i = [];
    function r(o) {
      n[o.name] || (n[o.name] = 1, i.push(o));
    }
    return t.forEach(r), e.forEach(r), i;
  }
  function xe(e) {
    return e[e.length - 1];
  }
  function zt(e) {
    return e == null || e === "" ? null : +e;
  }
  const NC = (e) => (t) => e * Math.exp(t), OC = (e) => (t) => Math.log(e * t), RC = (e) => (t) => Math.sign(t) * Math.log1p(Math.abs(t / e)), LC = (e) => (t) => Math.sign(t) * Math.expm1(Math.abs(t)) * e, ch = (e) => (t) => t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  function jg(e, t, n, i) {
    const r = n(e[0]), o = n(xe(e)), s = (o - r) * t;
    return [i(r - s), i(o - s)];
  }
  function PC(e, t) {
    return jg(e, t, zt, Ht);
  }
  function IC(e, t) {
    var n = Math.sign(e[0]);
    return jg(e, t, OC(n), NC(n));
  }
  function zC(e, t, n) {
    return jg(e, t, ch(n), ch(1 / n));
  }
  function BC(e, t, n) {
    return jg(e, t, RC(n), LC(n));
  }
  function qg(e, t, n, i, r) {
    const o = i(e[0]), s = i(xe(e)), a = t != null ? i(t) : (o + s) / 2;
    return [r(a + (o - a) * n), r(a + (s - a) * n)];
  }
  function Pb(e, t, n) {
    return qg(e, t, n, zt, Ht);
  }
  function Ib(e, t, n) {
    const i = Math.sign(e[0]);
    return qg(e, t, n, OC(i), NC(i));
  }
  function fh(e, t, n, i) {
    return qg(e, t, n, ch(i), ch(1 / i));
  }
  function zb(e, t, n, i) {
    return qg(e, t, n, RC(i), LC(i));
  }
  function UC(e) {
    return 1 + ~~(new Date(e).getMonth() / 3);
  }
  function jC(e) {
    return 1 + ~~(new Date(e).getUTCMonth() / 3);
  }
  function X(e) {
    return e != null ? P(e) ? e : [e] : [];
  }
  function qC(e, t, n) {
    let i = e[0], r = e[1], o;
    return r < i && (o = r, r = i, i = o), o = r - i, o >= n - t ? [t, n] : [i = Math.min(Math.max(i, t), n - o), i + o];
  }
  function fe(e) {
    return typeof e == "function";
  }
  const UL = "descending";
  function Bb(e, t, n) {
    n = n || {}, t = X(t) || [];
    const i = [], r = [], o = {}, s = n.comparator || jL;
    return X(e).forEach((a, u) => {
      a != null && (i.push(t[u] === UL ? -1 : 1), r.push(a = fe(a) ? a : Kn(a, null, n)), (Ut(a) || []).forEach((l) => o[l] = 1));
    }), r.length === 0 ? null : Sn(s(r, i), Object.keys(o));
  }
  const Wg = (e, t) => (e < t || e == null) && t != null ? -1 : (e > t || t == null) && e != null ? 1 : (t = t instanceof Date ? +t : t, (e = e instanceof Date ? +e : e) !== e && t === t ? -1 : t !== t && e === e ? 1 : 0), jL = (e, t) => e.length === 1 ? qL(e[0], t[0]) : WL(e, t, e.length), qL = (e, t) => function(n, i) {
    return Wg(e(n), e(i)) * t;
  }, WL = (e, t, n) => (t.push(0), function(i, r) {
    let o, s = 0, a = -1;
    for (; s === 0 && ++a < n; )
      o = e[a], s = Wg(o(i), o(r));
    return s * t[a];
  });
  function Gt(e) {
    return fe(e) ? e : () => e;
  }
  function Ub(e, t) {
    let n;
    return (i) => {
      n && clearTimeout(n), n = setTimeout(() => (t(i), n = null), e);
    };
  }
  function ce(e) {
    for (let t, n, i = 1, r = arguments.length; i < r; ++i) {
      t = arguments[i];
      for (n in t)
        e[n] = t[n];
    }
    return e;
  }
  function nr(e, t) {
    let n = 0, i, r, o, s;
    if (e && (i = e.length))
      if (t == null) {
        for (r = e[n]; n < i && (r == null || r !== r); r = e[++n]) ;
        for (o = s = r; n < i; ++n)
          r = e[n], r != null && (r < o && (o = r), r > s && (s = r));
      } else {
        for (r = t(e[n]); n < i && (r == null || r !== r); r = t(e[++n])) ;
        for (o = s = r; n < i; ++n)
          r = t(e[n]), r != null && (r < o && (o = r), r > s && (s = r));
      }
    return [o, s];
  }
  function WC(e, t) {
    const n = e.length;
    let i = -1, r, o, s, a, u;
    if (t == null) {
      for (; ++i < n; )
        if (o = e[i], o != null && o >= o) {
          r = s = o;
          break;
        }
      if (i === n) return [-1, -1];
      for (a = u = i; ++i < n; )
        o = e[i], o != null && (r > o && (r = o, a = i), s < o && (s = o, u = i));
    } else {
      for (; ++i < n; )
        if (o = t(e[i], i, e), o != null && o >= o) {
          r = s = o;
          break;
        }
      if (i === n) return [-1, -1];
      for (a = u = i; ++i < n; )
        o = t(e[i], i, e), o != null && (r > o && (r = o, a = i), s < o && (s = o, u = i));
    }
    return [a, u];
  }
  const HL = Object.prototype.hasOwnProperty;
  function J(e, t) {
    return HL.call(e, t);
  }
  const Xf = {};
  function Gu(e) {
    let t = {}, n;
    function i(o) {
      return J(t, o) && t[o] !== Xf;
    }
    const r = {
      size: 0,
      empty: 0,
      object: t,
      has: i,
      get(o) {
        return i(o) ? t[o] : void 0;
      },
      set(o, s) {
        return i(o) || (++r.size, t[o] === Xf && --r.empty), t[o] = s, this;
      },
      delete(o) {
        return i(o) && (--r.size, ++r.empty, t[o] = Xf), this;
      },
      clear() {
        r.size = r.empty = 0, r.object = t = {};
      },
      test(o) {
        return arguments.length ? (n = o, r) : n;
      },
      clean() {
        const o = {};
        let s = 0;
        for (const a in t) {
          const u = t[a];
          u !== Xf && (!n || !n(u)) && (o[a] = u, ++s);
        }
        r.size = s, r.empty = 0, r.object = t = o;
      }
    };
    return e && Object.keys(e).forEach((o) => {
      r.set(o, e[o]);
    }), r;
  }
  function HC(e, t, n, i, r, o) {
    if (!n && n !== 0) return o;
    const s = +n;
    let a = e[0], u = xe(e), l;
    u < a && (l = a, a = u, u = l), l = Math.abs(t - a);
    const c = Math.abs(u - t);
    return l < c && l <= s ? i : c <= s ? r : o;
  }
  function G(e, t, n) {
    const i = e.prototype = Object.create(t.prototype);
    return Object.defineProperty(i, "constructor", {
      value: e,
      writable: !0,
      enumerable: !0,
      configurable: !0
    }), ce(i, n);
  }
  function Ha(e, t, n, i) {
    let r = t[0], o = t[t.length - 1], s;
    return r > o && (s = r, r = o, o = s), n = n === void 0 || n, i = i === void 0 || i, (n ? r <= e : r < e) && (i ? e <= o : e < o);
  }
  function Ko(e) {
    return typeof e == "boolean";
  }
  function Co(e) {
    return Object.prototype.toString.call(e) === "[object Date]";
  }
  function GC(e) {
    return e && fe(e[Symbol.iterator]);
  }
  function $e(e) {
    return typeof e == "number";
  }
  function VC(e) {
    return Object.prototype.toString.call(e) === "[object RegExp]";
  }
  function K(e) {
    return typeof e == "string";
  }
  function jb(e, t, n) {
    e && (e = t ? X(e).map((a) => a.replace(/\\(.)/g, "$1")) : X(e));
    const i = e && e.length, r = n && n.get || FC, o = (a) => r(t ? [a] : fr(a));
    let s;
    if (!i)
      s = function() {
        return "";
      };
    else if (i === 1) {
      const a = o(e[0]);
      s = function(u) {
        return "" + a(u);
      };
    } else {
      const a = e.map(o);
      s = function(u) {
        let l = "" + a[0](u), c = 0;
        for (; ++c < i; ) l += "|" + a[c](u);
        return l;
      };
    }
    return Sn(s, e, "key");
  }
  function YC(e, t) {
    const n = e[0], i = xe(e), r = +t;
    return r ? r === 1 ? i : n + r * (i - n) : n;
  }
  const GL = 1e4;
  function XC(e) {
    e = +e || GL;
    let t, n, i;
    const r = () => {
      t = {}, n = {}, i = 0;
    }, o = (s, a) => (++i > e && (n = t, t = {}, i = 1), t[s] = a);
    return r(), {
      clear: r,
      has: (s) => J(t, s) || J(n, s),
      get: (s) => J(t, s) ? t[s] : J(n, s) ? o(s, n[s]) : void 0,
      set: (s, a) => J(t, s) ? t[s] = a : o(s, a)
    };
  }
  function KC(e, t, n, i) {
    const r = t.length, o = n.length;
    if (!o) return t;
    if (!r) return n;
    const s = i || new t.constructor(r + o);
    let a = 0, u = 0, l = 0;
    for (; a < r && u < o; ++l)
      s[l] = e(t[a], n[u]) > 0 ? n[u++] : t[a++];
    for (; a < r; ++a, ++l)
      s[l] = t[a];
    for (; u < o; ++u, ++l)
      s[l] = n[u];
    return s;
  }
  function Bl(e, t) {
    let n = "";
    for (; --t >= 0; ) n += e;
    return n;
  }
  function JC(e, t, n, i) {
    const r = n || " ", o = e + "", s = t - o.length;
    return s <= 0 ? o : i === "left" ? Bl(r, s) + o : i === "center" ? Bl(r, ~~(s / 2)) + o + Bl(r, Math.ceil(s / 2)) : o + Bl(r, s);
  }
  function nf(e) {
    return e && xe(e) - e[0] || 0;
  }
  function H(e) {
    return P(e) ? "[" + e.map(H) + "]" : Y(e) || K(e) ? (
      // Output valid JSON and JS source strings.
      // See http://timelessrepo.com/json-isnt-a-javascript-subset
      JSON.stringify(e).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029")
    ) : e;
  }
  function qb(e) {
    return e == null || e === "" ? null : !e || e === "false" || e === "0" ? !1 : !!e;
  }
  const VL = (e) => $e(e) || Co(e) ? e : Date.parse(e);
  function Wb(e, t) {
    return t = t || VL, e == null || e === "" ? null : t(e);
  }
  function Hb(e) {
    return e == null || e === "" ? null : e + "";
  }
  function wi(e) {
    const t = {}, n = e.length;
    for (let i = 0; i < n; ++i) t[e[i]] = !0;
    return t;
  }
  function QC(e, t, n, i) {
    const r = i ?? "…", o = e + "", s = o.length, a = Math.max(0, t - r.length);
    return s <= t ? o : n === "left" ? r + o.slice(s - a) : n === "center" ? o.slice(0, Math.ceil(a / 2)) + r + o.slice(s - ~~(a / 2)) : o.slice(0, a) + r;
  }
  function ho(e, t, n) {
    if (e)
      if (t) {
        const i = e.length;
        for (let r = 0; r < i; ++r) {
          const o = t(e[r]);
          o && n(o, r, e);
        }
      } else
        e.forEach(n);
  }
  var i_ = {}, Ym = {}, Xm = 34, pl = 10, Km = 13;
  function ZC(e) {
    return new Function("d", "return {" + e.map(function(t, n) {
      return JSON.stringify(t) + ": d[" + n + '] || ""';
    }).join(",") + "}");
  }
  function YL(e, t) {
    var n = ZC(e);
    return function(i, r) {
      return t(n(i), r, e);
    };
  }
  function r_(e) {
    var t = /* @__PURE__ */ Object.create(null), n = [];
    return e.forEach(function(i) {
      for (var r in i)
        r in t || n.push(t[r] = r);
    }), n;
  }
  function fn(e, t) {
    var n = e + "", i = n.length;
    return i < t ? new Array(t - i + 1).join(0) + n : n;
  }
  function XL(e) {
    return e < 0 ? "-" + fn(-e, 6) : e > 9999 ? "+" + fn(e, 6) : fn(e, 4);
  }
  function KL(e) {
    var t = e.getUTCHours(), n = e.getUTCMinutes(), i = e.getUTCSeconds(), r = e.getUTCMilliseconds();
    return isNaN(e) ? "Invalid Date" : XL(e.getUTCFullYear()) + "-" + fn(e.getUTCMonth() + 1, 2) + "-" + fn(e.getUTCDate(), 2) + (r ? "T" + fn(t, 2) + ":" + fn(n, 2) + ":" + fn(i, 2) + "." + fn(r, 3) + "Z" : i ? "T" + fn(t, 2) + ":" + fn(n, 2) + ":" + fn(i, 2) + "Z" : n || t ? "T" + fn(t, 2) + ":" + fn(n, 2) + "Z" : "");
  }
  function JL(e) {
    var t = new RegExp('["' + e + `
\r]`), n = e.charCodeAt(0);
    function i(f, d) {
      var h, g, p = r(f, function(m, y) {
        if (h) return h(m, y - 1);
        g = m, h = d ? YL(m, d) : ZC(m);
      });
      return p.columns = g || [], p;
    }
    function r(f, d) {
      var h = [], g = f.length, p = 0, m = 0, y, b = g <= 0, v = !1;
      f.charCodeAt(g - 1) === pl && --g, f.charCodeAt(g - 1) === Km && --g;
      function x() {
        if (b) return Ym;
        if (v) return v = !1, i_;
        var _, E = p, S;
        if (f.charCodeAt(E) === Xm) {
          for (; p++ < g && f.charCodeAt(p) !== Xm || f.charCodeAt(++p) === Xm; ) ;
          return (_ = p) >= g ? b = !0 : (S = f.charCodeAt(p++)) === pl ? v = !0 : S === Km && (v = !0, f.charCodeAt(p) === pl && ++p), f.slice(E + 1, _ - 1).replace(/""/g, '"');
        }
        for (; p < g; ) {
          if ((S = f.charCodeAt(_ = p++)) === pl) v = !0;
          else if (S === Km)
            v = !0, f.charCodeAt(p) === pl && ++p;
          else if (S !== n) continue;
          return f.slice(E, _);
        }
        return b = !0, f.slice(E, g);
      }
      for (; (y = x()) !== Ym; ) {
        for (var w = []; y !== i_ && y !== Ym; ) w.push(y), y = x();
        d && (w = d(w, m++)) == null || h.push(w);
      }
      return h;
    }
    function o(f, d) {
      return f.map(function(h) {
        return d.map(function(g) {
          return c(h[g]);
        }).join(e);
      });
    }
    function s(f, d) {
      return d == null && (d = r_(f)), [d.map(c).join(e)].concat(o(f, d)).join(`
`);
    }
    function a(f, d) {
      return d == null && (d = r_(f)), o(f, d).join(`
`);
    }
    function u(f) {
      return f.map(l).join(`
`);
    }
    function l(f) {
      return f.map(c).join(e);
    }
    function c(f) {
      return f == null ? "" : f instanceof Date ? KL(f) : t.test(f += "") ? '"' + f.replace(/"/g, '""') + '"' : f;
    }
    return {
      parse: i,
      parseRows: r,
      format: s,
      formatBody: a,
      formatRows: u,
      formatRow: l,
      formatValue: c
    };
  }
  function QL(e) {
    return e;
  }
  function ZL(e) {
    if (e == null) return QL;
    var t, n, i = e.scale[0], r = e.scale[1], o = e.translate[0], s = e.translate[1];
    return function(a, u) {
      u || (t = n = 0);
      var l = 2, c = a.length, f = new Array(c);
      for (f[0] = (t += a[0]) * i + o, f[1] = (n += a[1]) * r + s; l < c; ) f[l] = a[l], ++l;
      return f;
    };
  }
  function eP(e, t) {
    for (var n, i = e.length, r = i - t; r < --i; ) n = e[r], e[r++] = e[i], e[i] = n;
  }
  function tP(e, t) {
    return typeof t == "string" && (t = e.objects[t]), t.type === "GeometryCollection" ? { type: "FeatureCollection", features: t.geometries.map(function(n) {
      return o_(e, n);
    }) } : o_(e, t);
  }
  function o_(e, t) {
    var n = t.id, i = t.bbox, r = t.properties == null ? {} : t.properties, o = eF(e, t);
    return n == null && i == null ? { type: "Feature", properties: r, geometry: o } : i == null ? { type: "Feature", id: n, properties: r, geometry: o } : { type: "Feature", id: n, bbox: i, properties: r, geometry: o };
  }
  function eF(e, t) {
    var n = ZL(e.transform), i = e.arcs;
    function r(c, f) {
      f.length && f.pop();
      for (var d = i[c < 0 ? ~c : c], h = 0, g = d.length; h < g; ++h)
        f.push(n(d[h], h));
      c < 0 && eP(f, g);
    }
    function o(c) {
      return n(c);
    }
    function s(c) {
      for (var f = [], d = 0, h = c.length; d < h; ++d) r(c[d], f);
      return f.length < 2 && f.push(f[0]), f;
    }
    function a(c) {
      for (var f = s(c); f.length < 4; ) f.push(f[0]);
      return f;
    }
    function u(c) {
      return c.map(a);
    }
    function l(c) {
      var f = c.type, d;
      switch (f) {
        case "GeometryCollection":
          return { type: f, geometries: c.geometries.map(l) };
        case "Point":
          d = o(c.coordinates);
          break;
        case "MultiPoint":
          d = c.coordinates.map(o);
          break;
        case "LineString":
          d = s(c.arcs);
          break;
        case "MultiLineString":
          d = c.arcs.map(s);
          break;
        case "Polygon":
          d = u(c.arcs);
          break;
        case "MultiPolygon":
          d = c.arcs.map(u);
          break;
        default:
          return null;
      }
      return { type: f, coordinates: d };
    }
    return l(t);
  }
  function nP(e, t) {
    var n = {}, i = {}, r = {}, o = [], s = -1;
    t.forEach(function(l, c) {
      var f = e.arcs[l < 0 ? ~l : l], d;
      f.length < 3 && !f[1][0] && !f[1][1] && (d = t[++s], t[s] = l, t[c] = d);
    }), t.forEach(function(l) {
      var c = a(l), f = c[0], d = c[1], h, g;
      if (h = r[f])
        if (delete r[h.end], h.push(l), h.end = d, g = i[d]) {
          delete i[g.start];
          var p = g === h ? h : h.concat(g);
          i[p.start = h.start] = r[p.end = g.end] = p;
        } else
          i[h.start] = r[h.end] = h;
      else if (h = i[d])
        if (delete i[h.start], h.unshift(l), h.start = f, g = r[f]) {
          delete r[g.end];
          var m = g === h ? h : g.concat(h);
          i[m.start = g.start] = r[m.end = h.end] = m;
        } else
          i[h.start] = r[h.end] = h;
      else
        h = [l], i[h.start = f] = r[h.end = d] = h;
    });
    function a(l) {
      var c = e.arcs[l < 0 ? ~l : l], f = c[0], d;
      return e.transform ? (d = [0, 0], c.forEach(function(h) {
        d[0] += h[0], d[1] += h[1];
      })) : d = c[c.length - 1], l < 0 ? [d, f] : [f, d];
    }
    function u(l, c) {
      for (var f in l) {
        var d = l[f];
        delete c[d.start], delete d.start, delete d.end, d.forEach(function(h) {
          n[h < 0 ? ~h : h] = 1;
        }), o.push(d);
      }
    }
    return u(r, i), u(i, r), t.forEach(function(l) {
      n[l < 0 ? ~l : l] || o.push([l]);
    }), o;
  }
  function iP(e) {
    return eF(e, rP.apply(this, arguments));
  }
  function rP(e, t, n) {
    var i, r, o;
    if (arguments.length > 1) i = oP(e, t, n);
    else for (r = 0, i = new Array(o = e.arcs.length); r < o; ++r) i[r] = r;
    return { type: "MultiLineString", arcs: nP(e, i) };
  }
  function oP(e, t, n) {
    var i = [], r = [], o;
    function s(f) {
      var d = f < 0 ? ~f : f;
      (r[d] || (r[d] = [])).push({ i: f, g: o });
    }
    function a(f) {
      f.forEach(s);
    }
    function u(f) {
      f.forEach(a);
    }
    function l(f) {
      f.forEach(u);
    }
    function c(f) {
      switch (o = f, f.type) {
        case "GeometryCollection":
          f.geometries.forEach(c);
          break;
        case "LineString":
          a(f.arcs);
          break;
        case "MultiLineString":
        case "Polygon":
          u(f.arcs);
          break;
        case "MultiPolygon":
          l(f.arcs);
          break;
      }
    }
    return c(t), r.forEach(n == null ? function(f) {
      i.push(f[0].i);
    } : function(f) {
      n(f[0].g, f[f.length - 1].g) && i.push(f[0].i);
    }), i;
  }
  function zr(e, t) {
    return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
  }
  function sP(e, t) {
    return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
  }
  function Vu(e) {
    let t, n, i;
    e.length !== 2 ? (t = zr, n = (a, u) => zr(e(a), u), i = (a, u) => e(a) - u) : (t = e === zr || e === sP ? e : aP, n = e, i = e);
    function r(a, u, l = 0, c = a.length) {
      if (l < c) {
        if (t(u, u) !== 0) return c;
        do {
          const f = l + c >>> 1;
          n(a[f], u) < 0 ? l = f + 1 : c = f;
        } while (l < c);
      }
      return l;
    }
    function o(a, u, l = 0, c = a.length) {
      if (l < c) {
        if (t(u, u) !== 0) return c;
        do {
          const f = l + c >>> 1;
          n(a[f], u) <= 0 ? l = f + 1 : c = f;
        } while (l < c);
      }
      return l;
    }
    function s(a, u, l = 0, c = a.length) {
      const f = r(a, u, l, c - 1);
      return f > l && i(a[f - 1], u) > -i(a[f], u) ? f - 1 : f;
    }
    return { left: r, center: s, right: o };
  }
  function aP() {
    return 0;
  }
  function tF(e) {
    return e === null ? NaN : +e;
  }
  function* uP(e, t) {
    if (t === void 0)
      for (let n of e)
        n != null && (n = +n) >= n && (yield n);
    else {
      let n = -1;
      for (let i of e)
        (i = t(i, ++n, e)) != null && (i = +i) >= i && (yield i);
    }
  }
  const nF = Vu(zr), Oo = nF.right, lP = nF.left;
  Vu(tF).center;
  function cP(e, t) {
    let n = 0, i, r = 0, o = 0;
    if (t === void 0)
      for (let s of e)
        s != null && (s = +s) >= s && (i = s - r, r += i / ++n, o += i * (s - r));
    else {
      let s = -1;
      for (let a of e)
        (a = t(a, ++s, e)) != null && (a = +a) >= a && (i = a - r, r += i / ++n, o += i * (a - r));
    }
    if (n > 1) return o / (n - 1);
  }
  function fP(e, t) {
    const n = cP(e, t);
    return n && Math.sqrt(n);
  }
  class rn {
    constructor() {
      this._partials = new Float64Array(32), this._n = 0;
    }
    add(t) {
      const n = this._partials;
      let i = 0;
      for (let r = 0; r < this._n && r < 32; r++) {
        const o = n[r], s = t + o, a = Math.abs(t) < Math.abs(o) ? t - (s - o) : o - (s - t);
        a && (n[i++] = a), t = s;
      }
      return n[i] = t, this._n = i + 1, this;
    }
    valueOf() {
      const t = this._partials;
      let n = this._n, i, r, o, s = 0;
      if (n > 0) {
        for (s = t[--n]; n > 0 && (i = s, r = t[--n], s = i + r, o = r - (s - i), !o); )
          ;
        n > 0 && (o < 0 && t[n - 1] < 0 || o > 0 && t[n - 1] > 0) && (r = o * 2, i = s + r, r == i - s && (s = i));
      }
      return s;
    }
  }
  class s_ extends Map {
    constructor(t, n = oF) {
      if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null) for (const [i, r] of t) this.set(i, r);
    }
    get(t) {
      return super.get(_1(this, t));
    }
    has(t) {
      return super.has(_1(this, t));
    }
    set(t, n) {
      return super.set(iF(this, t), n);
    }
    delete(t) {
      return super.delete(rF(this, t));
    }
  }
  class dh extends Set {
    constructor(t, n = oF) {
      if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null) for (const i of t) this.add(i);
    }
    has(t) {
      return super.has(_1(this, t));
    }
    add(t) {
      return super.add(iF(this, t));
    }
    delete(t) {
      return super.delete(rF(this, t));
    }
  }
  function _1({ _intern: e, _key: t }, n) {
    const i = t(n);
    return e.has(i) ? e.get(i) : n;
  }
  function iF({ _intern: e, _key: t }, n) {
    const i = t(n);
    return e.has(i) ? e.get(i) : (e.set(i, n), n);
  }
  function rF({ _intern: e, _key: t }, n) {
    const i = t(n);
    return e.has(i) && (n = e.get(i), e.delete(i)), n;
  }
  function oF(e) {
    return e !== null && typeof e == "object" ? e.valueOf() : e;
  }
  function dP(e, t) {
    return Array.from(t, (n) => e[n]);
  }
  function hP(e = zr) {
    if (e === zr) return sF;
    if (typeof e != "function") throw new TypeError("compare is not a function");
    return (t, n) => {
      const i = e(t, n);
      return i || i === 0 ? i : (e(n, n) === 0) - (e(t, t) === 0);
    };
  }
  function sF(e, t) {
    return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);
  }
  const gP = Math.sqrt(50), pP = Math.sqrt(10), mP = Math.sqrt(2);
  function hh(e, t, n) {
    const i = (t - e) / Math.max(0, n), r = Math.floor(Math.log10(i)), o = i / Math.pow(10, r), s = o >= gP ? 10 : o >= pP ? 5 : o >= mP ? 2 : 1;
    let a, u, l;
    return r < 0 ? (l = Math.pow(10, -r) / s, a = Math.round(e * l), u = Math.round(t * l), a / l < e && ++a, u / l > t && --u, l = -l) : (l = Math.pow(10, r) * s, a = Math.round(e / l), u = Math.round(t / l), a * l < e && ++a, u * l > t && --u), u < a && 0.5 <= n && n < 2 ? hh(e, t, n * 2) : [a, u, l];
  }
  function S1(e, t, n) {
    if (t = +t, e = +e, n = +n, !(n > 0)) return [];
    if (e === t) return [e];
    const i = t < e, [r, o, s] = i ? hh(t, e, n) : hh(e, t, n);
    if (!(o >= r)) return [];
    const a = o - r + 1, u = new Array(a);
    if (i)
      if (s < 0) for (let l = 0; l < a; ++l) u[l] = (o - l) / -s;
      else for (let l = 0; l < a; ++l) u[l] = (o - l) * s;
    else if (s < 0) for (let l = 0; l < a; ++l) u[l] = (r + l) / -s;
    else for (let l = 0; l < a; ++l) u[l] = (r + l) * s;
    return u;
  }
  function $1(e, t, n) {
    return t = +t, e = +e, n = +n, hh(e, t, n)[2];
  }
  function Ro(e, t, n) {
    t = +t, e = +e, n = +n;
    const i = t < e, r = i ? $1(t, e, n) : $1(e, t, n);
    return (i ? -1 : 1) * (r < 0 ? 1 / -r : r);
  }
  function Rs(e, t) {
    let n;
    if (t === void 0)
      for (const i of e)
        i != null && (n < i || n === void 0 && i >= i) && (n = i);
    else {
      let i = -1;
      for (let r of e)
        (r = t(r, ++i, e)) != null && (n < r || n === void 0 && r >= r) && (n = r);
    }
    return n;
  }
  function k1(e, t) {
    let n;
    if (t === void 0)
      for (const i of e)
        i != null && (n > i || n === void 0 && i >= i) && (n = i);
    else {
      let i = -1;
      for (let r of e)
        (r = t(r, ++i, e)) != null && (n > r || n === void 0 && r >= r) && (n = r);
    }
    return n;
  }
  function aF(e, t, n = 0, i = 1 / 0, r) {
    if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), i = Math.floor(Math.min(e.length - 1, i)), !(n <= t && t <= i)) return e;
    for (r = r === void 0 ? sF : hP(r); i > n; ) {
      if (i - n > 600) {
        const u = i - n + 1, l = t - n + 1, c = Math.log(u), f = 0.5 * Math.exp(2 * c / 3), d = 0.5 * Math.sqrt(c * f * (u - f) / u) * (l - u / 2 < 0 ? -1 : 1), h = Math.max(n, Math.floor(t - l * f / u + d)), g = Math.min(i, Math.floor(t + (u - l) * f / u + d));
        aF(e, t, h, g, r);
      }
      const o = e[t];
      let s = n, a = i;
      for (ml(e, n, t), r(e[i], o) > 0 && ml(e, n, i); s < a; ) {
        for (ml(e, s, a), ++s, --a; r(e[s], o) < 0; ) ++s;
        for (; r(e[a], o) > 0; ) --a;
      }
      r(e[n], o) === 0 ? ml(e, n, a) : (++a, ml(e, a, i)), a <= t && (n = a + 1), t <= a && (i = a - 1);
    }
    return e;
  }
  function ml(e, t, n) {
    const i = e[t];
    e[t] = e[n], e[n] = i;
  }
  function A1(e, t, n) {
    if (e = Float64Array.from(uP(e, n)), !(!(i = e.length) || isNaN(t = +t))) {
      if (t <= 0 || i < 2) return k1(e);
      if (t >= 1) return Rs(e);
      var i, r = (i - 1) * t, o = Math.floor(r), s = Rs(aF(e, o).subarray(0, o + 1)), a = k1(e.subarray(o + 1));
      return s + (a - s) * (r - o);
    }
  }
  function uF(e, t, n = tF) {
    if (!(!(i = e.length) || isNaN(t = +t))) {
      if (t <= 0 || i < 2) return +n(e[0], 0, e);
      if (t >= 1) return +n(e[i - 1], i - 1, e);
      var i, r = (i - 1) * t, o = Math.floor(r), s = +n(e[o], o, e), a = +n(e[o + 1], o + 1, e);
      return s + (a - s) * (r - o);
    }
  }
  function yP(e, t) {
    let n = 0, i = 0;
    if (t === void 0)
      for (let r of e)
        r != null && (r = +r) >= r && (++n, i += r);
    else {
      let r = -1;
      for (let o of e)
        (o = t(o, ++r, e)) != null && (o = +o) >= o && (++n, i += o);
    }
    if (n) return i / n;
  }
  function lF(e, t) {
    return A1(e, 0.5, t);
  }
  function* bP(e) {
    for (const t of e)
      yield* t;
  }
  function cF(e) {
    return Array.from(bP(e));
  }
  function Tn(e, t, n) {
    e = +e, t = +t, n = (r = arguments.length) < 2 ? (t = e, e = 0, 1) : r < 3 ? 1 : +n;
    for (var i = -1, r = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(r); ++i < r; )
      o[i] = e + i * n;
    return o;
  }
  function fF(e, t) {
    let n = 0;
    for (let i of e)
      (i = +i) && (n += i);
    return n;
  }
  function vP(e, ...t) {
    e = new dh(e), t = t.map(xP);
    e: for (const n of e)
      for (const i of t)
        if (!i.has(n)) {
          e.delete(n);
          continue e;
        }
    return e;
  }
  function xP(e) {
    return e instanceof dh ? e : new dh(e);
  }
  function wP(...e) {
    const t = new dh();
    for (const n of e)
      for (const i of n)
        t.add(i);
    return t;
  }
  function EP(e) {
    return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
  }
  function gh(e, t) {
    if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0) return null;
    var n, i = e.slice(0, n);
    return [
      i.length > 1 ? i[0] + i.slice(2) : i,
      +e.slice(n + 1)
    ];
  }
  function au(e) {
    return e = gh(Math.abs(e)), e ? e[1] : NaN;
  }
  function _P(e, t) {
    return function(n, i) {
      for (var r = n.length, o = [], s = 0, a = e[0], u = 0; r > 0 && a > 0 && (u + a + 1 > i && (a = Math.max(1, i - u)), o.push(n.substring(r -= a, r + a)), !((u += a + 1) > i)); )
        a = e[s = (s + 1) % e.length];
      return o.reverse().join(t);
    };
  }
  function SP(e) {
    return function(t) {
      return t.replace(/[0-9]/g, function(n) {
        return e[+n];
      });
    };
  }
  var $P = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function Ws(e) {
    if (!(t = $P.exec(e))) throw new Error("invalid format: " + e);
    var t;
    return new Gb({
      fill: t[1],
      align: t[2],
      sign: t[3],
      symbol: t[4],
      zero: t[5],
      width: t[6],
      comma: t[7],
      precision: t[8] && t[8].slice(1),
      trim: t[9],
      type: t[10]
    });
  }
  Ws.prototype = Gb.prototype;
  function Gb(e) {
    this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
  }
  Gb.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };
  function kP(e) {
    e: for (var t = e.length, n = 1, i = -1, r; n < t; ++n)
      switch (e[n]) {
        case ".":
          i = r = n;
          break;
        case "0":
          i === 0 && (i = n), r = n;
          break;
        default:
          if (!+e[n]) break e;
          i > 0 && (i = 0);
          break;
      }
    return i > 0 ? e.slice(0, i) + e.slice(r + 1) : e;
  }
  var dF;
  function AP(e, t) {
    var n = gh(e, t);
    if (!n) return e + "";
    var i = n[0], r = n[1], o = r - (dF = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1, s = i.length;
    return o === s ? i : o > s ? i + new Array(o - s + 1).join("0") : o > 0 ? i.slice(0, o) + "." + i.slice(o) : "0." + new Array(1 - o).join("0") + gh(e, Math.max(0, t + o - 1))[0];
  }
  function a_(e, t) {
    var n = gh(e, t);
    if (!n) return e + "";
    var i = n[0], r = n[1];
    return r < 0 ? "0." + new Array(-r).join("0") + i : i.length > r + 1 ? i.slice(0, r + 1) + "." + i.slice(r + 1) : i + new Array(r - i.length + 2).join("0");
  }
  const u_ = {
    "%": (e, t) => (e * 100).toFixed(t),
    b: (e) => Math.round(e).toString(2),
    c: (e) => e + "",
    d: EP,
    e: (e, t) => e.toExponential(t),
    f: (e, t) => e.toFixed(t),
    g: (e, t) => e.toPrecision(t),
    o: (e) => Math.round(e).toString(8),
    p: (e, t) => a_(e * 100, t),
    r: a_,
    s: AP,
    X: (e) => Math.round(e).toString(16).toUpperCase(),
    x: (e) => Math.round(e).toString(16)
  };
  function l_(e) {
    return e;
  }
  var c_ = Array.prototype.map, f_ = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function hF(e) {
    var t = e.grouping === void 0 || e.thousands === void 0 ? l_ : _P(c_.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", i = e.currency === void 0 ? "" : e.currency[1] + "", r = e.decimal === void 0 ? "." : e.decimal + "", o = e.numerals === void 0 ? l_ : SP(c_.call(e.numerals, String)), s = e.percent === void 0 ? "%" : e.percent + "", a = e.minus === void 0 ? "−" : e.minus + "", u = e.nan === void 0 ? "NaN" : e.nan + "";
    function l(f) {
      f = Ws(f);
      var d = f.fill, h = f.align, g = f.sign, p = f.symbol, m = f.zero, y = f.width, b = f.comma, v = f.precision, x = f.trim, w = f.type;
      w === "n" ? (b = !0, w = "g") : u_[w] || (v === void 0 && (v = 12), x = !0, w = "g"), (m || d === "0" && h === "=") && (m = !0, d = "0", h = "=");
      var _ = p === "$" ? n : p === "#" && /[boxX]/.test(w) ? "0" + w.toLowerCase() : "", E = p === "$" ? i : /[%p]/.test(w) ? s : "", S = u_[w], $ = /[defgprs%]/.test(w);
      v = v === void 0 ? 6 : /[gprs]/.test(w) ? Math.max(1, Math.min(21, v)) : Math.max(0, Math.min(20, v));
      function F(A) {
        var D = _, k = E, M, C, T;
        if (w === "c")
          k = S(A) + k, A = "";
        else {
          A = +A;
          var L = A < 0 || 1 / A < 0;
          if (A = isNaN(A) ? u : S(Math.abs(A), v), x && (A = kP(A)), L && +A == 0 && g !== "+" && (L = !1), D = (L ? g === "(" ? g : a : g === "-" || g === "(" ? "" : g) + D, k = (w === "s" ? f_[8 + dF / 3] : "") + k + (L && g === "(" ? ")" : ""), $) {
            for (M = -1, C = A.length; ++M < C; )
              if (T = A.charCodeAt(M), 48 > T || T > 57) {
                k = (T === 46 ? r + A.slice(M + 1) : A.slice(M)) + k, A = A.slice(0, M);
                break;
              }
          }
        }
        b && !m && (A = t(A, 1 / 0));
        var I = D.length + A.length + k.length, z = I < y ? new Array(y - I + 1).join(d) : "";
        switch (b && m && (A = t(z + A, z.length ? y - k.length : 1 / 0), z = ""), h) {
          case "<":
            A = D + A + k + z;
            break;
          case "=":
            A = D + z + A + k;
            break;
          case "^":
            A = z.slice(0, I = z.length >> 1) + D + A + k + z.slice(I);
            break;
          default:
            A = z + D + A + k;
            break;
        }
        return o(A);
      }
      return F.toString = function() {
        return f + "";
      }, F;
    }
    function c(f, d) {
      var h = l((f = Ws(f), f.type = "f", f)), g = Math.max(-8, Math.min(8, Math.floor(au(d) / 3))) * 3, p = Math.pow(10, -g), m = f_[8 + g / 3];
      return function(y) {
        return h(p * y) + m;
      };
    }
    return {
      format: l,
      formatPrefix: c
    };
  }
  var Kf, Hg, Vb;
  CP({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function CP(e) {
    return Kf = hF(e), Hg = Kf.format, Vb = Kf.formatPrefix, Kf;
  }
  function gF(e) {
    return Math.max(0, -au(Math.abs(e)));
  }
  function pF(e, t) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(au(t) / 3))) * 3 - au(Math.abs(e)));
  }
  function mF(e, t) {
    return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, au(t) - au(e)) + 1;
  }
  const Jm = /* @__PURE__ */ new Date(), Qm = /* @__PURE__ */ new Date();
  function ut(e, t, n, i) {
    function r(o) {
      return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
    }
    return r.floor = (o) => (e(o = /* @__PURE__ */ new Date(+o)), o), r.ceil = (o) => (e(o = new Date(o - 1)), t(o, 1), e(o), o), r.round = (o) => {
      const s = r(o), a = r.ceil(o);
      return o - s < a - o ? s : a;
    }, r.offset = (o, s) => (t(o = /* @__PURE__ */ new Date(+o), s == null ? 1 : Math.floor(s)), o), r.range = (o, s, a) => {
      const u = [];
      if (o = r.ceil(o), a = a == null ? 1 : Math.floor(a), !(o < s) || !(a > 0)) return u;
      let l;
      do
        u.push(l = /* @__PURE__ */ new Date(+o)), t(o, a), e(o);
      while (l < o && o < s);
      return u;
    }, r.filter = (o) => ut((s) => {
      if (s >= s) for (; e(s), !o(s); ) s.setTime(s - 1);
    }, (s, a) => {
      if (s >= s)
        if (a < 0) for (; ++a <= 0; )
          for (; t(s, -1), !o(s); )
            ;
        else for (; --a >= 0; )
          for (; t(s, 1), !o(s); )
            ;
    }), n && (r.count = (o, s) => (Jm.setTime(+o), Qm.setTime(+s), e(Jm), e(Qm), Math.floor(n(Jm, Qm))), r.every = (o) => (o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? r.filter(i ? (s) => i(s) % o === 0 : (s) => r.count(0, s) % o === 0) : r)), r;
  }
  const uu = ut(() => {
  }, (e, t) => {
    e.setTime(+e + t);
  }, (e, t) => t - e);
  uu.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? ut((t) => {
    t.setTime(Math.floor(t / e) * e);
  }, (t, n) => {
    t.setTime(+t + n * e);
  }, (t, n) => (n - t) / e) : uu);
  uu.range;
  const Nr = 1e3, Wn = Nr * 60, Or = Wn * 60, Vr = Or * 24, Yb = Vr * 7, d_ = Vr * 30, Zm = Vr * 365, Rr = ut((e) => {
    e.setTime(e - e.getMilliseconds());
  }, (e, t) => {
    e.setTime(+e + t * Nr);
  }, (e, t) => (t - e) / Nr, (e) => e.getUTCSeconds());
  Rr.range;
  const Gg = ut((e) => {
    e.setTime(e - e.getMilliseconds() - e.getSeconds() * Nr);
  }, (e, t) => {
    e.setTime(+e + t * Wn);
  }, (e, t) => (t - e) / Wn, (e) => e.getMinutes());
  Gg.range;
  const Vg = ut((e) => {
    e.setUTCSeconds(0, 0);
  }, (e, t) => {
    e.setTime(+e + t * Wn);
  }, (e, t) => (t - e) / Wn, (e) => e.getUTCMinutes());
  Vg.range;
  const Yg = ut((e) => {
    e.setTime(e - e.getMilliseconds() - e.getSeconds() * Nr - e.getMinutes() * Wn);
  }, (e, t) => {
    e.setTime(+e + t * Or);
  }, (e, t) => (t - e) / Or, (e) => e.getHours());
  Yg.range;
  const Xg = ut((e) => {
    e.setUTCMinutes(0, 0, 0);
  }, (e, t) => {
    e.setTime(+e + t * Or);
  }, (e, t) => (t - e) / Or, (e) => e.getUTCHours());
  Xg.range;
  const Br = ut(
    (e) => e.setHours(0, 0, 0, 0),
    (e, t) => e.setDate(e.getDate() + t),
    (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Wn) / Vr,
    (e) => e.getDate() - 1
  );
  Br.range;
  const Fo = ut((e) => {
    e.setUTCHours(0, 0, 0, 0);
  }, (e, t) => {
    e.setUTCDate(e.getUTCDate() + t);
  }, (e, t) => (t - e) / Vr, (e) => e.getUTCDate() - 1);
  Fo.range;
  const yF = ut((e) => {
    e.setUTCHours(0, 0, 0, 0);
  }, (e, t) => {
    e.setUTCDate(e.getUTCDate() + t);
  }, (e, t) => (t - e) / Vr, (e) => Math.floor(e / Vr));
  yF.range;
  function fa(e) {
    return ut((t) => {
      t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
    }, (t, n) => {
      t.setDate(t.getDate() + n * 7);
    }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Wn) / Yb);
  }
  const Yu = fa(0), ph = fa(1), FP = fa(2), MP = fa(3), lu = fa(4), TP = fa(5), DP = fa(6);
  Yu.range;
  ph.range;
  FP.range;
  MP.range;
  lu.range;
  TP.range;
  DP.range;
  function da(e) {
    return ut((t) => {
      t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
    }, (t, n) => {
      t.setUTCDate(t.getUTCDate() + n * 7);
    }, (t, n) => (n - t) / Yb);
  }
  const Xu = da(0), mh = da(1), NP = da(2), OP = da(3), cu = da(4), RP = da(5), LP = da(6);
  Xu.range;
  mh.range;
  NP.range;
  OP.range;
  cu.range;
  RP.range;
  LP.range;
  const $c = ut((e) => {
    e.setDate(1), e.setHours(0, 0, 0, 0);
  }, (e, t) => {
    e.setMonth(e.getMonth() + t);
  }, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
  $c.range;
  const kc = ut((e) => {
    e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
  }, (e, t) => {
    e.setUTCMonth(e.getUTCMonth() + t);
  }, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
  kc.range;
  const ir = ut((e) => {
    e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
  }, (e, t) => {
    e.setFullYear(e.getFullYear() + t);
  }, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
  ir.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : ut((t) => {
    t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setFullYear(t.getFullYear() + n * e);
  });
  ir.range;
  const rr = ut((e) => {
    e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
  }, (e, t) => {
    e.setUTCFullYear(e.getUTCFullYear() + t);
  }, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
  rr.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : ut((t) => {
    t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setUTCFullYear(t.getUTCFullYear() + n * e);
  });
  rr.range;
  function bF(e, t, n, i, r, o) {
    const s = [
      [Rr, 1, Nr],
      [Rr, 5, 5 * Nr],
      [Rr, 15, 15 * Nr],
      [Rr, 30, 30 * Nr],
      [o, 1, Wn],
      [o, 5, 5 * Wn],
      [o, 15, 15 * Wn],
      [o, 30, 30 * Wn],
      [r, 1, Or],
      [r, 3, 3 * Or],
      [r, 6, 6 * Or],
      [r, 12, 12 * Or],
      [i, 1, Vr],
      [i, 2, 2 * Vr],
      [n, 1, Yb],
      [t, 1, d_],
      [t, 3, 3 * d_],
      [e, 1, Zm]
    ];
    function a(l, c, f) {
      const d = c < l;
      d && ([l, c] = [c, l]);
      const h = f && typeof f.range == "function" ? f : u(l, c, f), g = h ? h.range(l, +c + 1) : [];
      return d ? g.reverse() : g;
    }
    function u(l, c, f) {
      const d = Math.abs(c - l) / f, h = Vu(([, , m]) => m).right(s, d);
      if (h === s.length) return e.every(Ro(l / Zm, c / Zm, f));
      if (h === 0) return uu.every(Math.max(Ro(l, c, f), 1));
      const [g, p] = s[d / s[h - 1][2] < s[h][2] / d ? h - 1 : h];
      return g.every(p);
    }
    return [a, u];
  }
  const [PP, IP] = bF(rr, kc, Xu, yF, Xg, Vg), [zP, BP] = bF(ir, $c, Yu, Br, Yg, Gg), Ct = "year", bn = "quarter", jt = "month", ot = "week", vn = "date", It = "day", or = "dayofyear", Ln = "hours", Pn = "minutes", Qn = "seconds", Ei = "milliseconds", Xb = [Ct, bn, jt, ot, vn, It, or, Ln, Pn, Qn, Ei], e0 = Xb.reduce((e, t, n) => (e[t] = 1 + n, e), {});
  function Kb(e) {
    const t = X(e).slice(), n = {};
    return t.length || R("Missing time unit."), t.forEach((r) => {
      J(e0, r) ? n[r] = 1 : R(`Invalid time unit: ${r}.`);
    }), (n[ot] || n[It] ? 1 : 0) + (n[bn] || n[jt] || n[vn] ? 1 : 0) + (n[or] ? 1 : 0) > 1 && R(`Incompatible time units: ${e}`), t.sort((r, o) => e0[r] - e0[o]), t;
  }
  const UP = {
    [Ct]: "%Y ",
    [bn]: "Q%q ",
    [jt]: "%b ",
    [vn]: "%d ",
    [ot]: "W%U ",
    [It]: "%a ",
    [or]: "%j ",
    [Ln]: "%H:00",
    [Pn]: "00:%M",
    [Qn]: ":%S",
    [Ei]: ".%L",
    [`${Ct}-${jt}`]: "%Y-%m ",
    [`${Ct}-${jt}-${vn}`]: "%Y-%m-%d ",
    [`${Ln}-${Pn}`]: "%H:%M"
  };
  function vF(e, t) {
    const n = ce({}, UP, t), i = Kb(e), r = i.length;
    let o = "", s = 0, a, u;
    for (s = 0; s < r; )
      for (a = i.length; a > s; --a)
        if (u = i.slice(s, a).join("-"), n[u] != null) {
          o += n[u], s = a;
          break;
        }
    return o.trim();
  }
  const $s = /* @__PURE__ */ new Date();
  function Jb(e) {
    return $s.setFullYear(e), $s.setMonth(0), $s.setDate(1), $s.setHours(0, 0, 0, 0), $s;
  }
  function xF(e) {
    return EF(new Date(e));
  }
  function wF(e) {
    return C1(new Date(e));
  }
  function EF(e) {
    return Br.count(Jb(e.getFullYear()) - 1, e);
  }
  function C1(e) {
    return Yu.count(Jb(e.getFullYear()) - 1, e);
  }
  function F1(e) {
    return Jb(e).getDay();
  }
  function jP(e, t, n, i, r, o, s) {
    if (0 <= e && e < 100) {
      const a = new Date(-1, t, n, i, r, o, s);
      return a.setFullYear(e), a;
    }
    return new Date(e, t, n, i, r, o, s);
  }
  function _F(e) {
    return $F(new Date(e));
  }
  function SF(e) {
    return M1(new Date(e));
  }
  function $F(e) {
    const t = Date.UTC(e.getUTCFullYear(), 0, 1);
    return Fo.count(t - 1, e);
  }
  function M1(e) {
    const t = Date.UTC(e.getUTCFullYear(), 0, 1);
    return Xu.count(t - 1, e);
  }
  function T1(e) {
    return $s.setTime(Date.UTC(e, 0, 1)), $s.getUTCDay();
  }
  function qP(e, t, n, i, r, o, s) {
    if (0 <= e && e < 100) {
      const a = new Date(Date.UTC(-1, t, n, i, r, o, s));
      return a.setUTCFullYear(n.y), a;
    }
    return new Date(Date.UTC(e, t, n, i, r, o, s));
  }
  function kF(e, t, n, i, r) {
    const o = t || 1, s = xe(e), a = (y, b, v) => (v = v || y, WP(n[v], i[v], y === s && o, b)), u = /* @__PURE__ */ new Date(), l = wi(e), c = l[Ct] ? a(Ct) : Gt(2012), f = l[jt] ? a(jt) : l[bn] ? a(bn) : bo, d = l[ot] && l[It] ? a(It, 1, ot + It) : l[ot] ? a(ot, 1) : l[It] ? a(It, 1) : l[vn] ? a(vn, 1) : l[or] ? a(or, 1) : qu, h = l[Ln] ? a(Ln) : bo, g = l[Pn] ? a(Pn) : bo, p = l[Qn] ? a(Qn) : bo, m = l[Ei] ? a(Ei) : bo;
    return function(y) {
      u.setTime(+y);
      const b = c(u);
      return r(b, f(u), d(u, b), h(u), g(u), p(u), m(u));
    };
  }
  function WP(e, t, n, i) {
    const r = n <= 1 ? e : i ? (o, s) => i + n * Math.floor((e(o, s) - i) / n) : (o, s) => n * Math.floor(e(o, s) / n);
    return t ? (o, s) => t(r(o, s), s) : r;
  }
  function fu(e, t, n) {
    return t + e * 7 - (n + 6) % 7;
  }
  const HP = {
    [Ct]: (e) => e.getFullYear(),
    [bn]: (e) => Math.floor(e.getMonth() / 3),
    [jt]: (e) => e.getMonth(),
    [vn]: (e) => e.getDate(),
    [Ln]: (e) => e.getHours(),
    [Pn]: (e) => e.getMinutes(),
    [Qn]: (e) => e.getSeconds(),
    [Ei]: (e) => e.getMilliseconds(),
    [or]: (e) => EF(e),
    [ot]: (e) => C1(e),
    [ot + It]: (e, t) => fu(C1(e), e.getDay(), F1(t)),
    [It]: (e, t) => fu(1, e.getDay(), F1(t))
  }, GP = {
    [bn]: (e) => 3 * e,
    [ot]: (e, t) => fu(e, 0, F1(t))
  };
  function AF(e, t) {
    return kF(e, t || 1, HP, GP, jP);
  }
  const VP = {
    [Ct]: (e) => e.getUTCFullYear(),
    [bn]: (e) => Math.floor(e.getUTCMonth() / 3),
    [jt]: (e) => e.getUTCMonth(),
    [vn]: (e) => e.getUTCDate(),
    [Ln]: (e) => e.getUTCHours(),
    [Pn]: (e) => e.getUTCMinutes(),
    [Qn]: (e) => e.getUTCSeconds(),
    [Ei]: (e) => e.getUTCMilliseconds(),
    [or]: (e) => $F(e),
    [ot]: (e) => M1(e),
    [It]: (e, t) => fu(1, e.getUTCDay(), T1(t)),
    [ot + It]: (e, t) => fu(M1(e), e.getUTCDay(), T1(t))
  }, YP = {
    [bn]: (e) => 3 * e,
    [ot]: (e, t) => fu(e, 0, T1(t))
  };
  function CF(e, t) {
    return kF(e, t || 1, VP, YP, qP);
  }
  const XP = {
    [Ct]: ir,
    [bn]: $c.every(3),
    [jt]: $c,
    [ot]: Yu,
    [vn]: Br,
    [It]: Br,
    [or]: Br,
    [Ln]: Yg,
    [Pn]: Gg,
    [Qn]: Rr,
    [Ei]: uu
  }, KP = {
    [Ct]: rr,
    [bn]: kc.every(3),
    [jt]: kc,
    [ot]: Xu,
    [vn]: Fo,
    [It]: Fo,
    [or]: Fo,
    [Ln]: Xg,
    [Pn]: Vg,
    [Qn]: Rr,
    [Ei]: uu
  };
  function Ku(e) {
    return XP[e];
  }
  function Ju(e) {
    return KP[e];
  }
  function FF(e, t, n) {
    return e ? e.offset(t, n) : void 0;
  }
  function MF(e, t, n) {
    return FF(Ku(e), t, n);
  }
  function TF(e, t, n) {
    return FF(Ju(e), t, n);
  }
  function DF(e, t, n, i) {
    return e ? e.range(t, n, i) : void 0;
  }
  function NF(e, t, n, i) {
    return DF(Ku(e), t, n, i);
  }
  function OF(e, t, n, i) {
    return DF(Ju(e), t, n, i);
  }
  const Ul = 1e3, jl = Ul * 60, ql = jl * 60, Kg = ql * 24, JP = Kg * 7, h_ = Kg * 30, D1 = Kg * 365, RF = [Ct, jt, vn, Ln, Pn, Qn, Ei], Wl = RF.slice(0, -1), Hl = Wl.slice(0, -1), Gl = Hl.slice(0, -1), QP = Gl.slice(0, -1), ZP = [Ct, ot], g_ = [Ct, jt], LF = [Ct], yl = [[Wl, 1, Ul], [Wl, 5, 5 * Ul], [Wl, 15, 15 * Ul], [Wl, 30, 30 * Ul], [Hl, 1, jl], [Hl, 5, 5 * jl], [Hl, 15, 15 * jl], [Hl, 30, 30 * jl], [Gl, 1, ql], [Gl, 3, 3 * ql], [Gl, 6, 6 * ql], [Gl, 12, 12 * ql], [QP, 1, Kg], [ZP, 1, JP], [g_, 1, h_], [g_, 3, 3 * h_], [LF, 1, D1]];
  function PF(e) {
    const t = e.extent, n = e.maxbins || 40, i = Math.abs(nf(t)) / n;
    let r = Vu((a) => a[2]).right(yl, i), o, s;
    return r === yl.length ? (o = LF, s = Ro(t[0] / D1, t[1] / D1, n)) : r ? (r = yl[i / yl[r - 1][2] < yl[r][2] / i ? r - 1 : r], o = r[0], s = r[1]) : (o = RF, s = Math.max(Ro(t[0], t[1], n), 1)), {
      units: o,
      step: s
    };
  }
  function t0(e) {
    if (0 <= e.y && e.y < 100) {
      var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
      return t.setFullYear(e.y), t;
    }
    return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
  }
  function n0(e) {
    if (0 <= e.y && e.y < 100) {
      var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
      return t.setUTCFullYear(e.y), t;
    }
    return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
  }
  function bl(e, t, n) {
    return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
  }
  function IF(e) {
    var t = e.dateTime, n = e.date, i = e.time, r = e.periods, o = e.days, s = e.shortDays, a = e.months, u = e.shortMonths, l = vl(r), c = xl(r), f = vl(o), d = xl(o), h = vl(s), g = xl(s), p = vl(a), m = xl(a), y = vl(u), b = xl(u), v = {
      a: L,
      A: I,
      b: z,
      B: te,
      c: null,
      d: x_,
      e: x_,
      f: EI,
      g: DI,
      G: OI,
      H: vI,
      I: xI,
      j: wI,
      L: zF,
      m: _I,
      M: SI,
      p: ne,
      q: de,
      Q: __,
      s: S_,
      S: $I,
      u: kI,
      U: AI,
      V: CI,
      w: FI,
      W: MI,
      x: null,
      X: null,
      y: TI,
      Y: NI,
      Z: RI,
      "%": E_
    }, x = {
      a: _e,
      A: we,
      b: Pe,
      B: Li,
      c: null,
      d: w_,
      e: w_,
      f: zI,
      g: XI,
      G: JI,
      H: LI,
      I: PI,
      j: II,
      L: UF,
      m: BI,
      M: UI,
      p: cs,
      q: ao,
      Q: __,
      s: S_,
      S: jI,
      u: qI,
      U: WI,
      V: HI,
      w: GI,
      W: VI,
      x: null,
      X: null,
      y: YI,
      Y: KI,
      Z: QI,
      "%": E_
    }, w = {
      a: F,
      A,
      b: D,
      B: k,
      c: M,
      d: b_,
      e: b_,
      f: pI,
      g: y_,
      G: m_,
      H: v_,
      I: v_,
      j: fI,
      L: gI,
      m: cI,
      M: dI,
      p: $,
      q: lI,
      Q: yI,
      s: bI,
      S: hI,
      u: rI,
      U: oI,
      V: sI,
      w: iI,
      W: aI,
      x: C,
      X: T,
      y: y_,
      Y: m_,
      Z: uI,
      "%": mI
    };
    v.x = _(n, v), v.X = _(i, v), v.c = _(t, v), x.x = _(n, x), x.X = _(i, x), x.c = _(t, x);
    function _(Q, he) {
      return function(pe) {
        var W = [], wt = -1, Me = 0, Dt = Q.length, ct, Pi, Yf;
        for (pe instanceof Date || (pe = /* @__PURE__ */ new Date(+pe)); ++wt < Dt; )
          Q.charCodeAt(wt) === 37 && (W.push(Q.slice(Me, wt)), (Pi = p_[ct = Q.charAt(++wt)]) != null ? ct = Q.charAt(++wt) : Pi = ct === "e" ? " " : "0", (Yf = he[ct]) && (ct = Yf(pe, Pi)), W.push(ct), Me = wt + 1);
        return W.push(Q.slice(Me, wt)), W.join("");
      };
    }
    function E(Q, he) {
      return function(pe) {
        var W = bl(1900, void 0, 1), wt = S(W, Q, pe += "", 0), Me, Dt;
        if (wt != pe.length) return null;
        if ("Q" in W) return new Date(W.Q);
        if ("s" in W) return new Date(W.s * 1e3 + ("L" in W ? W.L : 0));
        if (he && !("Z" in W) && (W.Z = 0), "p" in W && (W.H = W.H % 12 + W.p * 12), W.m === void 0 && (W.m = "q" in W ? W.q : 0), "V" in W) {
          if (W.V < 1 || W.V > 53) return null;
          "w" in W || (W.w = 1), "Z" in W ? (Me = n0(bl(W.y, 0, 1)), Dt = Me.getUTCDay(), Me = Dt > 4 || Dt === 0 ? mh.ceil(Me) : mh(Me), Me = Fo.offset(Me, (W.V - 1) * 7), W.y = Me.getUTCFullYear(), W.m = Me.getUTCMonth(), W.d = Me.getUTCDate() + (W.w + 6) % 7) : (Me = t0(bl(W.y, 0, 1)), Dt = Me.getDay(), Me = Dt > 4 || Dt === 0 ? ph.ceil(Me) : ph(Me), Me = Br.offset(Me, (W.V - 1) * 7), W.y = Me.getFullYear(), W.m = Me.getMonth(), W.d = Me.getDate() + (W.w + 6) % 7);
        } else ("W" in W || "U" in W) && ("w" in W || (W.w = "u" in W ? W.u % 7 : "W" in W ? 1 : 0), Dt = "Z" in W ? n0(bl(W.y, 0, 1)).getUTCDay() : t0(bl(W.y, 0, 1)).getDay(), W.m = 0, W.d = "W" in W ? (W.w + 6) % 7 + W.W * 7 - (Dt + 5) % 7 : W.w + W.U * 7 - (Dt + 6) % 7);
        return "Z" in W ? (W.H += W.Z / 100 | 0, W.M += W.Z % 100, n0(W)) : t0(W);
      };
    }
    function S(Q, he, pe, W) {
      for (var wt = 0, Me = he.length, Dt = pe.length, ct, Pi; wt < Me; ) {
        if (W >= Dt) return -1;
        if (ct = he.charCodeAt(wt++), ct === 37) {
          if (ct = he.charAt(wt++), Pi = w[ct in p_ ? he.charAt(wt++) : ct], !Pi || (W = Pi(Q, pe, W)) < 0) return -1;
        } else if (ct != pe.charCodeAt(W++))
          return -1;
      }
      return W;
    }
    function $(Q, he, pe) {
      var W = l.exec(he.slice(pe));
      return W ? (Q.p = c.get(W[0].toLowerCase()), pe + W[0].length) : -1;
    }
    function F(Q, he, pe) {
      var W = h.exec(he.slice(pe));
      return W ? (Q.w = g.get(W[0].toLowerCase()), pe + W[0].length) : -1;
    }
    function A(Q, he, pe) {
      var W = f.exec(he.slice(pe));
      return W ? (Q.w = d.get(W[0].toLowerCase()), pe + W[0].length) : -1;
    }
    function D(Q, he, pe) {
      var W = y.exec(he.slice(pe));
      return W ? (Q.m = b.get(W[0].toLowerCase()), pe + W[0].length) : -1;
    }
    function k(Q, he, pe) {
      var W = p.exec(he.slice(pe));
      return W ? (Q.m = m.get(W[0].toLowerCase()), pe + W[0].length) : -1;
    }
    function M(Q, he, pe) {
      return S(Q, t, he, pe);
    }
    function C(Q, he, pe) {
      return S(Q, n, he, pe);
    }
    function T(Q, he, pe) {
      return S(Q, i, he, pe);
    }
    function L(Q) {
      return s[Q.getDay()];
    }
    function I(Q) {
      return o[Q.getDay()];
    }
    function z(Q) {
      return u[Q.getMonth()];
    }
    function te(Q) {
      return a[Q.getMonth()];
    }
    function ne(Q) {
      return r[+(Q.getHours() >= 12)];
    }
    function de(Q) {
      return 1 + ~~(Q.getMonth() / 3);
    }
    function _e(Q) {
      return s[Q.getUTCDay()];
    }
    function we(Q) {
      return o[Q.getUTCDay()];
    }
    function Pe(Q) {
      return u[Q.getUTCMonth()];
    }
    function Li(Q) {
      return a[Q.getUTCMonth()];
    }
    function cs(Q) {
      return r[+(Q.getUTCHours() >= 12)];
    }
    function ao(Q) {
      return 1 + ~~(Q.getUTCMonth() / 3);
    }
    return {
      format: function(Q) {
        var he = _(Q += "", v);
        return he.toString = function() {
          return Q;
        }, he;
      },
      parse: function(Q) {
        var he = E(Q += "", !1);
        return he.toString = function() {
          return Q;
        }, he;
      },
      utcFormat: function(Q) {
        var he = _(Q += "", x);
        return he.toString = function() {
          return Q;
        }, he;
      },
      utcParse: function(Q) {
        var he = E(Q += "", !0);
        return he.toString = function() {
          return Q;
        }, he;
      }
    };
  }
  var p_ = { "-": "", _: " ", 0: "0" }, vt = /^\s*\d+/, eI = /^%/, tI = /[\\^$*+?|[\]().{}]/g;
  function ke(e, t, n) {
    var i = e < 0 ? "-" : "", r = (i ? -e : e) + "", o = r.length;
    return i + (o < n ? new Array(n - o + 1).join(t) + r : r);
  }
  function nI(e) {
    return e.replace(tI, "\\$&");
  }
  function vl(e) {
    return new RegExp("^(?:" + e.map(nI).join("|") + ")", "i");
  }
  function xl(e) {
    return new Map(e.map((t, n) => [t.toLowerCase(), n]));
  }
  function iI(e, t, n) {
    var i = vt.exec(t.slice(n, n + 1));
    return i ? (e.w = +i[0], n + i[0].length) : -1;
  }
  function rI(e, t, n) {
    var i = vt.exec(t.slice(n, n + 1));
    return i ? (e.u = +i[0], n + i[0].length) : -1;
  }
  function oI(e, t, n) {
    var i = vt.exec(t.slice(n, n + 2));
    return i ? (e.U = +i[0], n + i[0].length) : -1;
  }
  function sI(e, t, n) {
    var i = vt.exec(t.slice(n, n + 2));
    return i ? (e.V = +i[0], n + i[0].length) : -1;
  }
  function aI(e, t, n) {
    var i = vt.exec(t.slice(n, n + 2));
    return i ? (e.W = +i[0], n + i[0].length) : -1;
  }
  function m_(e, t, n) {
    var i = vt.exec(t.slice(n, n + 4));
    return i ? (e.y = +i[0], n + i[0].length) : -1;
  }
  function y_(e, t, n) {
    var i = vt.exec(t.slice(n, n + 2));
    return i ? (e.y = +i[0] + (+i[0] > 68 ? 1900 : 2e3), n + i[0].length) : -1;
  }
  function uI(e, t, n) {
    var i = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
    return i ? (e.Z = i[1] ? 0 : -(i[2] + (i[3] || "00")), n + i[0].length) : -1;
  }
  function lI(e, t, n) {
    var i = vt.exec(t.slice(n, n + 1));
    return i ? (e.q = i[0] * 3 - 3, n + i[0].length) : -1;
  }
  function cI(e, t, n) {
    var i = vt.exec(t.slice(n, n + 2));
    return i ? (e.m = i[0] - 1, n + i[0].length) : -1;
  }
  function b_(e, t, n) {
    var i = vt.exec(t.slice(n, n + 2));
    return i ? (e.d = +i[0], n + i[0].length) : -1;
  }
  function fI(e, t, n) {
    var i = vt.exec(t.slice(n, n + 3));
    return i ? (e.m = 0, e.d = +i[0], n + i[0].length) : -1;
  }
  function v_(e, t, n) {
    var i = vt.exec(t.slice(n, n + 2));
    return i ? (e.H = +i[0], n + i[0].length) : -1;
  }
  function dI(e, t, n) {
    var i = vt.exec(t.slice(n, n + 2));
    return i ? (e.M = +i[0], n + i[0].length) : -1;
  }
  function hI(e, t, n) {
    var i = vt.exec(t.slice(n, n + 2));
    return i ? (e.S = +i[0], n + i[0].length) : -1;
  }
  function gI(e, t, n) {
    var i = vt.exec(t.slice(n, n + 3));
    return i ? (e.L = +i[0], n + i[0].length) : -1;
  }
  function pI(e, t, n) {
    var i = vt.exec(t.slice(n, n + 6));
    return i ? (e.L = Math.floor(i[0] / 1e3), n + i[0].length) : -1;
  }
  function mI(e, t, n) {
    var i = eI.exec(t.slice(n, n + 1));
    return i ? n + i[0].length : -1;
  }
  function yI(e, t, n) {
    var i = vt.exec(t.slice(n));
    return i ? (e.Q = +i[0], n + i[0].length) : -1;
  }
  function bI(e, t, n) {
    var i = vt.exec(t.slice(n));
    return i ? (e.s = +i[0], n + i[0].length) : -1;
  }
  function x_(e, t) {
    return ke(e.getDate(), t, 2);
  }
  function vI(e, t) {
    return ke(e.getHours(), t, 2);
  }
  function xI(e, t) {
    return ke(e.getHours() % 12 || 12, t, 2);
  }
  function wI(e, t) {
    return ke(1 + Br.count(ir(e), e), t, 3);
  }
  function zF(e, t) {
    return ke(e.getMilliseconds(), t, 3);
  }
  function EI(e, t) {
    return zF(e, t) + "000";
  }
  function _I(e, t) {
    return ke(e.getMonth() + 1, t, 2);
  }
  function SI(e, t) {
    return ke(e.getMinutes(), t, 2);
  }
  function $I(e, t) {
    return ke(e.getSeconds(), t, 2);
  }
  function kI(e) {
    var t = e.getDay();
    return t === 0 ? 7 : t;
  }
  function AI(e, t) {
    return ke(Yu.count(ir(e) - 1, e), t, 2);
  }
  function BF(e) {
    var t = e.getDay();
    return t >= 4 || t === 0 ? lu(e) : lu.ceil(e);
  }
  function CI(e, t) {
    return e = BF(e), ke(lu.count(ir(e), e) + (ir(e).getDay() === 4), t, 2);
  }
  function FI(e) {
    return e.getDay();
  }
  function MI(e, t) {
    return ke(ph.count(ir(e) - 1, e), t, 2);
  }
  function TI(e, t) {
    return ke(e.getFullYear() % 100, t, 2);
  }
  function DI(e, t) {
    return e = BF(e), ke(e.getFullYear() % 100, t, 2);
  }
  function NI(e, t) {
    return ke(e.getFullYear() % 1e4, t, 4);
  }
  function OI(e, t) {
    var n = e.getDay();
    return e = n >= 4 || n === 0 ? lu(e) : lu.ceil(e), ke(e.getFullYear() % 1e4, t, 4);
  }
  function RI(e) {
    var t = e.getTimezoneOffset();
    return (t > 0 ? "-" : (t *= -1, "+")) + ke(t / 60 | 0, "0", 2) + ke(t % 60, "0", 2);
  }
  function w_(e, t) {
    return ke(e.getUTCDate(), t, 2);
  }
  function LI(e, t) {
    return ke(e.getUTCHours(), t, 2);
  }
  function PI(e, t) {
    return ke(e.getUTCHours() % 12 || 12, t, 2);
  }
  function II(e, t) {
    return ke(1 + Fo.count(rr(e), e), t, 3);
  }
  function UF(e, t) {
    return ke(e.getUTCMilliseconds(), t, 3);
  }
  function zI(e, t) {
    return UF(e, t) + "000";
  }
  function BI(e, t) {
    return ke(e.getUTCMonth() + 1, t, 2);
  }
  function UI(e, t) {
    return ke(e.getUTCMinutes(), t, 2);
  }
  function jI(e, t) {
    return ke(e.getUTCSeconds(), t, 2);
  }
  function qI(e) {
    var t = e.getUTCDay();
    return t === 0 ? 7 : t;
  }
  function WI(e, t) {
    return ke(Xu.count(rr(e) - 1, e), t, 2);
  }
  function jF(e) {
    var t = e.getUTCDay();
    return t >= 4 || t === 0 ? cu(e) : cu.ceil(e);
  }
  function HI(e, t) {
    return e = jF(e), ke(cu.count(rr(e), e) + (rr(e).getUTCDay() === 4), t, 2);
  }
  function GI(e) {
    return e.getUTCDay();
  }
  function VI(e, t) {
    return ke(mh.count(rr(e) - 1, e), t, 2);
  }
  function YI(e, t) {
    return ke(e.getUTCFullYear() % 100, t, 2);
  }
  function XI(e, t) {
    return e = jF(e), ke(e.getUTCFullYear() % 100, t, 2);
  }
  function KI(e, t) {
    return ke(e.getUTCFullYear() % 1e4, t, 4);
  }
  function JI(e, t) {
    var n = e.getUTCDay();
    return e = n >= 4 || n === 0 ? cu(e) : cu.ceil(e), ke(e.getUTCFullYear() % 1e4, t, 4);
  }
  function QI() {
    return "+0000";
  }
  function E_() {
    return "%";
  }
  function __(e) {
    return +e;
  }
  function S_(e) {
    return Math.floor(+e / 1e3);
  }
  var Fa, Qb, qF, Zb, WF;
  ZI({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });
  function ZI(e) {
    return Fa = IF(e), Qb = Fa.format, qF = Fa.parse, Zb = Fa.utcFormat, WF = Fa.utcParse, Fa;
  }
  function Vl(e) {
    const t = {};
    return (n) => t[n] || (t[n] = e(n));
  }
  function ez(e, t) {
    return (n) => {
      const i = e(n), r = i.indexOf(t);
      if (r < 0) return i;
      let o = tz(i, r);
      const s = o < i.length ? i.slice(o) : "";
      for (; --o > r; ) if (i[o] !== "0") {
        ++o;
        break;
      }
      return i.slice(0, o) + s;
    };
  }
  function tz(e, t) {
    let n = e.lastIndexOf("e"), i;
    if (n > 0) return n;
    for (n = e.length; --n > t; )
      if (i = e.charCodeAt(n), i >= 48 && i <= 57) return n + 1;
  }
  function HF(e) {
    const t = Vl(e.format), n = e.formatPrefix;
    return {
      format: t,
      formatPrefix: n,
      formatFloat(i) {
        const r = Ws(i || ",");
        if (r.precision == null) {
          switch (r.precision = 12, r.type) {
            case "%":
              r.precision -= 2;
              break;
            case "e":
              r.precision -= 1;
              break;
          }
          return ez(
            t(r),
            // number format
            t(".1f")(1)[1]
            // decimal point character
          );
        } else
          return t(r);
      },
      formatSpan(i, r, o, s) {
        s = Ws(s ?? ",f");
        const a = Ro(i, r, o), u = Math.max(Math.abs(i), Math.abs(r));
        let l;
        if (s.precision == null)
          switch (s.type) {
            case "s":
              return isNaN(l = pF(a, u)) || (s.precision = l), n(s, u);
            case "":
            case "e":
            case "g":
            case "p":
            case "r": {
              isNaN(l = mF(a, u)) || (s.precision = l - (s.type === "e"));
              break;
            }
            case "f":
            case "%": {
              isNaN(l = gF(a)) || (s.precision = l - (s.type === "%") * 2);
              break;
            }
          }
        return t(s);
      }
    };
  }
  let N1;
  GF();
  function GF() {
    return N1 = HF({
      format: Hg,
      formatPrefix: Vb
    });
  }
  function VF(e) {
    return HF(hF(e));
  }
  function yh(e) {
    return arguments.length ? N1 = VF(e) : N1;
  }
  function $_(e, t, n) {
    n = n || {}, Y(n) || R(`Invalid time multi-format specifier: ${n}`);
    const i = t(Qn), r = t(Pn), o = t(Ln), s = t(vn), a = t(ot), u = t(jt), l = t(bn), c = t(Ct), f = e(n[Ei] || ".%L"), d = e(n[Qn] || ":%S"), h = e(n[Pn] || "%I:%M"), g = e(n[Ln] || "%I %p"), p = e(n[vn] || n[It] || "%a %d"), m = e(n[ot] || "%b %d"), y = e(n[jt] || "%B"), b = e(n[bn] || "%B"), v = e(n[Ct] || "%Y");
    return (x) => (i(x) < x ? f : r(x) < x ? d : o(x) < x ? h : s(x) < x ? g : u(x) < x ? a(x) < x ? p : m : c(x) < x ? l(x) < x ? y : b : v)(x);
  }
  function YF(e) {
    const t = Vl(e.format), n = Vl(e.utcFormat);
    return {
      timeFormat: (i) => K(i) ? t(i) : $_(t, Ku, i),
      utcFormat: (i) => K(i) ? n(i) : $_(n, Ju, i),
      timeParse: Vl(e.parse),
      utcParse: Vl(e.utcParse)
    };
  }
  let O1;
  XF();
  function XF() {
    return O1 = YF({
      format: Qb,
      parse: qF,
      utcFormat: Zb,
      utcParse: WF
    });
  }
  function KF(e) {
    return YF(IF(e));
  }
  function Ac(e) {
    return arguments.length ? O1 = KF(e) : O1;
  }
  const R1 = (e, t) => ce({}, e, t);
  function JF(e, t) {
    const n = e ? VF(e) : yh(), i = t ? KF(t) : Ac();
    return R1(n, i);
  }
  function ev(e, t) {
    const n = arguments.length;
    return n && n !== 2 && R("defaultLocale expects either zero or two arguments."), n ? R1(yh(e), Ac(t)) : R1(yh(), Ac());
  }
  function nz() {
    return GF(), XF(), ev();
  }
  const iz = /^(data:|([A-Za-z]+:)?\/\/)/, rz = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i, oz = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, k_ = "file://";
  function sz(e, t) {
    return (n) => ({
      options: n || {},
      sanitize: uz,
      load: az,
      fileAccess: !!t,
      file: lz(t),
      http: fz(e)
    });
  }
  async function az(e, t) {
    const n = await this.sanitize(e, t), i = n.href;
    return n.localFile ? this.file(i) : this.http(i, t);
  }
  async function uz(e, t) {
    t = ce({}, this.options, t);
    const n = this.fileAccess, i = {
      href: null
    };
    let r, o, s;
    const a = rz.test(e.replace(oz, ""));
    (e == null || typeof e != "string" || !a) && R("Sanitize failure, invalid URI: " + H(e));
    const u = iz.test(e);
    return (s = t.baseURL) && !u && (!e.startsWith("/") && !s.endsWith("/") && (e = "/" + e), e = s + e), o = (r = e.startsWith(k_)) || t.mode === "file" || t.mode !== "http" && !u && n, r ? e = e.slice(k_.length) : e.startsWith("//") && (t.defaultProtocol === "file" ? (e = e.slice(2), o = !0) : e = (t.defaultProtocol || "http") + ":" + e), Object.defineProperty(i, "localFile", {
      value: !!o
    }), i.href = e, t.target && (i.target = t.target + ""), t.rel && (i.rel = t.rel + ""), t.context === "image" && t.crossOrigin && (i.crossOrigin = t.crossOrigin + ""), i;
  }
  function lz(e) {
    return e ? (t) => new Promise((n, i) => {
      e.readFile(t, (r, o) => {
        r ? i(r) : n(o);
      });
    }) : cz;
  }
  async function cz() {
    R("No file system access.");
  }
  function fz(e) {
    return e ? async function(t, n) {
      const i = ce({}, this.options.http, n), r = n && n.response, o = await e(t, i);
      return o.ok ? fe(o[r]) ? o[r]() : o.text() : R(o.status + "" + o.statusText);
    } : dz;
  }
  async function dz() {
    R("No HTTP fetch method available.");
  }
  const hz = (e) => e != null && e === e, gz = (e) => e === "true" || e === "false" || e === !0 || e === !1, pz = (e) => !Number.isNaN(Date.parse(e)), QF = (e) => !Number.isNaN(+e) && !(e instanceof Date), mz = (e) => QF(e) && Number.isInteger(+e), L1 = {
    boolean: qb,
    integer: zt,
    number: zt,
    date: Wb,
    string: Hb,
    unknown: Ht
  }, Jf = [gz, mz, QF, pz], yz = ["boolean", "integer", "number", "date"];
  function ZF(e, t) {
    if (!e || !e.length) return "unknown";
    const n = e.length, i = Jf.length, r = Jf.map((o, s) => s + 1);
    for (let o = 0, s = 0, a, u; o < n; ++o)
      for (u = t ? e[o][t] : e[o], a = 0; a < i; ++a)
        if (r[a] && hz(u) && !Jf[a](u) && (r[a] = 0, ++s, s === Jf.length))
          return "string";
    return yz[r.reduce((o, s) => o === 0 ? s : o, 0) - 1];
  }
  function eM(e, t) {
    return t.reduce((n, i) => (n[i] = ZF(e, i), n), {});
  }
  function A_(e) {
    const t = function(n, i) {
      const r = {
        delimiter: e
      };
      return tv(n, i ? ce(i, r) : r);
    };
    return t.responseType = "text", t;
  }
  function tv(e, t) {
    return t.header && (e = t.header.map(H).join(t.delimiter) + `
` + e), JL(t.delimiter).parse(e + "");
  }
  tv.responseType = "text";
  function bz(e) {
    return typeof Buffer == "function" && fe(Buffer.isBuffer) ? Buffer.isBuffer(e) : !1;
  }
  function nv(e, t) {
    const n = t && t.property ? Kn(t.property) : Ht;
    return Y(e) && !bz(e) ? vz(n(e), t) : n(JSON.parse(e));
  }
  nv.responseType = "json";
  function vz(e, t) {
    return !P(e) && GC(e) && (e = [...e]), t && t.copy ? JSON.parse(JSON.stringify(e)) : e;
  }
  const xz = {
    interior: (e, t) => e !== t,
    exterior: (e, t) => e === t
  };
  function tM(e, t) {
    let n, i, r, o;
    return e = nv(e, t), t && t.feature ? (n = tP, r = t.feature) : t && t.mesh ? (n = iP, r = t.mesh, o = xz[t.filter]) : R("Missing TopoJSON feature or mesh parameter."), i = (i = e.objects[r]) ? n(e, i, o) : R("Invalid TopoJSON object: " + r), i && i.features || [i];
  }
  tM.responseType = "json";
  const Pd = {
    dsv: tv,
    csv: A_(","),
    tsv: A_("	"),
    json: nv,
    topojson: tM
  };
  function iv(e, t) {
    return arguments.length > 1 ? (Pd[e] = t, this) : J(Pd, e) ? Pd[e] : null;
  }
  function nM(e) {
    const t = iv(e);
    return t && t.responseType || "text";
  }
  function iM(e, t, n, i) {
    t = t || {};
    const r = iv(t.type || "json");
    return r || R("Unknown data format type: " + t.type), e = r(e, t), t.parse && wz(e, t.parse, n, i), J(e, "columns") && delete e.columns, e;
  }
  function wz(e, t, n, i) {
    if (!e.length) return;
    const r = Ac();
    n = n || r.timeParse, i = i || r.utcParse;
    let o = e.columns || Object.keys(e[0]), s, a, u, l, c, f;
    t === "auto" && (t = eM(e, o)), o = Object.keys(t);
    const d = o.map((h) => {
      const g = t[h];
      let p, m;
      if (g && (g.startsWith("date:") || g.startsWith("utc:")))
        return p = g.split(/:(.+)?/, 2), m = p[1], (m[0] === "'" && m[m.length - 1] === "'" || m[0] === '"' && m[m.length - 1] === '"') && (m = m.slice(1, -1)), (p[0] === "utc" ? i : n)(m);
      if (!L1[g])
        throw Error("Illegal format pattern: " + h + ":" + g);
      return L1[g];
    });
    for (u = 0, c = e.length, f = o.length; u < c; ++u)
      for (s = e[u], l = 0; l < f; ++l)
        a = o[l], s[a] = d[l](s[a]);
  }
  const Jg = sz(
    typeof fetch < "u" && fetch,
    // use built-in fetch API
    null
    // no file system access
  );
  function Qg(e) {
    const t = e || Ht, n = [], i = {};
    return n.add = (r) => {
      const o = t(r);
      return i[o] || (i[o] = 1, n.push(r)), n;
    }, n.remove = (r) => {
      const o = t(r);
      if (i[o]) {
        i[o] = 0;
        const s = n.indexOf(r);
        s >= 0 && n.splice(s, 1);
      }
      return n;
    }, n;
  }
  async function Id(e, t) {
    try {
      await t(e);
    } catch (n) {
      e.error(n);
    }
  }
  const rM = Symbol("vega_id");
  let Ez = 1;
  function Zg(e) {
    return !!(e && re(e));
  }
  function re(e) {
    return e[rM];
  }
  function oM(e, t) {
    return e[rM] = t, e;
  }
  function Ce(e) {
    const t = e === Object(e) ? e : {
      data: e
    };
    return re(t) ? t : oM(t, Ez++);
  }
  function rv(e) {
    return ep(e, Ce({}));
  }
  function ep(e, t) {
    for (const n in e) t[n] = e[n];
    return t;
  }
  function sM(e, t) {
    return oM(t, re(e));
  }
  function ha(e, t) {
    return e ? t ? (n, i) => e(n, i) || re(t(n)) - re(t(i)) : (n, i) => e(n, i) || re(n) - re(i) : null;
  }
  function aM(e) {
    return e && e.constructor === ga;
  }
  function ga() {
    const e = [], t = [], n = [], i = [], r = [];
    let o = null, s = !1;
    return {
      constructor: ga,
      insert(a) {
        const u = X(a), l = u.length;
        for (let c = 0; c < l; ++c) e.push(u[c]);
        return this;
      },
      remove(a) {
        const u = fe(a) ? i : t, l = X(a), c = l.length;
        for (let f = 0; f < c; ++f) u.push(l[f]);
        return this;
      },
      modify(a, u, l) {
        const c = {
          field: u,
          value: Gt(l)
        };
        return fe(a) ? (c.filter = a, r.push(c)) : (c.tuple = a, n.push(c)), this;
      },
      encode(a, u) {
        return fe(a) ? r.push({
          filter: a,
          field: u
        }) : n.push({
          tuple: a,
          field: u
        }), this;
      },
      clean(a) {
        return o = a, this;
      },
      reflow() {
        return s = !0, this;
      },
      pulse(a, u) {
        const l = {}, c = {};
        let f, d, h, g, p, m;
        for (f = 0, d = u.length; f < d; ++f)
          l[re(u[f])] = 1;
        for (f = 0, d = t.length; f < d; ++f)
          p = t[f], l[re(p)] = -1;
        for (f = 0, d = i.length; f < d; ++f)
          g = i[f], u.forEach((b) => {
            g(b) && (l[re(b)] = -1);
          });
        for (f = 0, d = e.length; f < d; ++f)
          p = e[f], m = re(p), l[m] ? l[m] = 1 : a.add.push(Ce(e[f]));
        for (f = 0, d = u.length; f < d; ++f)
          p = u[f], l[re(p)] < 0 && a.rem.push(p);
        function y(b, v, x) {
          x ? b[v] = x(b) : a.encode = v, s || (c[re(b)] = b);
        }
        for (f = 0, d = n.length; f < d; ++f)
          h = n[f], p = h.tuple, g = h.field, m = l[re(p)], m > 0 && (y(p, g, h.value), a.modifies(g));
        for (f = 0, d = r.length; f < d; ++f)
          h = r[f], g = h.filter, u.forEach((b) => {
            g(b) && l[re(b)] > 0 && y(b, h.field, h.value);
          }), a.modifies(h.field);
        if (s)
          a.mod = t.length || i.length ? u.filter((b) => l[re(b)] > 0) : u.slice();
        else
          for (m in c) a.mod.push(c[m]);
        return (o || o == null && (t.length || i.length)) && a.clean(!0), a;
      }
    };
  }
  const zd = "_:mod:_";
  function tp() {
    Object.defineProperty(this, zd, {
      writable: !0,
      value: {}
    });
  }
  tp.prototype = {
    /**
     * Set a parameter value. If the parameter value changes, the parameter
     * will be recorded as modified.
     * @param {string} name - The parameter name.
     * @param {number} index - The index into an array-value parameter. Ignored if
     *   the argument is undefined, null or less than zero.
     * @param {*} value - The parameter value to set.
     * @param {boolean} [force=false] - If true, records the parameter as modified
     *   even if the value is unchanged.
     * @return {Parameters} - This parameter object.
     */
    set(e, t, n, i) {
      const r = this, o = r[e], s = r[zd];
      return t != null && t >= 0 ? (o[t] !== n || i) && (o[t] = n, s[t + ":" + e] = -1, s[e] = -1) : (o !== n || i) && (r[e] = n, s[e] = P(n) ? 1 + n.length : -1), r;
    },
    /**
     * Tests if one or more parameters has been modified. If invoked with no
     * arguments, returns true if any parameter value has changed. If the first
     * argument is array, returns trues if any parameter name in the array has
     * changed. Otherwise, tests if the given name and optional array index has
     * changed.
     * @param {string} name - The parameter name to test.
     * @param {number} [index=undefined] - The parameter array index to test.
     * @return {boolean} - Returns true if a queried parameter was modified.
     */
    modified(e, t) {
      const n = this[zd];
      if (arguments.length) {
        if (P(e)) {
          for (let i = 0; i < e.length; ++i)
            if (n[e[i]]) return !0;
          return !1;
        }
      } else {
        for (const i in n)
          if (n[i]) return !0;
        return !1;
      }
      return t != null && t >= 0 ? t + 1 < n[e] || !!n[t + ":" + e] : !!n[e];
    },
    /**
     * Clears the modification records. After calling this method,
     * all parameters are considered unmodified.
     */
    clear() {
      return this[zd] = {}, this;
    }
  };
  let _z = 0;
  const Sz = "pulse", $z = new tp(), kz = 1, Az = 2;
  function Ie(e, t, n, i) {
    this.id = ++_z, this.value = e, this.stamp = -1, this.rank = -1, this.qrank = -1, this.flags = 0, t && (this._update = t), n && this.parameters(n, i);
  }
  function C_(e) {
    return function(t) {
      const n = this.flags;
      return arguments.length === 0 ? !!(n & e) : (this.flags = t ? n | e : n & ~e, this);
    };
  }
  Ie.prototype = {
    /**
     * Returns a list of target operators dependent on this operator.
     * If this list does not exist, it is created and then returned.
     * @return {UniqueList}
     */
    targets() {
      return this._targets || (this._targets = Qg(tf));
    },
    /**
     * Sets the value of this operator.
     * @param {*} value - the value to set.
     * @return {Number} Returns 1 if the operator value has changed
     *   according to strict equality, returns 0 otherwise.
     */
    set(e) {
      return this.value !== e ? (this.value = e, 1) : 0;
    },
    /**
     * Indicates that operator evaluation should be skipped on the next pulse.
     * This operator will still propagate incoming pulses, but its update function
     * will not be invoked. The skip flag is reset after every pulse, so calling
     * this method will affect processing of the next pulse only.
     */
    skip: C_(kz),
    /**
     * Indicates that this operator's value has been modified on its most recent
     * pulse. Normally modification is checked via strict equality; however, in
     * some cases it is more efficient to update the internal state of an object.
     * In those cases, the modified flag can be used to trigger propagation. Once
     * set, the modification flag persists across pulses until unset. The flag can
     * be used with the last timestamp to test if a modification is recent.
     */
    modified: C_(Az),
    /**
     * Sets the parameters for this operator. The parameter values are analyzed for
     * operator instances. If found, this operator will be added as a dependency
     * of the parameterizing operator. Operator values are dynamically marshalled
     * from each operator parameter prior to evaluation. If a parameter value is
     * an array, the array will also be searched for Operator instances. However,
     * the search does not recurse into sub-arrays or object properties.
     * @param {object} params - A hash of operator parameters.
     * @param {boolean} [react=true] - A flag indicating if this operator should
     *   automatically update (react) when parameter values change. In other words,
     *   this flag determines if the operator registers itself as a listener on
     *   any upstream operators included in the parameters.
     * @param {boolean} [initonly=false] - A flag indicating if this operator
     *   should calculate an update only upon its initial evaluation, then
     *   deregister dependencies and suppress all future update invocations.
     * @return {Operator[]} - An array of upstream dependencies.
     */
    parameters(e, t, n) {
      t = t !== !1;
      const i = this._argval = this._argval || new tp(), r = this._argops = this._argops || [], o = [];
      let s, a, u, l;
      const c = (f, d, h) => {
        h instanceof Ie ? (h !== this && (t && h.targets().add(this), o.push(h)), r.push({
          op: h,
          name: f,
          index: d
        })) : i.set(f, d, h);
      };
      for (s in e)
        if (a = e[s], s === Sz)
          X(a).forEach((f) => {
            f instanceof Ie ? f !== this && (f.targets().add(this), o.push(f)) : R("Pulse parameters must be operator instances.");
          }), this.source = a;
        else if (P(a))
          for (i.set(s, -1, Array(u = a.length)), l = 0; l < u; ++l) c(s, l, a[l]);
        else
          c(s, -1, a);
      return this.marshall().clear(), n && (r.initonly = !0), o;
    },
    /**
     * Internal method for marshalling parameter values.
     * Visits each operator dependency to pull the latest value.
     * @return {Parameters} A Parameters object to pass to the update function.
     */
    marshall(e) {
      const t = this._argval || $z, n = this._argops;
      let i, r, o, s;
      if (n) {
        const a = n.length;
        for (r = 0; r < a; ++r)
          i = n[r], o = i.op, s = o.modified() && o.stamp === e, t.set(i.name, i.index, o.value, s);
        if (n.initonly) {
          for (r = 0; r < a; ++r)
            i = n[r], i.op.targets().remove(this);
          this._argops = null, this._update = null;
        }
      }
      return t;
    },
    /**
     * Detach this operator from the dataflow.
     * Unregisters listeners on upstream dependencies.
     */
    detach() {
      const e = this._argops;
      let t, n, i, r;
      if (e)
        for (t = 0, n = e.length; t < n; ++t)
          i = e[t], r = i.op, r._targets && r._targets.remove(this);
      this.pulse = null, this.source = null;
    },
    /**
     * Delegate method to perform operator processing.
     * Subclasses can override this method to perform custom processing.
     * By default, it marshalls parameters and calls the update function
     * if that function is defined. If the update function does not
     * change the operator value then StopPropagation is returned.
     * If no update function is defined, this method does nothing.
     * @param {Pulse} pulse - the current dataflow pulse.
     * @return The output pulse or StopPropagation. A falsy return value
     *   (including undefined) will let the input pulse pass through.
     */
    evaluate(e) {
      const t = this._update;
      if (t) {
        const n = this.marshall(e.stamp), i = t.call(this, n, e);
        if (n.clear(), i !== this.value)
          this.value = i;
        else if (!this.modified())
          return e.StopPropagation;
      }
    },
    /**
     * Run this operator for the current pulse. If this operator has already
     * been run at (or after) the pulse timestamp, returns StopPropagation.
     * Internally, this method calls {@link evaluate} to perform processing.
     * If {@link evaluate} returns a falsy value, the input pulse is returned.
     * This method should NOT be overridden, instead overrride {@link evaluate}.
     * @param {Pulse} pulse - the current dataflow pulse.
     * @return the output pulse for this operator (or StopPropagation)
     */
    run(e) {
      if (e.stamp < this.stamp) return e.StopPropagation;
      let t;
      return this.skip() ? (this.skip(!1), t = 0) : t = this.evaluate(e), this.pulse = t || e;
    }
  };
  function Cz(e, t, n, i) {
    let r = 1, o;
    return e instanceof Ie ? o = e : e && e.prototype instanceof Ie ? o = new e() : fe(e) ? o = new Ie(null, e) : (r = 0, o = new Ie(e, t)), this.rank(o), r && (i = n, n = t), n && this.connect(o, o.parameters(n, i)), this.touch(o), o;
  }
  function Fz(e, t) {
    const n = e.rank, i = t.length;
    for (let r = 0; r < i; ++r)
      if (n < t[r].rank) {
        this.rerank(e);
        return;
      }
  }
  let Mz = 0;
  function np(e, t, n) {
    this.id = ++Mz, this.value = null, n && (this.receive = n), e && (this._filter = e), t && (this._apply = t);
  }
  function co(e, t, n) {
    return new np(e, t, n);
  }
  np.prototype = {
    _filter: Jn,
    _apply: Ht,
    targets() {
      return this._targets || (this._targets = Qg(tf));
    },
    consume(e) {
      return arguments.length ? (this._consume = !!e, this) : !!this._consume;
    },
    receive(e) {
      if (this._filter(e)) {
        const t = this.value = this._apply(e), n = this._targets, i = n ? n.length : 0;
        for (let r = 0; r < i; ++r) n[r].receive(t);
        this._consume && (e.preventDefault(), e.stopPropagation());
      }
    },
    filter(e) {
      const t = co(e);
      return this.targets().add(t), t;
    },
    apply(e) {
      const t = co(null, e);
      return this.targets().add(t), t;
    },
    merge() {
      const e = co();
      this.targets().add(e);
      for (let t = 0, n = arguments.length; t < n; ++t)
        arguments[t].targets().add(e);
      return e;
    },
    throttle(e) {
      let t = -1;
      return this.filter(() => {
        const n = Date.now();
        return n - t > e ? (t = n, 1) : 0;
      });
    },
    debounce(e) {
      const t = co();
      return this.targets().add(co(null, null, Ub(e, (n) => {
        const i = n.dataflow;
        t.receive(n), i && i.run && i.run();
      }))), t;
    },
    between(e, t) {
      let n = !1;
      return e.targets().add(co(null, null, () => n = !0)), t.targets().add(co(null, null, () => n = !1)), this.filter(() => n);
    },
    detach() {
      this._filter = Jn, this._targets = null;
    }
  };
  function Tz(e, t, n, i) {
    const r = this, o = co(n, i), s = function(l) {
      l.dataflow = r;
      try {
        o.receive(l);
      } catch (c) {
        r.error(c);
      } finally {
        r.run();
      }
    };
    let a;
    typeof e == "string" && typeof document < "u" ? a = document.querySelectorAll(e) : a = X(e);
    const u = a.length;
    for (let l = 0; l < u; ++l)
      a[l].addEventListener(t, s);
    return o;
  }
  function Dz(e, t) {
    const n = this.locale();
    return iM(e, t, n.timeParse, n.utcParse);
  }
  function Nz(e, t, n) {
    return t = this.parse(t, n), this.pulse(e, this.changeset().insert(t));
  }
  async function Oz(e, t) {
    const n = this;
    let i = 0, r;
    try {
      r = await n.loader().load(e, {
        context: "dataflow",
        response: nM(t && t.type)
      });
      try {
        r = n.parse(r, t);
      } catch (o) {
        i = -2, n.warn("Data ingestion failed", e, o);
      }
    } catch (o) {
      i = -1, n.warn("Loading failed", e, o);
    }
    return {
      data: r,
      status: i
    };
  }
  async function Rz(e, t, n) {
    const i = this, r = i._pending || Lz(i);
    r.requests += 1;
    const o = await i.request(t, n);
    return i.pulse(e, i.changeset().remove(Jn).insert(o.data || [])), r.done(), o;
  }
  function Lz(e) {
    let t;
    const n = new Promise((i) => t = i);
    return n.requests = 0, n.done = () => {
      --n.requests === 0 && (e._pending = null, t(e));
    }, e._pending = n;
  }
  const Pz = {
    skip: !0
  };
  function Iz(e, t, n, i, r) {
    return (e instanceof Ie ? Bz : zz)(this, e, t, n, i, r), this;
  }
  function zz(e, t, n, i, r, o) {
    const s = ce({}, o, Pz);
    let a, u;
    fe(n) || (n = Gt(n)), i === void 0 ? a = (l) => e.touch(n(l)) : fe(i) ? (u = new Ie(null, i, r, !1), a = (l) => {
      u.evaluate(l);
      const c = n(l), f = u.value;
      aM(f) ? e.pulse(c, f, o) : e.update(c, f, s);
    }) : a = (l) => e.update(n(l), i, s), t.apply(a);
  }
  function Bz(e, t, n, i, r, o) {
    if (i === void 0)
      t.targets().add(n);
    else {
      const s = o || {}, a = new Ie(null, Uz(n, i), r, !1);
      a.modified(s.force), a.rank = t.rank, t.targets().add(a), n && (a.skip(!0), a.value = n.value, a.targets().add(n), e.connect(n, [a]));
    }
  }
  function Uz(e, t) {
    return t = fe(t) ? t : Gt(t), e ? function(n, i) {
      const r = t(n, i);
      return e.skip() || (e.skip(r !== this.value).value = r), r;
    } : t;
  }
  function jz(e) {
    e.rank = ++this._rank;
  }
  function qz(e) {
    const t = [e];
    let n, i, r;
    for (; t.length; )
      if (this.rank(n = t.pop()), i = n._targets)
        for (r = i.length; --r >= 0; )
          t.push(n = i[r]), n === e && R("Cycle detected in dataflow graph.");
  }
  const bh = {}, qi = 1, go = 2, Cr = 4, Wz = qi | go, F_ = qi | Cr, Ma = qi | go | Cr, M_ = 8, wl = 16, T_ = 32, D_ = 64;
  function Mo(e, t, n) {
    this.dataflow = e, this.stamp = t ?? -1, this.add = [], this.rem = [], this.mod = [], this.fields = null, this.encode = n || null;
  }
  function i0(e, t) {
    const n = [];
    return ho(e, t, (i) => n.push(i)), n;
  }
  function N_(e, t) {
    const n = {};
    return e.visit(t, (i) => {
      n[re(i)] = 1;
    }), (i) => n[re(i)] ? null : i;
  }
  function Qf(e, t) {
    return e ? (n, i) => e(n, i) && t(n, i) : t;
  }
  Mo.prototype = {
    /**
     * Sentinel value indicating pulse propagation should stop.
     */
    StopPropagation: bh,
    /**
     * Boolean flag indicating ADD (added) tuples.
     */
    ADD: qi,
    /**
     * Boolean flag indicating REM (removed) tuples.
     */
    REM: go,
    /**
     * Boolean flag indicating MOD (modified) tuples.
     */
    MOD: Cr,
    /**
     * Boolean flag indicating ADD (added) and REM (removed) tuples.
     */
    ADD_REM: Wz,
    /**
     * Boolean flag indicating ADD (added) and MOD (modified) tuples.
     */
    ADD_MOD: F_,
    /**
     * Boolean flag indicating ADD, REM and MOD tuples.
     */
    ALL: Ma,
    /**
     * Boolean flag indicating all tuples in a data source
     * except for the ADD, REM and MOD tuples.
     */
    REFLOW: M_,
    /**
     * Boolean flag indicating a 'pass-through' to a
     * backing data source, ignoring ADD, REM and MOD tuples.
     */
    SOURCE: wl,
    /**
     * Boolean flag indicating that source data should be
     * suppressed when creating a forked pulse.
     */
    NO_SOURCE: T_,
    /**
     * Boolean flag indicating that field modifications should be
     * suppressed when creating a forked pulse.
     */
    NO_FIELDS: D_,
    /**
     * Creates a new pulse based on the values of this pulse.
     * The dataflow, time stamp and field modification values are copied over.
     * By default, new empty ADD, REM and MOD arrays are created.
     * @param {number} flags - Integer of boolean flags indicating which (if any)
     *   tuple arrays should be copied to the new pulse. The supported flag values
     *   are ADD, REM and MOD. Array references are copied directly: new array
     *   instances are not created.
     * @return {Pulse} - The forked pulse instance.
     * @see init
     */
    fork(e) {
      return new Mo(this.dataflow).init(this, e);
    },
    /**
     * Creates a copy of this pulse with new materialized array
     * instances for the ADD, REM, MOD, and SOURCE arrays.
     * The dataflow, time stamp and field modification values are copied over.
     * @return {Pulse} - The cloned pulse instance.
     * @see init
     */
    clone() {
      const e = this.fork(Ma);
      return e.add = e.add.slice(), e.rem = e.rem.slice(), e.mod = e.mod.slice(), e.source && (e.source = e.source.slice()), e.materialize(Ma | wl);
    },
    /**
     * Returns a pulse that adds all tuples from a backing source. This is
     * useful for cases where operators are added to a dataflow after an
     * upstream data pipeline has already been processed, ensuring that
     * new operators can observe all tuples within a stream.
     * @return {Pulse} - A pulse instance with all source tuples included
     *   in the add array. If the current pulse already has all source
     *   tuples in its add array, it is returned directly. If the current
     *   pulse does not have a backing source, it is returned directly.
     */
    addAll() {
      let e = this;
      return !e.source || e.add === e.rem || !e.rem.length && e.source.length === e.add.length || (e = new Mo(this.dataflow).init(this), e.add = e.source, e.rem = []), e;
    },
    /**
     * Initialize this pulse based on the values of another pulse. This method
     * is used internally by {@link fork} to initialize a new forked tuple.
     * The dataflow, time stamp and field modification values are copied over.
     * By default, new empty ADD, REM and MOD arrays are created.
     * @param {Pulse} src - The source pulse to copy from.
     * @param {number} flags - Integer of boolean flags indicating which (if any)
     *   tuple arrays should be copied to the new pulse. The supported flag values
     *   are ADD, REM and MOD. Array references are copied directly: new array
     *   instances are not created. By default, source data arrays are copied
     *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.
     * @return {Pulse} - Returns this Pulse instance.
     */
    init(e, t) {
      const n = this;
      return n.stamp = e.stamp, n.encode = e.encode, e.fields && !(t & D_) && (n.fields = e.fields), t & qi ? (n.addF = e.addF, n.add = e.add) : (n.addF = null, n.add = []), t & go ? (n.remF = e.remF, n.rem = e.rem) : (n.remF = null, n.rem = []), t & Cr ? (n.modF = e.modF, n.mod = e.mod) : (n.modF = null, n.mod = []), t & T_ ? (n.srcF = null, n.source = null) : (n.srcF = e.srcF, n.source = e.source, e.cleans && (n.cleans = e.cleans)), n;
    },
    /**
     * Schedules a function to run after pulse propagation completes.
     * @param {function} func - The function to run.
     */
    runAfter(e) {
      this.dataflow.runAfter(e);
    },
    /**
     * Indicates if tuples have been added, removed or modified.
     * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.
     *   Defaults to ALL, returning true if any tuple type has changed.
     * @return {boolean} - Returns true if one or more queried tuple types have
     *   changed, false otherwise.
     */
    changed(e) {
      const t = e || Ma;
      return t & qi && this.add.length || t & go && this.rem.length || t & Cr && this.mod.length;
    },
    /**
     * Forces a "reflow" of tuple values, such that all tuples in the backing
     * source are added to the MOD set, unless already present in the ADD set.
     * @param {boolean} [fork=false] - If true, returns a forked copy of this
     *   pulse, and invokes reflow on that derived pulse.
     * @return {Pulse} - The reflowed pulse instance.
     */
    reflow(e) {
      if (e) return this.fork(Ma).reflow();
      const t = this.add.length, n = this.source && this.source.length;
      return n && n !== t && (this.mod = this.source, t && this.filter(Cr, N_(this, qi))), this;
    },
    /**
     * Get/set metadata to pulse requesting garbage collection
     * to reclaim currently unused resources.
     */
    clean(e) {
      return arguments.length ? (this.cleans = !!e, this) : this.cleans;
    },
    /**
     * Marks one or more data field names as modified to assist dependency
     * tracking and incremental processing by transform operators.
     * @param {string|Array<string>} _ - The field(s) to mark as modified.
     * @return {Pulse} - This pulse instance.
     */
    modifies(e) {
      const t = this.fields || (this.fields = {});
      return P(e) ? e.forEach((n) => t[n] = !0) : t[e] = !0, this;
    },
    /**
     * Checks if one or more data fields have been modified during this pulse
     * propagation timestamp.
     * @param {string|Array<string>} _ - The field(s) to check for modified.
     * @param {boolean} nomod - If true, will check the modified flag even if
     *   no mod tuples exist. If false (default), mod tuples must be present.
     * @return {boolean} - Returns true if any of the provided fields has been
     *   marked as modified, false otherwise.
     */
    modified(e, t) {
      const n = this.fields;
      return (t || this.mod.length) && n ? arguments.length ? P(e) ? e.some((i) => n[i]) : n[e] : !!n : !1;
    },
    /**
     * Adds a filter function to one more tuple sets. Filters are applied to
     * backing tuple arrays, to determine the actual set of tuples considered
     * added, removed or modified. They can be used to delay materialization of
     * a tuple set in order to avoid expensive array copies. In addition, the
     * filter functions can serve as value transformers: unlike standard predicate
     * function (which return boolean values), Pulse filters should return the
     * actual tuple value to process. If a tuple set is already filtered, the
     * new filter function will be appended into a conjuntive ('and') query.
     * @param {number} flags - Flags indicating the tuple set(s) to filter.
     * @param {function(*):object} filter - Filter function that will be applied
     *   to the tuple set array, and should return a data tuple if the value
     *   should be included in the tuple set, and falsy (or null) otherwise.
     * @return {Pulse} - Returns this pulse instance.
     */
    filter(e, t) {
      const n = this;
      return e & qi && (n.addF = Qf(n.addF, t)), e & go && (n.remF = Qf(n.remF, t)), e & Cr && (n.modF = Qf(n.modF, t)), e & wl && (n.srcF = Qf(n.srcF, t)), n;
    },
    /**
     * Materialize one or more tuple sets in this pulse. If the tuple set(s) have
     * a registered filter function, it will be applied and the tuple set(s) will
     * be replaced with materialized tuple arrays.
     * @param {number} flags - Flags indicating the tuple set(s) to materialize.
     * @return {Pulse} - Returns this pulse instance.
     */
    materialize(e) {
      e = e || Ma;
      const t = this;
      return e & qi && t.addF && (t.add = i0(t.add, t.addF), t.addF = null), e & go && t.remF && (t.rem = i0(t.rem, t.remF), t.remF = null), e & Cr && t.modF && (t.mod = i0(t.mod, t.modF), t.modF = null), e & wl && t.srcF && (t.source = t.source.filter(t.srcF), t.srcF = null), t;
    },
    /**
     * Visit one or more tuple sets in this pulse.
     * @param {number} flags - Flags indicating the tuple set(s) to visit.
     *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source
     *   has been set).
     * @param {function(object):*} - Visitor function invoked per-tuple.
     * @return {Pulse} - Returns this pulse instance.
     */
    visit(e, t) {
      const n = this, i = t;
      if (e & wl)
        return ho(n.source, n.srcF, i), n;
      e & qi && ho(n.add, n.addF, i), e & go && ho(n.rem, n.remF, i), e & Cr && ho(n.mod, n.modF, i);
      const r = n.source;
      if (e & M_ && r) {
        const o = n.add.length + n.mod.length;
        o === r.length || (o ? ho(r, N_(n, F_), i) : ho(r, n.srcF, i));
      }
      return n;
    }
  };
  function ov(e, t, n, i) {
    const r = this;
    let o = 0;
    this.dataflow = e, this.stamp = t, this.fields = null, this.encode = i || null, this.pulses = n;
    for (const s of n)
      if (s.stamp === t) {
        if (s.fields) {
          const a = r.fields || (r.fields = {});
          for (const u in s.fields)
            a[u] = 1;
        }
        s.changed(r.ADD) && (o |= r.ADD), s.changed(r.REM) && (o |= r.REM), s.changed(r.MOD) && (o |= r.MOD);
      }
    this.changes = o;
  }
  G(ov, Mo, {
    /**
     * Creates a new pulse based on the values of this pulse.
     * The dataflow, time stamp and field modification values are copied over.
     * @return {Pulse}
     */
    fork(e) {
      const t = new Mo(this.dataflow).init(this, e & this.NO_FIELDS);
      return e !== void 0 && (e & t.ADD && this.visit(t.ADD, (n) => t.add.push(n)), e & t.REM && this.visit(t.REM, (n) => t.rem.push(n)), e & t.MOD && this.visit(t.MOD, (n) => t.mod.push(n))), t;
    },
    changed(e) {
      return this.changes & e;
    },
    modified(e) {
      const t = this, n = t.fields;
      return n && t.changes & t.MOD ? P(e) ? e.some((i) => n[i]) : n[e] : 0;
    },
    filter() {
      R("MultiPulse does not support filtering.");
    },
    materialize() {
      R("MultiPulse does not support materialization.");
    },
    visit(e, t) {
      const n = this, i = n.pulses, r = i.length;
      let o = 0;
      if (e & n.SOURCE)
        for (; o < r; ++o)
          i[o].visit(e, t);
      else
        for (; o < r; ++o)
          i[o].stamp === n.stamp && i[o].visit(e, t);
      return n;
    }
  });
  async function Hz(e, t, n) {
    const i = this, r = [];
    if (i._pulse) return uM(i);
    if (i._pending && await i._pending, t && await Id(i, t), !i._touched.length)
      return i.debug("Dataflow invoked, but nothing to do."), i;
    const o = ++i._clock;
    i._pulse = new Mo(i, o, e), i._touched.forEach((c) => i._enqueue(c, !0)), i._touched = Qg(tf);
    let s = 0, a, u, l;
    try {
      for (; i._heap.size() > 0; ) {
        if (a = i._heap.pop(), a.rank !== a.qrank) {
          i._enqueue(a, !0);
          continue;
        }
        u = a.run(i._getPulse(a, e)), u.then ? u = await u : u.async && (r.push(u.async), u = bh), u !== bh && a._targets && a._targets.forEach((c) => i._enqueue(c)), ++s;
      }
    } catch (c) {
      i._heap.clear(), l = c;
    }
    if (i._input = {}, i._pulse = null, i.debug(`Pulse ${o}: ${s} operators`), l && (i._postrun = [], i.error(l)), i._postrun.length) {
      const c = i._postrun.sort((f, d) => d.priority - f.priority);
      i._postrun = [];
      for (let f = 0; f < c.length; ++f)
        await Id(i, c[f].callback);
    }
    return n && await Id(i, n), r.length && Promise.all(r).then((c) => i.runAsync(null, () => {
      c.forEach((f) => {
        try {
          f(i);
        } catch (d) {
          i.error(d);
        }
      });
    })), i;
  }
  async function Gz(e, t, n) {
    for (; this._running; ) await this._running;
    const i = () => this._running = null;
    return (this._running = this.evaluate(e, t, n)).then(i, i), this._running;
  }
  function Vz(e, t, n) {
    return this._pulse ? uM(this) : (this.evaluate(e, t, n), this);
  }
  function Yz(e, t, n) {
    if (this._pulse || t)
      this._postrun.push({
        priority: n || 0,
        callback: e
      });
    else
      try {
        e(this);
      } catch (i) {
        this.error(i);
      }
  }
  function uM(e) {
    return e.error("Dataflow already running. Use runAsync() to chain invocations."), e;
  }
  function Xz(e, t) {
    const n = e.stamp < this._clock;
    n && (e.stamp = this._clock), (n || t) && (e.qrank = e.rank, this._heap.push(e));
  }
  function Kz(e, t) {
    const n = e.source, i = this._clock;
    return n && P(n) ? new ov(this, i, n.map((r) => r.pulse), t) : this._input[e.id] || Jz(this._pulse, n && n.pulse);
  }
  function Jz(e, t) {
    return t && t.stamp === e.stamp ? t : (e = e.fork(), t && t !== bh && (e.source = t.source), e);
  }
  const sv = {
    skip: !1,
    force: !1
  };
  function Qz(e, t) {
    const n = t || sv;
    return this._pulse ? this._enqueue(e) : this._touched.add(e), n.skip && e.skip(!0), this;
  }
  function Zz(e, t, n) {
    const i = n || sv;
    return (e.set(t) || i.force) && this.touch(e, i), this;
  }
  function e8(e, t, n) {
    this.touch(e, n || sv);
    const i = new Mo(this, this._clock + (this._pulse ? 0 : 1)), r = e.pulse && e.pulse.source || [];
    return i.target = e, this._input[e.id] = t.pulse(i, r), this;
  }
  function t8(e) {
    let t = [];
    return {
      clear: () => t = [],
      size: () => t.length,
      peek: () => t[0],
      push: (n) => (t.push(n), lM(t, 0, t.length - 1, e)),
      pop: () => {
        const n = t.pop();
        let i;
        return t.length ? (i = t[0], t[0] = n, n8(t, 0, e)) : i = n, i;
      }
    };
  }
  function lM(e, t, n, i) {
    let r, o;
    const s = e[n];
    for (; n > t; ) {
      if (o = n - 1 >> 1, r = e[o], i(s, r) < 0) {
        e[n] = r, n = o;
        continue;
      }
      break;
    }
    return e[n] = s;
  }
  function n8(e, t, n) {
    const i = t, r = e.length, o = e[t];
    let s = (t << 1) + 1, a;
    for (; s < r; )
      a = s + 1, a < r && n(e[s], e[a]) >= 0 && (s = a), e[t] = e[s], t = s, s = (t << 1) + 1;
    return e[t] = o, lM(e, i, t, n);
  }
  function Ja() {
    this.logger(Lb()), this.logLevel(Ob), this._clock = 0, this._rank = 0, this._locale = ev();
    try {
      this._loader = Jg();
    } catch {
    }
    this._touched = Qg(tf), this._input = {}, this._pulse = null, this._heap = t8((e, t) => e.qrank - t.qrank), this._postrun = [];
  }
  function El(e) {
    return function() {
      return this._log[e].apply(this, arguments);
    };
  }
  Ja.prototype = {
    /**
     * The current timestamp of this dataflow. This value reflects the
     * timestamp of the previous dataflow run. The dataflow is initialized
     * with a stamp value of 0. The initial run of the dataflow will have
     * a timestap of 1, and so on. This value will match the
     * {@link Pulse.stamp} property.
     * @return {number} - The current timestamp value.
     */
    stamp() {
      return this._clock;
    },
    /**
     * Gets or sets the loader instance to use for data file loading. A
     * loader object must provide a "load" method for loading files and a
     * "sanitize" method for checking URL/filename validity. Both methods
     * should accept a URI and options hash as arguments, and return a Promise
     * that resolves to the loaded file contents (load) or a hash containing
     * sanitized URI data with the sanitized url assigned to the "href" property
     * (sanitize).
     * @param {object} _ - The loader instance to use.
     * @return {object|Dataflow} - If no arguments are provided, returns
     *   the current loader instance. Otherwise returns this Dataflow instance.
     */
    loader(e) {
      return arguments.length ? (this._loader = e, this) : this._loader;
    },
    /**
     * Gets or sets the locale instance to use for formatting and parsing
     * string values. The locale object should be provided by the
     * vega-format library, and include methods such as format, timeFormat,
     * utcFormat, timeParse, and utcParse.
     * @param {object} _ - The locale instance to use.
     * @return {object|Dataflow} - If no arguments are provided, returns
     *   the current locale instance. Otherwise returns this Dataflow instance.
     */
    locale(e) {
      return arguments.length ? (this._locale = e, this) : this._locale;
    },
    /**
     * Get or set the logger instance used to log messages. If no arguments are
     * provided, returns the current logger instance. Otherwise, sets the logger
     * and return this Dataflow instance. Provided loggers must support the full
     * API of logger objects generated by the vega-util logger method. Note that
     * by default the log level of the new logger will be used; use the logLevel
     * method to adjust the log level as needed.
     */
    logger(e) {
      return arguments.length ? (this._log = e, this) : this._log;
    },
    /**
     * Logs an error message. By default, logged messages are written to console
     * output. The message will only be logged if the current log level is high
     * enough to permit error messages.
     */
    error: El("error"),
    /**
     * Logs a warning message. By default, logged messages are written to console
     * output. The message will only be logged if the current log level is high
     * enough to permit warning messages.
     */
    warn: El("warn"),
    /**
     * Logs a information message. By default, logged messages are written to
     * console output. The message will only be logged if the current log level is
     * high enough to permit information messages.
     */
    info: El("info"),
    /**
     * Logs a debug message. By default, logged messages are written to console
     * output. The message will only be logged if the current log level is high
     * enough to permit debug messages.
     */
    debug: El("debug"),
    /**
     * Get or set the current log level. If an argument is provided, it
     * will be used as the new log level.
     * @param {number} [level] - Should be one of None, Warn, Info
     * @return {number} - The current log level.
     */
    logLevel: El("level"),
    /**
     * Empty entry threshold for garbage cleaning. Map data structures will
     * perform cleaning once the number of empty entries exceeds this value.
     */
    cleanThreshold: 1e4,
    // OPERATOR REGISTRATION
    add: Cz,
    connect: Fz,
    rank: jz,
    rerank: qz,
    // OPERATOR UPDATES
    pulse: e8,
    touch: Qz,
    update: Zz,
    changeset: ga,
    // DATA LOADING
    ingest: Nz,
    parse: Dz,
    preload: Rz,
    request: Oz,
    // EVENT HANDLING
    events: Tz,
    on: Iz,
    // PULSE PROPAGATION
    evaluate: Hz,
    run: Vz,
    runAsync: Gz,
    runAfter: Yz,
    _enqueue: Xz,
    _getPulse: Kz
  };
  function N(e, t) {
    Ie.call(this, e, null, t);
  }
  G(N, Ie, {
    /**
     * Overrides {@link Operator.evaluate} for transform operators.
     * Internally, this method calls {@link evaluate} to perform processing.
     * If {@link evaluate} returns a falsy value, the input pulse is returned.
     * This method should NOT be overridden, instead overrride {@link evaluate}.
     * @param {Pulse} pulse - the current dataflow pulse.
     * @return the output pulse for this operator (or StopPropagation)
     */
    run(e) {
      if (e.stamp < this.stamp) return e.StopPropagation;
      let t;
      return this.skip() ? this.skip(!1) : t = this.evaluate(e), t = t || e, t.then ? t = t.then((n) => this.pulse = n) : t !== e.StopPropagation && (this.pulse = t), t;
    },
    /**
     * Overrides {@link Operator.evaluate} for transform operators.
     * Marshalls parameter values and then invokes {@link transform}.
     * @param {Pulse} pulse - the current dataflow pulse.
     * @return {Pulse} The output pulse (or StopPropagation). A falsy return
         value (including undefined) will let the input pulse pass through.
    */
    evaluate(e) {
      const t = this.marshall(e.stamp), n = this.transform(t, e);
      return t.clear(), n;
    },
    /**
     * Process incoming pulses.
     * Subclasses should override this method to implement transforms.
     * @param {Parameters} _ - The operator parameter values.
     * @param {Pulse} pulse - The current dataflow pulse.
     * @return {Pulse} The output pulse (or StopPropagation). A falsy return
     *   value (including undefined) will let the input pulse pass through.
     */
    transform() {
    }
  });
  const du = {};
  function cM(e) {
    const t = fM(e);
    return t && t.Definition || null;
  }
  function fM(e) {
    return e = e && e.toLowerCase(), J(du, e) ? du[e] : null;
  }
  function* dM(e, t) {
    if (t == null)
      for (let n of e)
        n != null && n !== "" && (n = +n) >= n && (yield n);
    else {
      let n = -1;
      for (let i of e)
        i = t(i, ++n, e), i != null && i !== "" && (i = +i) >= i && (yield i);
    }
  }
  function av(e, t, n) {
    const i = Float64Array.from(dM(e, n));
    return i.sort(zr), t.map((r) => uF(i, r));
  }
  function uv(e, t) {
    return av(e, [0.25, 0.5, 0.75], t);
  }
  function lv(e, t) {
    const n = e.length, i = fP(e, t), r = uv(e, t), o = (r[2] - r[0]) / 1.34;
    return 1.06 * (Math.min(i, o) || i || Math.abs(r[0]) || 1) * Math.pow(n, -0.2);
  }
  function hM(e) {
    const t = e.maxbins || 20, n = e.base || 10, i = Math.log(n), r = e.divide || [5, 2];
    let o = e.extent[0], s = e.extent[1], a, u, l, c, f, d;
    const h = e.span || s - o || Math.abs(o) || 1;
    if (e.step)
      a = e.step;
    else if (e.steps) {
      for (c = h / t, f = 0, d = e.steps.length; f < d && e.steps[f] < c; ++f) ;
      a = e.steps[Math.max(0, f - 1)];
    } else {
      for (u = Math.ceil(Math.log(t) / i), l = e.minstep || 0, a = Math.max(l, Math.pow(n, Math.round(Math.log(h) / i) - u)); Math.ceil(h / a) > t; )
        a *= n;
      for (f = 0, d = r.length; f < d; ++f)
        c = a / r[f], c >= l && h / c <= t && (a = c);
    }
    c = Math.log(a);
    const g = c >= 0 ? 0 : ~~(-c / i) + 1, p = Math.pow(n, -g - 1);
    return (e.nice || e.nice === void 0) && (c = Math.floor(o / a + p) * a, o = o < c ? c - a : c, s = Math.ceil(s / a) * a), {
      start: o,
      stop: s === o ? o + a : s,
      step: a
    };
  }
  var Zn = Math.random;
  function i8(e) {
    Zn = e;
  }
  function gM(e, t, n, i) {
    if (!e.length) return [void 0, void 0];
    const r = Float64Array.from(dM(e, i)), o = r.length, s = t;
    let a, u, l, c;
    for (l = 0, c = Array(s); l < s; ++l) {
      for (a = 0, u = 0; u < o; ++u)
        a += r[~~(Zn() * o)];
      c[l] = a / o;
    }
    return c.sort(zr), [A1(c, n / 2), A1(c, 1 - n / 2)];
  }
  function pM(e, t, n, i) {
    i = i || ((d) => d);
    const r = e.length, o = new Float64Array(r);
    let s = 0, a = 1, u = i(e[0]), l = u, c = u + t, f;
    for (; a < r; ++a) {
      if (f = i(e[a]), f >= c) {
        for (l = (u + l) / 2; s < a; ++s) o[s] = l;
        c = f + t, u = f;
      }
      l = f;
    }
    for (l = (u + l) / 2; s < a; ++s) o[s] = l;
    return n ? r8(o, t + t / 4) : o;
  }
  function r8(e, t) {
    const n = e.length;
    let i = 0, r = 1, o, s;
    for (; e[i] === e[r]; ) ++r;
    for (; r < n; ) {
      for (o = r + 1; e[r] === e[o]; ) ++o;
      if (e[r] - e[r - 1] < t) {
        for (s = r + (i + o - r - r >> 1); s < r; ) e[s++] = e[r];
        for (; s > r; ) e[s--] = e[i];
      }
      i = r, r = o;
    }
    return e;
  }
  function o8(e) {
    return function() {
      return e = (1103515245 * e + 12345) % 2147483647, e / 2147483647;
    };
  }
  function s8(e, t) {
    t == null && (t = e, e = 0);
    let n, i, r;
    const o = {
      min(s) {
        return arguments.length ? (n = s || 0, r = i - n, o) : n;
      },
      max(s) {
        return arguments.length ? (i = s || 0, r = i - n, o) : i;
      },
      sample() {
        return n + Math.floor(r * Zn());
      },
      pdf(s) {
        return s === Math.floor(s) && s >= n && s < i ? 1 / r : 0;
      },
      cdf(s) {
        const a = Math.floor(s);
        return a < n ? 0 : a >= i ? 1 : (a - n + 1) / r;
      },
      icdf(s) {
        return s >= 0 && s <= 1 ? n - 1 + Math.floor(s * r) : NaN;
      }
    };
    return o.min(e).max(t);
  }
  const mM = Math.sqrt(2 * Math.PI), a8 = Math.SQRT2;
  let _l = NaN;
  function ip(e, t) {
    e = e || 0, t = t ?? 1;
    let n = 0, i = 0, r, o;
    if (_l === _l)
      n = _l, _l = NaN;
    else {
      do
        n = Zn() * 2 - 1, i = Zn() * 2 - 1, r = n * n + i * i;
      while (r === 0 || r > 1);
      o = Math.sqrt(-2 * Math.log(r) / r), n *= o, _l = i * o;
    }
    return e + n * t;
  }
  function cv(e, t, n) {
    n = n ?? 1;
    const i = (e - (t || 0)) / n;
    return Math.exp(-0.5 * i * i) / (n * mM);
  }
  function rp(e, t, n) {
    t = t || 0, n = n ?? 1;
    const i = (e - t) / n, r = Math.abs(i);
    let o;
    if (r > 37)
      o = 0;
    else {
      const s = Math.exp(-r * r / 2);
      let a;
      r < 7.07106781186547 ? (a = 0.0352624965998911 * r + 0.700383064443688, a = a * r + 6.37396220353165, a = a * r + 33.912866078383, a = a * r + 112.079291497871, a = a * r + 221.213596169931, a = a * r + 220.206867912376, o = s * a, a = 0.0883883476483184 * r + 1.75566716318264, a = a * r + 16.064177579207, a = a * r + 86.7807322029461, a = a * r + 296.564248779674, a = a * r + 637.333633378831, a = a * r + 793.826512519948, a = a * r + 440.413735824752, o = o / a) : (a = r + 0.65, a = r + 4 / a, a = r + 3 / a, a = r + 2 / a, a = r + 1 / a, o = s / a / 2.506628274631);
    }
    return i > 0 ? 1 - o : o;
  }
  function op(e, t, n) {
    return e < 0 || e > 1 ? NaN : (t || 0) + (n ?? 1) * a8 * u8(2 * e - 1);
  }
  function u8(e) {
    let t = -Math.log((1 - e) * (1 + e)), n;
    return t < 6.25 ? (t -= 3.125, n = -364441206401782e-35, n = -16850591381820166e-35 + n * t, n = 128584807152564e-32 + n * t, n = 11157877678025181e-33 + n * t, n = -1333171662854621e-31 + n * t, n = 20972767875968562e-33 + n * t, n = 6637638134358324e-30 + n * t, n = -4054566272975207e-29 + n * t, n = -8151934197605472e-29 + n * t, n = 26335093153082323e-28 + n * t, n = -12975133253453532e-27 + n * t, n = -5415412054294628e-26 + n * t, n = 10512122733215323e-25 + n * t, n = -4112633980346984e-24 + n * t, n = -29070369957882005e-24 + n * t, n = 42347877827932404e-23 + n * t, n = -13654692000834679e-22 + n * t, n = -13882523362786469e-21 + n * t, n = 18673420803405714e-20 + n * t, n = -740702534166267e-18 + n * t, n = -0.006033670871430149 + n * t, n = 0.24015818242558962 + n * t, n = 1.6536545626831027 + n * t) : t < 16 ? (t = Math.sqrt(t) - 3.25, n = 22137376921775787e-25, n = 9075656193888539e-23 + n * t, n = -27517406297064545e-23 + n * t, n = 18239629214389228e-24 + n * t, n = 15027403968909828e-22 + n * t, n = -4013867526981546e-21 + n * t, n = 29234449089955446e-22 + n * t, n = 12475304481671779e-21 + n * t, n = -47318229009055734e-21 + n * t, n = 6828485145957318e-20 + n * t, n = 24031110387097894e-21 + n * t, n = -3550375203628475e-19 + n * t, n = 9532893797373805e-19 + n * t, n = -0.0016882755560235047 + n * t, n = 0.002491442096107851 + n * t, n = -0.003751208507569241 + n * t, n = 0.005370914553590064 + n * t, n = 1.0052589676941592 + n * t, n = 3.0838856104922208 + n * t) : Number.isFinite(t) ? (t = Math.sqrt(t) - 5, n = -27109920616438573e-27, n = -2555641816996525e-25 + n * t, n = 15076572693500548e-25 + n * t, n = -3789465440126737e-24 + n * t, n = 761570120807834e-23 + n * t, n = -1496002662714924e-23 + n * t, n = 2914795345090108e-23 + n * t, n = -6771199775845234e-23 + n * t, n = 22900482228026655e-23 + n * t, n = -99298272942317e-20 + n * t, n = 4526062597223154e-21 + n * t, n = -1968177810553167e-20 + n * t, n = 7599527703001776e-20 + n * t, n = -21503011930044477e-20 + n * t, n = -13871931833623122e-20 + n * t, n = 1.0103004648645344 + n * t, n = 4.849906401408584 + n * t) : n = 1 / 0, n * e;
  }
  function fv(e, t) {
    let n, i;
    const r = {
      mean(o) {
        return arguments.length ? (n = o || 0, r) : n;
      },
      stdev(o) {
        return arguments.length ? (i = o ?? 1, r) : i;
      },
      sample: () => ip(n, i),
      pdf: (o) => cv(o, n, i),
      cdf: (o) => rp(o, n, i),
      icdf: (o) => op(o, n, i)
    };
    return r.mean(e).stdev(t);
  }
  function dv(e, t) {
    const n = fv();
    let i = 0;
    const r = {
      data(o) {
        return arguments.length ? (e = o, i = o ? o.length : 0, r.bandwidth(t)) : e;
      },
      bandwidth(o) {
        return arguments.length ? (t = o, !t && e && (t = lv(e)), r) : t;
      },
      sample() {
        return e[~~(Zn() * i)] + t * n.sample();
      },
      pdf(o) {
        let s = 0, a = 0;
        for (; a < i; ++a)
          s += n.pdf((o - e[a]) / t);
        return s / t / i;
      },
      cdf(o) {
        let s = 0, a = 0;
        for (; a < i; ++a)
          s += n.cdf((o - e[a]) / t);
        return s / i;
      },
      icdf() {
        throw Error("KDE icdf not supported.");
      }
    };
    return r.data(e);
  }
  function hv(e, t) {
    return e = e || 0, t = t ?? 1, Math.exp(e + ip() * t);
  }
  function gv(e, t, n) {
    if (e <= 0) return 0;
    t = t || 0, n = n ?? 1;
    const i = (Math.log(e) - t) / n;
    return Math.exp(-0.5 * i * i) / (n * mM * e);
  }
  function pv(e, t, n) {
    return rp(Math.log(e), t, n);
  }
  function mv(e, t, n) {
    return Math.exp(op(e, t, n));
  }
  function yM(e, t) {
    let n, i;
    const r = {
      mean(o) {
        return arguments.length ? (n = o || 0, r) : n;
      },
      stdev(o) {
        return arguments.length ? (i = o ?? 1, r) : i;
      },
      sample: () => hv(n, i),
      pdf: (o) => gv(o, n, i),
      cdf: (o) => pv(o, n, i),
      icdf: (o) => mv(o, n, i)
    };
    return r.mean(e).stdev(t);
  }
  function bM(e, t) {
    let n = 0, i;
    function r(s) {
      const a = [];
      let u = 0, l;
      for (l = 0; l < n; ++l)
        u += a[l] = s[l] == null ? 1 : +s[l];
      for (l = 0; l < n; ++l)
        a[l] /= u;
      return a;
    }
    const o = {
      weights(s) {
        return arguments.length ? (i = r(t = s || []), o) : t;
      },
      distributions(s) {
        return arguments.length ? (s ? (n = s.length, e = s) : (n = 0, e = []), o.weights(t)) : e;
      },
      sample() {
        const s = Zn();
        let a = e[n - 1], u = i[0], l = 0;
        for (; l < n - 1; u += i[++l])
          if (s < u) {
            a = e[l];
            break;
          }
        return a.sample();
      },
      pdf(s) {
        let a = 0, u = 0;
        for (; u < n; ++u)
          a += i[u] * e[u].pdf(s);
        return a;
      },
      cdf(s) {
        let a = 0, u = 0;
        for (; u < n; ++u)
          a += i[u] * e[u].cdf(s);
        return a;
      },
      icdf() {
        throw Error("Mixture icdf not supported.");
      }
    };
    return o.distributions(e).weights(t);
  }
  function yv(e, t) {
    return t == null && (t = e ?? 1, e = 0), e + (t - e) * Zn();
  }
  function bv(e, t, n) {
    return n == null && (n = t ?? 1, t = 0), e >= t && e <= n ? 1 / (n - t) : 0;
  }
  function vv(e, t, n) {
    return n == null && (n = t ?? 1, t = 0), e < t ? 0 : e > n ? 1 : (e - t) / (n - t);
  }
  function xv(e, t, n) {
    return n == null && (n = t ?? 1, t = 0), e >= 0 && e <= 1 ? t + e * (n - t) : NaN;
  }
  function vM(e, t) {
    let n, i;
    const r = {
      min(o) {
        return arguments.length ? (n = o || 0, r) : n;
      },
      max(o) {
        return arguments.length ? (i = o ?? 1, r) : i;
      },
      sample: () => yv(n, i),
      pdf: (o) => bv(o, n, i),
      cdf: (o) => vv(o, n, i),
      icdf: (o) => xv(o, n, i)
    };
    return t == null && (t = e ?? 1, e = 0), r.min(e).max(t);
  }
  function wv(e, t, n) {
    let i = 0, r = 0;
    for (const o of e) {
      const s = n(o);
      t(o) == null || s == null || isNaN(s) || (i += (s - i) / ++r);
    }
    return {
      coef: [i],
      predict: () => i,
      rSquared: 0
    };
  }
  function rf(e, t, n, i) {
    const r = i - e * e, o = Math.abs(r) < 1e-24 ? 0 : (n - e * t) / r;
    return [t - o * e, o];
  }
  function sp(e, t, n, i) {
    e = e.filter((h) => {
      let g = t(h), p = n(h);
      return g != null && (g = +g) >= g && p != null && (p = +p) >= p;
    }), i && e.sort((h, g) => t(h) - t(g));
    const r = e.length, o = new Float64Array(r), s = new Float64Array(r);
    let a = 0, u = 0, l = 0, c, f, d;
    for (d of e)
      o[a] = c = +t(d), s[a] = f = +n(d), ++a, u += (c - u) / a, l += (f - l) / a;
    for (a = 0; a < r; ++a)
      o[a] -= u, s[a] -= l;
    return [o, s, u, l];
  }
  function of(e, t, n, i) {
    let r = -1, o, s;
    for (const a of e)
      o = t(a), s = n(a), o != null && (o = +o) >= o && s != null && (s = +s) >= s && i(o, s, ++r);
  }
  function Qu(e, t, n, i, r) {
    let o = 0, s = 0;
    return of(e, t, n, (a, u) => {
      const l = u - r(a), c = u - i;
      o += l * l, s += c * c;
    }), 1 - o / s;
  }
  function Ev(e, t, n) {
    let i = 0, r = 0, o = 0, s = 0, a = 0;
    of(e, t, n, (c, f) => {
      ++a, i += (c - i) / a, r += (f - r) / a, o += (c * f - o) / a, s += (c * c - s) / a;
    });
    const u = rf(i, r, o, s), l = (c) => u[0] + u[1] * c;
    return {
      coef: u,
      predict: l,
      rSquared: Qu(e, t, n, r, l)
    };
  }
  function xM(e, t, n) {
    let i = 0, r = 0, o = 0, s = 0, a = 0;
    of(e, t, n, (c, f) => {
      ++a, c = Math.log(c), i += (c - i) / a, r += (f - r) / a, o += (c * f - o) / a, s += (c * c - s) / a;
    });
    const u = rf(i, r, o, s), l = (c) => u[0] + u[1] * Math.log(c);
    return {
      coef: u,
      predict: l,
      rSquared: Qu(e, t, n, r, l)
    };
  }
  function wM(e, t, n) {
    const [i, r, o, s] = sp(e, t, n);
    let a = 0, u = 0, l = 0, c = 0, f = 0, d, h, g;
    of(e, t, n, (b, v) => {
      d = i[f++], h = Math.log(v), g = d * v, a += (v * h - a) / f, u += (g - u) / f, l += (g * h - l) / f, c += (d * g - c) / f;
    });
    const [p, m] = rf(u / s, a / s, l / s, c / s), y = (b) => Math.exp(p + m * (b - o));
    return {
      coef: [Math.exp(p - m * o), m],
      predict: y,
      rSquared: Qu(e, t, n, s, y)
    };
  }
  function EM(e, t, n) {
    let i = 0, r = 0, o = 0, s = 0, a = 0, u = 0;
    of(e, t, n, (f, d) => {
      const h = Math.log(f), g = Math.log(d);
      ++u, i += (h - i) / u, r += (g - r) / u, o += (h * g - o) / u, s += (h * h - s) / u, a += (d - a) / u;
    });
    const l = rf(i, r, o, s), c = (f) => l[0] * Math.pow(f, l[1]);
    return l[0] = Math.exp(l[0]), {
      coef: l,
      predict: c,
      rSquared: Qu(e, t, n, a, c)
    };
  }
  function _v(e, t, n) {
    const [i, r, o, s] = sp(e, t, n), a = i.length;
    let u = 0, l = 0, c = 0, f = 0, d = 0, h, g, p, m;
    for (h = 0; h < a; )
      g = i[h], p = r[h++], m = g * g, u += (m - u) / h, l += (m * g - l) / h, c += (m * m - c) / h, f += (g * p - f) / h, d += (m * p - d) / h;
    const y = c - u * u, b = u * y - l * l, v = (d * u - f * l) / b, x = (f * y - d * l) / b, w = -v * u, _ = (E) => (E = E - o, v * E * E + x * E + w + s);
    return {
      coef: [w - x * o + v * o * o + s, x - 2 * v * o, v],
      predict: _,
      rSquared: Qu(e, t, n, s, _)
    };
  }
  function _M(e, t, n, i) {
    if (i === 0) return wv(e, t, n);
    if (i === 1) return Ev(e, t, n);
    if (i === 2) return _v(e, t, n);
    const [r, o, s, a] = sp(e, t, n), u = r.length, l = [], c = [], f = i + 1;
    let d, h, g, p, m;
    for (d = 0; d < f; ++d) {
      for (g = 0, p = 0; g < u; ++g)
        p += Math.pow(r[g], d) * o[g];
      for (l.push(p), m = new Float64Array(f), h = 0; h < f; ++h) {
        for (g = 0, p = 0; g < u; ++g)
          p += Math.pow(r[g], d + h);
        m[h] = p;
      }
      c.push(m);
    }
    c.push(l);
    const y = c8(c), b = (v) => {
      v -= s;
      let x = a + y[0] + y[1] * v + y[2] * v * v;
      for (d = 3; d < f; ++d) x += y[d] * Math.pow(v, d);
      return x;
    };
    return {
      coef: l8(f, y, -s, a),
      predict: b,
      rSquared: Qu(e, t, n, a, b)
    };
  }
  function l8(e, t, n, i) {
    const r = Array(e);
    let o, s, a, u;
    for (o = 0; o < e; ++o) r[o] = 0;
    for (o = e - 1; o >= 0; --o)
      for (a = t[o], u = 1, r[o] += a, s = 1; s <= o; ++s)
        u *= (o + 1 - s) / s, r[o - s] += a * Math.pow(n, s) * u;
    return r[0] += i, r;
  }
  function c8(e) {
    const t = e.length - 1, n = [];
    let i, r, o, s, a;
    for (i = 0; i < t; ++i) {
      for (s = i, r = i + 1; r < t; ++r)
        Math.abs(e[i][r]) > Math.abs(e[i][s]) && (s = r);
      for (o = i; o < t + 1; ++o)
        a = e[o][i], e[o][i] = e[o][s], e[o][s] = a;
      for (r = i + 1; r < t; ++r)
        for (o = t; o >= i; o--)
          e[o][r] -= e[o][i] * e[i][r] / e[i][i];
    }
    for (r = t - 1; r >= 0; --r) {
      for (a = 0, o = r + 1; o < t; ++o)
        a += e[o][r] * n[o];
      n[r] = (e[t][r] - a) / e[r][r];
    }
    return n;
  }
  const O_ = 2, R_ = 1e-12;
  function SM(e, t, n, i) {
    const [r, o, s, a] = sp(e, t, n, !0), u = r.length, l = Math.max(2, ~~(i * u)), c = new Float64Array(u), f = new Float64Array(u), d = new Float64Array(u).fill(1);
    for (let h = -1; ++h <= O_; ) {
      const g = [0, l - 1];
      for (let m = 0; m < u; ++m) {
        const y = r[m], b = g[0], v = g[1], x = y - r[b] > r[v] - y ? b : v;
        let w = 0, _ = 0, E = 0, S = 0, $ = 0;
        const F = 1 / Math.abs(r[x] - y || 1);
        for (let k = b; k <= v; ++k) {
          const M = r[k], C = o[k], T = f8(Math.abs(y - M) * F) * d[k], L = M * T;
          w += T, _ += L, E += C * T, S += C * L, $ += M * L;
        }
        const [A, D] = rf(_ / w, E / w, S / w, $ / w);
        c[m] = A + D * y, f[m] = Math.abs(o[m] - c[m]), d8(r, m + 1, g);
      }
      if (h === O_)
        break;
      const p = lF(f);
      if (Math.abs(p) < R_) break;
      for (let m = 0, y, b; m < u; ++m)
        y = f[m] / (6 * p), d[m] = y >= 1 ? R_ : (b = 1 - y * y) * b;
    }
    return h8(r, c, s, a);
  }
  function f8(e) {
    return (e = 1 - e * e * e) * e * e;
  }
  function d8(e, t, n) {
    const i = e[t];
    let r = n[0], o = n[1] + 1;
    if (!(o >= e.length))
      for (; t > r && e[o] - i <= i - e[r]; )
        n[0] = ++r, n[1] = o, ++o;
  }
  function h8(e, t, n, i) {
    const r = e.length, o = [];
    let s = 0, a = 0, u = [], l;
    for (; s < r; ++s)
      l = e[s] + n, u[0] === l ? u[1] += (t[s] - u[1]) / ++a : (a = 0, u[1] += i, u = [l, t[s]], o.push(u));
    return u[1] += i, o;
  }
  const g8 = 0.5 * Math.PI / 180;
  function ap(e, t, n, i) {
    n = n || 25, i = Math.max(n, i || 200);
    const r = (p) => [p, e(p)], o = t[0], s = t[1], a = s - o, u = a / i, l = [r(o)], c = [];
    if (n === i) {
      for (let p = 1; p < i; ++p)
        l.push(r(o + p / n * a));
      return l.push(r(s)), l;
    } else {
      c.push(r(s));
      for (let p = n; --p > 0; )
        c.push(r(o + p / n * a));
    }
    let f = l[0], d = c[c.length - 1];
    const h = 1 / a, g = p8(f[1], c);
    for (; d; ) {
      const p = r((f[0] + d[0]) / 2);
      p[0] - f[0] >= u && m8(f, p, d, h, g) > g8 ? c.push(p) : (f = d, l.push(d), c.pop()), d = c[c.length - 1];
    }
    return l;
  }
  function p8(e, t) {
    let n = e, i = e;
    const r = t.length;
    for (let o = 0; o < r; ++o) {
      const s = t[o][1];
      s < n && (n = s), s > i && (i = s);
    }
    return 1 / (i - n);
  }
  function m8(e, t, n, i, r) {
    const o = Math.atan2(r * (n[1] - e[1]), i * (n[0] - e[0])), s = Math.atan2(r * (t[1] - e[1]), i * (t[0] - e[0]));
    return Math.abs(o - s);
  }
  function y8(e) {
    return (t) => {
      const n = e.length;
      let i = 1, r = String(e[0](t));
      for (; i < n; ++i)
        r += "|" + e[i](t);
      return r;
    };
  }
  function P1(e) {
    return !e || !e.length ? function() {
      return "";
    } : e.length === 1 ? e[0] : y8(e);
  }
  function $M(e, t, n) {
    return n || e + (t ? "_" + t : "");
  }
  const r0 = () => {
  }, b8 = {
    init: r0,
    add: r0,
    rem: r0,
    idx: 0
  }, Cc = {
    values: {
      init: (e) => e.cell.store = !0,
      value: (e) => e.cell.data.values(),
      idx: -1
    },
    count: {
      value: (e) => e.cell.num
    },
    __count__: {
      value: (e) => e.missing + e.valid
    },
    missing: {
      value: (e) => e.missing
    },
    valid: {
      value: (e) => e.valid
    },
    sum: {
      init: (e) => e.sum = 0,
      value: (e) => e.valid ? e.sum : void 0,
      add: (e, t) => e.sum += +t,
      rem: (e, t) => e.sum -= t
    },
    product: {
      init: (e) => e.product = 1,
      value: (e) => e.valid ? e.product : void 0,
      add: (e, t) => e.product *= t,
      rem: (e, t) => e.product /= t
    },
    mean: {
      init: (e) => e.mean = 0,
      value: (e) => e.valid ? e.mean : void 0,
      add: (e, t) => (e.mean_d = t - e.mean, e.mean += e.mean_d / e.valid),
      rem: (e, t) => (e.mean_d = t - e.mean, e.mean -= e.valid ? e.mean_d / e.valid : e.mean)
    },
    average: {
      value: (e) => e.valid ? e.mean : void 0,
      req: ["mean"],
      idx: 1
    },
    variance: {
      init: (e) => e.dev = 0,
      value: (e) => e.valid > 1 ? e.dev / (e.valid - 1) : void 0,
      add: (e, t) => e.dev += e.mean_d * (t - e.mean),
      rem: (e, t) => e.dev -= e.mean_d * (t - e.mean),
      req: ["mean"],
      idx: 1
    },
    variancep: {
      value: (e) => e.valid > 1 ? e.dev / e.valid : void 0,
      req: ["variance"],
      idx: 2
    },
    stdev: {
      value: (e) => e.valid > 1 ? Math.sqrt(e.dev / (e.valid - 1)) : void 0,
      req: ["variance"],
      idx: 2
    },
    stdevp: {
      value: (e) => e.valid > 1 ? Math.sqrt(e.dev / e.valid) : void 0,
      req: ["variance"],
      idx: 2
    },
    stderr: {
      value: (e) => e.valid > 1 ? Math.sqrt(e.dev / (e.valid * (e.valid - 1))) : void 0,
      req: ["variance"],
      idx: 2
    },
    distinct: {
      value: (e) => e.cell.data.distinct(e.get),
      req: ["values"],
      idx: 3
    },
    ci0: {
      value: (e) => e.cell.data.ci0(e.get),
      req: ["values"],
      idx: 3
    },
    ci1: {
      value: (e) => e.cell.data.ci1(e.get),
      req: ["values"],
      idx: 3
    },
    median: {
      value: (e) => e.cell.data.q2(e.get),
      req: ["values"],
      idx: 3
    },
    q1: {
      value: (e) => e.cell.data.q1(e.get),
      req: ["values"],
      idx: 3
    },
    q3: {
      value: (e) => e.cell.data.q3(e.get),
      req: ["values"],
      idx: 3
    },
    min: {
      init: (e) => e.min = void 0,
      value: (e) => e.min = Number.isNaN(e.min) ? e.cell.data.min(e.get) : e.min,
      add: (e, t) => {
        (t < e.min || e.min === void 0) && (e.min = t);
      },
      rem: (e, t) => {
        t <= e.min && (e.min = NaN);
      },
      req: ["values"],
      idx: 4
    },
    max: {
      init: (e) => e.max = void 0,
      value: (e) => e.max = Number.isNaN(e.max) ? e.cell.data.max(e.get) : e.max,
      add: (e, t) => {
        (t > e.max || e.max === void 0) && (e.max = t);
      },
      rem: (e, t) => {
        t >= e.max && (e.max = NaN);
      },
      req: ["values"],
      idx: 4
    },
    argmin: {
      init: (e) => e.argmin = void 0,
      value: (e) => e.argmin || e.cell.data.argmin(e.get),
      add: (e, t, n) => {
        t < e.min && (e.argmin = n);
      },
      rem: (e, t) => {
        t <= e.min && (e.argmin = void 0);
      },
      req: ["min", "values"],
      idx: 3
    },
    argmax: {
      init: (e) => e.argmax = void 0,
      value: (e) => e.argmax || e.cell.data.argmax(e.get),
      add: (e, t, n) => {
        t > e.max && (e.argmax = n);
      },
      rem: (e, t) => {
        t >= e.max && (e.argmax = void 0);
      },
      req: ["max", "values"],
      idx: 3
    },
    exponential: {
      init: (e, t) => {
        e.exp = 0, e.exp_r = t;
      },
      value: (e) => e.valid ? e.exp * (1 - e.exp_r) / (1 - e.exp_r ** e.valid) : void 0,
      add: (e, t) => e.exp = e.exp_r * e.exp + t,
      rem: (e, t) => e.exp = (e.exp - t / e.exp_r ** (e.valid - 1)) / e.exp_r
    },
    exponentialb: {
      value: (e) => e.valid ? e.exp * (1 - e.exp_r) : void 0,
      req: ["exponential"],
      idx: 1
    }
  }, sf = Object.keys(Cc).filter((e) => e !== "__count__");
  function v8(e, t) {
    return (n, i) => ce({
      name: e,
      aggregate_param: i,
      out: n || e
    }, b8, t);
  }
  [...sf, "__count__"].forEach((e) => {
    Cc[e] = v8(e, Cc[e]);
  });
  function kM(e, t, n) {
    return Cc[e](n, t);
  }
  function AM(e, t) {
    return e.idx - t.idx;
  }
  function x8(e) {
    const t = {};
    e.forEach((i) => t[i.name] = i);
    const n = (i) => {
      i.req && i.req.forEach((r) => {
        t[r] || n(t[r] = Cc[r]());
      });
    };
    return e.forEach(n), Object.values(t).sort(AM);
  }
  function w8() {
    this.valid = 0, this.missing = 0, this._ops.forEach((e) => e.aggregate_param == null ? e.init(this) : e.init(this, e.aggregate_param));
  }
  function E8(e, t) {
    if (e == null || e === "") {
      ++this.missing;
      return;
    }
    e === e && (++this.valid, this._ops.forEach((n) => n.add(this, e, t)));
  }
  function _8(e, t) {
    if (e == null || e === "") {
      --this.missing;
      return;
    }
    e === e && (--this.valid, this._ops.forEach((n) => n.rem(this, e, t)));
  }
  function S8(e) {
    return this._out.forEach((t) => e[t.out] = t.value(this)), e;
  }
  function CM(e, t) {
    const n = t || Ht, i = x8(e), r = e.slice().sort(AM);
    function o(s) {
      this._ops = i, this._out = r, this.cell = s, this.init();
    }
    return o.prototype.init = w8, o.prototype.add = E8, o.prototype.rem = _8, o.prototype.set = S8, o.prototype.get = n, o.fields = e.map((s) => s.out), o;
  }
  function Sv(e) {
    this._key = e ? Kn(e) : re, this.reset();
  }
  const Tt = Sv.prototype;
  Tt.reset = function() {
    this._add = [], this._rem = [], this._ext = null, this._get = null, this._q = null;
  };
  Tt.add = function(e) {
    this._add.push(e);
  };
  Tt.rem = function(e) {
    this._rem.push(e);
  };
  Tt.values = function() {
    if (this._get = null, this._rem.length === 0) return this._add;
    const e = this._add, t = this._rem, n = this._key, i = e.length, r = t.length, o = Array(i - r), s = {};
    let a, u, l;
    for (a = 0; a < r; ++a)
      s[n(t[a])] = 1;
    for (a = 0, u = 0; a < i; ++a)
      s[n(l = e[a])] ? s[n(l)] = 0 : o[u++] = l;
    return this._rem = [], this._add = o;
  };
  Tt.distinct = function(e) {
    const t = this.values(), n = {};
    let i = t.length, r = 0, o;
    for (; --i >= 0; )
      o = e(t[i]) + "", J(n, o) || (n[o] = 1, ++r);
    return r;
  };
  Tt.extent = function(e) {
    if (this._get !== e || !this._ext) {
      const t = this.values(), n = WC(t, e);
      this._ext = [t[n[0]], t[n[1]]], this._get = e;
    }
    return this._ext;
  };
  Tt.argmin = function(e) {
    return this.extent(e)[0] || {};
  };
  Tt.argmax = function(e) {
    return this.extent(e)[1] || {};
  };
  Tt.min = function(e) {
    const t = this.extent(e)[0];
    return t != null ? e(t) : void 0;
  };
  Tt.max = function(e) {
    const t = this.extent(e)[1];
    return t != null ? e(t) : void 0;
  };
  Tt.quartile = function(e) {
    return (this._get !== e || !this._q) && (this._q = uv(this.values(), e), this._get = e), this._q;
  };
  Tt.q1 = function(e) {
    return this.quartile(e)[0];
  };
  Tt.q2 = function(e) {
    return this.quartile(e)[1];
  };
  Tt.q3 = function(e) {
    return this.quartile(e)[2];
  };
  Tt.ci = function(e) {
    return (this._get !== e || !this._ci) && (this._ci = gM(this.values(), 1e3, 0.05, e), this._get = e), this._ci;
  };
  Tt.ci0 = function(e) {
    return this.ci(e)[0];
  };
  Tt.ci1 = function(e) {
    return this.ci(e)[1];
  };
  function Lo(e) {
    N.call(this, null, e), this._adds = [], this._mods = [], this._alen = 0, this._mlen = 0, this._drop = !0, this._cross = !1, this._dims = [], this._dnames = [], this._measures = [], this._countOnly = !1, this._counts = null, this._prev = null, this._inputs = null, this._outputs = null;
  }
  Lo.Definition = {
    type: "Aggregate",
    metadata: {
      generates: !0,
      changes: !0
    },
    params: [{
      name: "groupby",
      type: "field",
      array: !0
    }, {
      name: "ops",
      type: "enum",
      array: !0,
      values: sf
    }, {
      name: "aggregate_params",
      type: "number",
      null: !0,
      array: !0
    }, {
      name: "fields",
      type: "field",
      null: !0,
      array: !0
    }, {
      name: "as",
      type: "string",
      null: !0,
      array: !0
    }, {
      name: "drop",
      type: "boolean",
      default: !0
    }, {
      name: "cross",
      type: "boolean",
      default: !1
    }, {
      name: "key",
      type: "field"
    }]
  };
  G(Lo, N, {
    transform(e, t) {
      const n = this, i = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = e.modified();
      return n.stamp = i.stamp, n.value && (r || t.modified(n._inputs, !0)) ? (n._prev = n.value, n.value = r ? n.init(e) : /* @__PURE__ */ Object.create(null), t.visit(t.SOURCE, (o) => n.add(o))) : (n.value = n.value || n.init(e), t.visit(t.REM, (o) => n.rem(o)), t.visit(t.ADD, (o) => n.add(o))), i.modifies(n._outputs), n._drop = e.drop !== !1, e.cross && n._dims.length > 1 && (n._drop = !1, n.cross()), t.clean() && n._drop && i.clean(!0).runAfter(() => this.clean()), n.changes(i);
    },
    cross() {
      const e = this, t = e.value, n = e._dnames, i = n.map(() => ({})), r = n.length;
      function o(a) {
        let u, l, c, f;
        for (u in a)
          for (c = a[u].tuple, l = 0; l < r; ++l)
            i[l][f = c[n[l]]] = f;
      }
      o(e._prev), o(t);
      function s(a, u, l) {
        const c = n[l], f = i[l++];
        for (const d in f) {
          const h = a ? a + "|" + d : d;
          u[c] = f[d], l < r ? s(h, u, l) : t[h] || e.cell(h, u);
        }
      }
      s("", {}, 0);
    },
    init(e) {
      const t = this._inputs = [], n = this._outputs = [], i = {};
      function r(b) {
        const v = X(Ut(b)), x = v.length;
        let w = 0, _;
        for (; w < x; ++w)
          i[_ = v[w]] || (i[_] = 1, t.push(_));
      }
      this._dims = X(e.groupby), this._dnames = this._dims.map((b) => {
        const v = Je(b);
        return r(b), n.push(v), v;
      }), this.cellkey = e.key ? e.key : P1(this._dims), this._countOnly = !0, this._counts = [], this._measures = [];
      const o = e.fields || [null], s = e.ops || ["count"], a = e.aggregate_params || [null], u = e.as || [], l = o.length, c = {};
      let f, d, h, g, p, m, y;
      for (l !== s.length && R("Unmatched number of fields and aggregate ops."), y = 0; y < l; ++y) {
        if (f = o[y], d = s[y], h = a[y] || null, f == null && d !== "count" && R("Null aggregate field specified."), p = Je(f), m = $M(d, p, u[y]), n.push(m), d === "count") {
          this._counts.push(m);
          continue;
        }
        g = c[p], g || (r(f), g = c[p] = [], g.field = f, this._measures.push(g)), d !== "count" && (this._countOnly = !1), g.push(kM(d, h, m));
      }
      return this._measures = this._measures.map((b) => CM(b, b.field)), /* @__PURE__ */ Object.create(null);
    },
    // -- Cell Management -----
    cellkey: P1(),
    cell(e, t) {
      let n = this.value[e];
      return n ? n.num === 0 && this._drop && n.stamp < this.stamp ? (n.stamp = this.stamp, this._adds[this._alen++] = n) : n.stamp < this.stamp && (n.stamp = this.stamp, this._mods[this._mlen++] = n) : (n = this.value[e] = this.newcell(e, t), this._adds[this._alen++] = n), n;
    },
    newcell(e, t) {
      const n = {
        key: e,
        num: 0,
        agg: null,
        tuple: this.newtuple(t, this._prev && this._prev[e]),
        stamp: this.stamp,
        store: !1
      };
      if (!this._countOnly) {
        const i = this._measures, r = i.length;
        n.agg = Array(r);
        for (let o = 0; o < r; ++o)
          n.agg[o] = new i[o](n);
      }
      return n.store && (n.data = new Sv()), n;
    },
    newtuple(e, t) {
      const n = this._dnames, i = this._dims, r = i.length, o = {};
      for (let s = 0; s < r; ++s)
        o[n[s]] = i[s](e);
      return t ? sM(t.tuple, o) : Ce(o);
    },
    clean() {
      const e = this.value;
      for (const t in e)
        e[t].num === 0 && delete e[t];
    },
    // -- Process Tuples -----
    add(e) {
      const t = this.cellkey(e), n = this.cell(t, e);
      if (n.num += 1, this._countOnly) return;
      n.store && n.data.add(e);
      const i = n.agg;
      for (let r = 0, o = i.length; r < o; ++r)
        i[r].add(i[r].get(e), e);
    },
    rem(e) {
      const t = this.cellkey(e), n = this.cell(t, e);
      if (n.num -= 1, this._countOnly) return;
      n.store && n.data.rem(e);
      const i = n.agg;
      for (let r = 0, o = i.length; r < o; ++r)
        i[r].rem(i[r].get(e), e);
    },
    celltuple(e) {
      const t = e.tuple, n = this._counts;
      e.store && e.data.values();
      for (let i = 0, r = n.length; i < r; ++i)
        t[n[i]] = e.num;
      if (!this._countOnly) {
        const i = e.agg;
        for (let r = 0, o = i.length; r < o; ++r)
          i[r].set(t);
      }
      return t;
    },
    changes(e) {
      const t = this._adds, n = this._mods, i = this._prev, r = this._drop, o = e.add, s = e.rem, a = e.mod;
      let u, l, c, f;
      if (i) for (l in i)
        u = i[l], (!r || u.num) && s.push(u.tuple);
      for (c = 0, f = this._alen; c < f; ++c)
        o.push(this.celltuple(t[c])), t[c] = null;
      for (c = 0, f = this._mlen; c < f; ++c)
        u = n[c], (u.num === 0 && r ? s : a).push(this.celltuple(u)), n[c] = null;
      return this._alen = this._mlen = 0, this._prev = null, e;
    }
  });
  const $8 = 1e-14;
  function $v(e) {
    N.call(this, null, e);
  }
  $v.Definition = {
    type: "Bin",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "field",
      type: "field",
      required: !0
    }, {
      name: "interval",
      type: "boolean",
      default: !0
    }, {
      name: "anchor",
      type: "number"
    }, {
      name: "maxbins",
      type: "number",
      default: 20
    }, {
      name: "base",
      type: "number",
      default: 10
    }, {
      name: "divide",
      type: "number",
      array: !0,
      default: [5, 2]
    }, {
      name: "extent",
      type: "number",
      array: !0,
      length: 2,
      required: !0
    }, {
      name: "span",
      type: "number"
    }, {
      name: "step",
      type: "number"
    }, {
      name: "steps",
      type: "number",
      array: !0
    }, {
      name: "minstep",
      type: "number",
      default: 0
    }, {
      name: "nice",
      type: "boolean",
      default: !0
    }, {
      name: "name",
      type: "string"
    }, {
      name: "as",
      type: "string",
      array: !0,
      length: 2,
      default: ["bin0", "bin1"]
    }]
  };
  G($v, N, {
    transform(e, t) {
      const n = e.interval !== !1, i = this._bins(e), r = i.start, o = i.step, s = e.as || ["bin0", "bin1"], a = s[0], u = s[1];
      let l;
      return e.modified() ? (t = t.reflow(!0), l = t.SOURCE) : l = t.modified(Ut(e.field)) ? t.ADD_MOD : t.ADD, t.visit(l, n ? (c) => {
        const f = i(c);
        c[a] = f, c[u] = f == null ? null : r + o * (1 + (f - r) / o);
      } : (c) => c[a] = i(c)), t.modifies(n ? s : a);
    },
    _bins(e) {
      if (this.value && !e.modified())
        return this.value;
      const t = e.field, n = hM(e), i = n.step;
      let r = n.start, o = r + Math.ceil((n.stop - r) / i) * i, s, a;
      (s = e.anchor) != null && (a = s - (r + i * Math.floor((s - r) / i)), r += a, o += a);
      const u = function(l) {
        let c = zt(t(l));
        return c == null ? null : c < r ? -1 / 0 : c > o ? 1 / 0 : (c = Math.max(r, Math.min(c, o - i)), r + i * Math.floor($8 + (c - r) / i));
      };
      return u.start = r, u.stop = n.stop, u.step = i, this.value = Sn(u, Ut(t), e.name || "bin_" + Je(t));
    }
  });
  function FM(e, t, n) {
    const i = e;
    let r = t || [], o = n || [], s = {}, a = 0;
    return {
      add: (u) => o.push(u),
      remove: (u) => s[i(u)] = ++a,
      size: () => r.length,
      data: (u, l) => (a && (r = r.filter((c) => !s[i(c)]), s = {}, a = 0), l && u && r.sort(u), o.length && (r = u ? KC(u, r, o.sort(u)) : r.concat(o), o = []), r)
    };
  }
  function kv(e) {
    N.call(this, [], e);
  }
  kv.Definition = {
    type: "Collect",
    metadata: {
      source: !0
    },
    params: [{
      name: "sort",
      type: "compare"
    }]
  };
  G(kv, N, {
    transform(e, t) {
      const n = t.fork(t.ALL), i = FM(re, this.value, n.materialize(n.ADD).add), r = e.sort, o = t.changed() || r && (e.modified("sort") || t.modified(r.fields));
      return n.visit(n.REM, i.remove), this.modified(o), this.value = n.source = i.data(ha(r), o), t.source && t.source.root && (this.value.root = t.source.root), n;
    }
  });
  function MM(e) {
    Ie.call(this, null, k8, e);
  }
  G(MM, Ie);
  function k8(e) {
    return this.value && !e.modified() ? this.value : Bb(e.fields, e.orders);
  }
  function Av(e) {
    N.call(this, null, e);
  }
  Av.Definition = {
    type: "CountPattern",
    metadata: {
      generates: !0,
      changes: !0
    },
    params: [{
      name: "field",
      type: "field",
      required: !0
    }, {
      name: "case",
      type: "enum",
      values: ["upper", "lower", "mixed"],
      default: "mixed"
    }, {
      name: "pattern",
      type: "string",
      default: '[\\w"]+'
    }, {
      name: "stopwords",
      type: "string",
      default: ""
    }, {
      name: "as",
      type: "string",
      array: !0,
      length: 2,
      default: ["text", "count"]
    }]
  };
  function A8(e, t, n) {
    switch (t) {
      case "upper":
        e = e.toUpperCase();
        break;
      case "lower":
        e = e.toLowerCase();
        break;
    }
    return e.match(n);
  }
  G(Av, N, {
    transform(e, t) {
      const n = (f) => (d) => {
        for (var h = A8(a(d), e.case, o) || [], g, p = 0, m = h.length; p < m; ++p)
          s.test(g = h[p]) || f(g);
      }, i = this._parameterCheck(e, t), r = this._counts, o = this._match, s = this._stop, a = e.field, u = e.as || ["text", "count"], l = n((f) => r[f] = 1 + (r[f] || 0)), c = n((f) => r[f] -= 1);
      return i ? t.visit(t.SOURCE, l) : (t.visit(t.ADD, l), t.visit(t.REM, c)), this._finish(t, u);
    },
    _parameterCheck(e, t) {
      let n = !1;
      return (e.modified("stopwords") || !this._stop) && (this._stop = new RegExp("^" + (e.stopwords || "") + "$", "i"), n = !0), (e.modified("pattern") || !this._match) && (this._match = new RegExp(e.pattern || "[\\w']+", "g"), n = !0), (e.modified("field") || t.modified(e.field.fields)) && (n = !0), n && (this._counts = {}), n;
    },
    _finish(e, t) {
      const n = this._counts, i = this._tuples || (this._tuples = {}), r = t[0], o = t[1], s = e.fork(e.NO_SOURCE | e.NO_FIELDS);
      let a, u, l;
      for (a in n)
        u = i[a], l = n[a] || 0, !u && l ? (i[a] = u = Ce({}), u[r] = a, u[o] = l, s.add.push(u)) : l === 0 ? (u && s.rem.push(u), n[a] = null, i[a] = null) : u[o] !== l && (u[o] = l, s.mod.push(u));
      return s.modifies(t);
    }
  });
  function Cv(e) {
    N.call(this, null, e);
  }
  Cv.Definition = {
    type: "Cross",
    metadata: {
      generates: !0
    },
    params: [{
      name: "filter",
      type: "expr"
    }, {
      name: "as",
      type: "string",
      array: !0,
      length: 2,
      default: ["a", "b"]
    }]
  };
  G(Cv, N, {
    transform(e, t) {
      const n = t.fork(t.NO_SOURCE), i = e.as || ["a", "b"], r = i[0], o = i[1], s = !this.value || t.changed(t.ADD_REM) || e.modified("as") || e.modified("filter");
      let a = this.value;
      return s ? (a && (n.rem = a), a = t.materialize(t.SOURCE).source, n.add = this.value = C8(a, r, o, e.filter || Jn)) : n.mod = a, n.source = this.value, n.modifies(i);
    }
  });
  function C8(e, t, n, i) {
    for (var r = [], o = {}, s = e.length, a = 0, u, l; a < s; ++a)
      for (o[t] = l = e[a], u = 0; u < s; ++u)
        o[n] = e[u], i(o) && (r.push(Ce(o)), o = {}, o[t] = l);
    return r;
  }
  const L_ = {
    kde: dv,
    mixture: bM,
    normal: fv,
    lognormal: yM,
    uniform: vM
  }, F8 = "distributions", P_ = "function", M8 = "field";
  function TM(e, t) {
    const n = e[P_];
    J(L_, n) || R("Unknown distribution function: " + n);
    const i = L_[n]();
    for (const r in e)
      r === M8 ? i.data((e.from || t()).map(e[r])) : r === F8 ? i[r](e[r].map((o) => TM(o, t))) : typeof i[r] === P_ && i[r](e[r]);
    return i;
  }
  function Fv(e) {
    N.call(this, null, e);
  }
  const DM = [{
    key: {
      function: "normal"
    },
    params: [{
      name: "mean",
      type: "number",
      default: 0
    }, {
      name: "stdev",
      type: "number",
      default: 1
    }]
  }, {
    key: {
      function: "lognormal"
    },
    params: [{
      name: "mean",
      type: "number",
      default: 0
    }, {
      name: "stdev",
      type: "number",
      default: 1
    }]
  }, {
    key: {
      function: "uniform"
    },
    params: [{
      name: "min",
      type: "number",
      default: 0
    }, {
      name: "max",
      type: "number",
      default: 1
    }]
  }, {
    key: {
      function: "kde"
    },
    params: [{
      name: "field",
      type: "field",
      required: !0
    }, {
      name: "from",
      type: "data"
    }, {
      name: "bandwidth",
      type: "number",
      default: 0
    }]
  }], T8 = {
    key: {
      function: "mixture"
    },
    params: [{
      name: "distributions",
      type: "param",
      array: !0,
      params: DM
    }, {
      name: "weights",
      type: "number",
      array: !0
    }]
  };
  Fv.Definition = {
    type: "Density",
    metadata: {
      generates: !0
    },
    params: [{
      name: "extent",
      type: "number",
      array: !0,
      length: 2
    }, {
      name: "steps",
      type: "number"
    }, {
      name: "minsteps",
      type: "number",
      default: 25
    }, {
      name: "maxsteps",
      type: "number",
      default: 200
    }, {
      name: "method",
      type: "string",
      default: "pdf",
      values: ["pdf", "cdf"]
    }, {
      name: "distribution",
      type: "param",
      params: DM.concat(T8)
    }, {
      name: "as",
      type: "string",
      array: !0,
      default: ["value", "density"]
    }]
  };
  G(Fv, N, {
    transform(e, t) {
      const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
      if (!this.value || t.changed() || e.modified()) {
        const i = TM(e.distribution, D8(t)), r = e.steps || e.minsteps || 25, o = e.steps || e.maxsteps || 200;
        let s = e.method || "pdf";
        s !== "pdf" && s !== "cdf" && R("Invalid density method: " + s), !e.extent && !i.data && R("Missing density extent parameter."), s = i[s];
        const a = e.as || ["value", "density"], u = e.extent || nr(i.data()), l = ap(s, u, r, o).map((c) => {
          const f = {};
          return f[a[0]] = c[0], f[a[1]] = c[1], Ce(f);
        });
        this.value && (n.rem = this.value), this.value = n.add = n.source = l;
      }
      return n;
    }
  });
  function D8(e) {
    return () => e.materialize(e.SOURCE).source;
  }
  function NM(e, t) {
    return e ? e.map((n, i) => t[i] || Je(n)) : null;
  }
  function Mv(e, t, n) {
    const i = [], r = (f) => f(u);
    let o, s, a, u, l, c;
    if (t == null)
      i.push(e.map(n));
    else
      for (o = {}, s = 0, a = e.length; s < a; ++s)
        u = e[s], l = t.map(r), c = o[l], c || (o[l] = c = [], c.dims = l, i.push(c)), c.push(n(u));
    return i;
  }
  const OM = "bin";
  function Tv(e) {
    N.call(this, null, e);
  }
  Tv.Definition = {
    type: "DotBin",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "field",
      type: "field",
      required: !0
    }, {
      name: "groupby",
      type: "field",
      array: !0
    }, {
      name: "step",
      type: "number"
    }, {
      name: "smooth",
      type: "boolean",
      default: !1
    }, {
      name: "as",
      type: "string",
      default: OM
    }]
  };
  const N8 = (e, t) => nf(nr(e, t)) / 30;
  G(Tv, N, {
    transform(e, t) {
      if (this.value && !(e.modified() || t.changed()))
        return t;
      const n = t.materialize(t.SOURCE).source, i = Mv(t.source, e.groupby, Ht), r = e.smooth || !1, o = e.field, s = e.step || N8(n, o), a = ha((g, p) => o(g) - o(p)), u = e.as || OM, l = i.length;
      let c = 1 / 0, f = -1 / 0, d = 0, h;
      for (; d < l; ++d) {
        const g = i[d].sort(a);
        h = -1;
        for (const p of pM(g, s, r, o))
          p < c && (c = p), p > f && (f = p), g[++h][u] = p;
      }
      return this.value = {
        start: c,
        stop: f,
        step: s
      }, t.reflow(!0).modifies(u);
    }
  });
  function RM(e) {
    Ie.call(this, null, O8, e), this.modified(!0);
  }
  G(RM, Ie);
  function O8(e) {
    const t = e.expr;
    return this.value && !e.modified("expr") ? this.value : Sn((n) => t(n, e), Ut(t), Je(t));
  }
  function Dv(e) {
    N.call(this, [void 0, void 0], e);
  }
  Dv.Definition = {
    type: "Extent",
    metadata: {},
    params: [{
      name: "field",
      type: "field",
      required: !0
    }]
  };
  G(Dv, N, {
    transform(e, t) {
      const n = this.value, i = e.field, r = t.changed() || t.modified(i.fields) || e.modified("field");
      let o = n[0], s = n[1];
      if ((r || o == null) && (o = 1 / 0, s = -1 / 0), t.visit(r ? t.SOURCE : t.ADD, (a) => {
        const u = zt(i(a));
        u != null && (u < o && (o = u), u > s && (s = u));
      }), !Number.isFinite(o) || !Number.isFinite(s)) {
        let a = Je(i);
        a && (a = ` for field "${a}"`), t.dataflow.warn(`Infinite extent${a}: [${o}, ${s}]`), o = s = void 0;
      }
      this.value = [o, s];
    }
  });
  function Nv(e, t) {
    Ie.call(this, e), this.parent = t, this.count = 0;
  }
  G(Nv, Ie, {
    /**
     * Routes pulses from this subflow to a target transform.
     * @param {Transform} target - A transform that receives the subflow of tuples.
     */
    connect(e) {
      return this.detachSubflow = e.detachSubflow, this.targets().add(e), e.source = this;
    },
    /**
     * Add an 'add' tuple to the subflow pulse.
     * @param {Tuple} t - The tuple being added.
     */
    add(e) {
      this.count += 1, this.value.add.push(e);
    },
    /**
     * Add a 'rem' tuple to the subflow pulse.
     * @param {Tuple} t - The tuple being removed.
     */
    rem(e) {
      this.count -= 1, this.value.rem.push(e);
    },
    /**
     * Add a 'mod' tuple to the subflow pulse.
     * @param {Tuple} t - The tuple being modified.
     */
    mod(e) {
      this.value.mod.push(e);
    },
    /**
     * Re-initialize this operator's pulse value.
     * @param {Pulse} pulse - The pulse to copy from.
     * @see Pulse.init
     */
    init(e) {
      this.value.init(e, e.NO_SOURCE);
    },
    /**
     * Evaluate this operator. This method overrides the
     * default behavior to simply return the contained pulse value.
     * @return {Pulse}
     */
    evaluate() {
      return this.value;
    }
  });
  function up(e) {
    N.call(this, {}, e), this._keys = Gu();
    const t = this._targets = [];
    t.active = 0, t.forEach = (n) => {
      for (let i = 0, r = t.active; i < r; ++i)
        n(t[i], i, t);
    };
  }
  G(up, N, {
    activate(e) {
      this._targets[this._targets.active++] = e;
    },
    // parent argument provided by PreFacet subclass
    subflow(e, t, n, i) {
      const r = this.value;
      let o = J(r, e) && r[e], s, a;
      return o ? o.value.stamp < n.stamp && (o.init(n), this.activate(o)) : (a = i || (a = this._group[e]) && a.tuple, s = n.dataflow, o = new Nv(n.fork(n.NO_SOURCE), this), s.add(o).connect(t(s, e, a)), r[e] = o, this.activate(o)), o;
    },
    clean() {
      const e = this.value;
      let t = 0;
      for (const n in e)
        if (e[n].count === 0) {
          const i = e[n].detachSubflow;
          i && i(), delete e[n], ++t;
        }
      if (t) {
        const n = this._targets.filter((i) => i && i.count > 0);
        this.initTargets(n);
      }
    },
    initTargets(e) {
      const t = this._targets, n = t.length, i = e ? e.length : 0;
      let r = 0;
      for (; r < i; ++r)
        t[r] = e[r];
      for (; r < n && t[r] != null; ++r)
        t[r] = null;
      t.active = i;
    },
    transform(e, t) {
      const n = t.dataflow, i = e.key, r = e.subflow, o = this._keys, s = e.modified("key"), a = (u) => this.subflow(u, r, t);
      return this._group = e.group || {}, this.initTargets(), t.visit(t.REM, (u) => {
        const l = re(u), c = o.get(l);
        c !== void 0 && (o.delete(l), a(c).rem(u));
      }), t.visit(t.ADD, (u) => {
        const l = i(u);
        o.set(re(u), l), a(l).add(u);
      }), s || t.modified(i.fields) ? t.visit(t.MOD, (u) => {
        const l = re(u), c = o.get(l), f = i(u);
        c === f ? a(f).mod(u) : (o.set(l, f), a(c).rem(u), a(f).add(u));
      }) : t.changed(t.MOD) && t.visit(t.MOD, (u) => {
        a(o.get(re(u))).mod(u);
      }), s && t.visit(t.REFLOW, (u) => {
        const l = re(u), c = o.get(l), f = i(u);
        c !== f && (o.set(l, f), a(c).rem(u), a(f).add(u));
      }), t.clean() ? n.runAfter(() => {
        this.clean(), o.clean();
      }) : o.empty > n.cleanThreshold && n.runAfter(o.clean), t;
    }
  });
  function LM(e) {
    Ie.call(this, null, R8, e);
  }
  G(LM, Ie);
  function R8(e) {
    return this.value && !e.modified() ? this.value : P(e.name) ? X(e.name).map((t) => Kn(t)) : Kn(e.name, e.as);
  }
  function Ov(e) {
    N.call(this, Gu(), e);
  }
  Ov.Definition = {
    type: "Filter",
    metadata: {
      changes: !0
    },
    params: [{
      name: "expr",
      type: "expr",
      required: !0
    }]
  };
  G(Ov, N, {
    transform(e, t) {
      const n = t.dataflow, i = this.value, r = t.fork(), o = r.add, s = r.rem, a = r.mod, u = e.expr;
      let l = !0;
      t.visit(t.REM, (f) => {
        const d = re(f);
        i.has(d) ? i.delete(d) : s.push(f);
      }), t.visit(t.ADD, (f) => {
        u(f, e) ? o.push(f) : i.set(re(f), 1);
      });
      function c(f) {
        const d = re(f), h = u(f, e), g = i.get(d);
        h && g ? (i.delete(d), o.push(f)) : !h && !g ? (i.set(d, 1), s.push(f)) : l && h && !g && a.push(f);
      }
      return t.visit(t.MOD, c), e.modified() && (l = !1, t.visit(t.REFLOW, c)), i.empty > n.cleanThreshold && n.runAfter(i.clean), r;
    }
  });
  function Rv(e) {
    N.call(this, [], e);
  }
  Rv.Definition = {
    type: "Flatten",
    metadata: {
      generates: !0
    },
    params: [{
      name: "fields",
      type: "field",
      array: !0,
      required: !0
    }, {
      name: "index",
      type: "string"
    }, {
      name: "as",
      type: "string",
      array: !0
    }]
  };
  G(Rv, N, {
    transform(e, t) {
      const n = t.fork(t.NO_SOURCE), i = e.fields, r = NM(i, e.as || []), o = e.index || null, s = r.length;
      return n.rem = this.value, t.visit(t.SOURCE, (a) => {
        const u = i.map((g) => g(a)), l = u.reduce((g, p) => Math.max(g, p.length), 0);
        let c = 0, f, d, h;
        for (; c < l; ++c) {
          for (d = rv(a), f = 0; f < s; ++f)
            d[r[f]] = (h = u[f][c]) == null ? null : h;
          o && (d[o] = c), n.add.push(d);
        }
      }), this.value = n.source = n.add, o && n.modifies(o), n.modifies(r);
    }
  });
  function Lv(e) {
    N.call(this, [], e);
  }
  Lv.Definition = {
    type: "Fold",
    metadata: {
      generates: !0
    },
    params: [{
      name: "fields",
      type: "field",
      array: !0,
      required: !0
    }, {
      name: "as",
      type: "string",
      array: !0,
      length: 2,
      default: ["key", "value"]
    }]
  };
  G(Lv, N, {
    transform(e, t) {
      const n = t.fork(t.NO_SOURCE), i = e.fields, r = i.map(Je), o = e.as || ["key", "value"], s = o[0], a = o[1], u = i.length;
      return n.rem = this.value, t.visit(t.SOURCE, (l) => {
        for (let c = 0, f; c < u; ++c)
          f = rv(l), f[s] = r[c], f[a] = i[c](l), n.add.push(f);
      }), this.value = n.source = n.add, n.modifies(o);
    }
  });
  function Pv(e) {
    N.call(this, null, e);
  }
  Pv.Definition = {
    type: "Formula",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "expr",
      type: "expr",
      required: !0
    }, {
      name: "as",
      type: "string",
      required: !0
    }, {
      name: "initonly",
      type: "boolean"
    }]
  };
  G(Pv, N, {
    transform(e, t) {
      const n = e.expr, i = e.as, r = e.modified(), o = e.initonly ? t.ADD : r ? t.SOURCE : t.modified(n.fields) || t.modified(i) ? t.ADD_MOD : t.ADD;
      return r && (t = t.materialize().reflow(!0)), e.initonly || t.modifies(i), t.visit(o, (s) => s[i] = n(s, e));
    }
  });
  function PM(e) {
    N.call(this, [], e);
  }
  G(PM, N, {
    transform(e, t) {
      const n = t.fork(t.ALL), i = e.generator;
      let r = this.value, o = e.size - r.length, s, a, u;
      if (o > 0) {
        for (s = []; --o >= 0; )
          s.push(u = Ce(i(e))), r.push(u);
        n.add = n.add.length ? n.materialize(n.ADD).add.concat(s) : s;
      } else
        a = r.slice(0, -o), n.rem = n.rem.length ? n.materialize(n.REM).rem.concat(a) : a, r = r.slice(-o);
      return n.source = this.value = r, n;
    }
  });
  const Zf = {
    value: "value",
    median: lF,
    mean: yP,
    min: k1,
    max: Rs
  }, L8 = [];
  function Iv(e) {
    N.call(this, [], e);
  }
  Iv.Definition = {
    type: "Impute",
    metadata: {
      changes: !0
    },
    params: [{
      name: "field",
      type: "field",
      required: !0
    }, {
      name: "key",
      type: "field",
      required: !0
    }, {
      name: "keyvals",
      array: !0
    }, {
      name: "groupby",
      type: "field",
      array: !0
    }, {
      name: "method",
      type: "enum",
      default: "value",
      values: ["value", "mean", "median", "max", "min"]
    }, {
      name: "value",
      default: 0
    }]
  };
  function P8(e) {
    var t = e.method || Zf.value, n;
    if (Zf[t] == null)
      R("Unrecognized imputation method: " + t);
    else return t === Zf.value ? (n = e.value !== void 0 ? e.value : 0, () => n) : Zf[t];
  }
  function I8(e) {
    const t = e.field;
    return (n) => n ? t(n) : NaN;
  }
  G(Iv, N, {
    transform(e, t) {
      var n = t.fork(t.ALL), i = P8(e), r = I8(e), o = Je(e.field), s = Je(e.key), a = (e.groupby || []).map(Je), u = z8(t.source, e.groupby, e.key, e.keyvals), l = [], c = this.value, f = u.domain.length, d, h, g, p, m, y, b, v, x, w;
      for (m = 0, v = u.length; m < v; ++m)
        for (d = u[m], g = d.values, h = NaN, b = 0; b < f; ++b)
          if (d[b] == null) {
            for (p = u.domain[b], w = {
              _impute: !0
            }, y = 0, x = g.length; y < x; ++y) w[a[y]] = g[y];
            w[s] = p, w[o] = Number.isNaN(h) ? h = i(d, r) : h, l.push(Ce(w));
          }
      return l.length && (n.add = n.materialize(n.ADD).add.concat(l)), c.length && (n.rem = n.materialize(n.REM).rem.concat(c)), this.value = l, n;
    }
  });
  function z8(e, t, n, i) {
    var r = (y) => y(m), o = [], s = i ? i.slice() : [], a = {}, u = {}, l, c, f, d, h, g, p, m;
    for (s.forEach((y, b) => a[y] = b + 1), d = 0, p = e.length; d < p; ++d)
      m = e[d], g = n(m), h = a[g] || (a[g] = s.push(g)), c = (l = t ? t.map(r) : L8) + "", (f = u[c]) || (f = u[c] = [], o.push(f), f.values = l), f[h - 1] = m;
    return o.domain = s, o;
  }
  function zv(e) {
    Lo.call(this, e);
  }
  zv.Definition = {
    type: "JoinAggregate",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "groupby",
      type: "field",
      array: !0
    }, {
      name: "fields",
      type: "field",
      null: !0,
      array: !0
    }, {
      name: "ops",
      type: "enum",
      array: !0,
      values: sf
    }, {
      name: "as",
      type: "string",
      null: !0,
      array: !0
    }, {
      name: "key",
      type: "field"
    }]
  };
  G(zv, Lo, {
    transform(e, t) {
      const n = this, i = e.modified();
      let r;
      return n.value && (i || t.modified(n._inputs, !0)) ? (r = n.value = i ? n.init(e) : {}, t.visit(t.SOURCE, (o) => n.add(o))) : (r = n.value = n.value || this.init(e), t.visit(t.REM, (o) => n.rem(o)), t.visit(t.ADD, (o) => n.add(o))), n.changes(), t.visit(t.SOURCE, (o) => {
        ce(o, r[n.cellkey(o)].tuple);
      }), t.reflow(i).modifies(this._outputs);
    },
    changes() {
      const e = this._adds, t = this._mods;
      let n, i;
      for (n = 0, i = this._alen; n < i; ++n)
        this.celltuple(e[n]), e[n] = null;
      for (n = 0, i = this._mlen; n < i; ++n)
        this.celltuple(t[n]), t[n] = null;
      this._alen = this._mlen = 0;
    }
  });
  function Bv(e) {
    N.call(this, null, e);
  }
  Bv.Definition = {
    type: "KDE",
    metadata: {
      generates: !0
    },
    params: [{
      name: "groupby",
      type: "field",
      array: !0
    }, {
      name: "field",
      type: "field",
      required: !0
    }, {
      name: "cumulative",
      type: "boolean",
      default: !1
    }, {
      name: "counts",
      type: "boolean",
      default: !1
    }, {
      name: "bandwidth",
      type: "number",
      default: 0
    }, {
      name: "extent",
      type: "number",
      array: !0,
      length: 2
    }, {
      name: "resolve",
      type: "enum",
      values: ["shared", "independent"],
      default: "independent"
    }, {
      name: "steps",
      type: "number"
    }, {
      name: "minsteps",
      type: "number",
      default: 25
    }, {
      name: "maxsteps",
      type: "number",
      default: 200
    }, {
      name: "as",
      type: "string",
      array: !0,
      default: ["value", "density"]
    }]
  };
  G(Bv, N, {
    transform(e, t) {
      const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
      if (!this.value || t.changed() || e.modified()) {
        const i = t.materialize(t.SOURCE).source, r = Mv(i, e.groupby, e.field), o = (e.groupby || []).map(Je), s = e.bandwidth, a = e.cumulative ? "cdf" : "pdf", u = e.as || ["value", "density"], l = [];
        let c = e.extent, f = e.steps || e.minsteps || 25, d = e.steps || e.maxsteps || 200;
        a !== "pdf" && a !== "cdf" && R("Invalid density method: " + a), e.resolve === "shared" && (c || (c = nr(i, e.field)), f = d = e.steps || d), r.forEach((h) => {
          const g = dv(h, s)[a], p = e.counts ? h.length : 1, m = c || nr(h);
          ap(g, m, f, d).forEach((y) => {
            const b = {};
            for (let v = 0; v < o.length; ++v)
              b[o[v]] = h.dims[v];
            b[u[0]] = y[0], b[u[1]] = y[1] * p, l.push(Ce(b));
          });
        }), this.value && (n.rem = this.value), this.value = n.add = n.source = l;
      }
      return n;
    }
  });
  function IM(e) {
    Ie.call(this, null, B8, e);
  }
  G(IM, Ie);
  function B8(e) {
    return this.value && !e.modified() ? this.value : jb(e.fields, e.flat);
  }
  function zM(e) {
    N.call(this, [], e), this._pending = null;
  }
  G(zM, N, {
    transform(e, t) {
      const n = t.dataflow;
      return this._pending ? o0(this, t, this._pending) : U8(e) ? t.StopPropagation : e.values ? o0(this, t, n.parse(e.values, e.format)) : e.async ? {
        async: n.request(e.url, e.format).then((r) => (this._pending = X(r.data), (o) => o.touch(this)))
      } : n.request(e.url, e.format).then((i) => o0(this, t, X(i.data)));
    }
  });
  function U8(e) {
    return e.modified("async") && !(e.modified("values") || e.modified("url") || e.modified("format"));
  }
  function o0(e, t, n) {
    n.forEach(Ce);
    const i = t.fork(t.NO_FIELDS & t.NO_SOURCE);
    return i.rem = e.value, e.value = i.source = i.add = n, e._pending = null, i.rem.length && i.clean(!0), i;
  }
  function Uv(e) {
    N.call(this, {}, e);
  }
  Uv.Definition = {
    type: "Lookup",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "index",
      type: "index",
      params: [{
        name: "from",
        type: "data",
        required: !0
      }, {
        name: "key",
        type: "field",
        required: !0
      }]
    }, {
      name: "values",
      type: "field",
      array: !0
    }, {
      name: "fields",
      type: "field",
      array: !0,
      required: !0
    }, {
      name: "as",
      type: "string",
      array: !0
    }, {
      name: "default",
      default: null
    }]
  };
  G(Uv, N, {
    transform(e, t) {
      const n = e.fields, i = e.index, r = e.values, o = e.default == null ? null : e.default, s = e.modified(), a = n.length;
      let u = s ? t.SOURCE : t.ADD, l = t, c = e.as, f, d, h;
      return r ? (d = r.length, a > 1 && !c && R('Multi-field lookup requires explicit "as" parameter.'), c && c.length !== a * d && R('The "as" parameter has too few output field names.'), c = c || r.map(Je), f = function(g) {
        for (var p = 0, m = 0, y, b; p < a; ++p)
          if (b = i.get(n[p](g)), b == null) for (y = 0; y < d; ++y, ++m) g[c[m]] = o;
          else for (y = 0; y < d; ++y, ++m) g[c[m]] = r[y](b);
      }) : (c || R("Missing output field names."), f = function(g) {
        for (var p = 0, m; p < a; ++p)
          m = i.get(n[p](g)), g[c[p]] = m ?? o;
      }), s ? l = t.reflow(!0) : (h = n.some((g) => t.modified(g.fields)), u |= h ? t.MOD : 0), t.visit(u, f), l.modifies(c);
    }
  });
  function BM(e) {
    Ie.call(this, null, j8, e);
  }
  G(BM, Ie);
  function j8(e) {
    if (this.value && !e.modified())
      return this.value;
    const t = e.extents, n = t.length;
    let i = 1 / 0, r = -1 / 0, o, s;
    for (o = 0; o < n; ++o)
      s = t[o], s[0] < i && (i = s[0]), s[1] > r && (r = s[1]);
    return [i, r];
  }
  function UM(e) {
    Ie.call(this, null, q8, e);
  }
  G(UM, Ie);
  function q8(e) {
    return this.value && !e.modified() ? this.value : e.values.reduce((t, n) => t.concat(n), []);
  }
  function jM(e) {
    N.call(this, null, e);
  }
  G(jM, N, {
    transform(e, t) {
      return this.modified(e.modified()), this.value = e, t.fork(t.NO_SOURCE | t.NO_FIELDS);
    }
  });
  function jv(e) {
    Lo.call(this, e);
  }
  jv.Definition = {
    type: "Pivot",
    metadata: {
      generates: !0,
      changes: !0
    },
    params: [{
      name: "groupby",
      type: "field",
      array: !0
    }, {
      name: "field",
      type: "field",
      required: !0
    }, {
      name: "value",
      type: "field",
      required: !0
    }, {
      name: "op",
      type: "enum",
      values: sf,
      default: "sum"
    }, {
      name: "limit",
      type: "number",
      default: 0
    }, {
      name: "key",
      type: "field"
    }]
  };
  G(jv, Lo, {
    _transform: Lo.prototype.transform,
    transform(e, t) {
      return this._transform(W8(e, t), t);
    }
  });
  function W8(e, t) {
    const n = e.field, i = e.value, r = (e.op === "count" ? "__count__" : e.op) || "sum", o = Ut(n).concat(Ut(i)), s = G8(n, e.limit || 0, t);
    return t.changed() && e.set("__pivot__", null, null, !0), {
      key: e.key,
      groupby: e.groupby,
      ops: s.map(() => r),
      fields: s.map((a) => H8(a, n, i, o)),
      as: s.map((a) => a + ""),
      modified: e.modified.bind(e)
    };
  }
  function H8(e, t, n, i) {
    return Sn((r) => t(r) === e ? n(r) : NaN, i, e + "");
  }
  function G8(e, t, n) {
    const i = {}, r = [];
    return n.visit(n.SOURCE, (o) => {
      const s = e(o);
      i[s] || (i[s] = 1, r.push(s));
    }), r.sort(Wg), t ? r.slice(0, t) : r;
  }
  function qM(e) {
    up.call(this, e);
  }
  G(qM, up, {
    transform(e, t) {
      const n = e.subflow, i = e.field, r = (o) => this.subflow(re(o), n, t, o);
      return (e.modified("field") || i && t.modified(Ut(i))) && R("PreFacet does not support field modification."), this.initTargets(), i ? (t.visit(t.MOD, (o) => {
        const s = r(o);
        i(o).forEach((a) => s.mod(a));
      }), t.visit(t.ADD, (o) => {
        const s = r(o);
        i(o).forEach((a) => s.add(Ce(a)));
      }), t.visit(t.REM, (o) => {
        const s = r(o);
        i(o).forEach((a) => s.rem(a));
      })) : (t.visit(t.MOD, (o) => r(o).mod(o)), t.visit(t.ADD, (o) => r(o).add(o)), t.visit(t.REM, (o) => r(o).rem(o))), t.clean() && t.runAfter(() => this.clean()), t;
    }
  });
  function qv(e) {
    N.call(this, null, e);
  }
  qv.Definition = {
    type: "Project",
    metadata: {
      generates: !0,
      changes: !0
    },
    params: [{
      name: "fields",
      type: "field",
      array: !0
    }, {
      name: "as",
      type: "string",
      null: !0,
      array: !0
    }]
  };
  G(qv, N, {
    transform(e, t) {
      const n = t.fork(t.NO_SOURCE), i = e.fields, r = NM(e.fields, e.as || []), o = i ? (a, u) => V8(a, u, i, r) : ep;
      let s;
      return this.value ? s = this.value : (t = t.addAll(), s = this.value = {}), t.visit(t.REM, (a) => {
        const u = re(a);
        n.rem.push(s[u]), s[u] = null;
      }), t.visit(t.ADD, (a) => {
        const u = o(a, Ce({}));
        s[re(a)] = u, n.add.push(u);
      }), t.visit(t.MOD, (a) => {
        n.mod.push(o(a, s[re(a)]));
      }), n;
    }
  });
  function V8(e, t, n, i) {
    for (let r = 0, o = n.length; r < o; ++r)
      t[i[r]] = n[r](e);
    return t;
  }
  function WM(e) {
    N.call(this, null, e);
  }
  G(WM, N, {
    transform(e, t) {
      return this.value = e.value, e.modified("value") ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation;
    }
  });
  function Wv(e) {
    N.call(this, null, e);
  }
  Wv.Definition = {
    type: "Quantile",
    metadata: {
      generates: !0,
      changes: !0
    },
    params: [{
      name: "groupby",
      type: "field",
      array: !0
    }, {
      name: "field",
      type: "field",
      required: !0
    }, {
      name: "probs",
      type: "number",
      array: !0
    }, {
      name: "step",
      type: "number",
      default: 0.01
    }, {
      name: "as",
      type: "string",
      array: !0,
      default: ["prob", "value"]
    }]
  };
  const Y8 = 1e-14;
  G(Wv, N, {
    transform(e, t) {
      const n = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = e.as || ["prob", "value"];
      if (this.value && !e.modified() && !t.changed())
        return n.source = this.value, n;
      const r = t.materialize(t.SOURCE).source, o = Mv(r, e.groupby, e.field), s = (e.groupby || []).map(Je), a = [], u = e.step || 0.01, l = e.probs || Tn(u / 2, 1 - Y8, u), c = l.length;
      return o.forEach((f) => {
        const d = av(f, l);
        for (let h = 0; h < c; ++h) {
          const g = {};
          for (let p = 0; p < s.length; ++p)
            g[s[p]] = f.dims[p];
          g[i[0]] = l[h], g[i[1]] = d[h], a.push(Ce(g));
        }
      }), this.value && (n.rem = this.value), this.value = n.add = n.source = a, n;
    }
  });
  function HM(e) {
    N.call(this, null, e);
  }
  G(HM, N, {
    transform(e, t) {
      let n, i;
      return this.value ? i = this.value : (n = t = t.addAll(), i = this.value = {}), e.derive && (n = t.fork(t.NO_SOURCE), t.visit(t.REM, (r) => {
        const o = re(r);
        n.rem.push(i[o]), i[o] = null;
      }), t.visit(t.ADD, (r) => {
        const o = rv(r);
        i[re(r)] = o, n.add.push(o);
      }), t.visit(t.MOD, (r) => {
        const o = i[re(r)];
        for (const s in r)
          o[s] = r[s], n.modifies(s);
        n.mod.push(o);
      })), n;
    }
  });
  function Hv(e) {
    N.call(this, [], e), this.count = 0;
  }
  Hv.Definition = {
    type: "Sample",
    metadata: {},
    params: [{
      name: "size",
      type: "number",
      default: 1e3
    }]
  };
  G(Hv, N, {
    transform(e, t) {
      const n = t.fork(t.NO_SOURCE), i = e.modified("size"), r = e.size, o = this.value.reduce((c, f) => (c[re(f)] = 1, c), {});
      let s = this.value, a = this.count, u = 0;
      function l(c) {
        let f, d;
        s.length < r ? s.push(c) : (d = ~~((a + 1) * Zn()), d < s.length && d >= u && (f = s[d], o[re(f)] && n.rem.push(f), s[d] = c)), ++a;
      }
      if (t.rem.length && (t.visit(t.REM, (c) => {
        const f = re(c);
        o[f] && (o[f] = -1, n.rem.push(c)), --a;
      }), s = s.filter((c) => o[re(c)] !== -1)), (t.rem.length || i) && s.length < r && t.source && (u = a = s.length, t.visit(t.SOURCE, (c) => {
        o[re(c)] || l(c);
      }), u = -1), i && s.length > r) {
        const c = s.length - r;
        for (let f = 0; f < c; ++f)
          o[re(s[f])] = -1, n.rem.push(s[f]);
        s = s.slice(c);
      }
      return t.mod.length && t.visit(t.MOD, (c) => {
        o[re(c)] && n.mod.push(c);
      }), t.add.length && t.visit(t.ADD, l), (t.add.length || u < 0) && (n.add = s.filter((c) => !o[re(c)])), this.count = a, this.value = n.source = s, n;
    }
  });
  function Gv(e) {
    N.call(this, null, e);
  }
  Gv.Definition = {
    type: "Sequence",
    metadata: {
      generates: !0,
      changes: !0
    },
    params: [{
      name: "start",
      type: "number",
      required: !0
    }, {
      name: "stop",
      type: "number",
      required: !0
    }, {
      name: "step",
      type: "number",
      default: 1
    }, {
      name: "as",
      type: "string",
      default: "data"
    }]
  };
  G(Gv, N, {
    transform(e, t) {
      if (this.value && !e.modified()) return;
      const n = t.materialize().fork(t.MOD), i = e.as || "data";
      return n.rem = this.value ? t.rem.concat(this.value) : t.rem, this.value = Tn(e.start, e.stop, e.step || 1).map((r) => {
        const o = {};
        return o[i] = r, Ce(o);
      }), n.add = t.add.concat(this.value), n;
    }
  });
  function GM(e) {
    N.call(this, null, e), this.modified(!0);
  }
  G(GM, N, {
    transform(e, t) {
      return this.value = t.source, t.changed() ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation;
    }
  });
  function Vv(e) {
    N.call(this, null, e);
  }
  const VM = ["unit0", "unit1"];
  Vv.Definition = {
    type: "TimeUnit",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "field",
      type: "field",
      required: !0
    }, {
      name: "interval",
      type: "boolean",
      default: !0
    }, {
      name: "units",
      type: "enum",
      values: Xb,
      array: !0
    }, {
      name: "step",
      type: "number",
      default: 1
    }, {
      name: "maxbins",
      type: "number",
      default: 40
    }, {
      name: "extent",
      type: "date",
      array: !0
    }, {
      name: "timezone",
      type: "enum",
      default: "local",
      values: ["local", "utc"]
    }, {
      name: "as",
      type: "string",
      array: !0,
      length: 2,
      default: VM
    }]
  };
  G(Vv, N, {
    transform(e, t) {
      const n = e.field, i = e.interval !== !1, r = e.timezone === "utc", o = this._floor(e, t), s = (r ? Ju : Ku)(o.unit).offset, a = e.as || VM, u = a[0], l = a[1], c = o.step;
      let f = o.start || 1 / 0, d = o.stop || -1 / 0, h = t.ADD;
      return (e.modified() || t.changed(t.REM) || t.modified(Ut(n))) && (t = t.reflow(!0), h = t.SOURCE, f = 1 / 0, d = -1 / 0), t.visit(h, (g) => {
        const p = n(g);
        let m, y;
        p == null ? (g[u] = null, i && (g[l] = null)) : (g[u] = m = y = o(p), i && (g[l] = y = s(m, c)), m < f && (f = m), y > d && (d = y));
      }), o.start = f, o.stop = d, t.modifies(i ? a : u);
    },
    _floor(e, t) {
      const n = e.timezone === "utc", {
        units: i,
        step: r
      } = e.units ? {
        units: e.units,
        step: e.step || 1
      } : PF({
        extent: e.extent || nr(t.materialize(t.SOURCE).source, e.field),
        maxbins: e.maxbins
      }), o = Kb(i), s = this.value || {}, a = (n ? CF : AF)(o, r);
      return a.unit = xe(o), a.units = o, a.step = r, a.start = s.start, a.stop = s.stop, this.value = a;
    }
  });
  function YM(e) {
    N.call(this, Gu(), e);
  }
  G(YM, N, {
    transform(e, t) {
      const n = t.dataflow, i = e.field, r = this.value, o = (a) => r.set(i(a), a);
      let s = !0;
      return e.modified("field") || t.modified(i.fields) ? (r.clear(), t.visit(t.SOURCE, o)) : t.changed() ? (t.visit(t.REM, (a) => r.delete(i(a))), t.visit(t.ADD, o)) : s = !1, this.modified(s), r.empty > n.cleanThreshold && n.runAfter(r.clean), t.fork();
    }
  });
  function XM(e) {
    N.call(this, null, e);
  }
  G(XM, N, {
    transform(e, t) {
      (!this.value || e.modified("field") || e.modified("sort") || t.changed() || e.sort && t.modified(e.sort.fields)) && (this.value = (e.sort ? t.source.slice().sort(ha(e.sort)) : t.source).map(e.field));
    }
  });
  function X8(e, t, n, i) {
    const r = Fc[e](t, n);
    return {
      init: r.init || bo,
      update: function(o, s) {
        s[i] = r.next(o);
      }
    };
  }
  const Fc = {
    row_number: function() {
      return {
        next: (e) => e.index + 1
      };
    },
    rank: function() {
      let e;
      return {
        init: () => e = 1,
        next: (t) => {
          const n = t.index, i = t.data;
          return n && t.compare(i[n - 1], i[n]) ? e = n + 1 : e;
        }
      };
    },
    dense_rank: function() {
      let e;
      return {
        init: () => e = 1,
        next: (t) => {
          const n = t.index, i = t.data;
          return n && t.compare(i[n - 1], i[n]) ? ++e : e;
        }
      };
    },
    percent_rank: function() {
      const e = Fc.rank(), t = e.next;
      return {
        init: e.init,
        next: (n) => (t(n) - 1) / (n.data.length - 1)
      };
    },
    cume_dist: function() {
      let e;
      return {
        init: () => e = 0,
        next: (t) => {
          const n = t.data, i = t.compare;
          let r = t.index;
          if (e < r) {
            for (; r + 1 < n.length && !i(n[r], n[r + 1]); ) ++r;
            e = r;
          }
          return (1 + e) / n.length;
        }
      };
    },
    ntile: function(e, t) {
      t = +t, t > 0 || R("ntile num must be greater than zero.");
      const n = Fc.cume_dist(), i = n.next;
      return {
        init: n.init,
        next: (r) => Math.ceil(t * i(r))
      };
    },
    lag: function(e, t) {
      return t = +t || 1, {
        next: (n) => {
          const i = n.index - t;
          return i >= 0 ? e(n.data[i]) : null;
        }
      };
    },
    lead: function(e, t) {
      return t = +t || 1, {
        next: (n) => {
          const i = n.index + t, r = n.data;
          return i < r.length ? e(r[i]) : null;
        }
      };
    },
    first_value: function(e) {
      return {
        next: (t) => e(t.data[t.i0])
      };
    },
    last_value: function(e) {
      return {
        next: (t) => e(t.data[t.i1 - 1])
      };
    },
    nth_value: function(e, t) {
      return t = +t, t > 0 || R("nth_value nth must be greater than zero."), {
        next: (n) => {
          const i = n.i0 + (t - 1);
          return i < n.i1 ? e(n.data[i]) : null;
        }
      };
    },
    prev_value: function(e) {
      let t;
      return {
        init: () => t = null,
        next: (n) => {
          const i = e(n.data[n.index]);
          return i != null ? t = i : t;
        }
      };
    },
    next_value: function(e) {
      let t, n;
      return {
        init: () => (t = null, n = -1),
        next: (i) => {
          const r = i.data;
          return i.index <= n ? t : (n = K8(e, r, i.index)) < 0 ? (n = r.length, t = null) : t = e(r[n]);
        }
      };
    }
  };
  function K8(e, t, n) {
    for (let i = t.length; n < i; ++n)
      if (e(t[n]) != null) return n;
    return -1;
  }
  const J8 = Object.keys(Fc);
  function KM(e) {
    const t = X(e.ops), n = X(e.fields), i = X(e.params), r = X(e.aggregate_params), o = X(e.as), s = this.outputs = [], a = this.windows = [], u = {}, l = {}, c = [], f = [];
    let d = !0;
    function h(g) {
      X(Ut(g)).forEach((p) => u[p] = 1);
    }
    h(e.sort), t.forEach((g, p) => {
      const m = n[p], y = i[p], b = r[p] || null, v = Je(m), x = $M(g, v, o[p]);
      if (h(m), s.push(x), J(Fc, g))
        a.push(X8(g, m, y, x));
      else {
        if (m == null && g !== "count" && R("Null aggregate field specified."), g === "count") {
          c.push(x);
          return;
        }
        d = !1;
        let w = l[v];
        w || (w = l[v] = [], w.field = m, f.push(w)), w.push(kM(g, b, x));
      }
    }), (c.length || f.length) && (this.cell = Q8(f, c, d)), this.inputs = Object.keys(u);
  }
  const JM = KM.prototype;
  JM.init = function() {
    this.windows.forEach((e) => e.init()), this.cell && this.cell.init();
  };
  JM.update = function(e, t) {
    const n = this.cell, i = this.windows, r = e.data, o = i && i.length;
    let s;
    if (n) {
      for (s = e.p0; s < e.i0; ++s) n.rem(r[s]);
      for (s = e.p1; s < e.i1; ++s) n.add(r[s]);
      n.set(t);
    }
    for (s = 0; s < o; ++s) i[s].update(e, t);
  };
  function Q8(e, t, n) {
    e = e.map((u) => CM(u, u.field));
    const i = {
      num: 0,
      agg: null,
      store: !1,
      count: t
    };
    if (!n)
      for (var r = e.length, o = i.agg = Array(r), s = 0; s < r; ++s) o[s] = new e[s](i);
    if (i.store)
      var a = i.data = new Sv();
    return i.add = function(u) {
      if (i.num += 1, !n) {
        a && a.add(u);
        for (let l = 0; l < r; ++l)
          o[l].add(o[l].get(u), u);
      }
    }, i.rem = function(u) {
      if (i.num -= 1, !n) {
        a && a.rem(u);
        for (let l = 0; l < r; ++l)
          o[l].rem(o[l].get(u), u);
      }
    }, i.set = function(u) {
      let l, c;
      for (a && a.values(), l = 0, c = t.length; l < c; ++l) u[t[l]] = i.num;
      if (!n) for (l = 0, c = o.length; l < c; ++l) o[l].set(u);
    }, i.init = function() {
      i.num = 0, a && a.reset();
      for (let u = 0; u < r; ++u) o[u].init();
    }, i;
  }
  function Yv(e) {
    N.call(this, {}, e), this._mlen = 0, this._mods = [];
  }
  Yv.Definition = {
    type: "Window",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "sort",
      type: "compare"
    }, {
      name: "groupby",
      type: "field",
      array: !0
    }, {
      name: "ops",
      type: "enum",
      array: !0,
      values: J8.concat(sf)
    }, {
      name: "params",
      type: "number",
      null: !0,
      array: !0
    }, {
      name: "aggregate_params",
      type: "number",
      null: !0,
      array: !0
    }, {
      name: "fields",
      type: "field",
      null: !0,
      array: !0
    }, {
      name: "as",
      type: "string",
      null: !0,
      array: !0
    }, {
      name: "frame",
      type: "number",
      null: !0,
      array: !0,
      length: 2,
      default: [null, 0]
    }, {
      name: "ignorePeers",
      type: "boolean",
      default: !1
    }]
  };
  G(Yv, N, {
    transform(e, t) {
      this.stamp = t.stamp;
      const n = e.modified(), i = ha(e.sort), r = P1(e.groupby), o = (a) => this.group(r(a));
      let s = this.state;
      (!s || n) && (s = this.state = new KM(e)), n || t.modified(s.inputs) ? (this.value = {}, t.visit(t.SOURCE, (a) => o(a).add(a))) : (t.visit(t.REM, (a) => o(a).remove(a)), t.visit(t.ADD, (a) => o(a).add(a)));
      for (let a = 0, u = this._mlen; a < u; ++a)
        Z8(this._mods[a], s, i, e);
      return this._mlen = 0, this._mods = [], t.reflow(n).modifies(s.outputs);
    },
    group(e) {
      let t = this.value[e];
      return t || (t = this.value[e] = FM(re), t.stamp = -1), t.stamp < this.stamp && (t.stamp = this.stamp, this._mods[this._mlen++] = t), t;
    }
  });
  function Z8(e, t, n, i) {
    const r = i.sort, o = r && !i.ignorePeers, s = i.frame || [null, 0], a = e.data(n), u = a.length, l = o ? Vu(r) : null, c = {
      i0: 0,
      i1: 0,
      p0: 0,
      p1: 0,
      index: 0,
      data: a,
      compare: r || Gt(-1)
    };
    t.init();
    for (let f = 0; f < u; ++f)
      e9(c, s, f, u), o && t9(c, l), t.update(c, a[f]);
  }
  function e9(e, t, n, i) {
    e.p0 = e.i0, e.p1 = e.i1, e.i0 = t[0] == null ? 0 : Math.max(0, n - Math.abs(t[0])), e.i1 = t[1] == null ? i : Math.min(i, n + Math.abs(t[1]) + 1), e.index = n;
  }
  function t9(e, t) {
    const n = e.i0, i = e.i1 - 1, r = e.compare, o = e.data, s = o.length - 1;
    n > 0 && !r(o[n], o[n - 1]) && (e.i0 = t.left(o, o[n])), i < s && !r(o[i], o[i + 1]) && (e.i1 = t.right(o, o[i]));
  }
  const n9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    aggregate: Lo,
    bin: $v,
    collect: kv,
    compare: MM,
    countpattern: Av,
    cross: Cv,
    density: Fv,
    dotbin: Tv,
    expression: RM,
    extent: Dv,
    facet: up,
    field: LM,
    filter: Ov,
    flatten: Rv,
    fold: Lv,
    formula: Pv,
    generate: PM,
    impute: Iv,
    joinaggregate: zv,
    kde: Bv,
    key: IM,
    load: zM,
    lookup: Uv,
    multiextent: BM,
    multivalues: UM,
    params: jM,
    pivot: jv,
    prefacet: qM,
    project: qv,
    proxy: WM,
    quantile: Wv,
    relay: HM,
    sample: Hv,
    sequence: Gv,
    sieve: GM,
    subflow: Nv,
    timeunit: Vv,
    tupleindex: YM,
    values: XM,
    window: Yv
  }, Symbol.toStringTag, { value: "Module" }));
  function Fe(e) {
    return function() {
      return e;
    };
  }
  const I_ = Math.abs, Nt = Math.atan2, fs = Math.cos, i9 = Math.max, s0 = Math.min, Ii = Math.sin, Ms = Math.sqrt, Rt = 1e-12, hu = Math.PI, vh = hu / 2, QM = 2 * hu;
  function r9(e) {
    return e > 1 ? 0 : e < -1 ? hu : Math.acos(e);
  }
  function z_(e) {
    return e >= 1 ? vh : e <= -1 ? -vh : Math.asin(e);
  }
  const I1 = Math.PI, z1 = 2 * I1, _s = 1e-6, o9 = z1 - _s;
  function ZM(e) {
    this._ += e[0];
    for (let t = 1, n = e.length; t < n; ++t)
      this._ += arguments[t] + e[t];
  }
  function s9(e) {
    let t = Math.floor(e);
    if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
    if (t > 15) return ZM;
    const n = 10 ** t;
    return function(i) {
      this._ += i[0];
      for (let r = 1, o = i.length; r < o; ++r)
        this._ += Math.round(arguments[r] * n) / n + i[r];
    };
  }
  let Xv = class {
    constructor(t) {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null, this._ = "", this._append = t == null ? ZM : s9(t);
    }
    moveTo(t, n) {
      this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
    }
    closePath() {
      this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
    }
    lineTo(t, n) {
      this._append`L${this._x1 = +t},${this._y1 = +n}`;
    }
    quadraticCurveTo(t, n, i, r) {
      this._append`Q${+t},${+n},${this._x1 = +i},${this._y1 = +r}`;
    }
    bezierCurveTo(t, n, i, r, o, s) {
      this._append`C${+t},${+n},${+i},${+r},${this._x1 = +o},${this._y1 = +s}`;
    }
    arcTo(t, n, i, r, o) {
      if (t = +t, n = +n, i = +i, r = +r, o = +o, o < 0) throw new Error(`negative radius: ${o}`);
      let s = this._x1, a = this._y1, u = i - t, l = r - n, c = s - t, f = a - n, d = c * c + f * f;
      if (this._x1 === null)
        this._append`M${this._x1 = t},${this._y1 = n}`;
      else if (d > _s) if (!(Math.abs(f * u - l * c) > _s) || !o)
        this._append`L${this._x1 = t},${this._y1 = n}`;
      else {
        let h = i - s, g = r - a, p = u * u + l * l, m = h * h + g * g, y = Math.sqrt(p), b = Math.sqrt(d), v = o * Math.tan((I1 - Math.acos((p + d - m) / (2 * y * b))) / 2), x = v / b, w = v / y;
        Math.abs(x - 1) > _s && this._append`L${t + x * c},${n + x * f}`, this._append`A${o},${o},0,0,${+(f * h > c * g)},${this._x1 = t + w * u},${this._y1 = n + w * l}`;
      }
    }
    arc(t, n, i, r, o, s) {
      if (t = +t, n = +n, i = +i, s = !!s, i < 0) throw new Error(`negative radius: ${i}`);
      let a = i * Math.cos(r), u = i * Math.sin(r), l = t + a, c = n + u, f = 1 ^ s, d = s ? r - o : o - r;
      this._x1 === null ? this._append`M${l},${c}` : (Math.abs(this._x1 - l) > _s || Math.abs(this._y1 - c) > _s) && this._append`L${l},${c}`, i && (d < 0 && (d = d % z1 + z1), d > o9 ? this._append`A${i},${i},0,1,${f},${t - a},${n - u}A${i},${i},0,1,${f},${this._x1 = l},${this._y1 = c}` : d > _s && this._append`A${i},${i},0,${+(d >= I1)},${f},${this._x1 = t + i * Math.cos(o)},${this._y1 = n + i * Math.sin(o)}`);
    }
    rect(t, n, i, r) {
      this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${i = +i}v${+r}h${-i}Z`;
    }
    toString() {
      return this._;
    }
  };
  function lp() {
    return new Xv();
  }
  lp.prototype = Xv.prototype;
  function cp(e) {
    let t = 3;
    return e.digits = function(n) {
      if (!arguments.length) return t;
      if (n == null)
        t = null;
      else {
        const i = Math.floor(n);
        if (!(i >= 0)) throw new RangeError(`invalid digits: ${n}`);
        t = i;
      }
      return e;
    }, () => new Xv(t);
  }
  function a9(e) {
    return e.innerRadius;
  }
  function u9(e) {
    return e.outerRadius;
  }
  function l9(e) {
    return e.startAngle;
  }
  function c9(e) {
    return e.endAngle;
  }
  function f9(e) {
    return e && e.padAngle;
  }
  function d9(e, t, n, i, r, o, s, a) {
    var u = n - e, l = i - t, c = s - r, f = a - o, d = f * u - c * l;
    if (!(d * d < Rt))
      return d = (c * (t - o) - f * (e - r)) / d, [e + d * u, t + d * l];
  }
  function ed(e, t, n, i, r, o, s) {
    var a = e - n, u = t - i, l = (s ? o : -o) / Ms(a * a + u * u), c = l * u, f = -l * a, d = e + c, h = t + f, g = n + c, p = i + f, m = (d + g) / 2, y = (h + p) / 2, b = g - d, v = p - h, x = b * b + v * v, w = r - o, _ = d * p - g * h, E = (v < 0 ? -1 : 1) * Ms(i9(0, w * w * x - _ * _)), S = (_ * v - b * E) / x, $ = (-_ * b - v * E) / x, F = (_ * v + b * E) / x, A = (-_ * b + v * E) / x, D = S - m, k = $ - y, M = F - m, C = A - y;
    return D * D + k * k > M * M + C * C && (S = F, $ = A), {
      cx: S,
      cy: $,
      x01: -c,
      y01: -f,
      x11: S * (r / w - 1),
      y11: $ * (r / w - 1)
    };
  }
  function h9() {
    var e = a9, t = u9, n = Fe(0), i = null, r = l9, o = c9, s = f9, a = null, u = cp(l);
    function l() {
      var c, f, d = +e.apply(this, arguments), h = +t.apply(this, arguments), g = r.apply(this, arguments) - vh, p = o.apply(this, arguments) - vh, m = I_(p - g), y = p > g;
      if (a || (a = c = u()), h < d && (f = h, h = d, d = f), !(h > Rt)) a.moveTo(0, 0);
      else if (m > QM - Rt)
        a.moveTo(h * fs(g), h * Ii(g)), a.arc(0, 0, h, g, p, !y), d > Rt && (a.moveTo(d * fs(p), d * Ii(p)), a.arc(0, 0, d, p, g, y));
      else {
        var b = g, v = p, x = g, w = p, _ = m, E = m, S = s.apply(this, arguments) / 2, $ = S > Rt && (i ? +i.apply(this, arguments) : Ms(d * d + h * h)), F = s0(I_(h - d) / 2, +n.apply(this, arguments)), A = F, D = F, k, M;
        if ($ > Rt) {
          var C = z_($ / d * Ii(S)), T = z_($ / h * Ii(S));
          (_ -= C * 2) > Rt ? (C *= y ? 1 : -1, x += C, w -= C) : (_ = 0, x = w = (g + p) / 2), (E -= T * 2) > Rt ? (T *= y ? 1 : -1, b += T, v -= T) : (E = 0, b = v = (g + p) / 2);
        }
        var L = h * fs(b), I = h * Ii(b), z = d * fs(w), te = d * Ii(w);
        if (F > Rt) {
          var ne = h * fs(v), de = h * Ii(v), _e = d * fs(x), we = d * Ii(x), Pe;
          if (m < hu)
            if (Pe = d9(L, I, _e, we, ne, de, z, te)) {
              var Li = L - Pe[0], cs = I - Pe[1], ao = ne - Pe[0], Q = de - Pe[1], he = 1 / Ii(r9((Li * ao + cs * Q) / (Ms(Li * Li + cs * cs) * Ms(ao * ao + Q * Q))) / 2), pe = Ms(Pe[0] * Pe[0] + Pe[1] * Pe[1]);
              A = s0(F, (d - pe) / (he - 1)), D = s0(F, (h - pe) / (he + 1));
            } else
              A = D = 0;
        }
        E > Rt ? D > Rt ? (k = ed(_e, we, L, I, h, D, y), M = ed(ne, de, z, te, h, D, y), a.moveTo(k.cx + k.x01, k.cy + k.y01), D < F ? a.arc(k.cx, k.cy, D, Nt(k.y01, k.x01), Nt(M.y01, M.x01), !y) : (a.arc(k.cx, k.cy, D, Nt(k.y01, k.x01), Nt(k.y11, k.x11), !y), a.arc(0, 0, h, Nt(k.cy + k.y11, k.cx + k.x11), Nt(M.cy + M.y11, M.cx + M.x11), !y), a.arc(M.cx, M.cy, D, Nt(M.y11, M.x11), Nt(M.y01, M.x01), !y))) : (a.moveTo(L, I), a.arc(0, 0, h, b, v, !y)) : a.moveTo(L, I), !(d > Rt) || !(_ > Rt) ? a.lineTo(z, te) : A > Rt ? (k = ed(z, te, ne, de, d, -A, y), M = ed(L, I, _e, we, d, -A, y), a.lineTo(k.cx + k.x01, k.cy + k.y01), A < F ? a.arc(k.cx, k.cy, A, Nt(k.y01, k.x01), Nt(M.y01, M.x01), !y) : (a.arc(k.cx, k.cy, A, Nt(k.y01, k.x01), Nt(k.y11, k.x11), !y), a.arc(0, 0, d, Nt(k.cy + k.y11, k.cx + k.x11), Nt(M.cy + M.y11, M.cx + M.x11), y), a.arc(M.cx, M.cy, A, Nt(M.y11, M.x11), Nt(M.y01, M.x01), !y))) : a.arc(0, 0, d, w, x, y);
      }
      if (a.closePath(), c) return a = null, c + "" || null;
    }
    return l.centroid = function() {
      var c = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, f = (+r.apply(this, arguments) + +o.apply(this, arguments)) / 2 - hu / 2;
      return [fs(f) * c, Ii(f) * c];
    }, l.innerRadius = function(c) {
      return arguments.length ? (e = typeof c == "function" ? c : Fe(+c), l) : e;
    }, l.outerRadius = function(c) {
      return arguments.length ? (t = typeof c == "function" ? c : Fe(+c), l) : t;
    }, l.cornerRadius = function(c) {
      return arguments.length ? (n = typeof c == "function" ? c : Fe(+c), l) : n;
    }, l.padRadius = function(c) {
      return arguments.length ? (i = c == null ? null : typeof c == "function" ? c : Fe(+c), l) : i;
    }, l.startAngle = function(c) {
      return arguments.length ? (r = typeof c == "function" ? c : Fe(+c), l) : r;
    }, l.endAngle = function(c) {
      return arguments.length ? (o = typeof c == "function" ? c : Fe(+c), l) : o;
    }, l.padAngle = function(c) {
      return arguments.length ? (s = typeof c == "function" ? c : Fe(+c), l) : s;
    }, l.context = function(c) {
      return arguments.length ? (a = c ?? null, l) : a;
    }, l;
  }
  function eT(e) {
    return typeof e == "object" && "length" in e ? e : Array.from(e);
  }
  function tT(e) {
    this._context = e;
  }
  tT.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function(e, t) {
      switch (e = +e, t = +t, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
        default:
          this._context.lineTo(e, t);
          break;
      }
    }
  };
  function Kv(e) {
    return new tT(e);
  }
  function nT(e) {
    return e[0];
  }
  function iT(e) {
    return e[1];
  }
  function rT(e, t) {
    var n = Fe(!0), i = null, r = Kv, o = null, s = cp(a);
    e = typeof e == "function" ? e : e === void 0 ? nT : Fe(e), t = typeof t == "function" ? t : t === void 0 ? iT : Fe(t);
    function a(u) {
      var l, c = (u = eT(u)).length, f, d = !1, h;
      for (i == null && (o = r(h = s())), l = 0; l <= c; ++l)
        !(l < c && n(f = u[l], l, u)) === d && ((d = !d) ? o.lineStart() : o.lineEnd()), d && o.point(+e(f, l, u), +t(f, l, u));
      if (h) return o = null, h + "" || null;
    }
    return a.x = function(u) {
      return arguments.length ? (e = typeof u == "function" ? u : Fe(+u), a) : e;
    }, a.y = function(u) {
      return arguments.length ? (t = typeof u == "function" ? u : Fe(+u), a) : t;
    }, a.defined = function(u) {
      return arguments.length ? (n = typeof u == "function" ? u : Fe(!!u), a) : n;
    }, a.curve = function(u) {
      return arguments.length ? (r = u, i != null && (o = r(i)), a) : r;
    }, a.context = function(u) {
      return arguments.length ? (u == null ? i = o = null : o = r(i = u), a) : i;
    }, a;
  }
  function oT(e, t, n) {
    var i = null, r = Fe(!0), o = null, s = Kv, a = null, u = cp(l);
    e = typeof e == "function" ? e : e === void 0 ? nT : Fe(+e), t = typeof t == "function" ? t : Fe(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? iT : Fe(+n);
    function l(f) {
      var d, h, g, p = (f = eT(f)).length, m, y = !1, b, v = new Array(p), x = new Array(p);
      for (o == null && (a = s(b = u())), d = 0; d <= p; ++d) {
        if (!(d < p && r(m = f[d], d, f)) === y)
          if (y = !y)
            h = d, a.areaStart(), a.lineStart();
          else {
            for (a.lineEnd(), a.lineStart(), g = d - 1; g >= h; --g)
              a.point(v[g], x[g]);
            a.lineEnd(), a.areaEnd();
          }
        y && (v[d] = +e(m, d, f), x[d] = +t(m, d, f), a.point(i ? +i(m, d, f) : v[d], n ? +n(m, d, f) : x[d]));
      }
      if (b) return a = null, b + "" || null;
    }
    function c() {
      return rT().defined(r).curve(s).context(o);
    }
    return l.x = function(f) {
      return arguments.length ? (e = typeof f == "function" ? f : Fe(+f), i = null, l) : e;
    }, l.x0 = function(f) {
      return arguments.length ? (e = typeof f == "function" ? f : Fe(+f), l) : e;
    }, l.x1 = function(f) {
      return arguments.length ? (i = f == null ? null : typeof f == "function" ? f : Fe(+f), l) : i;
    }, l.y = function(f) {
      return arguments.length ? (t = typeof f == "function" ? f : Fe(+f), n = null, l) : t;
    }, l.y0 = function(f) {
      return arguments.length ? (t = typeof f == "function" ? f : Fe(+f), l) : t;
    }, l.y1 = function(f) {
      return arguments.length ? (n = f == null ? null : typeof f == "function" ? f : Fe(+f), l) : n;
    }, l.lineX0 = l.lineY0 = function() {
      return c().x(e).y(t);
    }, l.lineY1 = function() {
      return c().x(e).y(n);
    }, l.lineX1 = function() {
      return c().x(i).y(t);
    }, l.defined = function(f) {
      return arguments.length ? (r = typeof f == "function" ? f : Fe(!!f), l) : r;
    }, l.curve = function(f) {
      return arguments.length ? (s = f, o != null && (a = s(o)), l) : s;
    }, l.context = function(f) {
      return arguments.length ? (f == null ? o = a = null : a = s(o = f), l) : o;
    }, l;
  }
  const g9 = {
    draw(e, t) {
      const n = Ms(t / hu);
      e.moveTo(n, 0), e.arc(0, 0, n, 0, QM);
    }
  };
  function p9(e, t) {
    let n = null, i = cp(r);
    e = typeof e == "function" ? e : Fe(e || g9), t = typeof t == "function" ? t : Fe(t === void 0 ? 64 : +t);
    function r() {
      let o;
      if (n || (n = o = i()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), o) return n = null, o + "" || null;
    }
    return r.type = function(o) {
      return arguments.length ? (e = typeof o == "function" ? o : Fe(o), r) : e;
    }, r.size = function(o) {
      return arguments.length ? (t = typeof o == "function" ? o : Fe(+o), r) : t;
    }, r.context = function(o) {
      return arguments.length ? (n = o ?? null, r) : n;
    }, r;
  }
  function Po() {
  }
  function xh(e, t, n) {
    e._context.bezierCurveTo(
      (2 * e._x0 + e._x1) / 3,
      (2 * e._y0 + e._y1) / 3,
      (e._x0 + 2 * e._x1) / 3,
      (e._y0 + 2 * e._y1) / 3,
      (e._x0 + 4 * e._x1 + t) / 6,
      (e._y0 + 4 * e._y1 + n) / 6
    );
  }
  function fp(e) {
    this._context = e;
  }
  fp.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 3:
          xh(this, this._x1, this._y1);
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
      }
      (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function(e, t) {
      switch (e = +e, t = +t, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
        default:
          xh(this, e, t);
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
    }
  };
  function m9(e) {
    return new fp(e);
  }
  function sT(e) {
    this._context = e;
  }
  sT.prototype = {
    areaStart: Po,
    areaEnd: Po,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x2, this._y2), this._context.closePath();
          break;
        }
        case 2: {
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
          break;
        }
      }
    },
    point: function(e, t) {
      switch (e = +e, t = +t, this._point) {
        case 0:
          this._point = 1, this._x2 = e, this._y2 = t;
          break;
        case 1:
          this._point = 2, this._x3 = e, this._y3 = t;
          break;
        case 2:
          this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
          break;
        default:
          xh(this, e, t);
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
    }
  };
  function y9(e) {
    return new sT(e);
  }
  function aT(e) {
    this._context = e;
  }
  aT.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
    },
    lineEnd: function() {
      (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function(e, t) {
      switch (e = +e, t = +t, this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          var n = (this._x0 + 4 * this._x1 + e) / 6, i = (this._y0 + 4 * this._y1 + t) / 6;
          this._line ? this._context.lineTo(n, i) : this._context.moveTo(n, i);
          break;
        case 3:
          this._point = 4;
        default:
          xh(this, e, t);
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
    }
  };
  function b9(e) {
    return new aT(e);
  }
  function uT(e, t) {
    this._basis = new fp(e), this._beta = t;
  }
  uT.prototype = {
    lineStart: function() {
      this._x = [], this._y = [], this._basis.lineStart();
    },
    lineEnd: function() {
      var e = this._x, t = this._y, n = e.length - 1;
      if (n > 0)
        for (var i = e[0], r = t[0], o = e[n] - i, s = t[n] - r, a = -1, u; ++a <= n; )
          u = a / n, this._basis.point(
            this._beta * e[a] + (1 - this._beta) * (i + u * o),
            this._beta * t[a] + (1 - this._beta) * (r + u * s)
          );
      this._x = this._y = null, this._basis.lineEnd();
    },
    point: function(e, t) {
      this._x.push(+e), this._y.push(+t);
    }
  };
  const v9 = function e(t) {
    function n(i) {
      return t === 1 ? new fp(i) : new uT(i, t);
    }
    return n.beta = function(i) {
      return e(+i);
    }, n;
  }(0.85);
  function wh(e, t, n) {
    e._context.bezierCurveTo(
      e._x1 + e._k * (e._x2 - e._x0),
      e._y1 + e._k * (e._y2 - e._y0),
      e._x2 + e._k * (e._x1 - t),
      e._y2 + e._k * (e._y1 - n),
      e._x2,
      e._y2
    );
  }
  function Jv(e, t) {
    this._context = e, this._k = (1 - t) / 6;
  }
  Jv.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          wh(this, this._x1, this._y1);
          break;
      }
      (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function(e, t) {
      switch (e = +e, t = +t, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2, this._x1 = e, this._y1 = t;
          break;
        case 2:
          this._point = 3;
        default:
          wh(this, e, t);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
    }
  };
  const x9 = function e(t) {
    function n(i) {
      return new Jv(i, t);
    }
    return n.tension = function(i) {
      return e(+i);
    }, n;
  }(0);
  function Qv(e, t) {
    this._context = e, this._k = (1 - t) / 6;
  }
  Qv.prototype = {
    areaStart: Po,
    areaEnd: Po,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3), this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3), this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(e, t) {
      switch (e = +e, t = +t, this._point) {
        case 0:
          this._point = 1, this._x3 = e, this._y3 = t;
          break;
        case 1:
          this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
          break;
        case 2:
          this._point = 3, this._x5 = e, this._y5 = t;
          break;
        default:
          wh(this, e, t);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
    }
  };
  const w9 = function e(t) {
    function n(i) {
      return new Qv(i, t);
    }
    return n.tension = function(i) {
      return e(+i);
    }, n;
  }(0);
  function Zv(e, t) {
    this._context = e, this._k = (1 - t) / 6;
  }
  Zv.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
    },
    lineEnd: function() {
      (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function(e, t) {
      switch (e = +e, t = +t, this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;
        case 3:
          this._point = 4;
        default:
          wh(this, e, t);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
    }
  };
  const E9 = function e(t) {
    function n(i) {
      return new Zv(i, t);
    }
    return n.tension = function(i) {
      return e(+i);
    }, n;
  }(0);
  function ex(e, t, n) {
    var i = e._x1, r = e._y1, o = e._x2, s = e._y2;
    if (e._l01_a > Rt) {
      var a = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, u = 3 * e._l01_a * (e._l01_a + e._l12_a);
      i = (i * a - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / u, r = (r * a - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / u;
    }
    if (e._l23_a > Rt) {
      var l = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, c = 3 * e._l23_a * (e._l23_a + e._l12_a);
      o = (o * l + e._x1 * e._l23_2a - t * e._l12_2a) / c, s = (s * l + e._y1 * e._l23_2a - n * e._l12_2a) / c;
    }
    e._context.bezierCurveTo(i, r, o, s, e._x2, e._y2);
  }
  function lT(e, t) {
    this._context = e, this._alpha = t;
  }
  lT.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          this.point(this._x2, this._y2);
          break;
      }
      (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function(e, t) {
      if (e = +e, t = +t, this._point) {
        var n = this._x2 - e, i = this._y2 - t;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
        default:
          ex(this, e, t);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
    }
  };
  const _9 = function e(t) {
    function n(i) {
      return t ? new lT(i, t) : new Jv(i, 0);
    }
    return n.alpha = function(i) {
      return e(+i);
    }, n;
  }(0.5);
  function cT(e, t) {
    this._context = e, this._alpha = t;
  }
  cT.prototype = {
    areaStart: Po,
    areaEnd: Po,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3), this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3), this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(e, t) {
      if (e = +e, t = +t, this._point) {
        var n = this._x2 - e, i = this._y2 - t;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1, this._x3 = e, this._y3 = t;
          break;
        case 1:
          this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
          break;
        case 2:
          this._point = 3, this._x5 = e, this._y5 = t;
          break;
        default:
          ex(this, e, t);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
    }
  };
  const S9 = function e(t) {
    function n(i) {
      return t ? new cT(i, t) : new Qv(i, 0);
    }
    return n.alpha = function(i) {
      return e(+i);
    }, n;
  }(0.5);
  function fT(e, t) {
    this._context = e, this._alpha = t;
  }
  fT.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function(e, t) {
      if (e = +e, t = +t, this._point) {
        var n = this._x2 - e, i = this._y2 - t;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;
        case 3:
          this._point = 4;
        default:
          ex(this, e, t);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
    }
  };
  const $9 = function e(t) {
    function n(i) {
      return t ? new fT(i, t) : new Zv(i, 0);
    }
    return n.alpha = function(i) {
      return e(+i);
    }, n;
  }(0.5);
  function dT(e) {
    this._context = e;
  }
  dT.prototype = {
    areaStart: Po,
    areaEnd: Po,
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      this._point && this._context.closePath();
    },
    point: function(e, t) {
      e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
    }
  };
  function k9(e) {
    return new dT(e);
  }
  function B_(e) {
    return e < 0 ? -1 : 1;
  }
  function U_(e, t, n) {
    var i = e._x1 - e._x0, r = t - e._x1, o = (e._y1 - e._y0) / (i || r < 0 && -0), s = (n - e._y1) / (r || i < 0 && -0), a = (o * r + s * i) / (i + r);
    return (B_(o) + B_(s)) * Math.min(Math.abs(o), Math.abs(s), 0.5 * Math.abs(a)) || 0;
  }
  function j_(e, t) {
    var n = e._x1 - e._x0;
    return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
  }
  function a0(e, t, n) {
    var i = e._x0, r = e._y0, o = e._x1, s = e._y1, a = (o - i) / 3;
    e._context.bezierCurveTo(i + a, r + a * t, o - a, s - a * n, o, s);
  }
  function Eh(e) {
    this._context = e;
  }
  Eh.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
        case 3:
          a0(this, this._t0, j_(this, this._t0));
          break;
      }
      (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function(e, t) {
      var n = NaN;
      if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3, a0(this, j_(this, n = U_(this, e, t)), n);
            break;
          default:
            a0(this, this._t0, n = U_(this, e, t));
            break;
        }
        this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
      }
    }
  };
  function hT(e) {
    this._context = new gT(e);
  }
  (hT.prototype = Object.create(Eh.prototype)).point = function(e, t) {
    Eh.prototype.point.call(this, t, e);
  };
  function gT(e) {
    this._context = e;
  }
  gT.prototype = {
    moveTo: function(e, t) {
      this._context.moveTo(t, e);
    },
    closePath: function() {
      this._context.closePath();
    },
    lineTo: function(e, t) {
      this._context.lineTo(t, e);
    },
    bezierCurveTo: function(e, t, n, i, r, o) {
      this._context.bezierCurveTo(t, e, i, n, o, r);
    }
  };
  function A9(e) {
    return new Eh(e);
  }
  function C9(e) {
    return new hT(e);
  }
  function pT(e) {
    this._context = e;
  }
  pT.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = [], this._y = [];
    },
    lineEnd: function() {
      var e = this._x, t = this._y, n = e.length;
      if (n)
        if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
          this._context.lineTo(e[1], t[1]);
        else
          for (var i = q_(e), r = q_(t), o = 0, s = 1; s < n; ++o, ++s)
            this._context.bezierCurveTo(i[0][o], r[0][o], i[1][o], r[1][o], e[s], t[s]);
      (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
    },
    point: function(e, t) {
      this._x.push(+e), this._y.push(+t);
    }
  };
  function q_(e) {
    var t, n = e.length - 1, i, r = new Array(n), o = new Array(n), s = new Array(n);
    for (r[0] = 0, o[0] = 2, s[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t) r[t] = 1, o[t] = 4, s[t] = 4 * e[t] + 2 * e[t + 1];
    for (r[n - 1] = 2, o[n - 1] = 7, s[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t) i = r[t] / o[t - 1], o[t] -= i, s[t] -= i * s[t - 1];
    for (r[n - 1] = s[n - 1] / o[n - 1], t = n - 2; t >= 0; --t) r[t] = (s[t] - r[t + 1]) / o[t];
    for (o[n - 1] = (e[n] + r[n - 1]) / 2, t = 0; t < n - 1; ++t) o[t] = 2 * e[t + 1] - r[t + 1];
    return [r, o];
  }
  function F9(e) {
    return new pT(e);
  }
  function dp(e, t) {
    this._context = e, this._t = t;
  }
  dp.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = this._y = NaN, this._point = 0;
    },
    lineEnd: function() {
      0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
    },
    point: function(e, t) {
      switch (e = +e, t = +t, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
        default: {
          if (this._t <= 0)
            this._context.lineTo(this._x, t), this._context.lineTo(e, t);
          else {
            var n = this._x * (1 - this._t) + e * this._t;
            this._context.lineTo(n, this._y), this._context.lineTo(n, t);
          }
          break;
        }
      }
      this._x = e, this._y = t;
    }
  };
  function M9(e) {
    return new dp(e, 0.5);
  }
  function T9(e) {
    return new dp(e, 0);
  }
  function D9(e) {
    return new dp(e, 1);
  }
  function To(e, t) {
    if (typeof document < "u" && document.createElement) {
      const n = document.createElement("canvas");
      if (n && n.getContext)
        return n.width = e, n.height = t, n;
    }
    return null;
  }
  const N9 = () => typeof Image < "u" ? Image : null;
  function dr(e, t) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(e);
        break;
      default:
        this.range(t).domain(e);
        break;
    }
    return this;
  }
  function Jo(e, t) {
    switch (arguments.length) {
      case 0:
        break;
      case 1: {
        typeof e == "function" ? this.interpolator(e) : this.range(e);
        break;
      }
      default: {
        this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
        break;
      }
    }
    return this;
  }
  const B1 = Symbol("implicit");
  function tx() {
    var e = new s_(), t = [], n = [], i = B1;
    function r(o) {
      let s = e.get(o);
      if (s === void 0) {
        if (i !== B1) return i;
        e.set(o, s = t.push(o) - 1);
      }
      return n[s % n.length];
    }
    return r.domain = function(o) {
      if (!arguments.length) return t.slice();
      t = [], e = new s_();
      for (const s of o)
        e.has(s) || e.set(s, t.push(s) - 1);
      return r;
    }, r.range = function(o) {
      return arguments.length ? (n = Array.from(o), r) : n.slice();
    }, r.unknown = function(o) {
      return arguments.length ? (i = o, r) : i;
    }, r.copy = function() {
      return tx(t, n).unknown(i);
    }, dr.apply(r, arguments), r;
  }
  function Zu(e, t, n) {
    e.prototype = t.prototype = n, n.constructor = e;
  }
  function af(e, t) {
    var n = Object.create(e.prototype);
    for (var i in t) n[i] = t[i];
    return n;
  }
  function Qo() {
  }
  var Hs = 0.7, gu = 1 / Hs, Qa = "\\s*([+-]?\\d+)\\s*", Mc = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Ji = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", O9 = /^#([0-9a-f]{3,8})$/, R9 = new RegExp(`^rgb\\(${Qa},${Qa},${Qa}\\)$`), L9 = new RegExp(`^rgb\\(${Ji},${Ji},${Ji}\\)$`), P9 = new RegExp(`^rgba\\(${Qa},${Qa},${Qa},${Mc}\\)$`), I9 = new RegExp(`^rgba\\(${Ji},${Ji},${Ji},${Mc}\\)$`), z9 = new RegExp(`^hsl\\(${Mc},${Ji},${Ji}\\)$`), B9 = new RegExp(`^hsla\\(${Mc},${Ji},${Ji},${Mc}\\)$`), W_ = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  Zu(Qo, Tc, {
    copy(e) {
      return Object.assign(new this.constructor(), this, e);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: H_,
    // Deprecated! Use color.formatHex.
    formatHex: H_,
    formatHex8: U9,
    formatHsl: j9,
    formatRgb: G_,
    toString: G_
  });
  function H_() {
    return this.rgb().formatHex();
  }
  function U9() {
    return this.rgb().formatHex8();
  }
  function j9() {
    return mT(this).formatHsl();
  }
  function G_() {
    return this.rgb().formatRgb();
  }
  function Tc(e) {
    var t, n;
    return e = (e + "").trim().toLowerCase(), (t = O9.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? V_(t) : n === 3 ? new dt(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? td(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? td(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = R9.exec(e)) ? new dt(t[1], t[2], t[3], 1) : (t = L9.exec(e)) ? new dt(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = P9.exec(e)) ? td(t[1], t[2], t[3], t[4]) : (t = I9.exec(e)) ? td(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = z9.exec(e)) ? K_(t[1], t[2] / 100, t[3] / 100, 1) : (t = B9.exec(e)) ? K_(t[1], t[2] / 100, t[3] / 100, t[4]) : W_.hasOwnProperty(e) ? V_(W_[e]) : e === "transparent" ? new dt(NaN, NaN, NaN, 0) : null;
  }
  function V_(e) {
    return new dt(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
  }
  function td(e, t, n, i) {
    return i <= 0 && (e = t = n = NaN), new dt(e, t, n, i);
  }
  function nx(e) {
    return e instanceof Qo || (e = Tc(e)), e ? (e = e.rgb(), new dt(e.r, e.g, e.b, e.opacity)) : new dt();
  }
  function Io(e, t, n, i) {
    return arguments.length === 1 ? nx(e) : new dt(e, t, n, i ?? 1);
  }
  function dt(e, t, n, i) {
    this.r = +e, this.g = +t, this.b = +n, this.opacity = +i;
  }
  Zu(dt, Io, af(Qo, {
    brighter(e) {
      return e = e == null ? gu : Math.pow(gu, e), new dt(this.r * e, this.g * e, this.b * e, this.opacity);
    },
    darker(e) {
      return e = e == null ? Hs : Math.pow(Hs, e), new dt(this.r * e, this.g * e, this.b * e, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new dt(Ls(this.r), Ls(this.g), Ls(this.b), _h(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: Y_,
    // Deprecated! Use color.formatHex.
    formatHex: Y_,
    formatHex8: q9,
    formatRgb: X_,
    toString: X_
  }));
  function Y_() {
    return `#${Ts(this.r)}${Ts(this.g)}${Ts(this.b)}`;
  }
  function q9() {
    return `#${Ts(this.r)}${Ts(this.g)}${Ts(this.b)}${Ts((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function X_() {
    const e = _h(this.opacity);
    return `${e === 1 ? "rgb(" : "rgba("}${Ls(this.r)}, ${Ls(this.g)}, ${Ls(this.b)}${e === 1 ? ")" : `, ${e})`}`;
  }
  function _h(e) {
    return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
  }
  function Ls(e) {
    return Math.max(0, Math.min(255, Math.round(e) || 0));
  }
  function Ts(e) {
    return e = Ls(e), (e < 16 ? "0" : "") + e.toString(16);
  }
  function K_(e, t, n, i) {
    return i <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new hi(e, t, n, i);
  }
  function mT(e) {
    if (e instanceof hi) return new hi(e.h, e.s, e.l, e.opacity);
    if (e instanceof Qo || (e = Tc(e)), !e) return new hi();
    if (e instanceof hi) return e;
    e = e.rgb();
    var t = e.r / 255, n = e.g / 255, i = e.b / 255, r = Math.min(t, n, i), o = Math.max(t, n, i), s = NaN, a = o - r, u = (o + r) / 2;
    return a ? (t === o ? s = (n - i) / a + (n < i) * 6 : n === o ? s = (i - t) / a + 2 : s = (t - n) / a + 4, a /= u < 0.5 ? o + r : 2 - o - r, s *= 60) : a = u > 0 && u < 1 ? 0 : s, new hi(s, a, u, e.opacity);
  }
  function Sh(e, t, n, i) {
    return arguments.length === 1 ? mT(e) : new hi(e, t, n, i ?? 1);
  }
  function hi(e, t, n, i) {
    this.h = +e, this.s = +t, this.l = +n, this.opacity = +i;
  }
  Zu(hi, Sh, af(Qo, {
    brighter(e) {
      return e = e == null ? gu : Math.pow(gu, e), new hi(this.h, this.s, this.l * e, this.opacity);
    },
    darker(e) {
      return e = e == null ? Hs : Math.pow(Hs, e), new hi(this.h, this.s, this.l * e, this.opacity);
    },
    rgb() {
      var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, i = n + (n < 0.5 ? n : 1 - n) * t, r = 2 * n - i;
      return new dt(
        u0(e >= 240 ? e - 240 : e + 120, r, i),
        u0(e, r, i),
        u0(e < 120 ? e + 240 : e - 120, r, i),
        this.opacity
      );
    },
    clamp() {
      return new hi(J_(this.h), nd(this.s), nd(this.l), _h(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    },
    formatHsl() {
      const e = _h(this.opacity);
      return `${e === 1 ? "hsl(" : "hsla("}${J_(this.h)}, ${nd(this.s) * 100}%, ${nd(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
    }
  }));
  function J_(e) {
    return e = (e || 0) % 360, e < 0 ? e + 360 : e;
  }
  function nd(e) {
    return Math.max(0, Math.min(1, e || 0));
  }
  function u0(e, t, n) {
    return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
  }
  const yT = Math.PI / 180, bT = 180 / Math.PI, $h = 18, vT = 0.96422, xT = 1, wT = 0.82521, ET = 4 / 29, Za = 6 / 29, _T = 3 * Za * Za, W9 = Za * Za * Za;
  function ST(e) {
    if (e instanceof Qi) return new Qi(e.l, e.a, e.b, e.opacity);
    if (e instanceof Lr) return $T(e);
    e instanceof dt || (e = nx(e));
    var t = d0(e.r), n = d0(e.g), i = d0(e.b), r = l0((0.2225045 * t + 0.7168786 * n + 0.0606169 * i) / xT), o, s;
    return t === n && n === i ? o = s = r : (o = l0((0.4360747 * t + 0.3850649 * n + 0.1430804 * i) / vT), s = l0((0.0139322 * t + 0.0971045 * n + 0.7141733 * i) / wT)), new Qi(116 * r - 16, 500 * (o - r), 200 * (r - s), e.opacity);
  }
  function kh(e, t, n, i) {
    return arguments.length === 1 ? ST(e) : new Qi(e, t, n, i ?? 1);
  }
  function Qi(e, t, n, i) {
    this.l = +e, this.a = +t, this.b = +n, this.opacity = +i;
  }
  Zu(Qi, kh, af(Qo, {
    brighter(e) {
      return new Qi(this.l + $h * (e ?? 1), this.a, this.b, this.opacity);
    },
    darker(e) {
      return new Qi(this.l - $h * (e ?? 1), this.a, this.b, this.opacity);
    },
    rgb() {
      var e = (this.l + 16) / 116, t = isNaN(this.a) ? e : e + this.a / 500, n = isNaN(this.b) ? e : e - this.b / 200;
      return t = vT * c0(t), e = xT * c0(e), n = wT * c0(n), new dt(
        f0(3.1338561 * t - 1.6168667 * e - 0.4906146 * n),
        f0(-0.9787684 * t + 1.9161415 * e + 0.033454 * n),
        f0(0.0719453 * t - 0.2289914 * e + 1.4052427 * n),
        this.opacity
      );
    }
  }));
  function l0(e) {
    return e > W9 ? Math.pow(e, 1 / 3) : e / _T + ET;
  }
  function c0(e) {
    return e > Za ? e * e * e : _T * (e - ET);
  }
  function f0(e) {
    return 255 * (e <= 31308e-7 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - 0.055);
  }
  function d0(e) {
    return (e /= 255) <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
  }
  function H9(e) {
    if (e instanceof Lr) return new Lr(e.h, e.c, e.l, e.opacity);
    if (e instanceof Qi || (e = ST(e)), e.a === 0 && e.b === 0) return new Lr(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity);
    var t = Math.atan2(e.b, e.a) * bT;
    return new Lr(t < 0 ? t + 360 : t, Math.sqrt(e.a * e.a + e.b * e.b), e.l, e.opacity);
  }
  function Ah(e, t, n, i) {
    return arguments.length === 1 ? H9(e) : new Lr(e, t, n, i ?? 1);
  }
  function Lr(e, t, n, i) {
    this.h = +e, this.c = +t, this.l = +n, this.opacity = +i;
  }
  function $T(e) {
    if (isNaN(e.h)) return new Qi(e.l, 0, 0, e.opacity);
    var t = e.h * yT;
    return new Qi(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity);
  }
  Zu(Lr, Ah, af(Qo, {
    brighter(e) {
      return new Lr(this.h, this.c, this.l + $h * (e ?? 1), this.opacity);
    },
    darker(e) {
      return new Lr(this.h, this.c, this.l - $h * (e ?? 1), this.opacity);
    },
    rgb() {
      return $T(this).rgb();
    }
  }));
  var kT = -0.14861, ix = 1.78277, rx = -0.29227, hp = -0.90649, Dc = 1.97294, Q_ = Dc * hp, Z_ = Dc * ix, eS = ix * rx - hp * kT;
  function G9(e) {
    if (e instanceof Ps) return new Ps(e.h, e.s, e.l, e.opacity);
    e instanceof dt || (e = nx(e));
    var t = e.r / 255, n = e.g / 255, i = e.b / 255, r = (eS * i + Q_ * t - Z_ * n) / (eS + Q_ - Z_), o = i - r, s = (Dc * (n - r) - rx * o) / hp, a = Math.sqrt(s * s + o * o) / (Dc * r * (1 - r)), u = a ? Math.atan2(s, o) * bT - 120 : NaN;
    return new Ps(u < 0 ? u + 360 : u, a, r, e.opacity);
  }
  function U1(e, t, n, i) {
    return arguments.length === 1 ? G9(e) : new Ps(e, t, n, i ?? 1);
  }
  function Ps(e, t, n, i) {
    this.h = +e, this.s = +t, this.l = +n, this.opacity = +i;
  }
  Zu(Ps, U1, af(Qo, {
    brighter(e) {
      return e = e == null ? gu : Math.pow(gu, e), new Ps(this.h, this.s, this.l * e, this.opacity);
    },
    darker(e) {
      return e = e == null ? Hs : Math.pow(Hs, e), new Ps(this.h, this.s, this.l * e, this.opacity);
    },
    rgb() {
      var e = isNaN(this.h) ? 0 : (this.h + 120) * yT, t = +this.l, n = isNaN(this.s) ? 0 : this.s * t * (1 - t), i = Math.cos(e), r = Math.sin(e);
      return new dt(
        255 * (t + n * (kT * i + ix * r)),
        255 * (t + n * (rx * i + hp * r)),
        255 * (t + n * (Dc * i)),
        this.opacity
      );
    }
  }));
  function AT(e, t, n, i, r) {
    var o = e * e, s = o * e;
    return ((1 - 3 * e + 3 * o - s) * t + (4 - 6 * o + 3 * s) * n + (1 + 3 * e + 3 * o - 3 * s) * i + s * r) / 6;
  }
  function CT(e) {
    var t = e.length - 1;
    return function(n) {
      var i = n <= 0 ? n = 0 : n >= 1 ? (n = 1, t - 1) : Math.floor(n * t), r = e[i], o = e[i + 1], s = i > 0 ? e[i - 1] : 2 * r - o, a = i < t - 1 ? e[i + 2] : 2 * o - r;
      return AT((n - i / t) * t, s, r, o, a);
    };
  }
  function FT(e) {
    var t = e.length;
    return function(n) {
      var i = Math.floor(((n %= 1) < 0 ? ++n : n) * t), r = e[(i + t - 1) % t], o = e[i % t], s = e[(i + 1) % t], a = e[(i + 2) % t];
      return AT((n - i / t) * t, r, o, s, a);
    };
  }
  const gp = (e) => () => e;
  function MT(e, t) {
    return function(n) {
      return e + n * t;
    };
  }
  function V9(e, t, n) {
    return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(i) {
      return Math.pow(e + i * t, n);
    };
  }
  function pp(e, t) {
    var n = t - e;
    return n ? MT(e, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : gp(isNaN(e) ? t : e);
  }
  function Y9(e) {
    return (e = +e) == 1 ? ht : function(t, n) {
      return n - t ? V9(t, n, e) : gp(isNaN(t) ? n : t);
    };
  }
  function ht(e, t) {
    var n = t - e;
    return n ? MT(e, n) : gp(isNaN(e) ? t : e);
  }
  const j1 = function e(t) {
    var n = Y9(t);
    function i(r, o) {
      var s = n((r = Io(r)).r, (o = Io(o)).r), a = n(r.g, o.g), u = n(r.b, o.b), l = ht(r.opacity, o.opacity);
      return function(c) {
        return r.r = s(c), r.g = a(c), r.b = u(c), r.opacity = l(c), r + "";
      };
    }
    return i.gamma = e, i;
  }(1);
  function TT(e) {
    return function(t) {
      var n = t.length, i = new Array(n), r = new Array(n), o = new Array(n), s, a;
      for (s = 0; s < n; ++s)
        a = Io(t[s]), i[s] = a.r || 0, r[s] = a.g || 0, o[s] = a.b || 0;
      return i = e(i), r = e(r), o = e(o), a.opacity = 1, function(u) {
        return a.r = i(u), a.g = r(u), a.b = o(u), a + "";
      };
    };
  }
  var X9 = TT(CT), K9 = TT(FT);
  function ox(e, t) {
    t || (t = []);
    var n = e ? Math.min(t.length, e.length) : 0, i = t.slice(), r;
    return function(o) {
      for (r = 0; r < n; ++r) i[r] = e[r] * (1 - o) + t[r] * o;
      return i;
    };
  }
  function DT(e) {
    return ArrayBuffer.isView(e) && !(e instanceof DataView);
  }
  function J9(e, t) {
    return (DT(t) ? ox : NT)(e, t);
  }
  function NT(e, t) {
    var n = t ? t.length : 0, i = e ? Math.min(n, e.length) : 0, r = new Array(i), o = new Array(n), s;
    for (s = 0; s < i; ++s) r[s] = Zo(e[s], t[s]);
    for (; s < n; ++s) o[s] = t[s];
    return function(a) {
      for (s = 0; s < i; ++s) o[s] = r[s](a);
      return o;
    };
  }
  function OT(e, t) {
    var n = /* @__PURE__ */ new Date();
    return e = +e, t = +t, function(i) {
      return n.setTime(e * (1 - i) + t * i), n;
    };
  }
  function fi(e, t) {
    return e = +e, t = +t, function(n) {
      return e * (1 - n) + t * n;
    };
  }
  function RT(e, t) {
    var n = {}, i = {}, r;
    (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
    for (r in t)
      r in e ? n[r] = Zo(e[r], t[r]) : i[r] = t[r];
    return function(o) {
      for (r in n) i[r] = n[r](o);
      return i;
    };
  }
  var q1 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, h0 = new RegExp(q1.source, "g");
  function Q9(e) {
    return function() {
      return e;
    };
  }
  function Z9(e) {
    return function(t) {
      return e(t) + "";
    };
  }
  function LT(e, t) {
    var n = q1.lastIndex = h0.lastIndex = 0, i, r, o, s = -1, a = [], u = [];
    for (e = e + "", t = t + ""; (i = q1.exec(e)) && (r = h0.exec(t)); )
      (o = r.index) > n && (o = t.slice(n, o), a[s] ? a[s] += o : a[++s] = o), (i = i[0]) === (r = r[0]) ? a[s] ? a[s] += r : a[++s] = r : (a[++s] = null, u.push({ i: s, x: fi(i, r) })), n = h0.lastIndex;
    return n < t.length && (o = t.slice(n), a[s] ? a[s] += o : a[++s] = o), a.length < 2 ? u[0] ? Z9(u[0].x) : Q9(t) : (t = u.length, function(l) {
      for (var c = 0, f; c < t; ++c) a[(f = u[c]).i] = f.x(l);
      return a.join("");
    });
  }
  function Zo(e, t) {
    var n = typeof t, i;
    return t == null || n === "boolean" ? gp(t) : (n === "number" ? fi : n === "string" ? (i = Tc(t)) ? (t = i, j1) : LT : t instanceof Tc ? j1 : t instanceof Date ? OT : DT(t) ? ox : Array.isArray(t) ? NT : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? RT : fi)(e, t);
  }
  function e7(e) {
    var t = e.length;
    return function(n) {
      return e[Math.max(0, Math.min(t - 1, Math.floor(n * t)))];
    };
  }
  function t7(e, t) {
    var n = pp(+e, +t);
    return function(i) {
      var r = n(i);
      return r - 360 * Math.floor(r / 360);
    };
  }
  function uf(e, t) {
    return e = +e, t = +t, function(n) {
      return Math.round(e * (1 - n) + t * n);
    };
  }
  var tS = 180 / Math.PI, W1 = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function PT(e, t, n, i, r, o) {
    var s, a, u;
    return (s = Math.sqrt(e * e + t * t)) && (e /= s, t /= s), (u = e * n + t * i) && (n -= e * u, i -= t * u), (a = Math.sqrt(n * n + i * i)) && (n /= a, i /= a, u /= a), e * i < t * n && (e = -e, t = -t, u = -u, s = -s), {
      translateX: r,
      translateY: o,
      rotate: Math.atan2(t, e) * tS,
      skewX: Math.atan(u) * tS,
      scaleX: s,
      scaleY: a
    };
  }
  var id;
  function n7(e) {
    const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
    return t.isIdentity ? W1 : PT(t.a, t.b, t.c, t.d, t.e, t.f);
  }
  function i7(e) {
    return e == null || (id || (id = document.createElementNS("http://www.w3.org/2000/svg", "g")), id.setAttribute("transform", e), !(e = id.transform.baseVal.consolidate())) ? W1 : (e = e.matrix, PT(e.a, e.b, e.c, e.d, e.e, e.f));
  }
  function IT(e, t, n, i) {
    function r(l) {
      return l.length ? l.pop() + " " : "";
    }
    function o(l, c, f, d, h, g) {
      if (l !== f || c !== d) {
        var p = h.push("translate(", null, t, null, n);
        g.push({ i: p - 4, x: fi(l, f) }, { i: p - 2, x: fi(c, d) });
      } else (f || d) && h.push("translate(" + f + t + d + n);
    }
    function s(l, c, f, d) {
      l !== c ? (l - c > 180 ? c += 360 : c - l > 180 && (l += 360), d.push({ i: f.push(r(f) + "rotate(", null, i) - 2, x: fi(l, c) })) : c && f.push(r(f) + "rotate(" + c + i);
    }
    function a(l, c, f, d) {
      l !== c ? d.push({ i: f.push(r(f) + "skewX(", null, i) - 2, x: fi(l, c) }) : c && f.push(r(f) + "skewX(" + c + i);
    }
    function u(l, c, f, d, h, g) {
      if (l !== f || c !== d) {
        var p = h.push(r(h) + "scale(", null, ",", null, ")");
        g.push({ i: p - 4, x: fi(l, f) }, { i: p - 2, x: fi(c, d) });
      } else (f !== 1 || d !== 1) && h.push(r(h) + "scale(" + f + "," + d + ")");
    }
    return function(l, c) {
      var f = [], d = [];
      return l = e(l), c = e(c), o(l.translateX, l.translateY, c.translateX, c.translateY, f, d), s(l.rotate, c.rotate, f, d), a(l.skewX, c.skewX, f, d), u(l.scaleX, l.scaleY, c.scaleX, c.scaleY, f, d), l = c = null, function(h) {
        for (var g = -1, p = d.length, m; ++g < p; ) f[(m = d[g]).i] = m.x(h);
        return f.join("");
      };
    };
  }
  var r7 = IT(n7, "px, ", "px)", "deg)"), o7 = IT(i7, ", ", ")", ")"), s7 = 1e-12;
  function nS(e) {
    return ((e = Math.exp(e)) + 1 / e) / 2;
  }
  function a7(e) {
    return ((e = Math.exp(e)) - 1 / e) / 2;
  }
  function u7(e) {
    return ((e = Math.exp(2 * e)) - 1) / (e + 1);
  }
  const l7 = function e(t, n, i) {
    function r(o, s) {
      var a = o[0], u = o[1], l = o[2], c = s[0], f = s[1], d = s[2], h = c - a, g = f - u, p = h * h + g * g, m, y;
      if (p < s7)
        y = Math.log(d / l) / t, m = function(E) {
          return [
            a + E * h,
            u + E * g,
            l * Math.exp(t * E * y)
          ];
        };
      else {
        var b = Math.sqrt(p), v = (d * d - l * l + i * p) / (2 * l * n * b), x = (d * d - l * l - i * p) / (2 * d * n * b), w = Math.log(Math.sqrt(v * v + 1) - v), _ = Math.log(Math.sqrt(x * x + 1) - x);
        y = (_ - w) / t, m = function(E) {
          var S = E * y, $ = nS(w), F = l / (n * b) * ($ * u7(t * S + w) - a7(w));
          return [
            a + F * h,
            u + F * g,
            l * $ / nS(t * S + w)
          ];
        };
      }
      return m.duration = y * 1e3 * t / Math.SQRT2, m;
    }
    return r.rho = function(o) {
      var s = Math.max(1e-3, +o), a = s * s, u = a * a;
      return e(s, a, u);
    }, r;
  }(Math.SQRT2, 2, 4);
  function zT(e) {
    return function(t, n) {
      var i = e((t = Sh(t)).h, (n = Sh(n)).h), r = ht(t.s, n.s), o = ht(t.l, n.l), s = ht(t.opacity, n.opacity);
      return function(a) {
        return t.h = i(a), t.s = r(a), t.l = o(a), t.opacity = s(a), t + "";
      };
    };
  }
  const c7 = zT(pp);
  var f7 = zT(ht);
  function d7(e, t) {
    var n = ht((e = kh(e)).l, (t = kh(t)).l), i = ht(e.a, t.a), r = ht(e.b, t.b), o = ht(e.opacity, t.opacity);
    return function(s) {
      return e.l = n(s), e.a = i(s), e.b = r(s), e.opacity = o(s), e + "";
    };
  }
  function BT(e) {
    return function(t, n) {
      var i = e((t = Ah(t)).h, (n = Ah(n)).h), r = ht(t.c, n.c), o = ht(t.l, n.l), s = ht(t.opacity, n.opacity);
      return function(a) {
        return t.h = i(a), t.c = r(a), t.l = o(a), t.opacity = s(a), t + "";
      };
    };
  }
  const h7 = BT(pp);
  var g7 = BT(ht);
  function UT(e) {
    return function t(n) {
      n = +n;
      function i(r, o) {
        var s = e((r = U1(r)).h, (o = U1(o)).h), a = ht(r.s, o.s), u = ht(r.l, o.l), l = ht(r.opacity, o.opacity);
        return function(c) {
          return r.h = s(c), r.s = a(c), r.l = u(Math.pow(c, n)), r.opacity = l(c), r + "";
        };
      }
      return i.gamma = t, i;
    }(1);
  }
  const p7 = UT(pp);
  var m7 = UT(ht);
  function sx(e, t) {
    t === void 0 && (t = e, e = Zo);
    for (var n = 0, i = t.length - 1, r = t[0], o = new Array(i < 0 ? 0 : i); n < i; ) o[n] = e(r, r = t[++n]);
    return function(s) {
      var a = Math.max(0, Math.min(i - 1, Math.floor(s *= i)));
      return o[a](s - a);
    };
  }
  function y7(e, t) {
    for (var n = new Array(t), i = 0; i < t; ++i) n[i] = e(i / (t - 1));
    return n;
  }
  const b7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    interpolate: Zo,
    interpolateArray: J9,
    interpolateBasis: CT,
    interpolateBasisClosed: FT,
    interpolateCubehelix: p7,
    interpolateCubehelixLong: m7,
    interpolateDate: OT,
    interpolateDiscrete: e7,
    interpolateHcl: h7,
    interpolateHclLong: g7,
    interpolateHsl: c7,
    interpolateHslLong: f7,
    interpolateHue: t7,
    interpolateLab: d7,
    interpolateNumber: fi,
    interpolateNumberArray: ox,
    interpolateObject: RT,
    interpolateRgb: j1,
    interpolateRgbBasis: X9,
    interpolateRgbBasisClosed: K9,
    interpolateRound: uf,
    interpolateString: LT,
    interpolateTransformCss: r7,
    interpolateTransformSvg: o7,
    interpolateZoom: l7,
    piecewise: sx,
    quantize: y7
  }, Symbol.toStringTag, { value: "Module" }));
  function v7(e) {
    return function() {
      return e;
    };
  }
  function H1(e) {
    return +e;
  }
  var iS = [0, 1];
  function pn(e) {
    return e;
  }
  function G1(e, t) {
    return (t -= e = +e) ? function(n) {
      return (n - e) / t;
    } : v7(isNaN(t) ? NaN : 0.5);
  }
  function x7(e, t) {
    var n;
    return e > t && (n = e, e = t, t = n), function(i) {
      return Math.max(e, Math.min(t, i));
    };
  }
  function w7(e, t, n) {
    var i = e[0], r = e[1], o = t[0], s = t[1];
    return r < i ? (i = G1(r, i), o = n(s, o)) : (i = G1(i, r), o = n(o, s)), function(a) {
      return o(i(a));
    };
  }
  function E7(e, t, n) {
    var i = Math.min(e.length, t.length) - 1, r = new Array(i), o = new Array(i), s = -1;
    for (e[i] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++s < i; )
      r[s] = G1(e[s], e[s + 1]), o[s] = n(t[s], t[s + 1]);
    return function(a) {
      var u = Oo(e, a, 1, i) - 1;
      return o[u](r[u](a));
    };
  }
  function lf(e, t) {
    return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
  }
  function mp() {
    var e = iS, t = iS, n = Zo, i, r, o, s = pn, a, u, l;
    function c() {
      var d = Math.min(e.length, t.length);
      return s !== pn && (s = x7(e[0], e[d - 1])), a = d > 2 ? E7 : w7, u = l = null, f;
    }
    function f(d) {
      return d == null || isNaN(d = +d) ? o : (u || (u = a(e.map(i), t, n)))(i(s(d)));
    }
    return f.invert = function(d) {
      return s(r((l || (l = a(t, e.map(i), fi)))(d)));
    }, f.domain = function(d) {
      return arguments.length ? (e = Array.from(d, H1), c()) : e.slice();
    }, f.range = function(d) {
      return arguments.length ? (t = Array.from(d), c()) : t.slice();
    }, f.rangeRound = function(d) {
      return t = Array.from(d), n = uf, c();
    }, f.clamp = function(d) {
      return arguments.length ? (s = d ? !0 : pn, c()) : s !== pn;
    }, f.interpolate = function(d) {
      return arguments.length ? (n = d, c()) : n;
    }, f.unknown = function(d) {
      return arguments.length ? (o = d, f) : o;
    }, function(d, h) {
      return i = d, r = h, c();
    };
  }
  function jT() {
    return mp()(pn, pn);
  }
  function qT(e, t, n, i) {
    var r = Ro(e, t, n), o;
    switch (i = Ws(i ?? ",f"), i.type) {
      case "s": {
        var s = Math.max(Math.abs(e), Math.abs(t));
        return i.precision == null && !isNaN(o = pF(r, s)) && (i.precision = o), Vb(i, s);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        i.precision == null && !isNaN(o = mF(r, Math.max(Math.abs(e), Math.abs(t)))) && (i.precision = o - (i.type === "e"));
        break;
      }
      case "f":
      case "%": {
        i.precision == null && !isNaN(o = gF(r)) && (i.precision = o - (i.type === "%") * 2);
        break;
      }
    }
    return Hg(i);
  }
  function pa(e) {
    var t = e.domain;
    return e.ticks = function(n) {
      var i = t();
      return S1(i[0], i[i.length - 1], n ?? 10);
    }, e.tickFormat = function(n, i) {
      var r = t();
      return qT(r[0], r[r.length - 1], n ?? 10, i);
    }, e.nice = function(n) {
      n == null && (n = 10);
      var i = t(), r = 0, o = i.length - 1, s = i[r], a = i[o], u, l, c = 10;
      for (a < s && (l = s, s = a, a = l, l = r, r = o, o = l); c-- > 0; ) {
        if (l = $1(s, a, n), l === u)
          return i[r] = s, i[o] = a, t(i);
        if (l > 0)
          s = Math.floor(s / l) * l, a = Math.ceil(a / l) * l;
        else if (l < 0)
          s = Math.ceil(s * l) / l, a = Math.floor(a * l) / l;
        else
          break;
        u = l;
      }
      return e;
    }, e;
  }
  function WT() {
    var e = jT();
    return e.copy = function() {
      return lf(e, WT());
    }, dr.apply(e, arguments), pa(e);
  }
  function HT(e) {
    var t;
    function n(i) {
      return i == null || isNaN(i = +i) ? t : i;
    }
    return n.invert = n, n.domain = n.range = function(i) {
      return arguments.length ? (e = Array.from(i, H1), n) : e.slice();
    }, n.unknown = function(i) {
      return arguments.length ? (t = i, n) : t;
    }, n.copy = function() {
      return HT(e).unknown(t);
    }, e = arguments.length ? Array.from(e, H1) : [0, 1], pa(n);
  }
  function GT(e, t) {
    e = e.slice();
    var n = 0, i = e.length - 1, r = e[n], o = e[i], s;
    return o < r && (s = n, n = i, i = s, s = r, r = o, o = s), e[n] = t.floor(r), e[i] = t.ceil(o), e;
  }
  function rS(e) {
    return Math.log(e);
  }
  function oS(e) {
    return Math.exp(e);
  }
  function _7(e) {
    return -Math.log(-e);
  }
  function S7(e) {
    return -Math.exp(-e);
  }
  function $7(e) {
    return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
  }
  function k7(e) {
    return e === 10 ? $7 : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
  }
  function A7(e) {
    return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
  }
  function sS(e) {
    return (t, n) => -e(-t, n);
  }
  function ax(e) {
    const t = e(rS, oS), n = t.domain;
    let i = 10, r, o;
    function s() {
      return r = A7(i), o = k7(i), n()[0] < 0 ? (r = sS(r), o = sS(o), e(_7, S7)) : e(rS, oS), t;
    }
    return t.base = function(a) {
      return arguments.length ? (i = +a, s()) : i;
    }, t.domain = function(a) {
      return arguments.length ? (n(a), s()) : n();
    }, t.ticks = (a) => {
      const u = n();
      let l = u[0], c = u[u.length - 1];
      const f = c < l;
      f && ([l, c] = [c, l]);
      let d = r(l), h = r(c), g, p;
      const m = a == null ? 10 : +a;
      let y = [];
      if (!(i % 1) && h - d < m) {
        if (d = Math.floor(d), h = Math.ceil(h), l > 0) {
          for (; d <= h; ++d)
            for (g = 1; g < i; ++g)
              if (p = d < 0 ? g / o(-d) : g * o(d), !(p < l)) {
                if (p > c) break;
                y.push(p);
              }
        } else for (; d <= h; ++d)
          for (g = i - 1; g >= 1; --g)
            if (p = d > 0 ? g / o(-d) : g * o(d), !(p < l)) {
              if (p > c) break;
              y.push(p);
            }
        y.length * 2 < m && (y = S1(l, c, m));
      } else
        y = S1(d, h, Math.min(h - d, m)).map(o);
      return f ? y.reverse() : y;
    }, t.tickFormat = (a, u) => {
      if (a == null && (a = 10), u == null && (u = i === 10 ? "s" : ","), typeof u != "function" && (!(i % 1) && (u = Ws(u)).precision == null && (u.trim = !0), u = Hg(u)), a === 1 / 0) return u;
      const l = Math.max(1, i * a / t.ticks().length);
      return (c) => {
        let f = c / o(Math.round(r(c)));
        return f * i < i - 0.5 && (f *= i), f <= l ? u(c) : "";
      };
    }, t.nice = () => n(GT(n(), {
      floor: (a) => o(Math.floor(r(a))),
      ceil: (a) => o(Math.ceil(r(a)))
    })), t;
  }
  function VT() {
    const e = ax(mp()).domain([1, 10]);
    return e.copy = () => lf(e, VT()).base(e.base()), dr.apply(e, arguments), e;
  }
  function aS(e) {
    return function(t) {
      return Math.sign(t) * Math.log1p(Math.abs(t / e));
    };
  }
  function uS(e) {
    return function(t) {
      return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
    };
  }
  function ux(e) {
    var t = 1, n = e(aS(t), uS(t));
    return n.constant = function(i) {
      return arguments.length ? e(aS(t = +i), uS(t)) : t;
    }, pa(n);
  }
  function YT() {
    var e = ux(mp());
    return e.copy = function() {
      return lf(e, YT()).constant(e.constant());
    }, dr.apply(e, arguments);
  }
  function lS(e) {
    return function(t) {
      return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
    };
  }
  function C7(e) {
    return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
  }
  function F7(e) {
    return e < 0 ? -e * e : e * e;
  }
  function lx(e) {
    var t = e(pn, pn), n = 1;
    function i() {
      return n === 1 ? e(pn, pn) : n === 0.5 ? e(C7, F7) : e(lS(n), lS(1 / n));
    }
    return t.exponent = function(r) {
      return arguments.length ? (n = +r, i()) : n;
    }, pa(t);
  }
  function cx() {
    var e = lx(mp());
    return e.copy = function() {
      return lf(e, cx()).exponent(e.exponent());
    }, dr.apply(e, arguments), e;
  }
  function M7() {
    return cx.apply(null, arguments).exponent(0.5);
  }
  function XT() {
    var e = [], t = [], n = [], i;
    function r() {
      var s = 0, a = Math.max(1, t.length);
      for (n = new Array(a - 1); ++s < a; ) n[s - 1] = uF(e, s / a);
      return o;
    }
    function o(s) {
      return s == null || isNaN(s = +s) ? i : t[Oo(n, s)];
    }
    return o.invertExtent = function(s) {
      var a = t.indexOf(s);
      return a < 0 ? [NaN, NaN] : [
        a > 0 ? n[a - 1] : e[0],
        a < n.length ? n[a] : e[e.length - 1]
      ];
    }, o.domain = function(s) {
      if (!arguments.length) return e.slice();
      e = [];
      for (let a of s) a != null && !isNaN(a = +a) && e.push(a);
      return e.sort(zr), r();
    }, o.range = function(s) {
      return arguments.length ? (t = Array.from(s), r()) : t.slice();
    }, o.unknown = function(s) {
      return arguments.length ? (i = s, o) : i;
    }, o.quantiles = function() {
      return n.slice();
    }, o.copy = function() {
      return XT().domain(e).range(t).unknown(i);
    }, dr.apply(o, arguments);
  }
  function KT() {
    var e = 0, t = 1, n = 1, i = [0.5], r = [0, 1], o;
    function s(u) {
      return u != null && u <= u ? r[Oo(i, u, 0, n)] : o;
    }
    function a() {
      var u = -1;
      for (i = new Array(n); ++u < n; ) i[u] = ((u + 1) * t - (u - n) * e) / (n + 1);
      return s;
    }
    return s.domain = function(u) {
      return arguments.length ? ([e, t] = u, e = +e, t = +t, a()) : [e, t];
    }, s.range = function(u) {
      return arguments.length ? (n = (r = Array.from(u)).length - 1, a()) : r.slice();
    }, s.invertExtent = function(u) {
      var l = r.indexOf(u);
      return l < 0 ? [NaN, NaN] : l < 1 ? [e, i[0]] : l >= n ? [i[n - 1], t] : [i[l - 1], i[l]];
    }, s.unknown = function(u) {
      return arguments.length && (o = u), s;
    }, s.thresholds = function() {
      return i.slice();
    }, s.copy = function() {
      return KT().domain([e, t]).range(r).unknown(o);
    }, dr.apply(pa(s), arguments);
  }
  function JT() {
    var e = [0.5], t = [0, 1], n, i = 1;
    function r(o) {
      return o != null && o <= o ? t[Oo(e, o, 0, i)] : n;
    }
    return r.domain = function(o) {
      return arguments.length ? (e = Array.from(o), i = Math.min(e.length, t.length - 1), r) : e.slice();
    }, r.range = function(o) {
      return arguments.length ? (t = Array.from(o), i = Math.min(e.length, t.length - 1), r) : t.slice();
    }, r.invertExtent = function(o) {
      var s = t.indexOf(o);
      return [e[s - 1], e[s]];
    }, r.unknown = function(o) {
      return arguments.length ? (n = o, r) : n;
    }, r.copy = function() {
      return JT().domain(e).range(t).unknown(n);
    }, dr.apply(r, arguments);
  }
  function T7(e) {
    return new Date(e);
  }
  function D7(e) {
    return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
  }
  function fx(e, t, n, i, r, o, s, a, u, l) {
    var c = jT(), f = c.invert, d = c.domain, h = l(".%L"), g = l(":%S"), p = l("%I:%M"), m = l("%I %p"), y = l("%a %d"), b = l("%b %d"), v = l("%B"), x = l("%Y");
    function w(_) {
      return (u(_) < _ ? h : a(_) < _ ? g : s(_) < _ ? p : o(_) < _ ? m : i(_) < _ ? r(_) < _ ? y : b : n(_) < _ ? v : x)(_);
    }
    return c.invert = function(_) {
      return new Date(f(_));
    }, c.domain = function(_) {
      return arguments.length ? d(Array.from(_, D7)) : d().map(T7);
    }, c.ticks = function(_) {
      var E = d();
      return e(E[0], E[E.length - 1], _ ?? 10);
    }, c.tickFormat = function(_, E) {
      return E == null ? w : l(E);
    }, c.nice = function(_) {
      var E = d();
      return (!_ || typeof _.range != "function") && (_ = t(E[0], E[E.length - 1], _ ?? 10)), _ ? d(GT(E, _)) : c;
    }, c.copy = function() {
      return lf(c, fx(e, t, n, i, r, o, s, a, u, l));
    }, c;
  }
  function N7() {
    return dr.apply(fx(zP, BP, ir, $c, Yu, Br, Yg, Gg, Rr, Qb).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
  }
  function O7() {
    return dr.apply(fx(PP, IP, rr, kc, Xu, Fo, Xg, Vg, Rr, Zb).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
  }
  function yp() {
    var e = 0, t = 1, n, i, r, o, s = pn, a = !1, u;
    function l(f) {
      return f == null || isNaN(f = +f) ? u : s(r === 0 ? 0.5 : (f = (o(f) - n) * r, a ? Math.max(0, Math.min(1, f)) : f));
    }
    l.domain = function(f) {
      return arguments.length ? ([e, t] = f, n = o(e = +e), i = o(t = +t), r = n === i ? 0 : 1 / (i - n), l) : [e, t];
    }, l.clamp = function(f) {
      return arguments.length ? (a = !!f, l) : a;
    }, l.interpolator = function(f) {
      return arguments.length ? (s = f, l) : s;
    };
    function c(f) {
      return function(d) {
        var h, g;
        return arguments.length ? ([h, g] = d, s = f(h, g), l) : [s(0), s(1)];
      };
    }
    return l.range = c(Zo), l.rangeRound = c(uf), l.unknown = function(f) {
      return arguments.length ? (u = f, l) : u;
    }, function(f) {
      return o = f, n = f(e), i = f(t), r = n === i ? 0 : 1 / (i - n), l;
    };
  }
  function es(e, t) {
    return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
  }
  function dx() {
    var e = pa(yp()(pn));
    return e.copy = function() {
      return es(e, dx());
    }, Jo.apply(e, arguments);
  }
  function QT() {
    var e = ax(yp()).domain([1, 10]);
    return e.copy = function() {
      return es(e, QT()).base(e.base());
    }, Jo.apply(e, arguments);
  }
  function ZT() {
    var e = ux(yp());
    return e.copy = function() {
      return es(e, ZT()).constant(e.constant());
    }, Jo.apply(e, arguments);
  }
  function hx() {
    var e = lx(yp());
    return e.copy = function() {
      return es(e, hx()).exponent(e.exponent());
    }, Jo.apply(e, arguments);
  }
  function R7() {
    return hx.apply(null, arguments).exponent(0.5);
  }
  function bp() {
    var e = 0, t = 0.5, n = 1, i = 1, r, o, s, a, u, l = pn, c, f = !1, d;
    function h(p) {
      return isNaN(p = +p) ? d : (p = 0.5 + ((p = +c(p)) - o) * (i * p < i * o ? a : u), l(f ? Math.max(0, Math.min(1, p)) : p));
    }
    h.domain = function(p) {
      return arguments.length ? ([e, t, n] = p, r = c(e = +e), o = c(t = +t), s = c(n = +n), a = r === o ? 0 : 0.5 / (o - r), u = o === s ? 0 : 0.5 / (s - o), i = o < r ? -1 : 1, h) : [e, t, n];
    }, h.clamp = function(p) {
      return arguments.length ? (f = !!p, h) : f;
    }, h.interpolator = function(p) {
      return arguments.length ? (l = p, h) : l;
    };
    function g(p) {
      return function(m) {
        var y, b, v;
        return arguments.length ? ([y, b, v] = m, l = sx(p, [y, b, v]), h) : [l(0), l(0.5), l(1)];
      };
    }
    return h.range = g(Zo), h.rangeRound = g(uf), h.unknown = function(p) {
      return arguments.length ? (d = p, h) : d;
    }, function(p) {
      return c = p, r = p(e), o = p(t), s = p(n), a = r === o ? 0 : 0.5 / (o - r), u = o === s ? 0 : 0.5 / (s - o), i = o < r ? -1 : 1, h;
    };
  }
  function e3() {
    var e = pa(bp()(pn));
    return e.copy = function() {
      return es(e, e3());
    }, Jo.apply(e, arguments);
  }
  function t3() {
    var e = ax(bp()).domain([0.1, 1, 10]);
    return e.copy = function() {
      return es(e, t3()).base(e.base());
    }, Jo.apply(e, arguments);
  }
  function n3() {
    var e = ux(bp());
    return e.copy = function() {
      return es(e, n3()).constant(e.constant());
    }, Jo.apply(e, arguments);
  }
  function gx() {
    var e = lx(bp());
    return e.copy = function() {
      return es(e, gx()).exponent(e.exponent());
    }, Jo.apply(e, arguments);
  }
  function L7() {
    return gx.apply(null, arguments).exponent(0.5);
  }
  function hr(e) {
    for (var t = e.length / 6 | 0, n = new Array(t), i = 0; i < t; ) n[i] = "#" + e.slice(i * 6, ++i * 6);
    return n;
  }
  const P7 = hr("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"), I7 = hr("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"), z7 = hr("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"), B7 = hr("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0"), U7 = hr("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"), j7 = hr("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"), q7 = hr("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"), W7 = hr("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"), H7 = hr("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"), G7 = hr("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
  function px(e, t, n) {
    const i = e - t + n * 2;
    return e ? i > 0 ? i : 1 : 0;
  }
  const V7 = "identity", pu = "linear", Yr = "log", cf = "pow", ff = "sqrt", vp = "symlog", Gs = "time", Vs = "utc", Zi = "sequential", el = "diverging", mu = "quantile", xp = "quantize", wp = "threshold", mx = "ordinal", V1 = "point", i3 = "band", yx = "bin-ordinal", lt = "continuous", df = "discrete", hf = "discretizing", ii = "interpolating", bx = "temporal";
  function Y7(e) {
    return function(t) {
      let n = t[0], i = t[1], r;
      return i < n && (r = n, n = i, i = r), [e.invert(n), e.invert(i)];
    };
  }
  function X7(e) {
    return function(t) {
      const n = e.range();
      let i = t[0], r = t[1], o = -1, s, a, u, l;
      for (r < i && (a = i, i = r, r = a), u = 0, l = n.length; u < l; ++u)
        n[u] >= i && n[u] <= r && (o < 0 && (o = u), s = u);
      if (!(o < 0))
        return i = e.invertExtent(n[o]), r = e.invertExtent(n[s]), [i[0] === void 0 ? i[1] : i[0], r[1] === void 0 ? r[0] : r[1]];
    };
  }
  function vx() {
    const e = tx().unknown(void 0), t = e.domain, n = e.range;
    let i = [0, 1], r, o, s = !1, a = 0, u = 0, l = 0.5;
    delete e.unknown;
    function c() {
      const f = t().length, d = i[1] < i[0], h = i[1 - d], g = px(f, a, u);
      let p = i[d - 0];
      r = (h - p) / (g || 1), s && (r = Math.floor(r)), p += (h - p - r * (f - a)) * l, o = r * (1 - a), s && (p = Math.round(p), o = Math.round(o));
      const m = Tn(f).map((y) => p + r * y);
      return n(d ? m.reverse() : m);
    }
    return e.domain = function(f) {
      return arguments.length ? (t(f), c()) : t();
    }, e.range = function(f) {
      return arguments.length ? (i = [+f[0], +f[1]], c()) : i.slice();
    }, e.rangeRound = function(f) {
      return i = [+f[0], +f[1]], s = !0, c();
    }, e.bandwidth = function() {
      return o;
    }, e.step = function() {
      return r;
    }, e.round = function(f) {
      return arguments.length ? (s = !!f, c()) : s;
    }, e.padding = function(f) {
      return arguments.length ? (u = Math.max(0, Math.min(1, f)), a = u, c()) : a;
    }, e.paddingInner = function(f) {
      return arguments.length ? (a = Math.max(0, Math.min(1, f)), c()) : a;
    }, e.paddingOuter = function(f) {
      return arguments.length ? (u = Math.max(0, Math.min(1, f)), c()) : u;
    }, e.align = function(f) {
      return arguments.length ? (l = Math.max(0, Math.min(1, f)), c()) : l;
    }, e.invertRange = function(f) {
      if (f[0] == null || f[1] == null) return;
      const d = i[1] < i[0], h = d ? n().reverse() : n(), g = h.length - 1;
      let p = +f[0], m = +f[1], y, b, v;
      if (!(p !== p || m !== m) && (m < p && (v = p, p = m, m = v), !(m < h[0] || p > i[1 - d])))
        return y = Math.max(0, Oo(h, p) - 1), b = p === m ? y : Oo(h, m) - 1, p - h[y] > o + 1e-10 && ++y, d && (v = y, y = g - b, b = g - v), y > b ? void 0 : t().slice(y, b + 1);
    }, e.invert = function(f) {
      const d = e.invertRange([f, f]);
      return d && d[0];
    }, e.copy = function() {
      return vx().domain(t()).range(i).round(s).paddingInner(a).paddingOuter(u).align(l);
    }, c();
  }
  function r3(e) {
    const t = e.copy;
    return e.padding = e.paddingOuter, delete e.paddingInner, e.copy = function() {
      return r3(t());
    }, e;
  }
  function K7() {
    return r3(vx().paddingInner(1));
  }
  var J7 = Array.prototype.map;
  function Q7(e) {
    return J7.call(e, zt);
  }
  const Z7 = Array.prototype.slice;
  function o3() {
    let e = [], t = [];
    function n(i) {
      return i == null || i !== i ? void 0 : t[(Oo(e, i) - 1) % t.length];
    }
    return n.domain = function(i) {
      return arguments.length ? (e = Q7(i), n) : e.slice();
    }, n.range = function(i) {
      return arguments.length ? (t = Z7.call(i), n) : t.slice();
    }, n.tickFormat = function(i, r) {
      return qT(e[0], xe(e), i ?? 10, r);
    }, n.copy = function() {
      return o3().domain(n.domain()).range(n.range());
    }, n;
  }
  const Ch = /* @__PURE__ */ new Map(), s3 = Symbol("vega_scale");
  function a3(e) {
    return e[s3] = !0, e;
  }
  function eB(e) {
    return e && e[s3] === !0;
  }
  function tB(e, t, n) {
    const i = function() {
      const o = t();
      return o.invertRange || (o.invertRange = o.invert ? Y7(o) : o.invertExtent ? X7(o) : void 0), o.type = e, a3(o);
    };
    return i.metadata = wi(X(n)), i;
  }
  function Ae(e, t, n) {
    return arguments.length > 1 ? (Ch.set(e, tB(e, t, n)), this) : u3(e) ? Ch.get(e) : void 0;
  }
  Ae(V7, HT);
  Ae(pu, WT, lt);
  Ae(Yr, VT, [lt, Yr]);
  Ae(cf, cx, lt);
  Ae(ff, M7, lt);
  Ae(vp, YT, lt);
  Ae(Gs, N7, [lt, bx]);
  Ae(Vs, O7, [lt, bx]);
  Ae(Zi, dx, [lt, ii]);
  Ae(`${Zi}-${pu}`, dx, [lt, ii]);
  Ae(`${Zi}-${Yr}`, QT, [lt, ii, Yr]);
  Ae(`${Zi}-${cf}`, hx, [lt, ii]);
  Ae(`${Zi}-${ff}`, R7, [lt, ii]);
  Ae(`${Zi}-${vp}`, ZT, [lt, ii]);
  Ae(`${el}-${pu}`, e3, [lt, ii]);
  Ae(`${el}-${Yr}`, t3, [lt, ii, Yr]);
  Ae(`${el}-${cf}`, gx, [lt, ii]);
  Ae(`${el}-${ff}`, L7, [lt, ii]);
  Ae(`${el}-${vp}`, n3, [lt, ii]);
  Ae(mu, XT, [hf, mu]);
  Ae(xp, KT, hf);
  Ae(wp, JT, hf);
  Ae(yx, o3, [df, hf]);
  Ae(mx, tx, df);
  Ae(i3, vx, df);
  Ae(V1, K7, df);
  function u3(e) {
    return Ch.has(e);
  }
  function ma(e, t) {
    const n = Ch.get(e);
    return n && n.metadata[t];
  }
  function xx(e) {
    return ma(e, lt);
  }
  function yu(e) {
    return ma(e, df);
  }
  function Y1(e) {
    return ma(e, hf);
  }
  function l3(e) {
    return ma(e, Yr);
  }
  function nB(e) {
    return ma(e, bx);
  }
  function c3(e) {
    return ma(e, ii);
  }
  function f3(e) {
    return ma(e, mu);
  }
  const iB = ["clamp", "base", "constant", "exponent"];
  function d3(e, t) {
    const n = t[0], i = xe(t) - n;
    return function(r) {
      return e(n + r * i);
    };
  }
  function Ep(e, t, n) {
    return sx(wx(t || "rgb", n), e);
  }
  function h3(e, t) {
    const n = new Array(t), i = t + 1;
    for (let r = 0; r < t; ) n[r] = e(++r / i);
    return n;
  }
  function g3(e, t, n) {
    const i = n - t;
    let r, o, s;
    return !i || !Number.isFinite(i) ? Gt(0.5) : (r = (o = e.type).indexOf("-"), o = r < 0 ? o : o.slice(r + 1), s = Ae(o)().domain([t, n]).range([0, 1]), iB.forEach((a) => e[a] ? s[a](e[a]()) : 0), s);
  }
  function wx(e, t) {
    const n = b7[rB(e)];
    return t != null && n && n.gamma ? n.gamma(t) : n;
  }
  function rB(e) {
    return "interpolate" + e.toLowerCase().split("-").map((t) => t[0].toUpperCase() + t.slice(1)).join("");
  }
  const oB = {
    blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
    greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
    greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
    oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
    purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
    reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
    blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
    bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
    greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
    orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
    purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
    purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
    purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
    redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
    yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
    yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
    yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
    blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
    brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
    purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
    purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
    redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
    redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
    yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
    redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
    redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
    pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
    spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
    viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
    magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
    inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
    plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
    cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
    rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
    sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
    turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
    browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
    tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
    teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
    warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
    goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
    goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
    goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
    lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
    lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
    lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
    lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
    lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
    darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
    darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
    darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
    darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
    darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
  }, sB = {
    accent: I7,
    category10: P7,
    category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
    category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
    category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
    dark2: z7,
    observable10: B7,
    paired: U7,
    pastel1: j7,
    pastel2: q7,
    set1: W7,
    set2: H7,
    set3: G7,
    tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
    tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5"
  };
  function p3(e) {
    if (P(e)) return e;
    const t = e.length / 6 | 0, n = new Array(t);
    for (let i = 0; i < t; )
      n[i] = "#" + e.slice(i * 6, ++i * 6);
    return n;
  }
  function m3(e, t) {
    for (const n in e) Ex(n, t(e[n]));
  }
  const cS = {};
  m3(sB, p3);
  m3(oB, (e) => Ep(p3(e)));
  function Ex(e, t) {
    return e = e && e.toLowerCase(), arguments.length > 1 ? (cS[e] = t, this) : cS[e];
  }
  const Bd = "symbol", aB = "discrete", uB = "gradient", lB = (e) => P(e) ? e.map((t) => String(t)) : String(e), cB = (e, t) => e[1] - t[1], fB = (e, t) => t[1] - e[1];
  function _x(e, t, n) {
    let i;
    return $e(t) && (e.bins && (t = Math.max(t, e.bins.length)), n != null && (t = Math.min(t, Math.floor(nf(e.domain()) / n || 1) + 1))), Y(t) && (i = t.step, t = t.interval), K(t) && (t = e.type === Gs ? Ku(t) : e.type == Vs ? Ju(t) : R("Only time and utc scales accept interval strings."), i && (t = t.every(i))), t;
  }
  function y3(e, t, n) {
    let i = e.range(), r = i[0], o = xe(i), s = cB;
    if (r > o && (i = o, o = r, r = i, s = fB), r = Math.floor(r), o = Math.ceil(o), t = t.map((a) => [a, e(a)]).filter((a) => r <= a[1] && a[1] <= o).sort(s).map((a) => a[0]), n > 0 && t.length > 1) {
      const a = [t[0], xe(t)];
      for (; t.length > n && t.length >= 3; )
        t = t.filter((u, l) => !(l % 2));
      t.length < 3 && (t = a);
    }
    return t;
  }
  function Sx(e, t) {
    return e.bins ? y3(e, e.bins, t) : e.ticks ? e.ticks(t) : e.domain();
  }
  function b3(e, t, n, i, r, o) {
    const s = t.type;
    let a = lB;
    if (s === Gs || r === Gs)
      a = e.timeFormat(i);
    else if (s === Vs || r === Vs)
      a = e.utcFormat(i);
    else if (l3(s)) {
      const u = e.formatFloat(i);
      if (o || t.bins)
        a = u;
      else {
        const l = v3(t, n, !1);
        a = (c) => l(c) ? u(c) : "";
      }
    } else if (t.tickFormat) {
      const u = t.domain();
      a = e.formatSpan(u[0], u[u.length - 1], n, i);
    } else i && (a = e.format(i));
    return a;
  }
  function v3(e, t, n) {
    const i = Sx(e, t), r = e.base(), o = Math.log(r), s = Math.max(1, r * t / i.length), a = (u) => {
      let l = u / Math.pow(r, Math.round(Math.log(u) / o));
      return l * r < r - 0.5 && (l *= r), l <= s;
    };
    return n ? i.filter(a) : a;
  }
  const X1 = {
    [mu]: "quantiles",
    [xp]: "thresholds",
    [wp]: "domain"
  }, x3 = {
    [mu]: "quantiles",
    [xp]: "domain"
  };
  function w3(e, t) {
    return e.bins ? gB(e.bins) : e.type === Yr ? v3(e, t, !0) : X1[e.type] ? hB(e[X1[e.type]]()) : Sx(e, t);
  }
  function dB(e, t, n) {
    const i = t[x3[t.type]](), r = i.length;
    let o = r > 1 ? i[1] - i[0] : i[0], s;
    for (s = 1; s < r; ++s)
      o = Math.min(o, i[s] - i[s - 1]);
    return e.formatSpan(0, o, 3 * 10, n);
  }
  function hB(e) {
    const t = [-1 / 0].concat(e);
    return t.max = 1 / 0, t;
  }
  function gB(e) {
    const t = e.slice(0, -1);
    return t.max = xe(e), t;
  }
  const pB = (e) => X1[e.type] || e.bins;
  function E3(e, t, n, i, r, o, s) {
    const a = x3[t.type] && o !== Gs && o !== Vs ? dB(e, t, r) : b3(e, t, n, r, o, s);
    return i === Bd && pB(t) ? mB(a) : i === aB ? yB(a) : bB(a);
  }
  const mB = (e) => (t, n, i) => {
    const r = fS(i[n + 1], fS(i.max, 1 / 0)), o = dS(t, e), s = dS(r, e);
    return o && s ? o + " – " + s : s ? "< " + s : "≥ " + o;
  }, fS = (e, t) => e ?? t, yB = (e) => (t, n) => n ? e(t) : null, bB = (e) => (t) => e(t), dS = (e, t) => Number.isFinite(e) ? t(e) : null;
  function vB(e) {
    const t = e.domain(), n = t.length - 1;
    let i = +t[0], r = +xe(t), o = r - i;
    if (e.type === wp) {
      const s = n ? o / n : 0.1;
      i -= s, r += s, o = r - i;
    }
    return (s) => (s - i) / o;
  }
  function xB(e, t, n, i) {
    const r = i || t.type;
    return K(n) && nB(r) && (n = n.replace(/%a/g, "%A").replace(/%b/g, "%B")), !n && r === Gs ? e.timeFormat("%A, %d %B %Y, %X") : !n && r === Vs ? e.utcFormat("%A, %d %B %Y, %X UTC") : E3(e, t, 5, null, n, i, !0);
  }
  function _3(e, t, n) {
    n = n || {};
    const i = Math.max(3, n.maxlen || 7), r = xB(e, t, n.format, n.formatType);
    if (Y1(t.type)) {
      const o = w3(t).slice(1).map(r), s = o.length;
      return `${s} boundar${s === 1 ? "y" : "ies"}: ${o.join(", ")}`;
    } else if (yu(t.type)) {
      const o = t.domain(), s = o.length, a = s > i ? o.slice(0, i - 2).map(r).join(", ") + ", ending with " + o.slice(-1).map(r) : o.map(r).join(", ");
      return `${s} value${s === 1 ? "" : "s"}: ${a}`;
    } else {
      const o = t.domain();
      return `values from ${r(o[0])} to ${r(xe(o))}`;
    }
  }
  let S3 = 0;
  function wB() {
    S3 = 0;
  }
  const Fh = "p_";
  function $x(e) {
    return e && e.gradient;
  }
  function $3(e, t, n) {
    const i = e.gradient;
    let r = e.id, o = i === "radial" ? Fh : "";
    return r || (r = e.id = "gradient_" + S3++, i === "radial" ? (e.x1 = zi(e.x1, 0.5), e.y1 = zi(e.y1, 0.5), e.r1 = zi(e.r1, 0), e.x2 = zi(e.x2, 0.5), e.y2 = zi(e.y2, 0.5), e.r2 = zi(e.r2, 0.5), o = Fh) : (e.x1 = zi(e.x1, 0), e.y1 = zi(e.y1, 0), e.x2 = zi(e.x2, 1), e.y2 = zi(e.y2, 0))), t[r] = e, "url(" + (n || "") + "#" + o + r + ")";
  }
  function zi(e, t) {
    return e ?? t;
  }
  function k3(e, t) {
    var n = [], i;
    return i = {
      gradient: "linear",
      x1: e ? e[0] : 0,
      y1: e ? e[1] : 0,
      x2: t ? t[0] : 1,
      y2: t ? t[1] : 0,
      stops: n,
      stop: function(r, o) {
        return n.push({
          offset: r,
          color: o
        }), i;
      }
    };
  }
  const hS = {
    basis: {
      curve: m9
    },
    "basis-closed": {
      curve: y9
    },
    "basis-open": {
      curve: b9
    },
    bundle: {
      curve: v9,
      tension: "beta",
      value: 0.85
    },
    cardinal: {
      curve: x9,
      tension: "tension",
      value: 0
    },
    "cardinal-open": {
      curve: E9,
      tension: "tension",
      value: 0
    },
    "cardinal-closed": {
      curve: w9,
      tension: "tension",
      value: 0
    },
    "catmull-rom": {
      curve: _9,
      tension: "alpha",
      value: 0.5
    },
    "catmull-rom-closed": {
      curve: S9,
      tension: "alpha",
      value: 0.5
    },
    "catmull-rom-open": {
      curve: $9,
      tension: "alpha",
      value: 0.5
    },
    linear: {
      curve: Kv
    },
    "linear-closed": {
      curve: k9
    },
    monotone: {
      horizontal: C9,
      vertical: A9
    },
    natural: {
      curve: F9
    },
    step: {
      curve: M9
    },
    "step-after": {
      curve: D9
    },
    "step-before": {
      curve: T9
    }
  };
  function kx(e, t, n) {
    var i = J(hS, e) && hS[e], r = null;
    return i && (r = i.curve || i[t || "vertical"], i.tension && n != null && (r = r[i.tension](n))), r;
  }
  const EB = {
    m: 2,
    l: 2,
    h: 1,
    v: 1,
    z: 0,
    c: 6,
    s: 4,
    q: 4,
    t: 2,
    a: 7
  }, _B = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi, SB = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/, $B = /^((\s+,?\s*)|(,\s*))/, kB = /^[01]/;
  function bu(e) {
    const t = [];
    return (e.match(_B) || []).forEach((i) => {
      let r = i[0];
      const o = r.toLowerCase(), s = EB[o], a = AB(o, s, i.slice(1).trim()), u = a.length;
      if (u < s || u && u % s !== 0)
        throw Error("Invalid SVG path, incorrect parameter count");
      if (t.push([r, ...a.slice(0, s)]), u !== s) {
        o === "m" && (r = r === "M" ? "L" : "l");
        for (let l = s; l < u; l += s)
          t.push([r, ...a.slice(l, l + s)]);
      }
    }), t;
  }
  function AB(e, t, n) {
    const i = [];
    for (let r = 0; t && r < n.length; )
      for (let o = 0; o < t; ++o) {
        const s = e === "a" && (o === 3 || o === 4) ? kB : SB, a = n.slice(r).match(s);
        if (a === null)
          throw Error("Invalid SVG path, incorrect parameter type");
        r += a[0].length, i.push(+a[0]);
        const u = n.slice(r).match($B);
        u !== null && (r += u[0].length);
      }
    return i;
  }
  const zo = Math.PI / 180, CB = 1e-14, ks = Math.PI / 2, Gi = Math.PI * 2, Ta = Math.sqrt(3) / 2;
  var g0 = {}, p0 = {}, A3 = [].join;
  function FB(e, t, n, i, r, o, s, a, u) {
    const l = A3.call(arguments);
    if (g0[l])
      return g0[l];
    const c = s * zo, f = Math.sin(c), d = Math.cos(c);
    n = Math.abs(n), i = Math.abs(i);
    const h = d * (a - e) * 0.5 + f * (u - t) * 0.5, g = d * (u - t) * 0.5 - f * (a - e) * 0.5;
    let p = h * h / (n * n) + g * g / (i * i);
    p > 1 && (p = Math.sqrt(p), n *= p, i *= p);
    const m = d / n, y = f / n, b = -f / i, v = d / i, x = m * a + y * u, w = b * a + v * u, _ = m * e + y * t, E = b * e + v * t;
    let $ = 1 / ((_ - x) * (_ - x) + (E - w) * (E - w)) - 0.25;
    $ < 0 && ($ = 0);
    let F = Math.sqrt($);
    o == r && (F = -F);
    const A = 0.5 * (x + _) - F * (E - w), D = 0.5 * (w + E) + F * (_ - x), k = Math.atan2(w - D, x - A);
    let C = Math.atan2(E - D, _ - A) - k;
    C < 0 && o === 1 ? C += Gi : C > 0 && o === 0 && (C -= Gi);
    const T = Math.ceil(Math.abs(C / (ks + 1e-3))), L = [];
    for (let I = 0; I < T; ++I) {
      const z = k + I * C / T, te = k + (I + 1) * C / T;
      L[I] = [A, D, z, te, n, i, f, d];
    }
    return g0[l] = L;
  }
  function MB(e) {
    const t = A3.call(e);
    if (p0[t])
      return p0[t];
    var n = e[0], i = e[1], r = e[2], o = e[3], s = e[4], a = e[5], u = e[6], l = e[7];
    const c = l * s, f = -u * a, d = u * s, h = l * a, g = Math.cos(r), p = Math.sin(r), m = Math.cos(o), y = Math.sin(o), b = 0.5 * (o - r), v = Math.sin(b * 0.5), x = 8 / 3 * v * v / Math.sin(b), w = n + g - x * p, _ = i + p + x * g, E = n + m, S = i + y, $ = E + x * y, F = S - x * m;
    return p0[t] = [c * w + f * _, d * w + h * _, c * $ + f * F, d * $ + h * F, c * E + f * S, d * E + h * S];
  }
  const Bn = ["l", 0, 0, 0, 0, 0, 0, 0];
  function TB(e, t, n) {
    const i = Bn[0] = e[0];
    if (i === "a" || i === "A")
      Bn[1] = t * e[1], Bn[2] = n * e[2], Bn[3] = e[3], Bn[4] = e[4], Bn[5] = e[5], Bn[6] = t * e[6], Bn[7] = n * e[7];
    else if (i === "h" || i === "H")
      Bn[1] = t * e[1];
    else if (i === "v" || i === "V")
      Bn[1] = n * e[1];
    else
      for (var r = 1, o = e.length; r < o; ++r)
        Bn[r] = (r % 2 == 1 ? t : n) * e[r];
    return Bn;
  }
  function Nc(e, t, n, i, r, o) {
    var s, a = null, u = 0, l = 0, c = 0, f = 0, d, h, g, p, m = 0, y = 0;
    n == null && (n = 0), i == null && (i = 0), r == null && (r = 1), o == null && (o = r), e.beginPath && e.beginPath();
    for (var b = 0, v = t.length; b < v; ++b) {
      switch (s = t[b], (r !== 1 || o !== 1) && (s = TB(s, r, o)), s[0]) {
        case "l":
          u += s[1], l += s[2], e.lineTo(u + n, l + i);
          break;
        case "L":
          u = s[1], l = s[2], e.lineTo(u + n, l + i);
          break;
        case "h":
          u += s[1], e.lineTo(u + n, l + i);
          break;
        case "H":
          u = s[1], e.lineTo(u + n, l + i);
          break;
        case "v":
          l += s[1], e.lineTo(u + n, l + i);
          break;
        case "V":
          l = s[1], e.lineTo(u + n, l + i);
          break;
        case "m":
          u += s[1], l += s[2], m = u, y = l, e.moveTo(u + n, l + i);
          break;
        case "M":
          u = s[1], l = s[2], m = u, y = l, e.moveTo(u + n, l + i);
          break;
        case "c":
          d = u + s[5], h = l + s[6], c = u + s[3], f = l + s[4], e.bezierCurveTo(
            u + s[1] + n,
            // x1
            l + s[2] + i,
            // y1
            c + n,
            // x2
            f + i,
            // y2
            d + n,
            h + i
          ), u = d, l = h;
          break;
        case "C":
          u = s[5], l = s[6], c = s[3], f = s[4], e.bezierCurveTo(s[1] + n, s[2] + i, c + n, f + i, u + n, l + i);
          break;
        case "s":
          d = u + s[3], h = l + s[4], c = 2 * u - c, f = 2 * l - f, e.bezierCurveTo(c + n, f + i, u + s[1] + n, l + s[2] + i, d + n, h + i), c = u + s[1], f = l + s[2], u = d, l = h;
          break;
        case "S":
          d = s[3], h = s[4], c = 2 * u - c, f = 2 * l - f, e.bezierCurveTo(c + n, f + i, s[1] + n, s[2] + i, d + n, h + i), u = d, l = h, c = s[1], f = s[2];
          break;
        case "q":
          d = u + s[3], h = l + s[4], c = u + s[1], f = l + s[2], e.quadraticCurveTo(c + n, f + i, d + n, h + i), u = d, l = h;
          break;
        case "Q":
          d = s[3], h = s[4], e.quadraticCurveTo(s[1] + n, s[2] + i, d + n, h + i), u = d, l = h, c = s[1], f = s[2];
          break;
        case "t":
          d = u + s[1], h = l + s[2], a[0].match(/[QqTt]/) === null ? (c = u, f = l) : a[0] === "t" ? (c = 2 * u - g, f = 2 * l - p) : a[0] === "q" && (c = 2 * u - c, f = 2 * l - f), g = c, p = f, e.quadraticCurveTo(c + n, f + i, d + n, h + i), u = d, l = h, c = u + s[1], f = l + s[2];
          break;
        case "T":
          d = s[1], h = s[2], c = 2 * u - c, f = 2 * l - f, e.quadraticCurveTo(c + n, f + i, d + n, h + i), u = d, l = h;
          break;
        case "a":
          gS(e, u + n, l + i, [s[1], s[2], s[3], s[4], s[5], s[6] + u + n, s[7] + l + i]), u += s[6], l += s[7];
          break;
        case "A":
          gS(e, u + n, l + i, [s[1], s[2], s[3], s[4], s[5], s[6] + n, s[7] + i]), u = s[6], l = s[7];
          break;
        case "z":
        case "Z":
          u = m, l = y, e.closePath();
          break;
      }
      a = s;
    }
  }
  function gS(e, t, n, i) {
    const r = FB(
      i[5],
      // end x
      i[6],
      // end y
      i[0],
      // radius x
      i[1],
      // radius y
      i[3],
      // large flag
      i[4],
      // sweep flag
      i[2],
      // rotation
      t,
      n
    );
    for (let o = 0; o < r.length; ++o) {
      const s = MB(r[o]);
      e.bezierCurveTo(s[0], s[1], s[2], s[3], s[4], s[5]);
    }
  }
  const pS = 0.5773502691896257, mS = {
    circle: {
      draw: function(e, t) {
        const n = Math.sqrt(t) / 2;
        e.moveTo(n, 0), e.arc(0, 0, n, 0, Gi);
      }
    },
    cross: {
      draw: function(e, t) {
        var n = Math.sqrt(t) / 2, i = n / 2.5;
        e.moveTo(-n, -i), e.lineTo(-n, i), e.lineTo(-i, i), e.lineTo(-i, n), e.lineTo(i, n), e.lineTo(i, i), e.lineTo(n, i), e.lineTo(n, -i), e.lineTo(i, -i), e.lineTo(i, -n), e.lineTo(-i, -n), e.lineTo(-i, -i), e.closePath();
      }
    },
    diamond: {
      draw: function(e, t) {
        const n = Math.sqrt(t) / 2;
        e.moveTo(-n, 0), e.lineTo(0, -n), e.lineTo(n, 0), e.lineTo(0, n), e.closePath();
      }
    },
    square: {
      draw: function(e, t) {
        var n = Math.sqrt(t), i = -n / 2;
        e.rect(i, i, n, n);
      }
    },
    arrow: {
      draw: function(e, t) {
        var n = Math.sqrt(t) / 2, i = n / 7, r = n / 2.5, o = n / 8;
        e.moveTo(-i, n), e.lineTo(i, n), e.lineTo(i, -o), e.lineTo(r, -o), e.lineTo(0, -n), e.lineTo(-r, -o), e.lineTo(-i, -o), e.closePath();
      }
    },
    wedge: {
      draw: function(e, t) {
        var n = Math.sqrt(t) / 2, i = Ta * n, r = i - n * pS, o = n / 4;
        e.moveTo(0, -i - r), e.lineTo(-o, i - r), e.lineTo(o, i - r), e.closePath();
      }
    },
    triangle: {
      draw: function(e, t) {
        var n = Math.sqrt(t) / 2, i = Ta * n, r = i - n * pS;
        e.moveTo(0, -i - r), e.lineTo(-n, i - r), e.lineTo(n, i - r), e.closePath();
      }
    },
    "triangle-up": {
      draw: function(e, t) {
        var n = Math.sqrt(t) / 2, i = Ta * n;
        e.moveTo(0, -i), e.lineTo(-n, i), e.lineTo(n, i), e.closePath();
      }
    },
    "triangle-down": {
      draw: function(e, t) {
        var n = Math.sqrt(t) / 2, i = Ta * n;
        e.moveTo(0, i), e.lineTo(-n, -i), e.lineTo(n, -i), e.closePath();
      }
    },
    "triangle-right": {
      draw: function(e, t) {
        var n = Math.sqrt(t) / 2, i = Ta * n;
        e.moveTo(i, 0), e.lineTo(-i, -n), e.lineTo(-i, n), e.closePath();
      }
    },
    "triangle-left": {
      draw: function(e, t) {
        var n = Math.sqrt(t) / 2, i = Ta * n;
        e.moveTo(-i, 0), e.lineTo(i, -n), e.lineTo(i, n), e.closePath();
      }
    },
    stroke: {
      draw: function(e, t) {
        const n = Math.sqrt(t) / 2;
        e.moveTo(-n, 0), e.lineTo(n, 0);
      }
    }
  };
  function C3(e) {
    return J(mS, e) ? mS[e] : DB(e);
  }
  var m0 = {};
  function DB(e) {
    if (!J(m0, e)) {
      const t = bu(e);
      m0[e] = {
        draw: function(n, i) {
          Nc(n, t, 0, 0, Math.sqrt(i) / 2);
        }
      };
    }
    return m0[e];
  }
  const uo = 0.448084975506;
  function NB(e) {
    return e.x;
  }
  function OB(e) {
    return e.y;
  }
  function RB(e) {
    return e.width;
  }
  function LB(e) {
    return e.height;
  }
  function Sr(e) {
    return typeof e == "function" ? e : () => +e;
  }
  function rd(e, t, n) {
    return Math.max(t, Math.min(e, n));
  }
  function F3() {
    var e = NB, t = OB, n = RB, i = LB, r = Sr(0), o = r, s = r, a = r, u = null;
    function l(c, f, d) {
      var h, g = f ?? +e.call(this, c), p = d ?? +t.call(this, c), m = +n.call(this, c), y = +i.call(this, c), b = Math.min(m, y) / 2, v = rd(+r.call(this, c), 0, b), x = rd(+o.call(this, c), 0, b), w = rd(+s.call(this, c), 0, b), _ = rd(+a.call(this, c), 0, b);
      if (u || (u = h = lp()), v <= 0 && x <= 0 && w <= 0 && _ <= 0)
        u.rect(g, p, m, y);
      else {
        var E = g + m, S = p + y;
        u.moveTo(g + v, p), u.lineTo(E - x, p), u.bezierCurveTo(E - uo * x, p, E, p + uo * x, E, p + x), u.lineTo(E, S - _), u.bezierCurveTo(E, S - uo * _, E - uo * _, S, E - _, S), u.lineTo(g + w, S), u.bezierCurveTo(g + uo * w, S, g, S - uo * w, g, S - w), u.lineTo(g, p + v), u.bezierCurveTo(g, p + uo * v, g + uo * v, p, g + v, p), u.closePath();
      }
      if (h)
        return u = null, h + "" || null;
    }
    return l.x = function(c) {
      return arguments.length ? (e = Sr(c), l) : e;
    }, l.y = function(c) {
      return arguments.length ? (t = Sr(c), l) : t;
    }, l.width = function(c) {
      return arguments.length ? (n = Sr(c), l) : n;
    }, l.height = function(c) {
      return arguments.length ? (i = Sr(c), l) : i;
    }, l.cornerRadius = function(c, f, d, h) {
      return arguments.length ? (r = Sr(c), o = f != null ? Sr(f) : r, a = d != null ? Sr(d) : r, s = h != null ? Sr(h) : o, l) : r;
    }, l.context = function(c) {
      return arguments.length ? (u = c ?? null, l) : u;
    }, l;
  }
  function M3() {
    var e, t, n, i, r = null, o, s, a, u;
    function l(f, d, h) {
      const g = h / 2;
      if (o) {
        var p = a - d, m = f - s;
        if (p || m) {
          var y = Math.hypot(p, m), b = (p /= y) * u, v = (m /= y) * u, x = Math.atan2(m, p);
          r.moveTo(s - b, a - v), r.lineTo(f - p * g, d - m * g), r.arc(f, d, g, x - Math.PI, x), r.lineTo(s + b, a + v), r.arc(s, a, u, x, x + Math.PI);
        } else
          r.arc(f, d, g, 0, Gi);
        r.closePath();
      } else
        o = 1;
      s = f, a = d, u = g;
    }
    function c(f) {
      var d, h = f.length, g, p = !1, m;
      for (r == null && (r = m = lp()), d = 0; d <= h; ++d)
        !(d < h && i(g = f[d], d, f)) === p && (p = !p) && (o = 0), p && l(+e(g, d, f), +t(g, d, f), +n(g, d, f));
      if (m)
        return r = null, m + "" || null;
    }
    return c.x = function(f) {
      return arguments.length ? (e = f, c) : e;
    }, c.y = function(f) {
      return arguments.length ? (t = f, c) : t;
    }, c.size = function(f) {
      return arguments.length ? (n = f, c) : n;
    }, c.defined = function(f) {
      return arguments.length ? (i = f, c) : i;
    }, c.context = function(f) {
      return arguments.length ? (f == null ? r = null : r = f, c) : r;
    }, c;
  }
  function gf(e, t) {
    return e ?? t;
  }
  const pf = (e) => e.x || 0, mf = (e) => e.y || 0, PB = (e) => e.width || 0, IB = (e) => e.height || 0, zB = (e) => (e.x || 0) + (e.width || 0), BB = (e) => (e.y || 0) + (e.height || 0), UB = (e) => e.startAngle || 0, jB = (e) => e.endAngle || 0, qB = (e) => e.padAngle || 0, WB = (e) => e.innerRadius || 0, HB = (e) => e.outerRadius || 0, GB = (e) => e.cornerRadius || 0, VB = (e) => gf(e.cornerRadiusTopLeft, e.cornerRadius) || 0, YB = (e) => gf(e.cornerRadiusTopRight, e.cornerRadius) || 0, XB = (e) => gf(e.cornerRadiusBottomRight, e.cornerRadius) || 0, KB = (e) => gf(e.cornerRadiusBottomLeft, e.cornerRadius) || 0, JB = (e) => gf(e.size, 64), QB = (e) => e.size || 1, _p = (e) => e.defined !== !1, ZB = (e) => C3(e.shape || "circle"), eU = h9().startAngle(UB).endAngle(jB).padAngle(qB).innerRadius(WB).outerRadius(HB).cornerRadius(GB), tU = oT().x(pf).y1(mf).y0(BB).defined(_p), nU = oT().y(mf).x1(pf).x0(zB).defined(_p), iU = rT().x(pf).y(mf).defined(_p), rU = F3().x(pf).y(mf).width(PB).height(IB).cornerRadius(VB, YB, XB, KB), oU = p9().type(ZB).size(JB), sU = M3().x(pf).y(mf).defined(_p).size(QB);
  function Ax(e) {
    return e.cornerRadius || e.cornerRadiusTopLeft || e.cornerRadiusTopRight || e.cornerRadiusBottomRight || e.cornerRadiusBottomLeft;
  }
  function aU(e, t) {
    return eU.context(e)(t);
  }
  function uU(e, t) {
    const n = t[0], i = n.interpolate || "linear";
    return (n.orient === "horizontal" ? nU : tU).curve(kx(i, n.orient, n.tension)).context(e)(t);
  }
  function lU(e, t) {
    const n = t[0], i = n.interpolate || "linear";
    return iU.curve(kx(i, n.orient, n.tension)).context(e)(t);
  }
  function tl(e, t, n, i) {
    return rU.context(e)(t, n, i);
  }
  function cU(e, t) {
    return (t.mark.shape || t.shape).context(e)(t);
  }
  function fU(e, t) {
    return oU.context(e)(t);
  }
  function dU(e, t) {
    return sU.context(e)(t);
  }
  var T3 = 1;
  function D3() {
    T3 = 1;
  }
  function Cx(e, t, n) {
    var i = t.clip, r = e._defs, o = t.clip_id || (t.clip_id = "clip" + T3++), s = r.clipping[o] || (r.clipping[o] = {
      id: o
    });
    return fe(i) ? s.path = i(null) : Ax(n) ? s.path = tl(null, n, 0, 0) : (s.width = n.width || 0, s.height = n.height || 0), "url(#" + o + ")";
  }
  function nt(e) {
    this.clear(), e && this.union(e);
  }
  nt.prototype = {
    clone() {
      return new nt(this);
    },
    clear() {
      return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this;
    },
    empty() {
      return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
    },
    equals(e) {
      return this.x1 === e.x1 && this.y1 === e.y1 && this.x2 === e.x2 && this.y2 === e.y2;
    },
    set(e, t, n, i) {
      return n < e ? (this.x2 = e, this.x1 = n) : (this.x1 = e, this.x2 = n), i < t ? (this.y2 = t, this.y1 = i) : (this.y1 = t, this.y2 = i), this;
    },
    add(e, t) {
      return e < this.x1 && (this.x1 = e), t < this.y1 && (this.y1 = t), e > this.x2 && (this.x2 = e), t > this.y2 && (this.y2 = t), this;
    },
    expand(e) {
      return this.x1 -= e, this.y1 -= e, this.x2 += e, this.y2 += e, this;
    },
    round() {
      return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this;
    },
    scale(e) {
      return this.x1 *= e, this.y1 *= e, this.x2 *= e, this.y2 *= e, this;
    },
    translate(e, t) {
      return this.x1 += e, this.x2 += e, this.y1 += t, this.y2 += t, this;
    },
    rotate(e, t, n) {
      const i = this.rotatedPoints(e, t, n);
      return this.clear().add(i[0], i[1]).add(i[2], i[3]).add(i[4], i[5]).add(i[6], i[7]);
    },
    rotatedPoints(e, t, n) {
      var {
        x1: i,
        y1: r,
        x2: o,
        y2: s
      } = this, a = Math.cos(e), u = Math.sin(e), l = t - t * a + n * u, c = n - t * u - n * a;
      return [a * i - u * r + l, u * i + a * r + c, a * i - u * s + l, u * i + a * s + c, a * o - u * r + l, u * o + a * r + c, a * o - u * s + l, u * o + a * s + c];
    },
    union(e) {
      return e.x1 < this.x1 && (this.x1 = e.x1), e.y1 < this.y1 && (this.y1 = e.y1), e.x2 > this.x2 && (this.x2 = e.x2), e.y2 > this.y2 && (this.y2 = e.y2), this;
    },
    intersect(e) {
      return e.x1 > this.x1 && (this.x1 = e.x1), e.y1 > this.y1 && (this.y1 = e.y1), e.x2 < this.x2 && (this.x2 = e.x2), e.y2 < this.y2 && (this.y2 = e.y2), this;
    },
    encloses(e) {
      return e && this.x1 <= e.x1 && this.x2 >= e.x2 && this.y1 <= e.y1 && this.y2 >= e.y2;
    },
    alignsWith(e) {
      return e && (this.x1 == e.x1 || this.x2 == e.x2 || this.y1 == e.y1 || this.y2 == e.y2);
    },
    intersects(e) {
      return e && !(this.x2 < e.x1 || this.x1 > e.x2 || this.y2 < e.y1 || this.y1 > e.y2);
    },
    contains(e, t) {
      return !(e < this.x1 || e > this.x2 || t < this.y1 || t > this.y2);
    },
    width() {
      return this.x2 - this.x1;
    },
    height() {
      return this.y2 - this.y1;
    }
  };
  function Sp(e) {
    this.mark = e, this.bounds = this.bounds || new nt();
  }
  function $p(e) {
    Sp.call(this, e), this.items = this.items || [];
  }
  G($p, Sp);
  class N3 {
    constructor(t) {
      this._pending = 0, this._loader = t || Jg();
    }
    pending() {
      return this._pending;
    }
    sanitizeURL(t) {
      const n = this;
      return yS(n), n._loader.sanitize(t, {
        context: "href"
      }).then((i) => (Sl(n), i)).catch(() => (Sl(n), null));
    }
    loadImage(t) {
      const n = this, i = N9();
      return yS(n), n._loader.sanitize(t, {
        context: "image"
      }).then((r) => {
        const o = r.href;
        if (!o || !i) throw {
          url: o
        };
        const s = new i(), a = J(r, "crossOrigin") ? r.crossOrigin : "anonymous";
        return a != null && (s.crossOrigin = a), s.onload = () => Sl(n), s.onerror = () => Sl(n), s.src = o, s;
      }).catch((r) => (Sl(n), {
        complete: !1,
        width: 0,
        height: 0,
        src: r && r.url || ""
      }));
    }
    ready() {
      const t = this;
      return new Promise((n) => {
        function i(r) {
          t.pending() ? setTimeout(() => {
            i(!0);
          }, 10) : n(r);
        }
        i(!1);
      });
    }
  }
  function yS(e) {
    e._pending += 1;
  }
  function Sl(e) {
    e._pending -= 1;
  }
  function Qr(e, t, n) {
    if (t.stroke && t.opacity !== 0 && t.strokeOpacity !== 0) {
      const i = t.strokeWidth != null ? +t.strokeWidth : 1;
      e.expand(i + (n ? hU(t, i) : 0));
    }
    return e;
  }
  function hU(e, t) {
    return e.strokeJoin && e.strokeJoin !== "miter" ? 0 : t;
  }
  const gU = Gi - 1e-8;
  let kp, Ud, jd, Ds, K1, qd, J1, Q1;
  const vo = (e, t) => kp.add(e, t), Wd = (e, t) => vo(Ud = e, jd = t), bS = (e) => vo(e, kp.y1), vS = (e) => vo(kp.x1, e), As = (e, t) => K1 * e + J1 * t, Cs = (e, t) => qd * e + Q1 * t, y0 = (e, t) => vo(As(e, t), Cs(e, t)), b0 = (e, t) => Wd(As(e, t), Cs(e, t));
  function yf(e, t) {
    return kp = e, t ? (Ds = t * zo, K1 = Q1 = Math.cos(Ds), qd = Math.sin(Ds), J1 = -qd) : (K1 = Q1 = 1, Ds = qd = J1 = 0), pU;
  }
  const pU = {
    beginPath() {
    },
    closePath() {
    },
    moveTo: b0,
    lineTo: b0,
    rect(e, t, n, i) {
      Ds ? (y0(e + n, t), y0(e + n, t + i), y0(e, t + i), b0(e, t)) : (vo(e + n, t + i), Wd(e, t));
    },
    quadraticCurveTo(e, t, n, i) {
      const r = As(e, t), o = Cs(e, t), s = As(n, i), a = Cs(n, i);
      xS(Ud, r, s, bS), xS(jd, o, a, vS), Wd(s, a);
    },
    bezierCurveTo(e, t, n, i, r, o) {
      const s = As(e, t), a = Cs(e, t), u = As(n, i), l = Cs(n, i), c = As(r, o), f = Cs(r, o);
      wS(Ud, s, u, c, bS), wS(jd, a, l, f, vS), Wd(c, f);
    },
    arc(e, t, n, i, r, o) {
      if (i += Ds, r += Ds, Ud = n * Math.cos(r) + e, jd = n * Math.sin(r) + t, Math.abs(r - i) > gU)
        vo(e - n, t - n), vo(e + n, t + n);
      else {
        const s = (l) => vo(n * Math.cos(l) + e, n * Math.sin(l) + t);
        let a, u;
        if (s(i), s(r), r !== i)
          if (i = i % Gi, i < 0 && (i += Gi), r = r % Gi, r < 0 && (r += Gi), r < i && (o = !o, a = i, i = r, r = a), o)
            for (r -= Gi, a = i - i % ks, u = 0; u < 4 && a > r; ++u, a -= ks) s(a);
          else
            for (a = i - i % ks + ks, u = 0; u < 4 && a < r; ++u, a = a + ks) s(a);
      }
    }
  };
  function xS(e, t, n, i) {
    const r = (e - t) / (e + n - 2 * t);
    0 < r && r < 1 && i(e + (t - e) * r);
  }
  function wS(e, t, n, i, r) {
    const o = i - e + 3 * t - 3 * n, s = e + n - 2 * t, a = e - t;
    let u = 0, l = 0, c;
    Math.abs(o) > CB ? (c = s * s + a * o, c >= 0 && (c = Math.sqrt(c), u = (-s + c) / o, l = (-s - c) / o)) : u = 0.5 * a / s, 0 < u && u < 1 && r(ES(u, e, t, n, i)), 0 < l && l < 1 && r(ES(l, e, t, n, i));
  }
  function ES(e, t, n, i, r) {
    const o = 1 - e, s = o * o, a = e * e;
    return s * o * t + 3 * s * e * n + 3 * o * a * i + a * e * r;
  }
  var Do = (Do = To(1, 1)) ? Do.getContext("2d") : null;
  const Z1 = new nt();
  function Fx(e) {
    return function(t, n) {
      if (!Do) return !0;
      e(Do, t), Z1.clear().union(t.bounds).intersect(n).round();
      const {
        x1: i,
        y1: r,
        x2: o,
        y2: s
      } = Z1;
      for (let a = r; a <= s; ++a)
        for (let u = i; u <= o; ++u)
          if (Do.isPointInPath(u, a))
            return !0;
      return !1;
    };
  }
  function Mx(e, t) {
    return t.contains(e.x || 0, e.y || 0);
  }
  function O3(e, t) {
    const n = e.x || 0, i = e.y || 0, r = e.width || 0, o = e.height || 0;
    return t.intersects(Z1.set(n, i, n + r, i + o));
  }
  function R3(e, t) {
    const n = e.x || 0, i = e.y || 0, r = e.x2 != null ? e.x2 : n, o = e.y2 != null ? e.y2 : i;
    return Ga(t, n, i, r, o);
  }
  function Ga(e, t, n, i, r) {
    const {
      x1: o,
      y1: s,
      x2: a,
      y2: u
    } = e, l = i - t, c = r - n;
    let f = 0, d = 1, h, g, p, m;
    for (m = 0; m < 4; ++m) {
      if (m === 0 && (h = -l, g = -(o - t)), m === 1 && (h = l, g = a - t), m === 2 && (h = -c, g = -(s - n)), m === 3 && (h = c, g = u - n), Math.abs(h) < 1e-10 && g < 0) return !1;
      if (p = g / h, h < 0) {
        if (p > d) return !1;
        p > f && (f = p);
      } else if (h > 0) {
        if (p < f) return !1;
        p < d && (d = p);
      }
    }
    return !0;
  }
  function vu(e, t) {
    e.globalCompositeOperation = t.blend || "source-over";
  }
  function ai(e, t) {
    return e ?? t;
  }
  function _S(e, t) {
    const n = t.length;
    for (let i = 0; i < n; ++i)
      e.addColorStop(t[i].offset, t[i].color);
    return e;
  }
  function mU(e, t, n) {
    const i = n.width(), r = n.height();
    let o;
    if (t.gradient === "radial")
      o = e.createRadialGradient(n.x1 + ai(t.x1, 0.5) * i, n.y1 + ai(t.y1, 0.5) * r, Math.max(i, r) * ai(t.r1, 0), n.x1 + ai(t.x2, 0.5) * i, n.y1 + ai(t.y2, 0.5) * r, Math.max(i, r) * ai(t.r2, 0.5));
    else {
      const s = ai(t.x1, 0), a = ai(t.y1, 0), u = ai(t.x2, 1), l = ai(t.y2, 0);
      if (s === u || a === l || i === r)
        o = e.createLinearGradient(n.x1 + s * i, n.y1 + a * r, n.x1 + u * i, n.y1 + l * r);
      else {
        const c = To(Math.ceil(i), Math.ceil(r)), f = c.getContext("2d");
        return f.scale(i, r), f.fillStyle = _S(f.createLinearGradient(s, a, u, l), t.stops), f.fillRect(0, 0, i, r), e.createPattern(c, "no-repeat");
      }
    }
    return _S(o, t.stops);
  }
  function L3(e, t, n) {
    return $x(n) ? mU(e, n, t.bounds) : n;
  }
  function Mh(e, t, n) {
    return n *= t.fillOpacity == null ? 1 : t.fillOpacity, n > 0 ? (e.globalAlpha = n, e.fillStyle = L3(e, t, t.fill), !0) : !1;
  }
  var yU = [];
  function xu(e, t, n) {
    var i = (i = t.strokeWidth) != null ? i : 1;
    return i <= 0 ? !1 : (n *= t.strokeOpacity == null ? 1 : t.strokeOpacity, n > 0 ? (e.globalAlpha = n, e.strokeStyle = L3(e, t, t.stroke), e.lineWidth = i, e.lineCap = t.strokeCap || "butt", e.lineJoin = t.strokeJoin || "miter", e.miterLimit = t.strokeMiterLimit || 10, e.setLineDash && (e.setLineDash(t.strokeDash || yU), e.lineDashOffset = t.strokeDashOffset || 0), !0) : !1);
  }
  function bU(e, t) {
    return e.zindex - t.zindex || e.index - t.index;
  }
  function Tx(e) {
    if (!e.zdirty) return e.zitems;
    var t = e.items, n = [], i, r, o;
    for (r = 0, o = t.length; r < o; ++r)
      i = t[r], i.index = r, i.zindex && n.push(i);
    return e.zdirty = !1, e.zitems = n.sort(bU);
  }
  function _i(e, t) {
    var n = e.items, i, r;
    if (!n || !n.length) return;
    const o = Tx(e);
    if (o && o.length) {
      for (i = 0, r = n.length; i < r; ++i)
        n[i].zindex || t(n[i]);
      n = o;
    }
    for (i = 0, r = n.length; i < r; ++i)
      t(n[i]);
  }
  function Th(e, t) {
    var n = e.items, i, r;
    if (!n || !n.length) return null;
    const o = Tx(e);
    for (o && o.length && (n = o), r = n.length; --r >= 0; )
      if (i = t(n[r])) return i;
    if (n === o) {
      for (n = e.items, r = n.length; --r >= 0; )
        if (!n[r].zindex && (i = t(n[r])))
          return i;
    }
    return null;
  }
  function Dx(e) {
    return function(t, n, i) {
      _i(n, (r) => {
        (!i || i.intersects(r.bounds)) && P3(e, t, r, r);
      });
    };
  }
  function vU(e) {
    return function(t, n, i) {
      n.items.length && (!i || i.intersects(n.bounds)) && P3(e, t, n.items[0], n.items);
    };
  }
  function P3(e, t, n, i) {
    var r = n.opacity == null ? 1 : n.opacity;
    r !== 0 && (e(t, i) || (vu(t, n), n.fill && Mh(t, n, r) && t.fill(), n.stroke && xu(t, n, r) && t.stroke()));
  }
  function Ap(e) {
    return e = e || Jn, function(t, n, i, r, o, s) {
      return i *= t.pixelRatio, r *= t.pixelRatio, Th(n, (a) => {
        const u = a.bounds;
        if (!(u && !u.contains(o, s) || !u) && e(t, a, i, r, o, s))
          return a;
      });
    };
  }
  function bf(e, t) {
    return function(n, i, r, o) {
      var s = Array.isArray(i) ? i[0] : i, a = t ?? s.fill, u = s.stroke && n.isPointInStroke, l, c;
      return u && (l = s.strokeWidth, c = s.strokeCap, n.lineWidth = l ?? 1, n.lineCap = c ?? "butt"), e(n, i) ? !1 : a && n.isPointInPath(r, o) || u && n.isPointInStroke(r, o);
    };
  }
  function Nx(e) {
    return Ap(bf(e));
  }
  function Is(e, t) {
    return "translate(" + e + "," + t + ")";
  }
  function Ox(e) {
    return "rotate(" + e + ")";
  }
  function xU(e, t) {
    return "scale(" + e + "," + t + ")";
  }
  function I3(e) {
    return Is(e.x || 0, e.y || 0);
  }
  function wU(e) {
    return Is(e.x || 0, e.y || 0) + (e.angle ? " " + Ox(e.angle) : "");
  }
  function EU(e) {
    return Is(e.x || 0, e.y || 0) + (e.angle ? " " + Ox(e.angle) : "") + (e.scaleX || e.scaleY ? " " + xU(e.scaleX || 1, e.scaleY || 1) : "");
  }
  function Rx(e, t, n) {
    function i(s, a) {
      s("transform", wU(a)), s("d", t(null, a));
    }
    function r(s, a) {
      return t(yf(s, a.angle), a), Qr(s, a).translate(a.x || 0, a.y || 0);
    }
    function o(s, a) {
      var u = a.x || 0, l = a.y || 0, c = a.angle || 0;
      s.translate(u, l), c && s.rotate(c *= zo), s.beginPath(), t(s, a), c && s.rotate(-c), s.translate(-u, -l);
    }
    return {
      type: e,
      tag: "path",
      nested: !1,
      attr: i,
      bound: r,
      draw: Dx(o),
      pick: Nx(o),
      isect: n || Fx(o)
    };
  }
  var _U = Rx("arc", aU);
  function SU(e, t) {
    for (var n = e[0].orient === "horizontal" ? t[1] : t[0], i = e[0].orient === "horizontal" ? "y" : "x", r = e.length, o = 1 / 0, s, a; --r >= 0; )
      e[r].defined !== !1 && (a = Math.abs(e[r][i] - n), a < o && (o = a, s = e[r]));
    return s;
  }
  function $U(e, t) {
    for (var n = Math.pow(e[0].strokeWidth || 1, 2), i = e.length, r, o, s; --i >= 0; )
      if (e[i].defined !== !1 && (r = e[i].x - t[0], o = e[i].y - t[1], s = r * r + o * o, s < n))
        return e[i];
    return null;
  }
  function kU(e, t) {
    for (var n = e.length, i, r, o; --n >= 0; )
      if (e[n].defined !== !1 && (i = e[n].x - t[0], r = e[n].y - t[1], o = i * i + r * r, i = e[n].size || 1, o < i * i))
        return e[n];
    return null;
  }
  function Lx(e, t, n) {
    function i(u, l) {
      var c = l.mark.items;
      c.length && u("d", t(null, c));
    }
    function r(u, l) {
      var c = l.items;
      return c.length === 0 ? u : (t(yf(u), c), Qr(u, c[0]));
    }
    function o(u, l) {
      u.beginPath(), t(u, l);
    }
    const s = bf(o);
    function a(u, l, c, f, d, h) {
      var g = l.items, p = l.bounds;
      return !g || !g.length || p && !p.contains(d, h) ? null : (c *= u.pixelRatio, f *= u.pixelRatio, s(u, g, c, f) ? g[0] : null);
    }
    return {
      type: e,
      tag: "path",
      nested: !0,
      attr: i,
      bound: r,
      draw: vU(o),
      pick: a,
      isect: Mx,
      tip: n
    };
  }
  var AU = Lx("area", uU, SU);
  function CU(e, t) {
    var n = t.clip;
    e.save(), fe(n) ? (e.beginPath(), n(e), e.clip()) : z3(e, t.group);
  }
  function z3(e, t) {
    e.beginPath(), Ax(t) ? tl(e, t, 0, 0) : e.rect(0, 0, t.width || 0, t.height || 0), e.clip();
  }
  function B3(e) {
    const t = ai(e.strokeWidth, 1);
    return e.strokeOffset != null ? e.strokeOffset : e.stroke && t > 0.5 && t < 1.5 ? 0.5 - Math.abs(t - 1) : 0;
  }
  function FU(e, t) {
    e("transform", I3(t));
  }
  function U3(e, t) {
    const n = B3(t);
    e("d", tl(null, t, n, n));
  }
  function MU(e, t) {
    e("class", "background"), e("aria-hidden", !0), U3(e, t);
  }
  function TU(e, t) {
    e("class", "foreground"), e("aria-hidden", !0), t.strokeForeground ? U3(e, t) : e("d", "");
  }
  function DU(e, t, n) {
    const i = t.clip ? Cx(n, t, t) : null;
    e("clip-path", i);
  }
  function NU(e, t) {
    if (!t.clip && t.items) {
      const n = t.items, i = n.length;
      for (let r = 0; r < i; ++r)
        e.union(n[r].bounds);
    }
    return (t.clip || t.width || t.height) && !t.noBound && e.add(0, 0).add(t.width || 0, t.height || 0), Qr(e, t), e.translate(t.x || 0, t.y || 0);
  }
  function Oc(e, t, n, i) {
    const r = B3(t);
    e.beginPath(), tl(e, t, (n || 0) + r, (i || 0) + r);
  }
  const OU = bf(Oc), RU = bf(Oc, !1), LU = bf(Oc, !0);
  function PU(e, t, n, i) {
    _i(t, (r) => {
      const o = r.x || 0, s = r.y || 0, a = r.strokeForeground, u = r.opacity == null ? 1 : r.opacity;
      (r.stroke || r.fill) && u && (Oc(e, r, o, s), vu(e, r), r.fill && Mh(e, r, u) && e.fill(), r.stroke && !a && xu(e, r, u) && e.stroke()), e.save(), e.translate(o, s), r.clip && z3(e, r), n && n.translate(-o, -s), _i(r, (l) => {
        (l.marktype === "group" || i == null || i.includes(l.marktype)) && this.draw(e, l, n, i);
      }), n && n.translate(o, s), e.restore(), a && r.stroke && u && (Oc(e, r, o, s), vu(e, r), xu(e, r, u) && e.stroke());
    });
  }
  function IU(e, t, n, i, r, o) {
    if (t.bounds && !t.bounds.contains(r, o) || !t.items)
      return null;
    const s = n * e.pixelRatio, a = i * e.pixelRatio;
    return Th(t, (u) => {
      let l, c, f;
      const d = u.bounds;
      if (d && !d.contains(r, o)) return;
      c = u.x || 0, f = u.y || 0;
      const h = c + (u.width || 0), g = f + (u.height || 0), p = u.clip;
      if (p && (r < c || r > h || o < f || o > g)) return;
      if (e.save(), e.translate(c, f), c = r - c, f = o - f, p && Ax(u) && !LU(e, u, s, a))
        return e.restore(), null;
      const m = u.strokeForeground, y = t.interactive !== !1;
      return y && m && u.stroke && RU(e, u, s, a) ? (e.restore(), u) : (l = Th(u, (b) => zU(b, c, f) ? this.pick(b, n, i, c, f) : null), !l && y && (u.fill || !m && u.stroke) && OU(e, u, s, a) && (l = u), e.restore(), l || null);
    });
  }
  function zU(e, t, n) {
    return (e.interactive !== !1 || e.marktype === "group") && e.bounds && e.bounds.contains(t, n);
  }
  var BU = {
    type: "group",
    tag: "g",
    nested: !1,
    attr: FU,
    bound: NU,
    draw: PU,
    pick: IU,
    isect: O3,
    content: DU,
    background: MU,
    foreground: TU
  }, Rc = {
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    version: "1.1"
  };
  function Px(e, t) {
    var n = e.image;
    return (!n || e.url && e.url !== n.url) && (n = {
      complete: !1,
      width: 0,
      height: 0
    }, t.loadImage(e.url).then((i) => {
      e.image = i, e.image.url = e.url;
    })), n;
  }
  function Ix(e, t) {
    return e.width != null ? e.width : !t || !t.width ? 0 : e.aspect !== !1 && e.height ? e.height * t.width / t.height : t.width;
  }
  function zx(e, t) {
    return e.height != null ? e.height : !t || !t.height ? 0 : e.aspect !== !1 && e.width ? e.width * t.height / t.width : t.height;
  }
  function Cp(e, t) {
    return e === "center" ? t / 2 : e === "right" ? t : 0;
  }
  function Fp(e, t) {
    return e === "middle" ? t / 2 : e === "bottom" ? t : 0;
  }
  function UU(e, t, n) {
    const i = Px(t, n), r = Ix(t, i), o = zx(t, i), s = (t.x || 0) - Cp(t.align, r), a = (t.y || 0) - Fp(t.baseline, o), u = !i.src && i.toDataURL ? i.toDataURL() : i.src || "";
    e("href", u, Rc["xmlns:xlink"], "xlink:href"), e("transform", Is(s, a)), e("width", r), e("height", o), e("preserveAspectRatio", t.aspect === !1 ? "none" : "xMidYMid");
  }
  function jU(e, t) {
    const n = t.image, i = Ix(t, n), r = zx(t, n), o = (t.x || 0) - Cp(t.align, i), s = (t.y || 0) - Fp(t.baseline, r);
    return e.set(o, s, o + i, s + r);
  }
  function qU(e, t, n) {
    _i(t, (i) => {
      if (n && !n.intersects(i.bounds)) return;
      const r = Px(i, this);
      let o = Ix(i, r), s = zx(i, r);
      if (o === 0 || s === 0) return;
      let a = (i.x || 0) - Cp(i.align, o), u = (i.y || 0) - Fp(i.baseline, s), l, c, f, d;
      i.aspect !== !1 && (c = r.width / r.height, f = i.width / i.height, c === c && f === f && c !== f && (f < c ? (d = o / c, u += (s - d) / 2, s = d) : (d = s * c, a += (o - d) / 2, o = d))), (r.complete || r.toDataURL) && (vu(e, i), e.globalAlpha = (l = i.opacity) != null ? l : 1, e.imageSmoothingEnabled = i.smooth !== !1, e.drawImage(r, a, u, o, s));
    });
  }
  var WU = {
    type: "image",
    tag: "image",
    nested: !1,
    attr: UU,
    bound: jU,
    draw: qU,
    pick: Ap(),
    isect: Jn,
    // bounds check is sufficient
    get: Px,
    xOffset: Cp,
    yOffset: Fp
  }, HU = Lx("line", lU, $U);
  function GU(e, t) {
    var n = t.scaleX || 1, i = t.scaleY || 1;
    (n !== 1 || i !== 1) && e("vector-effect", "non-scaling-stroke"), e("transform", EU(t)), e("d", t.path);
  }
  function Hd(e, t) {
    var n = t.path;
    if (n == null) return !0;
    var i = t.x || 0, r = t.y || 0, o = t.scaleX || 1, s = t.scaleY || 1, a = (t.angle || 0) * zo, u = t.pathCache;
    (!u || u.path !== n) && ((t.pathCache = u = bu(n)).path = n), a && e.rotate && e.translate ? (e.translate(i, r), e.rotate(a), Nc(e, u, 0, 0, o, s), e.rotate(-a), e.translate(-i, -r)) : Nc(e, u, i, r, o, s);
  }
  function VU(e, t) {
    return Hd(yf(e, t.angle), t) ? e.set(0, 0, 0, 0) : Qr(e, t, !0);
  }
  var YU = {
    type: "path",
    tag: "path",
    nested: !1,
    attr: GU,
    bound: VU,
    draw: Dx(Hd),
    pick: Nx(Hd),
    isect: Fx(Hd)
  };
  function XU(e, t) {
    e("d", tl(null, t));
  }
  function KU(e, t) {
    var n, i;
    return Qr(e.set(n = t.x || 0, i = t.y || 0, n + t.width || 0, i + t.height || 0), t);
  }
  function SS(e, t) {
    e.beginPath(), tl(e, t);
  }
  var JU = {
    type: "rect",
    tag: "path",
    nested: !1,
    attr: XU,
    bound: KU,
    draw: Dx(SS),
    pick: Nx(SS),
    isect: O3
  };
  function QU(e, t) {
    e("transform", I3(t)), e("x2", t.x2 != null ? t.x2 - (t.x || 0) : 0), e("y2", t.y2 != null ? t.y2 - (t.y || 0) : 0);
  }
  function ZU(e, t) {
    var n, i;
    return Qr(e.set(n = t.x || 0, i = t.y || 0, t.x2 != null ? t.x2 : n, t.y2 != null ? t.y2 : i), t);
  }
  function j3(e, t, n) {
    var i, r, o, s;
    return t.stroke && xu(e, t, n) ? (i = t.x || 0, r = t.y || 0, o = t.x2 != null ? t.x2 : i, s = t.y2 != null ? t.y2 : r, e.beginPath(), e.moveTo(i, r), e.lineTo(o, s), !0) : !1;
  }
  function ej(e, t, n) {
    _i(t, (i) => {
      if (!(n && !n.intersects(i.bounds))) {
        var r = i.opacity == null ? 1 : i.opacity;
        r && j3(e, i, r) && (vu(e, i), e.stroke());
      }
    });
  }
  function tj(e, t, n, i) {
    return e.isPointInStroke ? j3(e, t, 1) && e.isPointInStroke(n, i) : !1;
  }
  var nj = {
    type: "rule",
    tag: "line",
    nested: !1,
    attr: QU,
    bound: ZU,
    draw: ej,
    pick: Ap(tj),
    isect: R3
  }, ij = Rx("shape", cU), rj = Rx("symbol", fU, Mx);
  const $S = XC();
  var Nn = {
    height: gr,
    measureWidth: Bx,
    estimateWidth: Dh,
    width: Dh,
    canvas: q3
  };
  q3(!0);
  function q3(e) {
    Nn.width = e && Do ? Bx : Dh;
  }
  function Dh(e, t) {
    return W3(Uo(e, t), gr(e));
  }
  function W3(e, t) {
    return ~~(0.8 * e.length * t);
  }
  function Bx(e, t) {
    return gr(e) <= 0 || !(t = Uo(e, t)) ? 0 : H3(t, Mp(e));
  }
  function H3(e, t) {
    const n = `(${t}) ${e}`;
    let i = $S.get(n);
    return i === void 0 && (Do.font = t, i = Do.measureText(e).width, $S.set(n, i)), i;
  }
  function gr(e) {
    return e.fontSize != null ? +e.fontSize || 0 : 11;
  }
  function Bo(e) {
    return e.lineHeight != null ? e.lineHeight : gr(e) + 2;
  }
  function oj(e) {
    return P(e) ? e.length > 1 ? e : e[0] : e;
  }
  function vf(e) {
    return oj(e.lineBreak && e.text && !P(e.text) ? e.text.split(e.lineBreak) : e.text);
  }
  function Ux(e) {
    const t = vf(e);
    return (P(t) ? t.length - 1 : 0) * Bo(e);
  }
  function Uo(e, t) {
    const n = t == null ? "" : (t + "").trim();
    return e.limit > 0 && n.length ? aj(e, n) : n;
  }
  function sj(e) {
    if (Nn.width === Bx) {
      const t = Mp(e);
      return (n) => H3(n, t);
    } else if (Nn.width === Dh) {
      const t = gr(e);
      return (n) => W3(n, t);
    } else
      return (t) => Nn.width(e, t);
  }
  function aj(e, t) {
    var n = +e.limit, i = sj(e);
    if (i(t) < n) return t;
    var r = e.ellipsis || "…", o = e.dir === "rtl", s = 0, a = t.length, u;
    if (n -= i(r), o) {
      for (; s < a; )
        u = s + a >>> 1, i(t.slice(u)) > n ? s = u + 1 : a = u;
      return r + t.slice(s);
    } else {
      for (; s < a; )
        u = 1 + (s + a >>> 1), i(t.slice(0, u)) < n ? s = u : a = u - 1;
      return t.slice(0, s) + r;
    }
  }
  function xf(e, t) {
    var n = e.font;
    return (t && n ? String(n).replace(/"/g, "'") : n) || "sans-serif";
  }
  function Mp(e, t) {
    return (e.fontStyle ? e.fontStyle + " " : "") + (e.fontVariant ? e.fontVariant + " " : "") + (e.fontWeight ? e.fontWeight + " " : "") + gr(e) + "px " + xf(e, t);
  }
  function jx(e) {
    var t = e.baseline, n = gr(e);
    return Math.round(t === "top" ? 0.79 * n : t === "middle" ? 0.3 * n : t === "bottom" ? -0.21 * n : t === "line-top" ? 0.29 * n + 0.5 * Bo(e) : t === "line-bottom" ? 0.29 * n - 0.5 * Bo(e) : 0);
  }
  const uj = {
    left: "start",
    center: "middle",
    right: "end"
  }, cc = new nt();
  function Tp(e) {
    var t = e.x || 0, n = e.y || 0, i = e.radius || 0, r;
    return i && (r = (e.theta || 0) - ks, t += i * Math.cos(r), n += i * Math.sin(r)), cc.x1 = t, cc.y1 = n, cc;
  }
  function lj(e, t) {
    var n = t.dx || 0, i = (t.dy || 0) + jx(t), r = Tp(t), o = r.x1, s = r.y1, a = t.angle || 0, u;
    e("text-anchor", uj[t.align] || "start"), a ? (u = Is(o, s) + " " + Ox(a), (n || i) && (u += " " + Is(n, i))) : u = Is(o + n, s + i), e("transform", u);
  }
  function qx(e, t, n) {
    var i = Nn.height(t), r = t.align, o = Tp(t), s = o.x1, a = o.y1, u = t.dx || 0, l = (t.dy || 0) + jx(t) - Math.round(0.8 * i), c = vf(t), f;
    if (P(c) ? (i += Bo(t) * (c.length - 1), f = c.reduce((d, h) => Math.max(d, Nn.width(t, h)), 0)) : f = Nn.width(t, c), r === "center" ? u -= f / 2 : r === "right" && (u -= f), e.set(u += s, l += a, u + f, l + i), t.angle && !n)
      e.rotate(t.angle * zo, s, a);
    else if (n === 2)
      return e.rotatedPoints(t.angle * zo, s, a);
    return e;
  }
  function cj(e, t, n) {
    _i(t, (i) => {
      var r = i.opacity == null ? 1 : i.opacity, o, s, a, u, l, c, f;
      if (!(n && !n.intersects(i.bounds) || // bounds check
      r === 0 || i.fontSize <= 0 || i.text == null || i.text.length === 0)) {
        if (e.font = Mp(i), e.textAlign = i.align || "left", o = Tp(i), s = o.x1, a = o.y1, i.angle && (e.save(), e.translate(s, a), e.rotate(i.angle * zo), s = a = 0), s += i.dx || 0, a += (i.dy || 0) + jx(i), c = vf(i), vu(e, i), P(c))
          for (l = Bo(i), u = 0; u < c.length; ++u)
            f = Uo(i, c[u]), i.fill && Mh(e, i, r) && e.fillText(f, s, a), i.stroke && xu(e, i, r) && e.strokeText(f, s, a), a += l;
        else
          f = Uo(i, c), i.fill && Mh(e, i, r) && e.fillText(f, s, a), i.stroke && xu(e, i, r) && e.strokeText(f, s, a);
        i.angle && e.restore();
      }
    });
  }
  function fj(e, t, n, i, r, o) {
    if (t.fontSize <= 0) return !1;
    if (!t.angle) return !0;
    var s = Tp(t), a = s.x1, u = s.y1, l = qx(cc, t, 1), c = -t.angle * zo, f = Math.cos(c), d = Math.sin(c), h = f * r - d * o + (a - f * a + d * u), g = d * r + f * o + (u - d * a - f * u);
    return l.contains(h, g);
  }
  function dj(e, t) {
    const n = qx(cc, e, 2);
    return Ga(t, n[0], n[1], n[2], n[3]) || Ga(t, n[0], n[1], n[4], n[5]) || Ga(t, n[4], n[5], n[6], n[7]) || Ga(t, n[2], n[3], n[6], n[7]);
  }
  var hj = {
    type: "text",
    tag: "text",
    nested: !1,
    attr: lj,
    bound: qx,
    draw: cj,
    pick: Ap(fj),
    isect: dj
  }, gj = Lx("trail", dU, kU), In = {
    arc: _U,
    area: AU,
    group: BU,
    image: WU,
    line: HU,
    path: YU,
    rect: JU,
    rule: nj,
    shape: ij,
    symbol: rj,
    text: hj,
    trail: gj
  };
  function ey(e, t, n) {
    var i = In[e.mark.marktype], r = t || i.bound;
    return i.nested && (e = e.mark), r(e.bounds || (e.bounds = new nt()), e, n);
  }
  var kS = {
    mark: null
  };
  function G3(e, t, n) {
    var i = In[e.marktype], r = i.bound, o = e.items, s = o && o.length, a, u, l, c;
    if (i.nested)
      return s ? l = o[0] : (kS.mark = e, l = kS), c = ey(l, r, n), t = t && t.union(c) || c, t;
    if (t = t || e.bounds && e.bounds.clear() || new nt(), s)
      for (a = 0, u = o.length; a < u; ++a)
        t.union(ey(o[a], r, n));
    return e.bounds = t;
  }
  const pj = [
    "marktype",
    "name",
    "role",
    "interactive",
    "clip",
    "items",
    "zindex",
    "x",
    "y",
    "width",
    "height",
    "align",
    "baseline",
    // layout
    "fill",
    "fillOpacity",
    "opacity",
    "blend",
    // fill
    "stroke",
    "strokeOpacity",
    "strokeWidth",
    "strokeCap",
    // stroke
    "strokeDash",
    "strokeDashOffset",
    // stroke dash
    "strokeForeground",
    "strokeOffset",
    // group
    "startAngle",
    "endAngle",
    "innerRadius",
    "outerRadius",
    // arc
    "cornerRadius",
    "padAngle",
    // arc, rect
    "cornerRadiusTopLeft",
    "cornerRadiusTopRight",
    // rect, group
    "cornerRadiusBottomLeft",
    "cornerRadiusBottomRight",
    "interpolate",
    "tension",
    "orient",
    "defined",
    // area, line
    "url",
    "aspect",
    "smooth",
    // image
    "path",
    "scaleX",
    "scaleY",
    // path
    "x2",
    "y2",
    // rule
    "size",
    "shape",
    // symbol
    "text",
    "angle",
    "theta",
    "radius",
    "dir",
    "dx",
    "dy",
    // text
    "ellipsis",
    "limit",
    "lineBreak",
    "lineHeight",
    "font",
    "fontSize",
    "fontWeight",
    "fontStyle",
    "fontVariant",
    // font
    "description",
    "aria",
    "ariaRole",
    "ariaRoleDescription"
    // aria
  ];
  function V3(e, t) {
    return JSON.stringify(e, pj, t);
  }
  function Y3(e) {
    const t = typeof e == "string" ? JSON.parse(e) : e;
    return X3(t);
  }
  function X3(e) {
    var t = e.marktype, n = e.items, i, r, o;
    if (n)
      for (r = 0, o = n.length; r < o; ++r)
        i = t ? "mark" : "group", n[r][i] = e, n[r].zindex && (n[r][i].zdirty = !0), (t || i) === "group" && X3(n[r]);
    return t && G3(e), e;
  }
  class K3 {
    constructor(t) {
      arguments.length ? this.root = Y3(t) : (this.root = AS({
        marktype: "group",
        name: "root",
        role: "frame"
      }), this.root.items = [new $p(this.root)]);
    }
    toJSON(t) {
      return V3(this.root, t || 0);
    }
    mark(t, n, i) {
      n = n || this.root.items[0];
      const r = AS(t, n);
      return n.items[i] = r, r.zindex && (r.group.zdirty = !0), r;
    }
  }
  function AS(e, t) {
    const n = {
      bounds: new nt(),
      clip: !!e.clip,
      group: t,
      interactive: e.interactive !== !1,
      items: [],
      marktype: e.marktype,
      name: e.name || void 0,
      role: e.role || void 0,
      zindex: e.zindex || 0
    };
    return e.aria != null && (n.aria = e.aria), e.description && (n.description = e.description), n;
  }
  function xo(e, t, n) {
    return !e && typeof document < "u" && document.createElement && (e = document), e ? n ? e.createElementNS(n, t) : e.createElement(t) : null;
  }
  function Wx(e, t) {
    t = t.toLowerCase();
    for (var n = e.childNodes, i = 0, r = n.length; i < r; ++i) if (n[i].tagName.toLowerCase() === t)
      return n[i];
  }
  function rt(e, t, n, i) {
    var r = e.childNodes[t], o;
    return (!r || r.tagName.toLowerCase() !== n.toLowerCase()) && (o = r || null, r = xo(e.ownerDocument, n, i), e.insertBefore(r, o)), r;
  }
  function jn(e, t) {
    for (var n = e.childNodes, i = n.length; i > t; ) e.removeChild(n[--i]);
    return e;
  }
  function J3(e) {
    return "mark-" + e.marktype + (e.role ? " role-" + e.role : "") + (e.name ? " " + e.name : "");
  }
  function Dp(e, t) {
    const n = t.getBoundingClientRect();
    return [e.clientX - n.left - (t.clientLeft || 0), e.clientY - n.top - (t.clientTop || 0)];
  }
  function mj(e, t, n, i) {
    var r = e && e.mark, o, s;
    if (r && (o = In[r.marktype]).tip) {
      for (s = Dp(t, n), s[0] -= i[0], s[1] -= i[1]; e = e.mark.group; )
        s[0] -= e.x || 0, s[1] -= e.y || 0;
      e = o.tip(r.items, s);
    }
    return e;
  }
  let Hx = class {
    /**
     * Create a new Handler instance.
     * @param {object} [customLoader] - Optional loader instance for
     *   href URL sanitization. If not specified, a standard loader
     *   instance will be generated.
     * @param {function} [customTooltip] - Optional tooltip handler
     *   function for custom tooltip display.
     * @constructor
     */
    constructor(t, n) {
      this._active = null, this._handlers = {}, this._loader = t || Jg(), this._tooltip = n || yj;
    }
    /**
     * Initialize a new Handler instance.
     * @param {DOMElement} el - The containing DOM element for the display.
     * @param {Array<number>} origin - The origin of the display, in pixels.
     *   The coordinate system will be translated to this point.
     * @param {object} [obj] - Optional context object that should serve as
     *   the "this" context for event callbacks.
     * @return {Handler} - This handler instance.
     */
    initialize(t, n, i) {
      return this._el = t, this._obj = i || null, this.origin(n);
    }
    /**
     * Returns the parent container element for a visualization.
     * @return {DOMElement} - The containing DOM element.
     */
    element() {
      return this._el;
    }
    /**
     * Returns the scene element (e.g., canvas or SVG) of the visualization
     * Subclasses must override if the first child is not the scene element.
     * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
     */
    canvas() {
      return this._el && this._el.firstChild;
    }
    /**
     * Get / set the origin coordinates of the visualization.
     */
    origin(t) {
      return arguments.length ? (this._origin = t || [0, 0], this) : this._origin.slice();
    }
    /**
     * Get / set the scenegraph root.
     */
    scene(t) {
      return arguments.length ? (this._scene = t, this) : this._scene;
    }
    /**
     * Add an event handler. Subclasses should override this method.
     */
    on() {
    }
    /**
     * Remove an event handler. Subclasses should override this method.
     */
    off() {
    }
    /**
     * Utility method for finding the array index of an event handler.
     * @param {Array} h - An array of registered event handlers.
     * @param {string} type - The event type.
     * @param {function} handler - The event handler instance to find.
     * @return {number} - The handler's array index or -1 if not registered.
     */
    _handlerIndex(t, n, i) {
      for (let r = t ? t.length : 0; --r >= 0; )
        if (t[r].type === n && (!i || t[r].handler === i))
          return r;
      return -1;
    }
    /**
     * Returns an array with registered event handlers.
     * @param {string} [type] - The event type to query. Any annotations
     *   are ignored; for example, for the argument "click.foo", ".foo" will
     *   be ignored and the method returns all "click" handlers. If type is
     *   null or unspecified, this method returns handlers for all types.
     * @return {Array} - A new array containing all registered event handlers.
     */
    handlers(t) {
      const n = this._handlers, i = [];
      if (t)
        i.push(...n[this.eventName(t)]);
      else
        for (const r in n)
          i.push(...n[r]);
      return i;
    }
    /**
     * Parses an event name string to return the specific event type.
     * For example, given "click.foo" returns "click"
     * @param {string} name - The input event type string.
     * @return {string} - A string with the event type only.
     */
    eventName(t) {
      const n = t.indexOf(".");
      return n < 0 ? t : t.slice(0, n);
    }
    /**
     * Handle hyperlink navigation in response to an item.href value.
     * @param {Event} event - The event triggering hyperlink navigation.
     * @param {Item} item - The scenegraph item.
     * @param {string} href - The URL to navigate to.
     */
    handleHref(t, n, i) {
      this._loader.sanitize(i, {
        context: "href"
      }).then((r) => {
        const o = new MouseEvent(t.type, t), s = xo(null, "a");
        for (const a in r) s.setAttribute(a, r[a]);
        s.dispatchEvent(o);
      }).catch(() => {
      });
    }
    /**
     * Handle tooltip display in response to an item.tooltip value.
     * @param {Event} event - The event triggering tooltip display.
     * @param {Item} item - The scenegraph item.
     * @param {boolean} show - A boolean flag indicating whether
     *   to show or hide a tooltip for the given item.
     */
    handleTooltip(t, n, i) {
      if (n && n.tooltip != null) {
        n = mj(n, t, this.canvas(), this._origin);
        const r = i && n && n.tooltip || null;
        this._tooltip.call(this._obj, this, t, n, r);
      }
    }
    /**
     * Returns the size of a scenegraph item and its position relative
     * to the viewport.
     * @param {Item} item - The scenegraph item.
     * @return {object} - A bounding box object (compatible with the
     *   DOMRect type) consisting of x, y, width, heigh, top, left,
     *   right, and bottom properties.
     */
    getItemBoundingClientRect(t) {
      const n = this.canvas();
      if (!n) return;
      const i = n.getBoundingClientRect(), r = this._origin, o = t.bounds, s = o.width(), a = o.height();
      let u = o.x1 + r[0] + i.left, l = o.y1 + r[1] + i.top;
      for (; t.mark && (t = t.mark.group); )
        u += t.x || 0, l += t.y || 0;
      return {
        x: u,
        y: l,
        width: s,
        height: a,
        left: u,
        top: l,
        right: u + s,
        bottom: l + a
      };
    }
  };
  function yj(e, t, n, i) {
    e.element().setAttribute("title", i || "");
  }
  class wf {
    /**
     * Create a new Renderer instance.
     * @param {object} [loader] - Optional loader instance for
     *   image and href URL sanitization. If not specified, a
     *   standard loader instance will be generated.
     * @constructor
     */
    constructor(t) {
      this._el = null, this._bgcolor = null, this._loader = new N3(t);
    }
    /**
     * Initialize a new Renderer instance.
     * @param {DOMElement} el - The containing DOM element for the display.
     * @param {number} width - The coordinate width of the display, in pixels.
     * @param {number} height - The coordinate height of the display, in pixels.
     * @param {Array<number>} origin - The origin of the display, in pixels.
     *   The coordinate system will be translated to this point.
     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
     *   the width and height to determine the final pixel size.
     * @return {Renderer} - This renderer instance.
     */
    initialize(t, n, i, r, o) {
      return this._el = t, this.resize(n, i, r, o);
    }
    /**
     * Returns the parent container element for a visualization.
     * @return {DOMElement} - The containing DOM element.
     */
    element() {
      return this._el;
    }
    /**
     * Returns the scene element (e.g., canvas or SVG) of the visualization
     * Subclasses must override if the first child is not the scene element.
     * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
     */
    canvas() {
      return this._el && this._el.firstChild;
    }
    /**
     * Get / set the background color.
     */
    background(t) {
      return arguments.length === 0 ? this._bgcolor : (this._bgcolor = t, this);
    }
    /**
     * Resize the display.
     * @param {number} width - The new coordinate width of the display, in pixels.
     * @param {number} height - The new coordinate height of the display, in pixels.
     * @param {Array<number>} origin - The new origin of the display, in pixels.
     *   The coordinate system will be translated to this point.
     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
     *   the width and height to determine the final pixel size.
     * @return {Renderer} - This renderer instance;
     */
    resize(t, n, i, r) {
      return this._width = t, this._height = n, this._origin = i || [0, 0], this._scale = r || 1, this;
    }
    /**
     * Report a dirty item whose bounds should be redrawn.
     * This base class method does nothing. Subclasses that perform
     * incremental should implement this method.
     * @param {Item} item - The dirty item whose bounds should be redrawn.
     */
    dirty() {
    }
    /**
     * Render an input scenegraph, potentially with a set of dirty items.
     * This method will perform an immediate rendering with available resources.
     * The renderer may also need to perform image loading to perform a complete
     * render. This process can lead to asynchronous re-rendering of the scene
     * after this method returns. To receive notification when rendering is
     * complete, use the renderAsync method instead.
     * @param {object} scene - The root mark of a scenegraph to render.
     * @param {Array} markTypes - Array of the mark types to render.
     *                            If undefined, render all mark types
     * @return {Renderer} - This renderer instance.
     */
    render(t, n) {
      const i = this;
      return i._call = function() {
        i._render(t, n);
      }, i._call(), i._call = null, i;
    }
    /**
     * Internal rendering method. Renderer subclasses should override this
     * method to actually perform rendering.
     * @param {object} scene - The root mark of a scenegraph to render.
     * @param {Array} markTypes - Array of the mark types to render.
     *                            If undefined, render all mark types
     */
    _render() {
    }
    /**
     * Asynchronous rendering method. Similar to render, but returns a Promise
     * that resolves when all rendering is completed. Sometimes a renderer must
     * perform image loading to get a complete rendering. The returned
     * Promise will not resolve until this process completes.
     * @param {object} scene - The root mark of a scenegraph to render.
     * @param {Array} markTypes - Array of the mark types to render.
     *                            If undefined, render all mark types
     * @return {Promise} - A Promise that resolves when rendering is complete.
     */
    renderAsync(t, n) {
      const i = this.render(t, n);
      return this._ready ? this._ready.then(() => i) : Promise.resolve(i);
    }
    /**
     * Internal method for asynchronous resource loading.
     * Proxies method calls to the ImageLoader, and tracks loading
     * progress to invoke a re-render once complete.
     * @param {string} method - The method name to invoke on the ImageLoader.
     * @param {string} uri - The URI for the requested resource.
     * @return {Promise} - A Promise that resolves to the requested resource.
     */
    _load(t, n) {
      var i = this, r = i._loader[t](n);
      if (!i._ready) {
        const o = i._call;
        i._ready = i._loader.ready().then((s) => {
          s && o(), i._ready = null;
        });
      }
      return r;
    }
    /**
     * Sanitize a URL to include as a hyperlink in the rendered scene.
     * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
     * image loading progress and invokes a re-render once complete.
     * @param {string} uri - The URI string to sanitize.
     * @return {Promise} - A Promise that resolves to the sanitized URL.
     */
    sanitizeURL(t) {
      return this._load("sanitizeURL", t);
    }
    /**
     * Requests an image to include in the rendered scene.
     * This method proxies a call to ImageLoader.loadImage, but also tracks
     * image loading progress and invokes a re-render once complete.
     * @param {string} uri - The URI string of the image.
     * @return {Promise} - A Promise that resolves to the loaded Image.
     */
    loadImage(t) {
      return this._load("loadImage", t);
    }
  }
  const bj = "keydown", vj = "keypress", xj = "keyup", Q3 = "dragenter", Gd = "dragleave", Z3 = "dragover", ty = "pointerdown", wj = "pointerup", Nh = "pointermove", Vd = "pointerout", eD = "pointerover", ny = "mousedown", Ej = "mouseup", tD = "mousemove", Oh = "mouseout", nD = "mouseover", Rh = "click", _j = "dblclick", Sj = "wheel", iD = "mousewheel", Lh = "touchstart", Ph = "touchmove", Ih = "touchend", $j = [bj, vj, xj, Q3, Gd, Z3, ty, wj, Nh, Vd, eD, ny, Ej, tD, Oh, nD, Rh, _j, Sj, iD, Lh, Ph, Ih], iy = Nh, fc = Oh, ry = Rh;
  class Ef extends Hx {
    constructor(t, n) {
      super(t, n), this._down = null, this._touch = null, this._first = !0, this._events = {}, this.events = $j, this.pointermove = FS([Nh, tD], [eD, nD], [Vd, Oh]), this.dragover = FS([Z3], [Q3], [Gd]), this.pointerout = MS([Vd, Oh]), this.dragleave = MS([Gd]);
    }
    initialize(t, n, i) {
      return this._canvas = t && Wx(t, "canvas"), [Rh, ny, ty, Nh, Vd, Gd].forEach((r) => CS(this, r)), super.initialize(t, n, i);
    }
    // return the backing canvas instance
    canvas() {
      return this._canvas;
    }
    // retrieve the current canvas context
    context() {
      return this._canvas.getContext("2d");
    }
    // to keep old versions of firefox happy
    DOMMouseScroll(t) {
      this.fire(iD, t);
    }
    pointerdown(t) {
      this._down = this._active, this.fire(ty, t);
    }
    mousedown(t) {
      this._down = this._active, this.fire(ny, t);
    }
    click(t) {
      this._down === this._active && (this.fire(Rh, t), this._down = null);
    }
    touchstart(t) {
      this._touch = this.pickEvent(t.changedTouches[0]), this._first && (this._active = this._touch, this._first = !1), this.fire(Lh, t, !0);
    }
    touchmove(t) {
      this.fire(Ph, t, !0);
    }
    touchend(t) {
      this.fire(Ih, t, !0), this._touch = null;
    }
    // fire an event
    fire(t, n, i) {
      const r = i ? this._touch : this._active, o = this._handlers[t];
      if (n.vegaType = t, t === ry && r && r.href ? this.handleHref(n, r, r.href) : (t === iy || t === fc) && this.handleTooltip(n, r, t !== fc), o)
        for (let s = 0, a = o.length; s < a; ++s)
          o[s].handler.call(this._obj, n, r);
    }
    // add an event handler
    on(t, n) {
      const i = this.eventName(t), r = this._handlers;
      return this._handlerIndex(r[i], t, n) < 0 && (CS(this, t), (r[i] || (r[i] = [])).push({
        type: t,
        handler: n
      })), this;
    }
    // remove an event handler
    off(t, n) {
      const i = this.eventName(t), r = this._handlers[i], o = this._handlerIndex(r, t, n);
      return o >= 0 && r.splice(o, 1), this;
    }
    pickEvent(t) {
      const n = Dp(t, this._canvas), i = this._origin;
      return this.pick(this._scene, n[0], n[1], n[0] - i[0], n[1] - i[1]);
    }
    // find the scenegraph item at the current pointer position
    // x, y -- the absolute x, y pointer coordinates on the canvas element
    // gx, gy -- the relative coordinates within the current group
    pick(t, n, i, r, o) {
      const s = this.context();
      return In[t.marktype].pick.call(this, s, t, n, i, r, o);
    }
  }
  const kj = (e) => e === Lh || e === Ph || e === Ih ? [Lh, Ph, Ih] : [e];
  function CS(e, t) {
    kj(t).forEach((n) => Aj(e, n));
  }
  function Aj(e, t) {
    const n = e.canvas();
    n && !e._events[t] && (e._events[t] = 1, n.addEventListener(t, e[t] ? (i) => e[t](i) : (i) => e.fire(t, i)));
  }
  function Yl(e, t, n) {
    t.forEach((i) => e.fire(i, n));
  }
  function FS(e, t, n) {
    return function(i) {
      const r = this._active, o = this.pickEvent(i);
      o === r ? Yl(this, e, i) : ((!r || !r.exit) && Yl(this, n, i), this._active = o, Yl(this, t, i), Yl(this, e, i));
    };
  }
  function MS(e) {
    return function(t) {
      Yl(this, e, t), this._active = null;
    };
  }
  function Cj() {
    return typeof window < "u" && window.devicePixelRatio || 1;
  }
  function Fj(e, t, n, i, r, o) {
    const s = typeof HTMLElement < "u" && e instanceof HTMLElement && e.parentNode != null, a = e.getContext("2d"), u = s ? Cj() : r;
    e.width = t * u, e.height = n * u;
    for (const l in o)
      a[l] = o[l];
    return s && u !== 1 && (e.style.width = t + "px", e.style.height = n + "px"), a.pixelRatio = u, a.setTransform(u, 0, 0, u, u * i[0], u * i[1]), e;
  }
  class zh extends wf {
    constructor(t) {
      super(t), this._options = {}, this._redraw = !1, this._dirty = new nt(), this._tempb = new nt();
    }
    initialize(t, n, i, r, o, s) {
      return this._options = s || {}, this._canvas = this._options.externalContext ? null : To(1, 1, this._options.type), t && this._canvas && (jn(t, 0).appendChild(this._canvas), this._canvas.setAttribute("class", "marks")), super.initialize(t, n, i, r, o);
    }
    resize(t, n, i, r) {
      if (super.resize(t, n, i, r), this._canvas)
        Fj(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
      else {
        const o = this._options.externalContext;
        o || R("CanvasRenderer is missing a valid canvas or context"), o.scale(this._scale, this._scale), o.translate(this._origin[0], this._origin[1]);
      }
      return this._redraw = !0, this;
    }
    canvas() {
      return this._canvas;
    }
    context() {
      return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
    }
    dirty(t) {
      const n = this._tempb.clear().union(t.bounds);
      let i = t.mark.group;
      for (; i; )
        n.translate(i.x || 0, i.y || 0), i = i.mark.group;
      this._dirty.union(n);
    }
    _render(t, n) {
      const i = this.context(), r = this._origin, o = this._width, s = this._height, a = this._dirty, u = Mj(r, o, s);
      i.save();
      const l = this._redraw || a.empty() ? (this._redraw = !1, u.expand(1)) : Tj(i, u.intersect(a), r);
      return this.clear(-r[0], -r[1], o, s), this.draw(i, t, l, n), i.restore(), a.clear(), this;
    }
    draw(t, n, i, r) {
      if (n.marktype !== "group" && r != null && !r.includes(n.marktype))
        return;
      const o = In[n.marktype];
      n.clip && CU(t, n), o.draw.call(this, t, n, i, r), n.clip && t.restore();
    }
    clear(t, n, i, r) {
      const o = this._options, s = this.context();
      o.type !== "pdf" && !o.externalContext && s.clearRect(t, n, i, r), this._bgcolor != null && (s.fillStyle = this._bgcolor, s.fillRect(t, n, i, r));
    }
  }
  const Mj = (e, t, n) => new nt().set(0, 0, t, n).translate(-e[0], -e[1]);
  function Tj(e, t, n) {
    return t.expand(1).round(), e.pixelRatio % 1 && t.scale(e.pixelRatio).round().scale(1 / e.pixelRatio), t.translate(-(n[0] % 1), -(n[1] % 1)), e.beginPath(), e.rect(t.x1, t.y1, t.width(), t.height()), e.clip(), t;
  }
  class rD extends Hx {
    constructor(t, n) {
      super(t, n);
      const i = this;
      i._hrefHandler = v0(i, (r, o) => {
        o && o.href && i.handleHref(r, o, o.href);
      }), i._tooltipHandler = v0(i, (r, o) => {
        i.handleTooltip(r, o, r.type !== fc);
      });
    }
    initialize(t, n, i) {
      let r = this._svg;
      return r && (r.removeEventListener(ry, this._hrefHandler), r.removeEventListener(iy, this._tooltipHandler), r.removeEventListener(fc, this._tooltipHandler)), this._svg = r = t && Wx(t, "svg"), r && (r.addEventListener(ry, this._hrefHandler), r.addEventListener(iy, this._tooltipHandler), r.addEventListener(fc, this._tooltipHandler)), super.initialize(t, n, i);
    }
    canvas() {
      return this._svg;
    }
    // add an event handler
    on(t, n) {
      const i = this.eventName(t), r = this._handlers;
      if (this._handlerIndex(r[i], t, n) < 0) {
        const s = {
          type: t,
          handler: n,
          listener: v0(this, n)
        };
        (r[i] || (r[i] = [])).push(s), this._svg && this._svg.addEventListener(i, s.listener);
      }
      return this;
    }
    // remove an event handler
    off(t, n) {
      const i = this.eventName(t), r = this._handlers[i], o = this._handlerIndex(r, t, n);
      return o >= 0 && (this._svg && this._svg.removeEventListener(i, r[o].listener), r.splice(o, 1)), this;
    }
  }
  const v0 = (e, t) => (n) => {
    let i = n.target.__data__;
    i = Array.isArray(i) ? i[0] : i, n.vegaType = n.type, t.call(e._obj, n, i);
  }, oD = "aria-hidden", Gx = "aria-label", Vx = "role", Yx = "aria-roledescription", sD = "graphics-object", Xx = "graphics-symbol", aD = (e, t, n) => ({
    [Vx]: e,
    [Yx]: t,
    [Gx]: n || void 0
  }), Dj = wi(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]), TS = {
    axis: {
      desc: "axis",
      caption: Rj
    },
    legend: {
      desc: "legend",
      caption: Lj
    },
    "title-text": {
      desc: "title",
      caption: (e) => `Title text '${NS(e)}'`
    },
    "title-subtitle": {
      desc: "subtitle",
      caption: (e) => `Subtitle text '${NS(e)}'`
    }
  }, DS = {
    ariaRole: Vx,
    ariaRoleDescription: Yx,
    description: Gx
  };
  function uD(e, t) {
    const n = t.aria === !1;
    if (e(oD, n || void 0), n || t.description == null)
      for (const i in DS)
        e(DS[i], void 0);
    else {
      const i = t.mark.marktype;
      e(Gx, t.description), e(Vx, t.ariaRole || (i === "group" ? sD : Xx)), e(Yx, t.ariaRoleDescription || `${i} mark`);
    }
  }
  function lD(e) {
    return e.aria === !1 ? {
      [oD]: !0
    } : Dj[e.role] ? null : TS[e.role] ? Oj(e, TS[e.role]) : Nj(e);
  }
  function Nj(e) {
    const t = e.marktype, n = t === "group" || t === "text" || e.items.some((i) => i.description != null && i.aria !== !1);
    return aD(n ? sD : Xx, `${t} mark container`, e.description);
  }
  function Oj(e, t) {
    try {
      const n = e.items[0], i = t.caption || (() => "");
      return aD(t.role || Xx, t.desc, n.description || i(n));
    } catch {
      return null;
    }
  }
  function NS(e) {
    return X(e.text).join(" ");
  }
  function Rj(e) {
    const t = e.datum, n = e.orient, i = t.title ? cD(e) : null, r = e.context, o = r.scales[t.scale].value, s = r.dataflow.locale(), a = o.type;
    return `${n === "left" || n === "right" ? "Y" : "X"}-axis` + (i ? ` titled '${i}'` : "") + ` for a ${yu(a) ? "discrete" : a} scale with ${_3(s, o, e)}`;
  }
  function Lj(e) {
    const t = e.datum, n = t.title ? cD(e) : null, i = `${t.type || ""} legend`.trim(), r = t.scales, o = Object.keys(r), s = e.context, a = s.scales[r[o[0]]].value, u = s.dataflow.locale();
    return Ij(i) + (n ? ` titled '${n}'` : "") + ` for ${Pj(o)} with ${_3(u, a, e)}`;
  }
  function cD(e) {
    try {
      return X(xe(e.items).items[0].text).join(" ");
    } catch {
      return null;
    }
  }
  function Pj(e) {
    return e = e.map((t) => t + (t === "fill" || t === "stroke" ? " color" : "")), e.length < 2 ? e[0] : e.slice(0, -1).join(", ") + " and " + xe(e);
  }
  function Ij(e) {
    return e.length ? e[0].toUpperCase() + e.slice(1) : e;
  }
  const fD = (e) => (e + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), zj = (e) => fD(e).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
  function Kx() {
    let e = "", t = "", n = "";
    const i = [], r = () => t = n = "", o = (u) => {
      t && (e += `${t}>${n}`, r()), i.push(u);
    }, s = (u, l) => (l != null && (t += ` ${u}="${zj(l)}"`), a), a = {
      open(u) {
        o(u), t = "<" + u;
        for (var l = arguments.length, c = new Array(l > 1 ? l - 1 : 0), f = 1; f < l; f++)
          c[f - 1] = arguments[f];
        for (const d of c)
          for (const h in d) s(h, d[h]);
        return a;
      },
      close() {
        const u = i.pop();
        return t ? e += t + (n ? `>${n}</${u}>` : "/>") : e += `</${u}>`, r(), a;
      },
      attr: s,
      text: (u) => (n += fD(u), a),
      toString: () => e
    };
    return a;
  }
  const dD = (e) => hD(Kx(), e) + "";
  function hD(e, t) {
    if (e.open(t.tagName), t.hasAttributes()) {
      const n = t.attributes, i = n.length;
      for (let r = 0; r < i; ++r)
        e.attr(n[r].name, n[r].value);
    }
    if (t.hasChildNodes()) {
      const n = t.childNodes;
      for (const i of n)
        i.nodeType === 3 ? e.text(i.nodeValue) : hD(e, i);
    }
    return e.close();
  }
  const Bh = {
    fill: "fill",
    fillOpacity: "fill-opacity",
    stroke: "stroke",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    strokeCap: "stroke-linecap",
    strokeJoin: "stroke-linejoin",
    strokeDash: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeMiterLimit: "stroke-miterlimit",
    opacity: "opacity"
  }, Uh = {
    blend: "mix-blend-mode"
  }, gD = {
    fill: "none",
    "stroke-miterlimit": 10
  }, $l = 0, OS = "http://www.w3.org/2000/xmlns/", it = Rc.xmlns;
  class Jx extends wf {
    constructor(t) {
      super(t), this._dirtyID = 0, this._dirty = [], this._svg = null, this._root = null, this._defs = null;
    }
    /**
     * Initialize a new SVGRenderer instance.
     * @param {DOMElement} el - The containing DOM element for the display.
     * @param {number} width - The coordinate width of the display, in pixels.
     * @param {number} height - The coordinate height of the display, in pixels.
     * @param {Array<number>} origin - The origin of the display, in pixels.
     *   The coordinate system will be translated to this point.
     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
     *   the width and height to determine the final pixel size.
     * @return {SVGRenderer} - This renderer instance.
     */
    initialize(t, n, i, r, o) {
      return this._defs = {}, this._clearDefs(), t && (this._svg = rt(t, 0, "svg", it), this._svg.setAttributeNS(OS, "xmlns", it), this._svg.setAttributeNS(OS, "xmlns:xlink", Rc["xmlns:xlink"]), this._svg.setAttribute("version", Rc.version), this._svg.setAttribute("class", "marks"), jn(t, 1), this._root = rt(this._svg, $l, "g", it), wo(this._root, gD), jn(this._svg, $l + 1)), this.background(this._bgcolor), super.initialize(t, n, i, r, o);
    }
    /**
     * Get / set the background color.
     */
    background(t) {
      return arguments.length && this._svg && this._svg.style.setProperty("background-color", t), super.background(...arguments);
    }
    /**
     * Resize the display.
     * @param {number} width - The new coordinate width of the display, in pixels.
     * @param {number} height - The new coordinate height of the display, in pixels.
     * @param {Array<number>} origin - The new origin of the display, in pixels.
     *   The coordinate system will be translated to this point.
     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
     *   the width and height to determine the final pixel size.
     * @return {SVGRenderer} - This renderer instance;
     */
    resize(t, n, i, r) {
      return super.resize(t, n, i, r), this._svg && (wo(this._svg, {
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: `0 0 ${this._width} ${this._height}`
      }), this._root.setAttribute("transform", `translate(${this._origin})`)), this._dirty = [], this;
    }
    /**
     * Returns the SVG element of the visualization.
     * @return {DOMElement} - The SVG element.
     */
    canvas() {
      return this._svg;
    }
    /**
     * Returns an SVG text string for the rendered content,
     * or null if this renderer is currently headless.
     */
    svg() {
      const t = this._svg, n = this._bgcolor;
      if (!t) return null;
      let i;
      n && (t.removeAttribute("style"), i = rt(t, $l, "rect", it), wo(i, {
        width: this._width,
        height: this._height,
        fill: n
      }));
      const r = dD(t);
      return n && (t.removeChild(i), this._svg.style.setProperty("background-color", n)), r;
    }
    /**
     * Internal rendering method.
     * @param {object} scene - The root mark of a scenegraph to render.
     * @param {Array} markTypes - Array of the mark types to render.
     *                            If undefined, render all mark types
     */
    _render(t, n) {
      return this._dirtyCheck() && (this._dirtyAll && this._clearDefs(), this.mark(this._root, t, void 0, n), jn(this._root, 1)), this.defs(), this._dirty = [], ++this._dirtyID, this;
    }
    // -- Manage rendering of items marked as dirty --
    /**
     * Flag a mark item as dirty.
     * @param {Item} item - The mark item.
     */
    dirty(t) {
      t.dirty !== this._dirtyID && (t.dirty = this._dirtyID, this._dirty.push(t));
    }
    /**
     * Check if a mark item is considered dirty.
     * @param {Item} item - The mark item.
     */
    isDirty(t) {
      return this._dirtyAll || !t._svg || !t._svg.ownerSVGElement || t.dirty === this._dirtyID;
    }
    /**
     * Internal method to check dirty status and, if possible,
     * make targetted updates without a full rendering pass.
     */
    _dirtyCheck() {
      this._dirtyAll = !0;
      const t = this._dirty;
      if (!t.length || !this._dirtyID) return !0;
      const n = ++this._dirtyID;
      let i, r, o, s, a, u, l;
      for (a = 0, u = t.length; a < u; ++a)
        if (i = t[a], r = i.mark, r.marktype !== o && (o = r.marktype, s = In[o]), r.zdirty && r.dirty !== n && (this._dirtyAll = !1, RS(i, n), r.items.forEach((c) => {
          c.dirty = n;
        })), !r.zdirty) {
          if (i.exit) {
            s.nested && r.items.length ? (l = r.items[0], l._svg && this._update(s, l._svg, l)) : i._svg && (l = i._svg.parentNode, l && l.removeChild(i._svg)), i._svg = null;
            continue;
          }
          i = s.nested ? r.items[0] : i, i._update !== n && (!i._svg || !i._svg.ownerSVGElement ? (this._dirtyAll = !1, RS(i, n)) : this._update(s, i._svg, i), i._update = n);
        }
      return !this._dirtyAll;
    }
    // -- Construct & maintain scenegraph to SVG mapping ---
    /**
     * Render a set of mark items.
     * @param {SVGElement} el - The parent element in the SVG tree.
     * @param {object} scene - The mark parent to render.
     * @param {SVGElement} prev - The previous sibling in the SVG tree.
     * @param {Array} markTypes - Array of the mark types to render.
     *                            If undefined, render all mark types
     */
    mark(t, n, i, r) {
      if (!this.isDirty(n))
        return n._svg;
      const o = this._svg, s = n.marktype, a = In[s], u = n.interactive === !1 ? "none" : null, l = a.tag === "g", c = LS(n, t, i, "g", o);
      if (s !== "group" && r != null && !r.includes(s))
        return jn(c, 0), n._svg;
      c.setAttribute("class", J3(n));
      const f = lD(n);
      for (const p in f) Xt(c, p, f[p]);
      l || Xt(c, "pointer-events", u), Xt(c, "clip-path", n.clip ? Cx(this, n, n.group) : null);
      let d = null, h = 0;
      const g = (p) => {
        const m = this.isDirty(p), y = LS(p, c, d, a.tag, o);
        m && (this._update(a, y, p), l && jj(this, y, p, r)), d = y, ++h;
      };
      return a.nested ? n.items.length && g(n.items[0]) : _i(n, g), jn(c, h), c;
    }
    /**
     * Update the attributes of an SVG element for a mark item.
     * @param {object} mdef - The mark definition object
     * @param {SVGElement} el - The SVG element.
     * @param {Item} item - The mark item.
     */
    _update(t, n, i) {
      Pr = n, Pt = n.__values__, uD(dc, i), t.attr(dc, i, this);
      const r = Wj[t.type];
      r && r.call(this, t, n, i), Pr && this.style(Pr, i);
    }
    /**
     * Update the presentation attributes of an SVG element for a mark item.
     * @param {SVGElement} el - The SVG element.
     * @param {Item} item - The mark item.
     */
    style(t, n) {
      if (n != null) {
        for (const i in Bh) {
          let r = i === "font" ? xf(n) : n[i];
          if (r === Pt[i]) continue;
          const o = Bh[i];
          r == null ? t.removeAttribute(o) : ($x(r) && (r = $3(r, this._defs.gradient, pD())), t.setAttribute(o, r + "")), Pt[i] = r;
        }
        for (const i in Uh)
          Yd(t, Uh[i], n[i]);
      }
    }
    /**
     * Render SVG defs, as needed.
     * Must be called *after* marks have been processed to ensure the
     * collected state is current and accurate.
     */
    defs() {
      const t = this._svg, n = this._defs;
      let i = n.el, r = 0;
      for (const o in n.gradient)
        i || (n.el = i = rt(t, $l + 1, "defs", it)), r = Bj(i, n.gradient[o], r);
      for (const o in n.clipping)
        i || (n.el = i = rt(t, $l + 1, "defs", it)), r = Uj(i, n.clipping[o], r);
      i && (r === 0 ? (t.removeChild(i), n.el = null) : jn(i, r));
    }
    /**
     * Clear defs caches.
     */
    _clearDefs() {
      const t = this._defs;
      t.gradient = {}, t.clipping = {};
    }
  }
  function RS(e, t) {
    for (; e && e.dirty !== t; e = e.mark.group)
      if (e.dirty = t, e.mark && e.mark.dirty !== t)
        e.mark.dirty = t;
      else return;
  }
  function Bj(e, t, n) {
    let i, r, o;
    if (t.gradient === "radial") {
      let s = rt(e, n++, "pattern", it);
      wo(s, {
        id: Fh + t.id,
        viewBox: "0,0,1,1",
        width: "100%",
        height: "100%",
        preserveAspectRatio: "xMidYMid slice"
      }), s = rt(s, 0, "rect", it), wo(s, {
        width: 1,
        height: 1,
        fill: `url(${pD()}#${t.id})`
      }), e = rt(e, n++, "radialGradient", it), wo(e, {
        id: t.id,
        fx: t.x1,
        fy: t.y1,
        fr: t.r1,
        cx: t.x2,
        cy: t.y2,
        r: t.r2
      });
    } else
      e = rt(e, n++, "linearGradient", it), wo(e, {
        id: t.id,
        x1: t.x1,
        x2: t.x2,
        y1: t.y1,
        y2: t.y2
      });
    for (i = 0, r = t.stops.length; i < r; ++i)
      o = rt(e, i, "stop", it), o.setAttribute("offset", t.stops[i].offset), o.setAttribute("stop-color", t.stops[i].color);
    return jn(e, i), n;
  }
  function Uj(e, t, n) {
    let i;
    return e = rt(e, n, "clipPath", it), e.setAttribute("id", t.id), t.path ? (i = rt(e, 0, "path", it), i.setAttribute("d", t.path)) : (i = rt(e, 0, "rect", it), wo(i, {
      x: 0,
      y: 0,
      width: t.width,
      height: t.height
    })), jn(e, 1), n + 1;
  }
  function jj(e, t, n, i) {
    t = t.lastChild.previousSibling;
    let r, o = 0;
    _i(n, (s) => {
      r = e.mark(t, s, r, i), ++o;
    }), jn(t, 1 + o);
  }
  function LS(e, t, n, i, r) {
    let o = e._svg, s;
    if (!o && (s = t.ownerDocument, o = xo(s, i, it), e._svg = o, e.mark && (o.__data__ = e, o.__values__ = {
      fill: "default"
    }, i === "g"))) {
      const a = xo(s, "path", it);
      o.appendChild(a), a.__data__ = e;
      const u = xo(s, "g", it);
      o.appendChild(u), u.__data__ = e;
      const l = xo(s, "path", it);
      o.appendChild(l), l.__data__ = e, l.__values__ = {
        fill: "default"
      };
    }
    return (o.ownerSVGElement !== r || qj(o, n)) && t.insertBefore(o, n ? n.nextSibling : t.firstChild), o;
  }
  function qj(e, t) {
    return e.parentNode && e.parentNode.childNodes.length > 1 && e.previousSibling != t;
  }
  let Pr = null, Pt = null;
  const Wj = {
    group(e, t, n) {
      const i = Pr = t.childNodes[2];
      Pt = i.__values__, e.foreground(dc, n, this), Pt = t.__values__, Pr = t.childNodes[1], e.content(dc, n, this);
      const r = Pr = t.childNodes[0];
      e.background(dc, n, this);
      const o = n.mark.interactive === !1 ? "none" : null;
      if (o !== Pt.events && (Xt(i, "pointer-events", o), Xt(r, "pointer-events", o), Pt.events = o), n.strokeForeground && n.stroke) {
        const s = n.fill;
        Xt(i, "display", null), this.style(r, n), Xt(r, "stroke", null), s && (n.fill = null), Pt = i.__values__, this.style(i, n), s && (n.fill = s), Pr = null;
      } else
        Xt(i, "display", "none");
    },
    image(e, t, n) {
      n.smooth === !1 ? (Yd(t, "image-rendering", "optimizeSpeed"), Yd(t, "image-rendering", "pixelated")) : Yd(t, "image-rendering", null);
    },
    text(e, t, n) {
      const i = vf(n);
      let r, o, s, a;
      P(i) ? (o = i.map((u) => Uo(n, u)), r = o.join(`
`), r !== Pt.text && (jn(t, 0), s = t.ownerDocument, a = Bo(n), o.forEach((u, l) => {
        const c = xo(s, "tspan", it);
        c.__data__ = n, c.textContent = u, l && (c.setAttribute("x", 0), c.setAttribute("dy", a)), t.appendChild(c);
      }), Pt.text = r)) : (o = Uo(n, i), o !== Pt.text && (t.textContent = o, Pt.text = o)), Xt(t, "font-family", xf(n)), Xt(t, "font-size", gr(n) + "px"), Xt(t, "font-style", n.fontStyle), Xt(t, "font-variant", n.fontVariant), Xt(t, "font-weight", n.fontWeight);
    }
  };
  function dc(e, t, n) {
    t !== Pt[e] && (n ? Hj(Pr, e, t, n) : Xt(Pr, e, t), Pt[e] = t);
  }
  function Yd(e, t, n) {
    n !== Pt[t] && (n == null ? e.style.removeProperty(t) : e.style.setProperty(t, n + ""), Pt[t] = n);
  }
  function wo(e, t) {
    for (const n in t)
      Xt(e, n, t[n]);
  }
  function Xt(e, t, n) {
    n != null ? e.setAttribute(t, n) : e.removeAttribute(t);
  }
  function Hj(e, t, n, i) {
    n != null ? e.setAttributeNS(i, t, n) : e.removeAttributeNS(i, t);
  }
  function pD() {
    let e;
    return typeof window > "u" ? "" : (e = window.location).hash ? e.href.slice(0, -e.hash.length) : e.href;
  }
  class mD extends wf {
    constructor(t) {
      super(t), this._text = null, this._defs = {
        gradient: {},
        clipping: {}
      };
    }
    /**
     * Returns the rendered SVG text string,
     * or null if rendering has not yet occurred.
     */
    svg() {
      return this._text;
    }
    /**
     * Internal rendering method.
     * @param {object} scene - The root mark of a scenegraph to render.
     */
    _render(t) {
      const n = Kx();
      n.open("svg", ce({}, Rc, {
        class: "marks",
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: `0 0 ${this._width} ${this._height}`
      }));
      const i = this._bgcolor;
      return i && i !== "transparent" && i !== "none" && n.open("rect", {
        width: this._width,
        height: this._height,
        fill: i
      }).close(), n.open("g", gD, {
        transform: "translate(" + this._origin + ")"
      }), this.mark(n, t), n.close(), this.defs(n), this._text = n.close() + "", this;
    }
    /**
     * Render a set of mark items.
     * @param {object} m - The markup context.
     * @param {object} scene - The mark parent to render.
     */
    mark(t, n) {
      const i = In[n.marktype], r = i.tag, o = [uD, i.attr];
      t.open("g", {
        class: J3(n),
        "clip-path": n.clip ? Cx(this, n, n.group) : null
      }, lD(n), {
        "pointer-events": r !== "g" && n.interactive === !1 ? "none" : null
      });
      const s = (a) => {
        const u = this.href(a);
        if (u && t.open("a", u), t.open(r, this.attr(n, a, o, r !== "g" ? r : null)), r === "text") {
          const l = vf(a);
          if (P(l)) {
            const c = {
              x: 0,
              dy: Bo(a)
            };
            for (let f = 0; f < l.length; ++f)
              t.open("tspan", f ? c : null).text(Uo(a, l[f])).close();
          } else
            t.text(Uo(a, l));
        } else if (r === "g") {
          const l = a.strokeForeground, c = a.fill, f = a.stroke;
          l && f && (a.stroke = null), t.open("path", this.attr(n, a, i.background, "bgrect")).close(), t.open("g", this.attr(n, a, i.content)), _i(a, (d) => this.mark(t, d)), t.close(), l && f ? (c && (a.fill = null), a.stroke = f, t.open("path", this.attr(n, a, i.foreground, "bgrect")).close(), c && (a.fill = c)) : t.open("path", this.attr(n, a, i.foreground, "bgfore")).close();
        }
        t.close(), u && t.close();
      };
      return i.nested ? n.items && n.items.length && s(n.items[0]) : _i(n, s), t.close();
    }
    /**
     * Get href attributes for a hyperlinked mark item.
     * @param {Item} item - The mark item.
     */
    href(t) {
      const n = t.href;
      let i;
      if (n) {
        if (i = this._hrefs && this._hrefs[n])
          return i;
        this.sanitizeURL(n).then((r) => {
          r["xlink:href"] = r.href, r.href = null, (this._hrefs || (this._hrefs = {}))[n] = r;
        });
      }
      return null;
    }
    /**
     * Get an object of SVG attributes for a mark item.
     * @param {object} scene - The mark parent.
     * @param {Item} item - The mark item.
     * @param {array|function} attrs - One or more attribute emitters.
     * @param {string} tag - The tag being rendered.
     */
    attr(t, n, i, r) {
      const o = {}, s = (a, u, l, c) => {
        o[c || a] = u;
      };
      return Array.isArray(i) ? i.forEach((a) => a(s, n, this)) : i(s, n, this), r && Gj(o, n, t, r, this._defs), o;
    }
    /**
     * Render SVG defs, as needed.
     * Must be called *after* marks have been processed to ensure the
     * collected state is current and accurate.
     * @param {object} m - The markup context.
     */
    defs(t) {
      const n = this._defs.gradient, i = this._defs.clipping;
      if (Object.keys(n).length + Object.keys(i).length !== 0) {
        t.open("defs");
        for (const o in n) {
          const s = n[o], a = s.stops;
          s.gradient === "radial" ? (t.open("pattern", {
            id: Fh + o,
            viewBox: "0,0,1,1",
            width: "100%",
            height: "100%",
            preserveAspectRatio: "xMidYMid slice"
          }), t.open("rect", {
            width: "1",
            height: "1",
            fill: "url(#" + o + ")"
          }).close(), t.close(), t.open("radialGradient", {
            id: o,
            fx: s.x1,
            fy: s.y1,
            fr: s.r1,
            cx: s.x2,
            cy: s.y2,
            r: s.r2
          })) : t.open("linearGradient", {
            id: o,
            x1: s.x1,
            x2: s.x2,
            y1: s.y1,
            y2: s.y2
          });
          for (let u = 0; u < a.length; ++u)
            t.open("stop", {
              offset: a[u].offset,
              "stop-color": a[u].color
            }).close();
          t.close();
        }
        for (const o in i) {
          const s = i[o];
          t.open("clipPath", {
            id: o
          }), s.path ? t.open("path", {
            d: s.path
          }).close() : t.open("rect", {
            x: 0,
            y: 0,
            width: s.width,
            height: s.height
          }).close(), t.close();
        }
        t.close();
      }
    }
  }
  function Gj(e, t, n, i, r) {
    let o;
    if (t == null || (i === "bgrect" && n.interactive === !1 && (e["pointer-events"] = "none"), i === "bgfore" && (n.interactive === !1 && (e["pointer-events"] = "none"), e.display = "none", t.fill !== null)))
      return e;
    i === "image" && t.smooth === !1 && (o = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"]), i === "text" && (e["font-family"] = xf(t), e["font-size"] = gr(t) + "px", e["font-style"] = t.fontStyle, e["font-variant"] = t.fontVariant, e["font-weight"] = t.fontWeight);
    for (const s in Bh) {
      let a = t[s];
      const u = Bh[s];
      a === "transparent" && (u === "fill" || u === "stroke") || a != null && ($x(a) && (a = $3(a, r.gradient, "")), e[u] = a);
    }
    for (const s in Uh) {
      const a = t[s];
      a != null && (o = o || [], o.push(`${Uh[s]}: ${a};`));
    }
    return o && (e.style = o.join(" ")), e;
  }
  const li = {
    svgMarkTypes: ["text"],
    svgOnTop: !0,
    debug: !1
  };
  function Vj(e) {
    li.svgMarkTypes = e.svgMarkTypes ?? ["text"], li.svgOnTop = e.svgOnTop ?? !0, li.debug = e.debug ?? !1;
  }
  class oy extends wf {
    constructor(t) {
      super(t), this._svgRenderer = new Jx(t), this._canvasRenderer = new zh(t);
    }
    /**
     * Initialize a new HybridRenderer instance.
     * @param {DOMElement} el - The containing DOM element for the display.
     * @param {number} width - The coordinate width of the display, in pixels.
     * @param {number} height - The coordinate height of the display, in pixels.
     * @param {Array<number>} origin - The origin of the display, in pixels.
     *   The coordinate system will be translated to this point.
     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
     *   the width and height to determine the final pixel size.
     * @return {HybridRenderer} - This renderer instance.
     */
    initialize(t, n, i, r, o) {
      this._root_el = rt(t, 0, "div");
      const s = rt(this._root_el, 0, "div"), a = rt(this._root_el, 1, "div");
      return this._root_el.style.position = "relative", li.debug || (s.style.height = "100%", a.style.position = "absolute", a.style.top = "0", a.style.left = "0", a.style.height = "100%", a.style.width = "100%"), this._svgEl = li.svgOnTop ? a : s, this._canvasEl = li.svgOnTop ? s : a, this._svgEl.style.pointerEvents = "none", this._canvasRenderer.initialize(this._canvasEl, n, i, r, o), this._svgRenderer.initialize(this._svgEl, n, i, r, o), super.initialize(t, n, i, r, o);
    }
    /**
     * Flag a mark item as dirty.
     * @param {Item} item - The mark item.
     */
    dirty(t) {
      return li.svgMarkTypes.includes(t.mark.marktype) ? this._svgRenderer.dirty(t) : this._canvasRenderer.dirty(t), this;
    }
    /**
     * Internal rendering method.
     * @param {object} scene - The root mark of a scenegraph to render.
     * @param {Array} markTypes - Array of the mark types to render.
     *                            If undefined, render all mark types
     */
    _render(t, n) {
      const r = (n ?? ["arc", "area", "image", "line", "path", "rect", "rule", "shape", "symbol", "text", "trail"]).filter((o) => !li.svgMarkTypes.includes(o));
      this._svgRenderer.render(t, li.svgMarkTypes), this._canvasRenderer.render(t, r);
    }
    /**
     * Resize the display.
     * @param {number} width - The new coordinate width of the display, in pixels.
     * @param {number} height - The new coordinate height of the display, in pixels.
     * @param {Array<number>} origin - The new origin of the display, in pixels.
     *   The coordinate system will be translated to this point.
     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
     *   the width and height to determine the final pixel size.
     * @return {SVGRenderer} - This renderer instance;
     */
    resize(t, n, i, r) {
      return super.resize(t, n, i, r), this._svgRenderer.resize(t, n, i, r), this._canvasRenderer.resize(t, n, i, r), this;
    }
    background(t) {
      return li.svgOnTop ? this._canvasRenderer.background(t) : this._svgRenderer.background(t), this;
    }
  }
  class yD extends Ef {
    constructor(t, n) {
      super(t, n);
    }
    initialize(t, n, i) {
      const r = rt(rt(t, 0, "div"), li.svgOnTop ? 0 : 1, "div");
      return super.initialize(r, n, i);
    }
  }
  const bD = "canvas", vD = "hybrid", xD = "png", wD = "svg", ED = "none", Eo = {
    Canvas: bD,
    PNG: xD,
    SVG: wD,
    Hybrid: vD,
    None: ED
  }, Ys = {};
  Ys[bD] = Ys[xD] = {
    renderer: zh,
    headless: zh,
    handler: Ef
  };
  Ys[wD] = {
    renderer: Jx,
    headless: mD,
    handler: rD
  };
  Ys[vD] = {
    renderer: oy,
    headless: oy,
    handler: yD
  };
  Ys[ED] = {};
  function Np(e, t) {
    return e = String(e || "").toLowerCase(), arguments.length > 1 ? (Ys[e] = t, this) : Ys[e];
  }
  function _D(e, t, n) {
    const i = [], r = new nt().union(t), o = e.marktype;
    return o ? SD(e, r, n, i) : o === "group" ? $D(e, r, n, i) : R("Intersect scene must be mark node or group item.");
  }
  function SD(e, t, n, i) {
    if (Yj(e, t, n)) {
      const r = e.items, o = e.marktype, s = r.length;
      let a = 0;
      if (o === "group")
        for (; a < s; ++a)
          $D(r[a], t, n, i);
      else
        for (const u = In[o].isect; a < s; ++a) {
          const l = r[a];
          kD(l, t, u) && i.push(l);
        }
    }
    return i;
  }
  function Yj(e, t, n) {
    return e.bounds && t.intersects(e.bounds) && (e.marktype === "group" || e.interactive !== !1 && (!n || n(e)));
  }
  function $D(e, t, n, i) {
    n && n(e.mark) && kD(e, t, In.group.isect) && i.push(e);
    const r = e.items, o = r && r.length;
    if (o) {
      const s = e.x || 0, a = e.y || 0;
      t.translate(-s, -a);
      for (let u = 0; u < o; ++u)
        SD(r[u], t, n, i);
      t.translate(s, a);
    }
    return i;
  }
  function kD(e, t, n) {
    const i = e.bounds;
    return t.encloses(i) || t.intersects(i) && n(e, t);
  }
  const x0 = new nt();
  function AD(e) {
    const t = e.clip;
    if (fe(t))
      t(yf(x0.clear()));
    else if (t)
      x0.set(0, 0, e.group.width, e.group.height);
    else return;
    e.bounds.intersect(x0);
  }
  const Xj = 1e-9;
  function Qx(e, t, n) {
    return e === t ? !0 : n === "path" ? CD(e, t) : e instanceof Date && t instanceof Date ? +e == +t : $e(e) && $e(t) ? Math.abs(e - t) <= Xj : !e || !t || !Y(e) && !Y(t) ? e == t : Kj(e, t);
  }
  function CD(e, t) {
    return Qx(bu(e), bu(t));
  }
  function Kj(e, t) {
    var n = Object.keys(e), i = Object.keys(t), r, o;
    if (n.length !== i.length) return !1;
    for (n.sort(), i.sort(), o = n.length - 1; o >= 0; o--)
      if (n[o] != i[o]) return !1;
    for (o = n.length - 1; o >= 0; o--)
      if (r = n[o], !Qx(e[r], t[r], r)) return !1;
    return typeof e == typeof t;
  }
  function Jj() {
    D3(), wB();
  }
  const wu = "top", gi = "left", pi = "right", jo = "bottom", Qj = "top-left", Zj = "top-right", eq = "bottom-left", tq = "bottom-right", Zx = "start", sy = "middle", Kt = "end", nq = "x", iq = "y", Op = "group", e2 = "axis", t2 = "title", rq = "frame", oq = "scope", n2 = "legend", FD = "row-header", MD = "row-footer", TD = "row-title", DD = "column-header", ND = "column-footer", OD = "column-title", sq = "padding", aq = "symbol", RD = "fit", LD = "fit-x", PD = "fit-y", uq = "pad", i2 = "none", od = "all", ay = "each", r2 = "flush", _o = "column", So = "row";
  function ID(e) {
    N.call(this, null, e);
  }
  G(ID, N, {
    transform(e, t) {
      const n = t.dataflow, i = e.mark, r = i.marktype, o = In[r], s = o.bound;
      let a = i.bounds, u;
      if (o.nested)
        i.items.length && n.dirty(i.items[0]), a = sd(i, s), i.items.forEach((l) => {
          l.bounds.clear().union(a);
        });
      else if (r === Op || e.modified())
        switch (t.visit(t.MOD, (l) => n.dirty(l)), a.clear(), i.items.forEach((l) => a.union(sd(l, s))), i.role) {
          case e2:
          case n2:
          case t2:
            t.reflow();
        }
      else
        u = t.changed(t.REM), t.visit(t.ADD, (l) => {
          a.union(sd(l, s));
        }), t.visit(t.MOD, (l) => {
          u = u || a.alignsWith(l.bounds), n.dirty(l), a.union(sd(l, s));
        }), u && (a.clear(), i.items.forEach((l) => a.union(l.bounds)));
      return AD(i), t.modifies("bounds");
    }
  });
  function sd(e, t, n) {
    return t(e.bounds.clear(), e, n);
  }
  const PS = ":vega_identifier:";
  function o2(e) {
    N.call(this, 0, e);
  }
  o2.Definition = {
    type: "Identifier",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "as",
      type: "string",
      required: !0
    }]
  };
  G(o2, N, {
    transform(e, t) {
      const n = lq(t.dataflow), i = e.as;
      let r = n.value;
      return t.visit(t.ADD, (o) => o[i] = o[i] || ++r), n.set(this.value = r), t;
    }
  });
  function lq(e) {
    return e._signals[PS] || (e._signals[PS] = e.add(0));
  }
  function zD(e) {
    N.call(this, null, e);
  }
  G(zD, N, {
    transform(e, t) {
      let n = this.value;
      n || (n = t.dataflow.scenegraph().mark(e.markdef, cq(e), e.index), n.group.context = e.context, e.context.group || (e.context.group = n.group), n.source = this.source, n.clip = e.clip, n.interactive = e.interactive, this.value = n);
      const i = n.marktype === Op ? $p : Sp;
      return t.visit(t.ADD, (r) => i.call(r, n)), (e.modified("clip") || e.modified("interactive")) && (n.clip = e.clip, n.interactive = !!e.interactive, n.zdirty = !0, t.reflow()), n.items = t.source, t;
    }
  });
  function cq(e) {
    const t = e.groups, n = e.parent;
    return t && t.size === 1 ? t.get(Object.keys(t.object)[0]) : t && n ? t.lookup(n) : null;
  }
  function BD(e) {
    N.call(this, null, e);
  }
  const IS = {
    parity: (e) => e.filter((t, n) => n % 2 ? t.opacity = 0 : 1),
    greedy: (e, t) => {
      let n;
      return e.filter((i, r) => !r || !UD(n.bounds, i.bounds, t) ? (n = i, 1) : i.opacity = 0);
    }
  }, UD = (e, t, n) => n > Math.max(t.x1 - e.x2, e.x1 - t.x2, t.y1 - e.y2, e.y1 - t.y2), zS = (e, t) => {
    for (var n = 1, i = e.length, r = e[0].bounds, o; n < i; r = o, ++n)
      if (UD(r, o = e[n].bounds, t)) return !0;
  }, fq = (e) => {
    const t = e.bounds;
    return t.width() > 1 && t.height() > 1;
  }, dq = (e, t, n) => {
    var i = e.range(), r = new nt();
    return t === wu || t === jo ? r.set(i[0], -1 / 0, i[1], 1 / 0) : r.set(-1 / 0, i[0], 1 / 0, i[1]), r.expand(n || 1), (o) => r.encloses(o.bounds);
  }, BS = (e) => (e.forEach((t) => t.opacity = 1), e), US = (e, t) => e.reflow(t.modified()).modifies("opacity");
  G(BD, N, {
    transform(e, t) {
      const n = IS[e.method] || IS.parity, i = e.separation || 0;
      let r = t.materialize(t.SOURCE).source, o, s;
      if (!r || !r.length) return;
      if (!e.method)
        return e.modified("method") && (BS(r), t = US(t, e)), t;
      if (r = r.filter(fq), !r.length) return;
      if (e.sort && (r = r.slice().sort(e.sort)), o = BS(r), t = US(t, e), o.length >= 3 && zS(o, i)) {
        do
          o = n(o, i);
        while (o.length >= 3 && zS(o, i));
        o.length < 3 && !xe(r).opacity && (o.length > 1 && (xe(o).opacity = 0), xe(r).opacity = 1);
      }
      e.boundScale && e.boundTolerance >= 0 && (s = dq(e.boundScale, e.boundOrient, +e.boundTolerance), r.forEach((u) => {
        s(u) || (u.opacity = 0);
      }));
      const a = o[0].mark.bounds.clear();
      return r.forEach((u) => {
        u.opacity && a.union(u.bounds);
      }), t;
    }
  });
  function jD(e) {
    N.call(this, null, e);
  }
  G(jD, N, {
    transform(e, t) {
      const n = t.dataflow;
      if (t.visit(t.ALL, (i) => n.dirty(i)), t.fields && t.fields.zindex) {
        const i = t.source && t.source[0];
        i && (i.mark.zdirty = !0);
      }
    }
  });
  const Lt = new nt();
  function Va(e, t, n) {
    return e[t] === n ? 0 : (e[t] = n, 1);
  }
  function hq(e) {
    var t = e.items[0].orient;
    return t === gi || t === pi;
  }
  function gq(e) {
    let t = +e.grid;
    return [
      e.ticks ? t++ : -1,
      // ticks index
      e.labels ? t++ : -1,
      // labels index
      t + +e.domain
      // title index
    ];
  }
  function pq(e, t, n, i) {
    var r = t.items[0], o = r.datum, s = r.translate != null ? r.translate : 0.5, a = r.orient, u = gq(o), l = r.range, c = r.offset, f = r.position, d = r.minExtent, h = r.maxExtent, g = o.title && r.items[u[2]].items[0], p = r.titlePadding, m = r.bounds, y = g && Ux(g), b = 0, v = 0, x, w;
    switch (Lt.clear().union(m), m.clear(), (x = u[0]) > -1 && m.union(r.items[x].bounds), (x = u[1]) > -1 && m.union(r.items[x].bounds), a) {
      case wu:
        b = f || 0, v = -c, w = Math.max(d, Math.min(h, -m.y1)), m.add(0, -w).add(l, 0), g && ad(e, g, w, p, y, 0, -1, m);
        break;
      case gi:
        b = -c, v = f || 0, w = Math.max(d, Math.min(h, -m.x1)), m.add(-w, 0).add(0, l), g && ad(e, g, w, p, y, 1, -1, m);
        break;
      case pi:
        b = n + c, v = f || 0, w = Math.max(d, Math.min(h, m.x2)), m.add(0, 0).add(w, l), g && ad(e, g, w, p, y, 1, 1, m);
        break;
      case jo:
        b = f || 0, v = i + c, w = Math.max(d, Math.min(h, m.y2)), m.add(0, 0).add(l, w), g && ad(e, g, w, p, 0, 0, 1, m);
        break;
      default:
        b = r.x, v = r.y;
    }
    return Qr(m.translate(b, v), r), Va(r, "x", b + s) | Va(r, "y", v + s) && (r.bounds = Lt, e.dirty(r), r.bounds = m, e.dirty(r)), r.mark.bounds.clear().union(m);
  }
  function ad(e, t, n, i, r, o, s, a) {
    const u = t.bounds;
    if (t.auto) {
      const l = s * (n + r + i);
      let c = 0, f = 0;
      e.dirty(t), o ? c = (t.x || 0) - (t.x = l) : f = (t.y || 0) - (t.y = l), t.mark.bounds.clear().union(u.translate(-c, -f)), e.dirty(t);
    }
    a.union(u);
  }
  const jS = (e, t) => Math.floor(Math.min(e, t)), qS = (e, t) => Math.ceil(Math.max(e, t));
  function mq(e) {
    var t = e.items, n = t.length, i = 0, r, o;
    const s = {
      marks: [],
      rowheaders: [],
      rowfooters: [],
      colheaders: [],
      colfooters: [],
      rowtitle: null,
      coltitle: null
    };
    for (; i < n; ++i)
      if (r = t[i], o = r.items, r.marktype === Op)
        switch (r.role) {
          case e2:
          case n2:
          case t2:
            break;
          case FD:
            s.rowheaders.push(...o);
            break;
          case MD:
            s.rowfooters.push(...o);
            break;
          case DD:
            s.colheaders.push(...o);
            break;
          case ND:
            s.colfooters.push(...o);
            break;
          case TD:
            s.rowtitle = o[0];
            break;
          case OD:
            s.coltitle = o[0];
            break;
          default:
            s.marks.push(...o);
        }
    return s;
  }
  function yq(e) {
    return new nt().set(0, 0, e.width || 0, e.height || 0);
  }
  function bq(e) {
    const t = e.bounds.clone();
    return t.empty() ? t.set(0, 0, 0, 0) : t.translate(-(e.x || 0), -(e.y || 0));
  }
  function je(e, t, n) {
    const i = Y(e) ? e[t] : e;
    return i ?? (n !== void 0 ? n : 0);
  }
  function WS(e) {
    return e < 0 ? Math.ceil(-e) : 0;
  }
  function qD(e, t, n) {
    var i = !n.nodirty, r = n.bounds === r2 ? yq : bq, o = Lt.set(0, 0, 0, 0), s = je(n.align, _o), a = je(n.align, So), u = je(n.padding, _o), l = je(n.padding, So), c = n.columns || t.length, f = c <= 0 ? 1 : Math.ceil(t.length / c), d = t.length, h = Array(d), g = Array(c), p = 0, m = Array(d), y = Array(f), b = 0, v = Array(d), x = Array(d), w = Array(d), _, E, S, $, F, A, D, k, M, C, T;
    for (E = 0; E < c; ++E) g[E] = 0;
    for (E = 0; E < f; ++E) y[E] = 0;
    for (E = 0; E < d; ++E)
      A = t[E], F = w[E] = r(A), A.x = A.x || 0, v[E] = 0, A.y = A.y || 0, x[E] = 0, S = E % c, $ = ~~(E / c), p = Math.max(p, D = Math.ceil(F.x2)), b = Math.max(b, k = Math.ceil(F.y2)), g[S] = Math.max(g[S], D), y[$] = Math.max(y[$], k), h[E] = u + WS(F.x1), m[E] = l + WS(F.y1), i && e.dirty(t[E]);
    for (E = 0; E < d; ++E)
      E % c === 0 && (h[E] = 0), E < c && (m[E] = 0);
    if (s === ay)
      for (S = 1; S < c; ++S) {
        for (T = 0, E = S; E < d; E += c)
          T < h[E] && (T = h[E]);
        for (E = S; E < d; E += c)
          h[E] = T + g[S - 1];
      }
    else if (s === od) {
      for (T = 0, E = 0; E < d; ++E)
        E % c && T < h[E] && (T = h[E]);
      for (E = 0; E < d; ++E)
        E % c && (h[E] = T + p);
    } else
      for (s = !1, S = 1; S < c; ++S)
        for (E = S; E < d; E += c)
          h[E] += g[S - 1];
    if (a === ay)
      for ($ = 1; $ < f; ++$) {
        for (T = 0, E = $ * c, _ = E + c; E < _; ++E)
          T < m[E] && (T = m[E]);
        for (E = $ * c; E < _; ++E)
          m[E] = T + y[$ - 1];
      }
    else if (a === od) {
      for (T = 0, E = c; E < d; ++E)
        T < m[E] && (T = m[E]);
      for (E = c; E < d; ++E)
        m[E] = T + b;
    } else
      for (a = !1, $ = 1; $ < f; ++$)
        for (E = $ * c, _ = E + c; E < _; ++E)
          m[E] += y[$ - 1];
    for (M = 0, E = 0; E < d; ++E)
      M = h[E] + (E % c ? M : 0), v[E] += M - t[E].x;
    for (S = 0; S < c; ++S)
      for (C = 0, E = S; E < d; E += c)
        C += m[E], x[E] += C - t[E].y;
    if (s && je(n.center, _o) && f > 1)
      for (E = 0; E < d; ++E)
        F = s === od ? p : g[E % c], M = F - w[E].x2 - t[E].x - v[E], M > 0 && (v[E] += M / 2);
    if (a && je(n.center, So) && c !== 1)
      for (E = 0; E < d; ++E)
        F = a === od ? b : y[~~(E / c)], C = F - w[E].y2 - t[E].y - x[E], C > 0 && (x[E] += C / 2);
    for (E = 0; E < d; ++E)
      o.union(w[E].translate(v[E], x[E]));
    switch (M = je(n.anchor, nq), C = je(n.anchor, iq), je(n.anchor, _o)) {
      case Kt:
        M -= o.width();
        break;
      case sy:
        M -= o.width() / 2;
    }
    switch (je(n.anchor, So)) {
      case Kt:
        C -= o.height();
        break;
      case sy:
        C -= o.height() / 2;
    }
    for (M = Math.round(M), C = Math.round(C), o.clear(), E = 0; E < d; ++E)
      t[E].mark.bounds.clear();
    for (E = 0; E < d; ++E)
      A = t[E], A.x += v[E] += M, A.y += x[E] += C, o.union(A.mark.bounds.union(A.bounds.translate(v[E], x[E]))), i && e.dirty(A);
    return o;
  }
  function vq(e, t, n) {
    var i = mq(t), r = i.marks, o = n.bounds === r2 ? xq : wq, s = n.offset, a = n.columns || r.length, u = a <= 0 ? 1 : Math.ceil(r.length / a), l = u * a, c, f, d, h, g, p, m;
    const y = qD(e, r, n);
    y.empty() && y.set(0, 0, 0, 0), i.rowheaders && (p = je(n.headerBand, So, null), c = ud(e, i.rowheaders, r, a, u, -je(s, "rowHeader"), jS, 0, o, "x1", 0, a, 1, p)), i.colheaders && (p = je(n.headerBand, _o, null), f = ud(e, i.colheaders, r, a, a, -je(s, "columnHeader"), jS, 1, o, "y1", 0, 1, a, p)), i.rowfooters && (p = je(n.footerBand, So, null), d = ud(e, i.rowfooters, r, a, u, je(s, "rowFooter"), qS, 0, o, "x2", a - 1, a, 1, p)), i.colfooters && (p = je(n.footerBand, _o, null), h = ud(e, i.colfooters, r, a, a, je(s, "columnFooter"), qS, 1, o, "y2", l - a, 1, a, p)), i.rowtitle && (g = je(n.titleAnchor, So), m = je(s, "rowTitle"), m = g === Kt ? d + m : c - m, p = je(n.titleBand, So, 0.5), HS(e, i.rowtitle, m, 0, y, p)), i.coltitle && (g = je(n.titleAnchor, _o), m = je(s, "columnTitle"), m = g === Kt ? h + m : f - m, p = je(n.titleBand, _o, 0.5), HS(e, i.coltitle, m, 1, y, p));
  }
  function xq(e, t) {
    return t === "x1" ? e.x || 0 : t === "y1" ? e.y || 0 : t === "x2" ? (e.x || 0) + (e.width || 0) : t === "y2" ? (e.y || 0) + (e.height || 0) : void 0;
  }
  function wq(e, t) {
    return e.bounds[t];
  }
  function ud(e, t, n, i, r, o, s, a, u, l, c, f, d, h) {
    var g = n.length, p = 0, m = 0, y, b, v, x, w, _, E, S, $;
    if (!g) return p;
    for (y = c; y < g; y += f)
      n[y] && (p = s(p, u(n[y], l)));
    if (!t.length) return p;
    for (t.length > r && (e.warn("Grid headers exceed limit: " + r), t = t.slice(0, r)), p += o, b = 0, x = t.length; b < x; ++b)
      e.dirty(t[b]), t[b].mark.bounds.clear();
    for (y = c, b = 0, x = t.length; b < x; ++b, y += f) {
      for (_ = t[b], w = _.mark.bounds, v = y; v >= 0 && (E = n[v]) == null; v -= d) ;
      a ? (S = h == null ? E.x : Math.round(E.bounds.x1 + h * E.bounds.width()), $ = p) : (S = p, $ = h == null ? E.y : Math.round(E.bounds.y1 + h * E.bounds.height())), w.union(_.bounds.translate(S - (_.x || 0), $ - (_.y || 0))), _.x = S, _.y = $, e.dirty(_), m = s(m, w[l]);
    }
    return m;
  }
  function HS(e, t, n, i, r, o) {
    if (t) {
      e.dirty(t);
      var s = n, a = n;
      i ? s = Math.round(r.x1 + o * r.width()) : a = Math.round(r.y1 + o * r.height()), t.bounds.translate(s - (t.x || 0), a - (t.y || 0)), t.mark.bounds.clear().union(t.bounds), t.x = s, t.y = a, e.dirty(t);
    }
  }
  function Eq(e, t) {
    const n = e[t] || {};
    return (i, r) => n[i] != null ? n[i] : e[i] != null ? e[i] : r;
  }
  function _q(e, t) {
    let n = -1 / 0;
    return e.forEach((i) => {
      i.offset != null && (n = Math.max(n, i.offset));
    }), n > -1 / 0 ? n : t;
  }
  function Sq(e, t, n, i, r, o, s) {
    const a = Eq(n, t), u = _q(e, a("offset", 0)), l = a("anchor", Zx), c = l === Kt ? 1 : l === sy ? 0.5 : 0, f = {
      align: ay,
      bounds: a("bounds", r2),
      columns: a("direction") === "vertical" ? 1 : e.length,
      padding: a("margin", 8),
      center: a("center"),
      nodirty: !0
    };
    switch (t) {
      case gi:
        f.anchor = {
          x: Math.floor(i.x1) - u,
          column: Kt,
          y: c * (s || i.height() + 2 * i.y1),
          row: l
        };
        break;
      case pi:
        f.anchor = {
          x: Math.ceil(i.x2) + u,
          y: c * (s || i.height() + 2 * i.y1),
          row: l
        };
        break;
      case wu:
        f.anchor = {
          y: Math.floor(r.y1) - u,
          row: Kt,
          x: c * (o || r.width() + 2 * r.x1),
          column: l
        };
        break;
      case jo:
        f.anchor = {
          y: Math.ceil(r.y2) + u,
          x: c * (o || r.width() + 2 * r.x1),
          column: l
        };
        break;
      case Qj:
        f.anchor = {
          x: u,
          y: u
        };
        break;
      case Zj:
        f.anchor = {
          x: o - u,
          y: u,
          column: Kt
        };
        break;
      case eq:
        f.anchor = {
          x: u,
          y: s - u,
          row: Kt
        };
        break;
      case tq:
        f.anchor = {
          x: o - u,
          y: s - u,
          column: Kt,
          row: Kt
        };
        break;
    }
    return f;
  }
  function $q(e, t) {
    var n = t.items[0], i = n.datum, r = n.orient, o = n.bounds, s = n.x, a = n.y, u, l;
    return n._bounds ? n._bounds.clear().union(o) : n._bounds = o.clone(), o.clear(), Aq(e, n, n.items[0].items[0]), o = kq(n, o), u = 2 * n.padding, l = 2 * n.padding, o.empty() || (u = Math.ceil(o.width() + u), l = Math.ceil(o.height() + l)), i.type === aq && Cq(n.items[0].items[0].items[0].items), r !== i2 && (n.x = s = 0, n.y = a = 0), n.width = u, n.height = l, Qr(o.set(s, a, s + u, a + l), n), n.mark.bounds.clear().union(o), n;
  }
  function kq(e, t) {
    return e.items.forEach((n) => t.union(n.bounds)), t.x1 = e.padding, t.y1 = e.padding, t;
  }
  function Aq(e, t, n) {
    var i = t.padding, r = i - n.x, o = i - n.y;
    if (!t.datum.title)
      (r || o) && kl(e, n, r, o);
    else {
      var s = t.items[1].items[0], a = s.anchor, u = t.titlePadding || 0, l = i - s.x, c = i - s.y;
      switch (s.orient) {
        case gi:
          r += Math.ceil(s.bounds.width()) + u;
          break;
        case pi:
        case jo:
          break;
        default:
          o += s.bounds.height() + u;
      }
      switch ((r || o) && kl(e, n, r, o), s.orient) {
        case gi:
          c += Da(t, n, s, a, 1, 1);
          break;
        case pi:
          l += Da(t, n, s, Kt, 0, 0) + u, c += Da(t, n, s, a, 1, 1);
          break;
        case jo:
          l += Da(t, n, s, a, 0, 0), c += Da(t, n, s, Kt, -1, 0, 1) + u;
          break;
        default:
          l += Da(t, n, s, a, 0, 0);
      }
      (l || c) && kl(e, s, l, c), (l = Math.round(s.bounds.x1 - i)) < 0 && (kl(e, n, -l, 0), kl(e, s, -l, 0));
    }
  }
  function Da(e, t, n, i, r, o, s) {
    const a = e.datum.type !== "symbol", u = n.datum.vgrad, l = a && (o || !u) && !s ? t.items[0] : t, c = l.bounds[r ? "y2" : "x2"] - e.padding, f = u && o ? c : 0, d = u && o ? 0 : c, h = r <= 0 ? 0 : Ux(n);
    return Math.round(i === Zx ? f : i === Kt ? d - h : 0.5 * (c - h));
  }
  function kl(e, t, n, i) {
    t.x += n, t.y += i, t.bounds.translate(n, i), t.mark.bounds.translate(n, i), e.dirty(t);
  }
  function Cq(e) {
    const t = e.reduce((n, i) => (n[i.column] = Math.max(i.bounds.x2 - i.x, n[i.column] || 0), n), {});
    e.forEach((n) => {
      n.width = t[n.column], n.height = n.bounds.y2 - n.y;
    });
  }
  function Fq(e, t, n, i, r) {
    var o = t.items[0], s = o.frame, a = o.orient, u = o.anchor, l = o.offset, c = o.padding, f = o.items[0].items[0], d = o.items[1] && o.items[1].items[0], h = a === gi || a === pi ? i : n, g = 0, p = 0, m = 0, y = 0, b = 0, v;
    if (s !== Op ? a === gi ? (g = r.y2, h = r.y1) : a === pi ? (g = r.y1, h = r.y2) : (g = r.x1, h = r.x2) : a === gi && (g = i, h = 0), v = u === Zx ? g : u === Kt ? h : (g + h) / 2, d && d.text) {
      switch (a) {
        case wu:
        case jo:
          b = f.bounds.height() + c;
          break;
        case gi:
          y = f.bounds.width() + c;
          break;
        case pi:
          y = -f.bounds.width() - c;
          break;
      }
      Lt.clear().union(d.bounds), Lt.translate(y - (d.x || 0), b - (d.y || 0)), Va(d, "x", y) | Va(d, "y", b) && (e.dirty(d), d.bounds.clear().union(Lt), d.mark.bounds.clear().union(Lt), e.dirty(d)), Lt.clear().union(d.bounds);
    } else
      Lt.clear();
    switch (Lt.union(f.bounds), a) {
      case wu:
        p = v, m = r.y1 - Lt.height() - l;
        break;
      case gi:
        p = r.x1 - Lt.width() - l, m = v;
        break;
      case pi:
        p = r.x2 + Lt.width() + l, m = v;
        break;
      case jo:
        p = v, m = r.y2 + l;
        break;
      default:
        p = o.x, m = o.y;
    }
    return Va(o, "x", p) | Va(o, "y", m) && (Lt.translate(p, m), e.dirty(o), o.bounds.clear().union(Lt), t.bounds.clear().union(Lt), e.dirty(o)), o.bounds;
  }
  function WD(e) {
    N.call(this, null, e);
  }
  G(WD, N, {
    transform(e, t) {
      const n = t.dataflow;
      return e.mark.items.forEach((i) => {
        e.layout && vq(n, i, e.layout), Tq(n, i, e);
      }), Mq(e.mark.group) ? t.reflow() : t;
    }
  });
  function Mq(e) {
    return e && e.mark.role !== "legend-entry";
  }
  function Tq(e, t, n) {
    var i = t.items, r = Math.max(0, t.width || 0), o = Math.max(0, t.height || 0), s = new nt().set(0, 0, r, o), a = s.clone(), u = s.clone(), l = [], c, f, d, h, g, p;
    for (g = 0, p = i.length; g < p; ++g)
      switch (f = i[g], f.role) {
        case e2:
          h = hq(f) ? a : u, h.union(pq(e, f, r, o));
          break;
        case t2:
          c = f;
          break;
        case n2:
          l.push($q(e, f));
          break;
        case rq:
        case oq:
        case FD:
        case MD:
        case TD:
        case DD:
        case ND:
        case OD:
          a.union(f.bounds), u.union(f.bounds);
          break;
        default:
          s.union(f.bounds);
      }
    if (l.length) {
      const m = {};
      l.forEach((y) => {
        d = y.orient || pi, d !== i2 && (m[d] || (m[d] = [])).push(y);
      });
      for (const y in m) {
        const b = m[y];
        qD(e, b, Sq(b, y, n.legends, a, u, r, o));
      }
      l.forEach((y) => {
        const b = y.bounds;
        if (b.equals(y._bounds) || (y.bounds = y._bounds, e.dirty(y), y.bounds = b, e.dirty(y)), n.autosize && (n.autosize.type === RD || n.autosize.type === LD || n.autosize.type === PD))
          switch (y.orient) {
            case gi:
            case pi:
              s.add(b.x1, 0).add(b.x2, 0);
              break;
            case wu:
            case jo:
              s.add(0, b.y1).add(0, b.y2);
          }
        else
          s.union(b);
      });
    }
    s.union(a).union(u), c && s.union(Fq(e, c, r, o, s)), t.clip && s.set(0, 0, t.width || 0, t.height || 0), Dq(e, t, s, n);
  }
  function Dq(e, t, n, i) {
    const r = i.autosize || {}, o = r.type;
    if (e._autosize < 1 || !o) return;
    let s = e._width, a = e._height, u = Math.max(0, t.width || 0), l = Math.max(0, Math.ceil(-n.x1)), c = Math.max(0, t.height || 0), f = Math.max(0, Math.ceil(-n.y1));
    const d = Math.max(0, Math.ceil(n.x2 - u)), h = Math.max(0, Math.ceil(n.y2 - c));
    if (r.contains === sq) {
      const g = e.padding();
      s -= g.left + g.right, a -= g.top + g.bottom;
    }
    o === i2 ? (l = 0, f = 0, u = s, c = a) : o === RD ? (u = Math.max(0, s - l - d), c = Math.max(0, a - f - h)) : o === LD ? (u = Math.max(0, s - l - d), a = c + f + h) : o === PD ? (s = u + l + d, c = Math.max(0, a - f - h)) : o === uq && (s = u + l + d, a = c + f + h), e._resizeView(s, a, u, c, [l, f], r.resize);
  }
  const Nq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    bound: ID,
    identifier: o2,
    mark: zD,
    overlap: BD,
    render: jD,
    viewlayout: WD
  }, Symbol.toStringTag, { value: "Module" }));
  function HD(e) {
    N.call(this, null, e);
  }
  G(HD, N, {
    transform(e, t) {
      if (this.value && !e.modified())
        return t.StopPropagation;
      var n = t.dataflow.locale(), i = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = this.value, o = e.scale, s = e.count == null ? e.values ? e.values.length : 10 : e.count, a = _x(o, s, e.minstep), u = e.format || b3(n, o, a, e.formatSpecifier, e.formatType, !!e.values), l = e.values ? y3(o, e.values, a) : Sx(o, a);
      return r && (i.rem = r), r = l.map((c, f) => Ce({
        index: f / (l.length - 1 || 1),
        value: c,
        label: u(c)
      })), e.extra && r.length && r.push(Ce({
        index: -1,
        extra: {
          value: r[0].value
        },
        label: ""
      })), i.source = r, i.add = r, this.value = r, i;
    }
  });
  function GD(e) {
    N.call(this, null, e);
  }
  function Oq() {
    return Ce({});
  }
  function Rq(e) {
    const t = Gu().test((n) => n.exit);
    return t.lookup = (n) => t.get(e(n)), t;
  }
  G(GD, N, {
    transform(e, t) {
      var n = t.dataflow, i = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = e.item || Oq, o = e.key || re, s = this.value;
      return P(i.encode) && (i.encode = null), s && (e.modified("key") || t.modified(o)) && R("DataJoin does not support modified key function or fields."), s || (t = t.addAll(), this.value = s = Rq(o)), t.visit(t.ADD, (a) => {
        const u = o(a);
        let l = s.get(u);
        l ? l.exit ? (s.empty--, i.add.push(l)) : i.mod.push(l) : (l = r(a), s.set(u, l), i.add.push(l)), l.datum = a, l.exit = !1;
      }), t.visit(t.MOD, (a) => {
        const u = o(a), l = s.get(u);
        l && (l.datum = a, i.mod.push(l));
      }), t.visit(t.REM, (a) => {
        const u = o(a), l = s.get(u);
        a === l.datum && !l.exit && (i.rem.push(l), l.exit = !0, ++s.empty);
      }), t.changed(t.ADD_MOD) && i.modifies("datum"), (t.clean() || e.clean && s.empty > n.cleanThreshold) && n.runAfter(s.clean), i;
    }
  });
  function VD(e) {
    N.call(this, null, e);
  }
  G(VD, N, {
    transform(e, t) {
      var n = t.fork(t.ADD_REM), i = e.mod || !1, r = e.encoders, o = t.encode;
      if (P(o))
        if (n.changed() || o.every((f) => r[f]))
          o = o[0], n.encode = null;
        else
          return t.StopPropagation;
      var s = o === "enter", a = r.update || lo, u = r.enter || lo, l = r.exit || lo, c = (o && !s ? r[o] : a) || lo;
      if (t.changed(t.ADD) && (t.visit(t.ADD, (f) => {
        u(f, e), a(f, e);
      }), n.modifies(u.output), n.modifies(a.output), c !== lo && c !== a && (t.visit(t.ADD, (f) => {
        c(f, e);
      }), n.modifies(c.output))), t.changed(t.REM) && l !== lo && (t.visit(t.REM, (f) => {
        l(f, e);
      }), n.modifies(l.output)), s || c !== lo) {
        const f = t.MOD | (e.modified() ? t.REFLOW : 0);
        s ? (t.visit(f, (d) => {
          const h = u(d, e) || i;
          (c(d, e) || h) && n.mod.push(d);
        }), n.mod.length && n.modifies(u.output)) : t.visit(f, (d) => {
          (c(d, e) || i) && n.mod.push(d);
        }), n.mod.length && n.modifies(c.output);
      }
      return n.changed() ? n : t.StopPropagation;
    }
  });
  function YD(e) {
    N.call(this, [], e);
  }
  G(YD, N, {
    transform(e, t) {
      if (this.value != null && !e.modified())
        return t.StopPropagation;
      var n = t.dataflow.locale(), i = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = this.value, o = e.type || Bd, s = e.scale, a = +e.limit, u = _x(s, e.count == null ? 5 : e.count, e.minstep), l = !!e.values || o === Bd, c = e.format || E3(n, s, u, o, e.formatSpecifier, e.formatType, l), f = e.values || w3(s, u), d, h, g, p, m;
      return r && (i.rem = r), o === Bd ? (a && f.length > a ? (t.dataflow.warn("Symbol legend count exceeds limit, filtering items."), r = f.slice(0, a - 1), m = !0) : r = f, fe(g = e.size) ? (!e.values && s(r[0]) === 0 && (r = r.slice(1)), p = r.reduce((y, b) => Math.max(y, g(b, e)), 0)) : g = Gt(p = g || 8), r = r.map((y, b) => Ce({
        index: b,
        label: c(y, b, r),
        value: y,
        offset: p,
        size: g(y, e)
      })), m && (m = f[r.length], r.push(Ce({
        index: r.length,
        label: `…${f.length - r.length} entries`,
        value: m,
        offset: p,
        size: g(m, e)
      })))) : o === uB ? (d = s.domain(), h = g3(s, d[0], xe(d)), f.length < 3 && !e.values && d[0] !== xe(d) && (f = [d[0], xe(d)]), r = f.map((y, b) => Ce({
        index: b,
        label: c(y, b, f),
        value: y,
        perc: h(y)
      }))) : (g = f.length - 1, h = vB(s), r = f.map((y, b) => Ce({
        index: b,
        label: c(y, b, f),
        value: y,
        perc: b ? h(y) : 0,
        perc2: b === g ? 1 : h(f[b + 1])
      }))), i.source = r, i.add = r, this.value = r, i;
    }
  });
  const Lq = (e) => e.source.x, Pq = (e) => e.source.y, Iq = (e) => e.target.x, zq = (e) => e.target.y;
  function s2(e) {
    N.call(this, {}, e);
  }
  s2.Definition = {
    type: "LinkPath",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "sourceX",
      type: "field",
      default: "source.x"
    }, {
      name: "sourceY",
      type: "field",
      default: "source.y"
    }, {
      name: "targetX",
      type: "field",
      default: "target.x"
    }, {
      name: "targetY",
      type: "field",
      default: "target.y"
    }, {
      name: "orient",
      type: "enum",
      default: "vertical",
      values: ["horizontal", "vertical", "radial"]
    }, {
      name: "shape",
      type: "enum",
      default: "line",
      values: ["line", "arc", "curve", "diagonal", "orthogonal"]
    }, {
      name: "require",
      type: "signal"
    }, {
      name: "as",
      type: "string",
      default: "path"
    }]
  };
  G(s2, N, {
    transform(e, t) {
      var n = e.sourceX || Lq, i = e.sourceY || Pq, r = e.targetX || Iq, o = e.targetY || zq, s = e.as || "path", a = e.orient || "vertical", u = e.shape || "line", l = GS.get(u + "-" + a) || GS.get(u);
      return l || R("LinkPath unsupported type: " + e.shape + (e.orient ? "-" + e.orient : "")), t.visit(t.SOURCE, (c) => {
        c[s] = l(n(c), i(c), r(c), o(c));
      }), t.reflow(e.modified()).modifies(s);
    }
  });
  const XD = (e, t, n, i) => "M" + e + "," + t + "L" + n + "," + i, Bq = (e, t, n, i) => XD(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)), KD = (e, t, n, i) => {
    var r = n - e, o = i - t, s = Math.hypot(r, o) / 2, a = 180 * Math.atan2(o, r) / Math.PI;
    return "M" + e + "," + t + "A" + s + "," + s + " " + a + " 0 1 " + n + "," + i;
  }, Uq = (e, t, n, i) => KD(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)), JD = (e, t, n, i) => {
    const r = n - e, o = i - t, s = 0.2 * (r + o), a = 0.2 * (o - r);
    return "M" + e + "," + t + "C" + (e + s) + "," + (t + a) + " " + (n + a) + "," + (i - s) + " " + n + "," + i;
  }, jq = (e, t, n, i) => JD(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)), qq = (e, t, n, i) => "M" + e + "," + t + "V" + i + "H" + n, Wq = (e, t, n, i) => "M" + e + "," + t + "H" + n + "V" + i, Hq = (e, t, n, i) => {
    const r = Math.cos(e), o = Math.sin(e), s = Math.cos(n), a = Math.sin(n), u = Math.abs(n - e) > Math.PI ? n <= e : n > e;
    return "M" + t * r + "," + t * o + "A" + t + "," + t + " 0 0," + (u ? 1 : 0) + " " + t * s + "," + t * a + "L" + i * s + "," + i * a;
  }, Gq = (e, t, n, i) => {
    const r = (e + n) / 2;
    return "M" + e + "," + t + "C" + r + "," + t + " " + r + "," + i + " " + n + "," + i;
  }, Vq = (e, t, n, i) => {
    const r = (t + i) / 2;
    return "M" + e + "," + t + "C" + e + "," + r + " " + n + "," + r + " " + n + "," + i;
  }, Yq = (e, t, n, i) => {
    const r = Math.cos(e), o = Math.sin(e), s = Math.cos(n), a = Math.sin(n), u = (t + i) / 2;
    return "M" + t * r + "," + t * o + "C" + u * r + "," + u * o + " " + u * s + "," + u * a + " " + i * s + "," + i * a;
  }, GS = Gu({
    line: XD,
    "line-radial": Bq,
    arc: KD,
    "arc-radial": Uq,
    curve: JD,
    "curve-radial": jq,
    "orthogonal-horizontal": qq,
    "orthogonal-vertical": Wq,
    "orthogonal-radial": Hq,
    "diagonal-horizontal": Gq,
    "diagonal-vertical": Vq,
    "diagonal-radial": Yq
  });
  function a2(e) {
    N.call(this, null, e);
  }
  a2.Definition = {
    type: "Pie",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "field",
      type: "field"
    }, {
      name: "startAngle",
      type: "number",
      default: 0
    }, {
      name: "endAngle",
      type: "number",
      default: 6.283185307179586
    }, {
      name: "sort",
      type: "boolean",
      default: !1
    }, {
      name: "as",
      type: "string",
      array: !0,
      length: 2,
      default: ["startAngle", "endAngle"]
    }]
  };
  G(a2, N, {
    transform(e, t) {
      var n = e.as || ["startAngle", "endAngle"], i = n[0], r = n[1], o = e.field || qu, s = e.startAngle || 0, a = e.endAngle != null ? e.endAngle : 2 * Math.PI, u = t.source, l = u.map(o), c = l.length, f = s, d = (a - s) / fF(l), h = Tn(c), g, p, m;
      for (e.sort && h.sort((y, b) => l[y] - l[b]), g = 0; g < c; ++g)
        m = l[h[g]], p = u[h[g]], p[i] = f, p[r] = f += m * d;
      return this.value = l, t.reflow(e.modified()).modifies(n);
    }
  });
  const Xq = 5;
  function Kq(e) {
    const t = e.type;
    return !e.bins && (t === pu || t === cf || t === ff);
  }
  function QD(e) {
    return xx(e) && e !== Zi;
  }
  const Jq = wi(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
  function ZD(e) {
    N.call(this, null, e), this.modified(!0);
  }
  G(ZD, N, {
    transform(e, t) {
      var n = t.dataflow, i = this.value, r = Qq(e);
      (!i || r !== i.type) && (this.value = i = Ae(r)());
      for (r in e) if (!Jq[r]) {
        if (r === "padding" && QD(i.type)) continue;
        fe(i[r]) ? i[r](e[r]) : n.warn("Unsupported scale property: " + r);
      }
      return rW(i, e, iW(i, e, eW(i, e, n))), t.fork(t.NO_SOURCE | t.NO_FIELDS);
    }
  });
  function Qq(e) {
    var t = e.type, n = "", i;
    return t === Zi ? Zi + "-" + pu : (Zq(e) && (i = e.rawDomain ? e.rawDomain.length : e.domain ? e.domain.length + +(e.domainMid != null) : 0, n = i === 2 ? Zi + "-" : i === 3 ? el + "-" : ""), (n + t || pu).toLowerCase());
  }
  function Zq(e) {
    const t = e.type;
    return xx(t) && t !== Gs && t !== Vs && (e.scheme || e.range && e.range.length && e.range.every(K));
  }
  function eW(e, t, n) {
    const i = tW(e, t.domainRaw, n);
    if (i > -1) return i;
    var r = t.domain, o = e.type, s = t.zero || t.zero === void 0 && Kq(e), a, u;
    if (!r) return 0;
    if ((s || t.domainMin != null || t.domainMax != null || t.domainMid != null) && (a = (r = r.slice()).length - 1 || 1, s && (r[0] > 0 && (r[0] = 0), r[a] < 0 && (r[a] = 0)), t.domainMin != null && (r[0] = t.domainMin), t.domainMax != null && (r[a] = t.domainMax), t.domainMid != null)) {
      u = t.domainMid;
      const l = u > r[a] ? a + 1 : u < r[0] ? 0 : a;
      l !== a && n.warn("Scale domainMid exceeds domain min or max.", u), r.splice(l, 0, u);
    }
    return QD(o) && t.padding && r[0] !== xe(r) && (r = nW(o, r, t.range, t.padding, t.exponent, t.constant)), e.domain(eN(o, r, n)), o === mx && e.unknown(t.domainImplicit ? B1 : void 0), t.nice && e.nice && e.nice(t.nice !== !0 && _x(e, t.nice) || null), r.length;
  }
  function tW(e, t, n) {
    return t ? (e.domain(eN(e.type, t, n)), t.length) : -1;
  }
  function nW(e, t, n, i, r, o) {
    var s = Math.abs(xe(n) - n[0]), a = s / (s - 2 * i), u = e === Yr ? Ib(t, null, a) : e === ff ? fh(t, null, a, 0.5) : e === cf ? fh(t, null, a, r || 1) : e === vp ? zb(t, null, a, o || 1) : Pb(t, null, a);
    return t = t.slice(), t[0] = u[0], t[t.length - 1] = u[1], t;
  }
  function eN(e, t, n) {
    if (l3(e)) {
      var i = Math.abs(t.reduce((r, o) => r + (o < 0 ? -1 : o > 0 ? 1 : 0), 0));
      i !== t.length && n.warn("Log scale domain includes zero: " + H(t));
    }
    return t;
  }
  function iW(e, t, n) {
    let i = t.bins;
    if (i && !P(i)) {
      const r = e.domain(), o = r[0], s = xe(r), a = i.step;
      let u = i.start == null ? o : i.start, l = i.stop == null ? s : i.stop;
      a || R("Scale bins parameter missing step property."), u < o && (u = a * Math.ceil(o / a)), l > s && (l = a * Math.floor(s / a)), i = Tn(u, l + a / 2, a);
    }
    return i ? e.bins = i : e.bins && delete e.bins, e.type === yx && (i ? !t.domain && !t.domainRaw && (e.domain(i), n = i.length) : e.bins = e.domain()), n;
  }
  function rW(e, t, n) {
    var i = e.type, r = t.round || !1, o = t.range;
    if (t.rangeStep != null)
      o = oW(i, t, n);
    else if (t.scheme && (o = sW(i, t, n), fe(o))) {
      if (e.interpolator)
        return e.interpolator(o);
      R(`Scale type ${i} does not support interpolating color schemes.`);
    }
    if (o && c3(i))
      return e.interpolator(Ep(uy(o, t.reverse), t.interpolate, t.interpolateGamma));
    o && t.interpolate && e.interpolate ? e.interpolate(wx(t.interpolate, t.interpolateGamma)) : fe(e.round) ? e.round(r) : fe(e.rangeRound) && e.interpolate(r ? uf : Zo), o && e.range(uy(o, t.reverse));
  }
  function oW(e, t, n) {
    e !== i3 && e !== V1 && R("Only band and point scales support rangeStep.");
    var i = (t.paddingOuter != null ? t.paddingOuter : t.padding) || 0, r = e === V1 ? 1 : (t.paddingInner != null ? t.paddingInner : t.padding) || 0;
    return [0, t.rangeStep * px(n, r, i)];
  }
  function sW(e, t, n) {
    var i = t.schemeExtent, r, o;
    return P(t.scheme) ? o = Ep(t.scheme, t.interpolate, t.interpolateGamma) : (r = t.scheme.toLowerCase(), o = Ex(r), o || R(`Unrecognized scheme name: ${t.scheme}`)), n = e === wp ? n + 1 : e === yx ? n - 1 : e === mu || e === xp ? +t.schemeCount || Xq : n, c3(e) ? VS(o, i, t.reverse) : fe(o) ? h3(VS(o, i), n) : e === mx ? o : o.slice(0, n);
  }
  function VS(e, t, n) {
    return fe(e) && (t || n) ? d3(e, uy(t || [0, 1], n)) : e;
  }
  function uy(e, t) {
    return t ? e.slice().reverse() : e;
  }
  function tN(e) {
    N.call(this, null, e);
  }
  G(tN, N, {
    transform(e, t) {
      const n = e.modified("sort") || t.changed(t.ADD) || t.modified(e.sort.fields) || t.modified("datum");
      return n && t.source.sort(ha(e.sort)), this.modified(n), t;
    }
  });
  const YS = "zero", nN = "center", iN = "normalize", rN = ["y0", "y1"];
  function u2(e) {
    N.call(this, null, e);
  }
  u2.Definition = {
    type: "Stack",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "field",
      type: "field"
    }, {
      name: "groupby",
      type: "field",
      array: !0
    }, {
      name: "sort",
      type: "compare"
    }, {
      name: "offset",
      type: "enum",
      default: YS,
      values: [YS, nN, iN]
    }, {
      name: "as",
      type: "string",
      array: !0,
      length: 2,
      default: rN
    }]
  };
  G(u2, N, {
    transform(e, t) {
      var n = e.as || rN, i = n[0], r = n[1], o = ha(e.sort), s = e.field || qu, a = e.offset === nN ? aW : e.offset === iN ? uW : lW, u, l, c, f;
      for (u = cW(t.source, e.groupby, o, s), l = 0, c = u.length, f = u.max; l < c; ++l)
        a(u[l], f, s, i, r);
      return t.reflow(e.modified()).modifies(n);
    }
  });
  function aW(e, t, n, i, r) {
    for (var o = (t - e.sum) / 2, s = e.length, a = 0, u; a < s; ++a)
      u = e[a], u[i] = o, u[r] = o += Math.abs(n(u));
  }
  function uW(e, t, n, i, r) {
    for (var o = 1 / e.sum, s = 0, a = e.length, u = 0, l = 0, c; u < a; ++u)
      c = e[u], c[i] = s, c[r] = s = o * (l += Math.abs(n(c)));
  }
  function lW(e, t, n, i, r) {
    for (var o = 0, s = 0, a = e.length, u = 0, l, c; u < a; ++u)
      c = e[u], l = +n(c), l < 0 ? (c[i] = s, c[r] = s += l) : (c[i] = o, c[r] = o += l);
  }
  function cW(e, t, n, i) {
    var r = [], o = (p) => p(c), s, a, u, l, c, f, d, h, g;
    if (t == null)
      r.push(e.slice());
    else
      for (s = {}, a = 0, u = e.length; a < u; ++a)
        c = e[a], f = t.map(o), d = s[f], d || (s[f] = d = [], r.push(d)), d.push(c);
    for (f = 0, g = 0, l = r.length; f < l; ++f) {
      for (d = r[f], a = 0, h = 0, u = d.length; a < u; ++a)
        h += Math.abs(i(d[a]));
      d.sum = h, h > g && (g = h), n && d.sort(n);
    }
    return r.max = g, r;
  }
  const fW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    axisticks: HD,
    datajoin: GD,
    encode: VD,
    legendentries: YD,
    linkpath: s2,
    pie: a2,
    scale: ZD,
    sortitems: tN,
    stack: u2
  }, Symbol.toStringTag, { value: "Module" }));
  var se = 1e-6, jh = 1e-12, me = Math.PI, Xe = me / 2, qh = me / 4, sn = me * 2, Qe = 180 / me, ge = me / 180, ve = Math.abs, nl = Math.atan, ei = Math.atan2, ae = Math.cos, ld = Math.ceil, oN = Math.exp, ly = Math.hypot, Wh = Math.log, w0 = Math.pow, oe = Math.sin, Hn = Math.sign || function(e) {
    return e > 0 ? 1 : e < 0 ? -1 : 0;
  }, an = Math.sqrt, l2 = Math.tan;
  function sN(e) {
    return e > 1 ? 0 : e < -1 ? me : Math.acos(e);
  }
  function xn(e) {
    return e > 1 ? Xe : e < -1 ? -Xe : Math.asin(e);
  }
  function kt() {
  }
  function Hh(e, t) {
    e && KS.hasOwnProperty(e.type) && KS[e.type](e, t);
  }
  var XS = {
    Feature: function(e, t) {
      Hh(e.geometry, t);
    },
    FeatureCollection: function(e, t) {
      for (var n = e.features, i = -1, r = n.length; ++i < r; ) Hh(n[i].geometry, t);
    }
  }, KS = {
    Sphere: function(e, t) {
      t.sphere();
    },
    Point: function(e, t) {
      e = e.coordinates, t.point(e[0], e[1], e[2]);
    },
    MultiPoint: function(e, t) {
      for (var n = e.coordinates, i = -1, r = n.length; ++i < r; ) e = n[i], t.point(e[0], e[1], e[2]);
    },
    LineString: function(e, t) {
      cy(e.coordinates, t, 0);
    },
    MultiLineString: function(e, t) {
      for (var n = e.coordinates, i = -1, r = n.length; ++i < r; ) cy(n[i], t, 0);
    },
    Polygon: function(e, t) {
      JS(e.coordinates, t);
    },
    MultiPolygon: function(e, t) {
      for (var n = e.coordinates, i = -1, r = n.length; ++i < r; ) JS(n[i], t);
    },
    GeometryCollection: function(e, t) {
      for (var n = e.geometries, i = -1, r = n.length; ++i < r; ) Hh(n[i], t);
    }
  };
  function cy(e, t, n) {
    var i = -1, r = e.length - n, o;
    for (t.lineStart(); ++i < r; ) o = e[i], t.point(o[0], o[1], o[2]);
    t.lineEnd();
  }
  function JS(e, t) {
    var n = -1, i = e.length;
    for (t.polygonStart(); ++n < i; ) cy(e[n], t, 1);
    t.polygonEnd();
  }
  function Tr(e, t) {
    e && XS.hasOwnProperty(e.type) ? XS[e.type](e, t) : Hh(e, t);
  }
  var Gh = new rn(), Vh = new rn(), aN, uN, fy, dy, hy, sr = {
    point: kt,
    lineStart: kt,
    lineEnd: kt,
    polygonStart: function() {
      Gh = new rn(), sr.lineStart = dW, sr.lineEnd = hW;
    },
    polygonEnd: function() {
      var e = +Gh;
      Vh.add(e < 0 ? sn + e : e), this.lineStart = this.lineEnd = this.point = kt;
    },
    sphere: function() {
      Vh.add(sn);
    }
  };
  function dW() {
    sr.point = gW;
  }
  function hW() {
    lN(aN, uN);
  }
  function gW(e, t) {
    sr.point = lN, aN = e, uN = t, e *= ge, t *= ge, fy = e, dy = ae(t = t / 2 + qh), hy = oe(t);
  }
  function lN(e, t) {
    e *= ge, t *= ge, t = t / 2 + qh;
    var n = e - fy, i = n >= 0 ? 1 : -1, r = i * n, o = ae(t), s = oe(t), a = hy * s, u = dy * o + a * ae(r), l = a * i * oe(r);
    Gh.add(ei(l, u)), fy = e, dy = o, hy = s;
  }
  function pW(e) {
    return Vh = new rn(), Tr(e, sr), Vh * 2;
  }
  function Yh(e) {
    return [ei(e[1], e[0]), xn(e[2])];
  }
  function Xs(e) {
    var t = e[0], n = e[1], i = ae(n);
    return [i * ae(t), i * oe(t), oe(n)];
  }
  function cd(e, t) {
    return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
  }
  function Eu(e, t) {
    return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]];
  }
  function E0(e, t) {
    e[0] += t[0], e[1] += t[1], e[2] += t[2];
  }
  function fd(e, t) {
    return [e[0] * t, e[1] * t, e[2] * t];
  }
  function Xh(e) {
    var t = an(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
    e[0] /= t, e[1] /= t, e[2] /= t;
  }
  var He, hn, Ve, Cn, Ss, cN, fN, eu, hc, po, Xr, Fr = {
    point: gy,
    lineStart: QS,
    lineEnd: ZS,
    polygonStart: function() {
      Fr.point = hN, Fr.lineStart = mW, Fr.lineEnd = yW, hc = new rn(), sr.polygonStart();
    },
    polygonEnd: function() {
      sr.polygonEnd(), Fr.point = gy, Fr.lineStart = QS, Fr.lineEnd = ZS, Gh < 0 ? (He = -(Ve = 180), hn = -(Cn = 90)) : hc > se ? Cn = 90 : hc < -se && (hn = -90), Xr[0] = He, Xr[1] = Ve;
    },
    sphere: function() {
      He = -(Ve = 180), hn = -(Cn = 90);
    }
  };
  function gy(e, t) {
    po.push(Xr = [He = e, Ve = e]), t < hn && (hn = t), t > Cn && (Cn = t);
  }
  function dN(e, t) {
    var n = Xs([e * ge, t * ge]);
    if (eu) {
      var i = Eu(eu, n), r = [i[1], -i[0], 0], o = Eu(r, i);
      Xh(o), o = Yh(o);
      var s = e - Ss, a = s > 0 ? 1 : -1, u = o[0] * Qe * a, l, c = ve(s) > 180;
      c ^ (a * Ss < u && u < a * e) ? (l = o[1] * Qe, l > Cn && (Cn = l)) : (u = (u + 360) % 360 - 180, c ^ (a * Ss < u && u < a * e) ? (l = -o[1] * Qe, l < hn && (hn = l)) : (t < hn && (hn = t), t > Cn && (Cn = t))), c ? e < Ss ? An(He, e) > An(He, Ve) && (Ve = e) : An(e, Ve) > An(He, Ve) && (He = e) : Ve >= He ? (e < He && (He = e), e > Ve && (Ve = e)) : e > Ss ? An(He, e) > An(He, Ve) && (Ve = e) : An(e, Ve) > An(He, Ve) && (He = e);
    } else
      po.push(Xr = [He = e, Ve = e]);
    t < hn && (hn = t), t > Cn && (Cn = t), eu = n, Ss = e;
  }
  function QS() {
    Fr.point = dN;
  }
  function ZS() {
    Xr[0] = He, Xr[1] = Ve, Fr.point = gy, eu = null;
  }
  function hN(e, t) {
    if (eu) {
      var n = e - Ss;
      hc.add(ve(n) > 180 ? n + (n > 0 ? 360 : -360) : n);
    } else
      cN = e, fN = t;
    sr.point(e, t), dN(e, t);
  }
  function mW() {
    sr.lineStart();
  }
  function yW() {
    hN(cN, fN), sr.lineEnd(), ve(hc) > se && (He = -(Ve = 180)), Xr[0] = He, Xr[1] = Ve, eu = null;
  }
  function An(e, t) {
    return (t -= e) < 0 ? t + 360 : t;
  }
  function bW(e, t) {
    return e[0] - t[0];
  }
  function e$(e, t) {
    return e[0] <= e[1] ? e[0] <= t && t <= e[1] : t < e[0] || e[1] < t;
  }
  function vW(e) {
    var t, n, i, r, o, s, a;
    if (Cn = Ve = -(He = hn = 1 / 0), po = [], Tr(e, Fr), n = po.length) {
      for (po.sort(bW), t = 1, i = po[0], o = [i]; t < n; ++t)
        r = po[t], e$(i, r[0]) || e$(i, r[1]) ? (An(i[0], r[1]) > An(i[0], i[1]) && (i[1] = r[1]), An(r[0], i[1]) > An(i[0], i[1]) && (i[0] = r[0])) : o.push(i = r);
      for (s = -1 / 0, n = o.length - 1, t = 0, i = o[n]; t <= n; i = r, ++t)
        r = o[t], (a = An(i[1], r[0])) > s && (s = a, He = r[0], Ve = i[1]);
    }
    return po = Xr = null, He === 1 / 0 || hn === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[He, hn], [Ve, Cn]];
  }
  var Xl, Kh, Jh, Qh, Zh, eg, tg, ng, py, my, yy, gN, pN, Jt, Qt, Zt, mi = {
    sphere: kt,
    point: c2,
    lineStart: t$,
    lineEnd: n$,
    polygonStart: function() {
      mi.lineStart = EW, mi.lineEnd = _W;
    },
    polygonEnd: function() {
      mi.lineStart = t$, mi.lineEnd = n$;
    }
  };
  function c2(e, t) {
    e *= ge, t *= ge;
    var n = ae(t);
    _f(n * ae(e), n * oe(e), oe(t));
  }
  function _f(e, t, n) {
    ++Xl, Jh += (e - Jh) / Xl, Qh += (t - Qh) / Xl, Zh += (n - Zh) / Xl;
  }
  function t$() {
    mi.point = xW;
  }
  function xW(e, t) {
    e *= ge, t *= ge;
    var n = ae(t);
    Jt = n * ae(e), Qt = n * oe(e), Zt = oe(t), mi.point = wW, _f(Jt, Qt, Zt);
  }
  function wW(e, t) {
    e *= ge, t *= ge;
    var n = ae(t), i = n * ae(e), r = n * oe(e), o = oe(t), s = ei(an((s = Qt * o - Zt * r) * s + (s = Zt * i - Jt * o) * s + (s = Jt * r - Qt * i) * s), Jt * i + Qt * r + Zt * o);
    Kh += s, eg += s * (Jt + (Jt = i)), tg += s * (Qt + (Qt = r)), ng += s * (Zt + (Zt = o)), _f(Jt, Qt, Zt);
  }
  function n$() {
    mi.point = c2;
  }
  function EW() {
    mi.point = SW;
  }
  function _W() {
    mN(gN, pN), mi.point = c2;
  }
  function SW(e, t) {
    gN = e, pN = t, e *= ge, t *= ge, mi.point = mN;
    var n = ae(t);
    Jt = n * ae(e), Qt = n * oe(e), Zt = oe(t), _f(Jt, Qt, Zt);
  }
  function mN(e, t) {
    e *= ge, t *= ge;
    var n = ae(t), i = n * ae(e), r = n * oe(e), o = oe(t), s = Qt * o - Zt * r, a = Zt * i - Jt * o, u = Jt * r - Qt * i, l = ly(s, a, u), c = xn(l), f = l && -c / l;
    py.add(f * s), my.add(f * a), yy.add(f * u), Kh += c, eg += c * (Jt + (Jt = i)), tg += c * (Qt + (Qt = r)), ng += c * (Zt + (Zt = o)), _f(Jt, Qt, Zt);
  }
  function $W(e) {
    Xl = Kh = Jh = Qh = Zh = eg = tg = ng = 0, py = new rn(), my = new rn(), yy = new rn(), Tr(e, mi);
    var t = +py, n = +my, i = +yy, r = ly(t, n, i);
    return r < jh && (t = eg, n = tg, i = ng, Kh < se && (t = Jh, n = Qh, i = Zh), r = ly(t, n, i), r < jh) ? [NaN, NaN] : [ei(n, t) * Qe, xn(i / r) * Qe];
  }
  function by(e, t) {
    function n(i, r) {
      return i = e(i, r), t(i[0], i[1]);
    }
    return e.invert && t.invert && (n.invert = function(i, r) {
      return i = t.invert(i, r), i && e.invert(i[0], i[1]);
    }), n;
  }
  function vy(e, t) {
    return ve(e) > me && (e -= Math.round(e / sn) * sn), [e, t];
  }
  vy.invert = vy;
  function yN(e, t, n) {
    return (e %= sn) ? t || n ? by(r$(e), o$(t, n)) : r$(e) : t || n ? o$(t, n) : vy;
  }
  function i$(e) {
    return function(t, n) {
      return t += e, ve(t) > me && (t -= Math.round(t / sn) * sn), [t, n];
    };
  }
  function r$(e) {
    var t = i$(e);
    return t.invert = i$(-e), t;
  }
  function o$(e, t) {
    var n = ae(e), i = oe(e), r = ae(t), o = oe(t);
    function s(a, u) {
      var l = ae(u), c = ae(a) * l, f = oe(a) * l, d = oe(u), h = d * n + c * i;
      return [
        ei(f * r - h * o, c * n - d * i),
        xn(h * r + f * o)
      ];
    }
    return s.invert = function(a, u) {
      var l = ae(u), c = ae(a) * l, f = oe(a) * l, d = oe(u), h = d * r - f * o;
      return [
        ei(f * r + d * o, c * n + h * i),
        xn(h * n - c * i)
      ];
    }, s;
  }
  function kW(e) {
    e = yN(e[0] * ge, e[1] * ge, e.length > 2 ? e[2] * ge : 0);
    function t(n) {
      return n = e(n[0] * ge, n[1] * ge), n[0] *= Qe, n[1] *= Qe, n;
    }
    return t.invert = function(n) {
      return n = e.invert(n[0] * ge, n[1] * ge), n[0] *= Qe, n[1] *= Qe, n;
    }, t;
  }
  function AW(e, t, n, i, r, o) {
    if (n) {
      var s = ae(t), a = oe(t), u = i * n;
      r == null ? (r = t + i * sn, o = t - u / 2) : (r = s$(s, r), o = s$(s, o), (i > 0 ? r < o : r > o) && (r += i * sn));
      for (var l, c = r; i > 0 ? c > o : c < o; c -= u)
        l = Yh([s, -a * ae(c), -a * oe(c)]), e.point(l[0], l[1]);
    }
  }
  function s$(e, t) {
    t = Xs(t), t[0] -= e, Xh(t);
    var n = sN(-t[1]);
    return ((-t[2] < 0 ? -n : n) + sn - se) % sn;
  }
  function bN() {
    var e = [], t;
    return {
      point: function(n, i, r) {
        t.push([n, i, r]);
      },
      lineStart: function() {
        e.push(t = []);
      },
      lineEnd: kt,
      rejoin: function() {
        e.length > 1 && e.push(e.pop().concat(e.shift()));
      },
      result: function() {
        var n = e;
        return e = [], t = null, n;
      }
    };
  }
  function Xd(e, t) {
    return ve(e[0] - t[0]) < se && ve(e[1] - t[1]) < se;
  }
  function dd(e, t, n, i) {
    this.x = e, this.z = t, this.o = n, this.e = i, this.v = !1, this.n = this.p = null;
  }
  function vN(e, t, n, i, r) {
    var o = [], s = [], a, u;
    if (e.forEach(function(g) {
      if (!((p = g.length - 1) <= 0)) {
        var p, m = g[0], y = g[p], b;
        if (Xd(m, y)) {
          if (!m[2] && !y[2]) {
            for (r.lineStart(), a = 0; a < p; ++a) r.point((m = g[a])[0], m[1]);
            r.lineEnd();
            return;
          }
          y[0] += 2 * se;
        }
        o.push(b = new dd(m, g, null, !0)), s.push(b.o = new dd(m, null, b, !1)), o.push(b = new dd(y, g, null, !1)), s.push(b.o = new dd(y, null, b, !0));
      }
    }), !!o.length) {
      for (s.sort(t), a$(o), a$(s), a = 0, u = s.length; a < u; ++a)
        s[a].e = n = !n;
      for (var l = o[0], c, f; ; ) {
        for (var d = l, h = !0; d.v; ) if ((d = d.n) === l) return;
        c = d.z, r.lineStart();
        do {
          if (d.v = d.o.v = !0, d.e) {
            if (h)
              for (a = 0, u = c.length; a < u; ++a) r.point((f = c[a])[0], f[1]);
            else
              i(d.x, d.n.x, 1, r);
            d = d.n;
          } else {
            if (h)
              for (c = d.p.z, a = c.length - 1; a >= 0; --a) r.point((f = c[a])[0], f[1]);
            else
              i(d.x, d.p.x, -1, r);
            d = d.p;
          }
          d = d.o, c = d.z, h = !h;
        } while (!d.v);
        r.lineEnd();
      }
    }
  }
  function a$(e) {
    if (t = e.length) {
      for (var t, n = 0, i = e[0], r; ++n < t; )
        i.n = r = e[n], r.p = i, i = r;
      i.n = r = e[0], r.p = i;
    }
  }
  function _0(e) {
    return ve(e[0]) <= me ? e[0] : Hn(e[0]) * ((ve(e[0]) + me) % sn - me);
  }
  function CW(e, t) {
    var n = _0(t), i = t[1], r = oe(i), o = [oe(n), -ae(n), 0], s = 0, a = 0, u = new rn();
    r === 1 ? i = Xe + se : r === -1 && (i = -Xe - se);
    for (var l = 0, c = e.length; l < c; ++l)
      if (d = (f = e[l]).length)
        for (var f, d, h = f[d - 1], g = _0(h), p = h[1] / 2 + qh, m = oe(p), y = ae(p), b = 0; b < d; ++b, g = x, m = _, y = E, h = v) {
          var v = f[b], x = _0(v), w = v[1] / 2 + qh, _ = oe(w), E = ae(w), S = x - g, $ = S >= 0 ? 1 : -1, F = $ * S, A = F > me, D = m * _;
          if (u.add(ei(D * $ * oe(F), y * E + D * ae(F))), s += A ? S + $ * sn : S, A ^ g >= n ^ x >= n) {
            var k = Eu(Xs(h), Xs(v));
            Xh(k);
            var M = Eu(o, k);
            Xh(M);
            var C = (A ^ S >= 0 ? -1 : 1) * xn(M[2]);
            (i > C || i === C && (k[0] || k[1])) && (a += A ^ S >= 0 ? 1 : -1);
          }
        }
    return (s < -se || s < se && u < -jh) ^ a & 1;
  }
  function xN(e, t, n, i) {
    return function(r) {
      var o = t(r), s = bN(), a = t(s), u = !1, l, c, f, d = {
        point: h,
        lineStart: p,
        lineEnd: m,
        polygonStart: function() {
          d.point = y, d.lineStart = b, d.lineEnd = v, c = [], l = [];
        },
        polygonEnd: function() {
          d.point = h, d.lineStart = p, d.lineEnd = m, c = cF(c);
          var x = CW(l, i);
          c.length ? (u || (r.polygonStart(), u = !0), vN(c, MW, x, n, r)) : x && (u || (r.polygonStart(), u = !0), r.lineStart(), n(null, null, 1, r), r.lineEnd()), u && (r.polygonEnd(), u = !1), c = l = null;
        },
        sphere: function() {
          r.polygonStart(), r.lineStart(), n(null, null, 1, r), r.lineEnd(), r.polygonEnd();
        }
      };
      function h(x, w) {
        e(x, w) && r.point(x, w);
      }
      function g(x, w) {
        o.point(x, w);
      }
      function p() {
        d.point = g, o.lineStart();
      }
      function m() {
        d.point = h, o.lineEnd();
      }
      function y(x, w) {
        f.push([x, w]), a.point(x, w);
      }
      function b() {
        a.lineStart(), f = [];
      }
      function v() {
        y(f[0][0], f[0][1]), a.lineEnd();
        var x = a.clean(), w = s.result(), _, E = w.length, S, $, F;
        if (f.pop(), l.push(f), f = null, !!E) {
          if (x & 1) {
            if ($ = w[0], (S = $.length - 1) > 0) {
              for (u || (r.polygonStart(), u = !0), r.lineStart(), _ = 0; _ < S; ++_) r.point((F = $[_])[0], F[1]);
              r.lineEnd();
            }
            return;
          }
          E > 1 && x & 2 && w.push(w.pop().concat(w.shift())), c.push(w.filter(FW));
        }
      }
      return d;
    };
  }
  function FW(e) {
    return e.length > 1;
  }
  function MW(e, t) {
    return ((e = e.x)[0] < 0 ? e[1] - Xe - se : Xe - e[1]) - ((t = t.x)[0] < 0 ? t[1] - Xe - se : Xe - t[1]);
  }
  const u$ = xN(
    function() {
      return !0;
    },
    TW,
    NW,
    [-me, -Xe]
  );
  function TW(e) {
    var t = NaN, n = NaN, i = NaN, r;
    return {
      lineStart: function() {
        e.lineStart(), r = 1;
      },
      point: function(o, s) {
        var a = o > 0 ? me : -me, u = ve(o - t);
        ve(u - me) < se ? (e.point(t, n = (n + s) / 2 > 0 ? Xe : -Xe), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(a, n), e.point(o, n), r = 0) : i !== a && u >= me && (ve(t - i) < se && (t -= i * se), ve(o - a) < se && (o -= a * se), n = DW(t, n, o, s), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(a, n), r = 0), e.point(t = o, n = s), i = a;
      },
      lineEnd: function() {
        e.lineEnd(), t = n = NaN;
      },
      clean: function() {
        return 2 - r;
      }
    };
  }
  function DW(e, t, n, i) {
    var r, o, s = oe(e - n);
    return ve(s) > se ? nl((oe(t) * (o = ae(i)) * oe(n) - oe(i) * (r = ae(t)) * oe(e)) / (r * o * s)) : (t + i) / 2;
  }
  function NW(e, t, n, i) {
    var r;
    if (e == null)
      r = n * Xe, i.point(-me, r), i.point(0, r), i.point(me, r), i.point(me, 0), i.point(me, -r), i.point(0, -r), i.point(-me, -r), i.point(-me, 0), i.point(-me, r);
    else if (ve(e[0] - t[0]) > se) {
      var o = e[0] < t[0] ? me : -me;
      r = n * o / 2, i.point(-o, r), i.point(0, r), i.point(o, r);
    } else
      i.point(t[0], t[1]);
  }
  function OW(e) {
    var t = ae(e), n = 2 * ge, i = t > 0, r = ve(t) > se;
    function o(c, f, d, h) {
      AW(h, e, n, d, c, f);
    }
    function s(c, f) {
      return ae(c) * ae(f) > t;
    }
    function a(c) {
      var f, d, h, g, p;
      return {
        lineStart: function() {
          g = h = !1, p = 1;
        },
        point: function(m, y) {
          var b = [m, y], v, x = s(m, y), w = i ? x ? 0 : l(m, y) : x ? l(m + (m < 0 ? me : -me), y) : 0;
          if (!f && (g = h = x) && c.lineStart(), x !== h && (v = u(f, b), (!v || Xd(f, v) || Xd(b, v)) && (b[2] = 1)), x !== h)
            p = 0, x ? (c.lineStart(), v = u(b, f), c.point(v[0], v[1])) : (v = u(f, b), c.point(v[0], v[1], 2), c.lineEnd()), f = v;
          else if (r && f && i ^ x) {
            var _;
            !(w & d) && (_ = u(b, f, !0)) && (p = 0, i ? (c.lineStart(), c.point(_[0][0], _[0][1]), c.point(_[1][0], _[1][1]), c.lineEnd()) : (c.point(_[1][0], _[1][1]), c.lineEnd(), c.lineStart(), c.point(_[0][0], _[0][1], 3)));
          }
          x && (!f || !Xd(f, b)) && c.point(b[0], b[1]), f = b, h = x, d = w;
        },
        lineEnd: function() {
          h && c.lineEnd(), f = null;
        },
        // Rejoin first and last segments if there were intersections and the first
        // and last points were visible.
        clean: function() {
          return p | (g && h) << 1;
        }
      };
    }
    function u(c, f, d) {
      var h = Xs(c), g = Xs(f), p = [1, 0, 0], m = Eu(h, g), y = cd(m, m), b = m[0], v = y - b * b;
      if (!v) return !d && c;
      var x = t * y / v, w = -t * b / v, _ = Eu(p, m), E = fd(p, x), S = fd(m, w);
      E0(E, S);
      var $ = _, F = cd(E, $), A = cd($, $), D = F * F - A * (cd(E, E) - 1);
      if (!(D < 0)) {
        var k = an(D), M = fd($, (-F - k) / A);
        if (E0(M, E), M = Yh(M), !d) return M;
        var C = c[0], T = f[0], L = c[1], I = f[1], z;
        T < C && (z = C, C = T, T = z);
        var te = T - C, ne = ve(te - me) < se, de = ne || te < se;
        if (!ne && I < L && (z = L, L = I, I = z), de ? ne ? L + I > 0 ^ M[1] < (ve(M[0] - C) < se ? L : I) : L <= M[1] && M[1] <= I : te > me ^ (C <= M[0] && M[0] <= T)) {
          var _e = fd($, (-F + k) / A);
          return E0(_e, E), [M, Yh(_e)];
        }
      }
    }
    function l(c, f) {
      var d = i ? e : me - e, h = 0;
      return c < -d ? h |= 1 : c > d && (h |= 2), f < -d ? h |= 4 : f > d && (h |= 8), h;
    }
    return xN(s, a, o, i ? [0, -e] : [-me, e - me]);
  }
  function RW(e, t, n, i, r, o) {
    var s = e[0], a = e[1], u = t[0], l = t[1], c = 0, f = 1, d = u - s, h = l - a, g;
    if (g = n - s, !(!d && g > 0)) {
      if (g /= d, d < 0) {
        if (g < c) return;
        g < f && (f = g);
      } else if (d > 0) {
        if (g > f) return;
        g > c && (c = g);
      }
      if (g = r - s, !(!d && g < 0)) {
        if (g /= d, d < 0) {
          if (g > f) return;
          g > c && (c = g);
        } else if (d > 0) {
          if (g < c) return;
          g < f && (f = g);
        }
        if (g = i - a, !(!h && g > 0)) {
          if (g /= h, h < 0) {
            if (g < c) return;
            g < f && (f = g);
          } else if (h > 0) {
            if (g > f) return;
            g > c && (c = g);
          }
          if (g = o - a, !(!h && g < 0)) {
            if (g /= h, h < 0) {
              if (g > f) return;
              g > c && (c = g);
            } else if (h > 0) {
              if (g < c) return;
              g < f && (f = g);
            }
            return c > 0 && (e[0] = s + c * d, e[1] = a + c * h), f < 1 && (t[0] = s + f * d, t[1] = a + f * h), !0;
          }
        }
      }
    }
  }
  var Kl = 1e9, hd = -Kl;
  function wN(e, t, n, i) {
    function r(l, c) {
      return e <= l && l <= n && t <= c && c <= i;
    }
    function o(l, c, f, d) {
      var h = 0, g = 0;
      if (l == null || (h = s(l, f)) !== (g = s(c, f)) || u(l, c) < 0 ^ f > 0)
        do
          d.point(h === 0 || h === 3 ? e : n, h > 1 ? i : t);
        while ((h = (h + f + 4) % 4) !== g);
      else
        d.point(c[0], c[1]);
    }
    function s(l, c) {
      return ve(l[0] - e) < se ? c > 0 ? 0 : 3 : ve(l[0] - n) < se ? c > 0 ? 2 : 1 : ve(l[1] - t) < se ? c > 0 ? 1 : 0 : c > 0 ? 3 : 2;
    }
    function a(l, c) {
      return u(l.x, c.x);
    }
    function u(l, c) {
      var f = s(l, 1), d = s(c, 1);
      return f !== d ? f - d : f === 0 ? c[1] - l[1] : f === 1 ? l[0] - c[0] : f === 2 ? l[1] - c[1] : c[0] - l[0];
    }
    return function(l) {
      var c = l, f = bN(), d, h, g, p, m, y, b, v, x, w, _, E = {
        point: S,
        lineStart: D,
        lineEnd: k,
        polygonStart: F,
        polygonEnd: A
      };
      function S(C, T) {
        r(C, T) && c.point(C, T);
      }
      function $() {
        for (var C = 0, T = 0, L = h.length; T < L; ++T)
          for (var I = h[T], z = 1, te = I.length, ne = I[0], de, _e, we = ne[0], Pe = ne[1]; z < te; ++z)
            de = we, _e = Pe, ne = I[z], we = ne[0], Pe = ne[1], _e <= i ? Pe > i && (we - de) * (i - _e) > (Pe - _e) * (e - de) && ++C : Pe <= i && (we - de) * (i - _e) < (Pe - _e) * (e - de) && --C;
        return C;
      }
      function F() {
        c = f, d = [], h = [], _ = !0;
      }
      function A() {
        var C = $(), T = _ && C, L = (d = cF(d)).length;
        (T || L) && (l.polygonStart(), T && (l.lineStart(), o(null, null, 1, l), l.lineEnd()), L && vN(d, a, C, o, l), l.polygonEnd()), c = l, d = h = g = null;
      }
      function D() {
        E.point = M, h && h.push(g = []), w = !0, x = !1, b = v = NaN;
      }
      function k() {
        d && (M(p, m), y && x && f.rejoin(), d.push(f.result())), E.point = S, x && c.lineEnd();
      }
      function M(C, T) {
        var L = r(C, T);
        if (h && g.push([C, T]), w)
          p = C, m = T, y = L, w = !1, L && (c.lineStart(), c.point(C, T));
        else if (L && x) c.point(C, T);
        else {
          var I = [b = Math.max(hd, Math.min(Kl, b)), v = Math.max(hd, Math.min(Kl, v))], z = [C = Math.max(hd, Math.min(Kl, C)), T = Math.max(hd, Math.min(Kl, T))];
          RW(I, z, e, t, n, i) ? (x || (c.lineStart(), c.point(I[0], I[1])), c.point(z[0], z[1]), L || c.lineEnd(), _ = !1) : L && (c.lineStart(), c.point(C, T), _ = !1);
        }
        b = C, v = T, x = L;
      }
      return E;
    };
  }
  function l$(e, t, n) {
    var i = Tn(e, t - se, n).concat(t);
    return function(r) {
      return i.map(function(o) {
        return [r, o];
      });
    };
  }
  function c$(e, t, n) {
    var i = Tn(e, t - se, n).concat(t);
    return function(r) {
      return i.map(function(o) {
        return [o, r];
      });
    };
  }
  function LW() {
    var e, t, n, i, r, o, s, a, u = 10, l = u, c = 90, f = 360, d, h, g, p, m = 2.5;
    function y() {
      return { type: "MultiLineString", coordinates: b() };
    }
    function b() {
      return Tn(ld(i / c) * c, n, c).map(g).concat(Tn(ld(a / f) * f, s, f).map(p)).concat(Tn(ld(t / u) * u, e, u).filter(function(v) {
        return ve(v % c) > se;
      }).map(d)).concat(Tn(ld(o / l) * l, r, l).filter(function(v) {
        return ve(v % f) > se;
      }).map(h));
    }
    return y.lines = function() {
      return b().map(function(v) {
        return { type: "LineString", coordinates: v };
      });
    }, y.outline = function() {
      return {
        type: "Polygon",
        coordinates: [
          g(i).concat(
            p(s).slice(1),
            g(n).reverse().slice(1),
            p(a).reverse().slice(1)
          )
        ]
      };
    }, y.extent = function(v) {
      return arguments.length ? y.extentMajor(v).extentMinor(v) : y.extentMinor();
    }, y.extentMajor = function(v) {
      return arguments.length ? (i = +v[0][0], n = +v[1][0], a = +v[0][1], s = +v[1][1], i > n && (v = i, i = n, n = v), a > s && (v = a, a = s, s = v), y.precision(m)) : [[i, a], [n, s]];
    }, y.extentMinor = function(v) {
      return arguments.length ? (t = +v[0][0], e = +v[1][0], o = +v[0][1], r = +v[1][1], t > e && (v = t, t = e, e = v), o > r && (v = o, o = r, r = v), y.precision(m)) : [[t, o], [e, r]];
    }, y.step = function(v) {
      return arguments.length ? y.stepMajor(v).stepMinor(v) : y.stepMinor();
    }, y.stepMajor = function(v) {
      return arguments.length ? (c = +v[0], f = +v[1], y) : [c, f];
    }, y.stepMinor = function(v) {
      return arguments.length ? (u = +v[0], l = +v[1], y) : [u, l];
    }, y.precision = function(v) {
      return arguments.length ? (m = +v, d = l$(o, r, 90), h = c$(t, e, m), g = l$(a, s, 90), p = c$(i, n, m), y) : m;
    }, y.extentMajor([[-180, -90 + se], [180, 90 - se]]).extentMinor([[-180, -80 - se], [180, 80 + se]]);
  }
  const Lc = (e) => e;
  var S0 = new rn(), xy = new rn(), EN, _N, wy, Ey, Dr = {
    point: kt,
    lineStart: kt,
    lineEnd: kt,
    polygonStart: function() {
      Dr.lineStart = PW, Dr.lineEnd = zW;
    },
    polygonEnd: function() {
      Dr.lineStart = Dr.lineEnd = Dr.point = kt, S0.add(ve(xy)), xy = new rn();
    },
    result: function() {
      var e = S0 / 2;
      return S0 = new rn(), e;
    }
  };
  function PW() {
    Dr.point = IW;
  }
  function IW(e, t) {
    Dr.point = SN, EN = wy = e, _N = Ey = t;
  }
  function SN(e, t) {
    xy.add(Ey * e - wy * t), wy = e, Ey = t;
  }
  function zW() {
    SN(EN, _N);
  }
  var _u = 1 / 0, ig = _u, Pc = -_u, rg = Pc, og = {
    point: BW,
    lineStart: kt,
    lineEnd: kt,
    polygonStart: kt,
    polygonEnd: kt,
    result: function() {
      var e = [[_u, ig], [Pc, rg]];
      return Pc = rg = -(ig = _u = 1 / 0), e;
    }
  };
  function BW(e, t) {
    e < _u && (_u = e), e > Pc && (Pc = e), t < ig && (ig = t), t > rg && (rg = t);
  }
  var _y = 0, Sy = 0, Jl = 0, sg = 0, ag = 0, Ya = 0, $y = 0, ky = 0, Ql = 0, $N, kN, Vi, Yi, qn = {
    point: Ks,
    lineStart: f$,
    lineEnd: d$,
    polygonStart: function() {
      qn.lineStart = qW, qn.lineEnd = WW;
    },
    polygonEnd: function() {
      qn.point = Ks, qn.lineStart = f$, qn.lineEnd = d$;
    },
    result: function() {
      var e = Ql ? [$y / Ql, ky / Ql] : Ya ? [sg / Ya, ag / Ya] : Jl ? [_y / Jl, Sy / Jl] : [NaN, NaN];
      return _y = Sy = Jl = sg = ag = Ya = $y = ky = Ql = 0, e;
    }
  };
  function Ks(e, t) {
    _y += e, Sy += t, ++Jl;
  }
  function f$() {
    qn.point = UW;
  }
  function UW(e, t) {
    qn.point = jW, Ks(Vi = e, Yi = t);
  }
  function jW(e, t) {
    var n = e - Vi, i = t - Yi, r = an(n * n + i * i);
    sg += r * (Vi + e) / 2, ag += r * (Yi + t) / 2, Ya += r, Ks(Vi = e, Yi = t);
  }
  function d$() {
    qn.point = Ks;
  }
  function qW() {
    qn.point = HW;
  }
  function WW() {
    AN($N, kN);
  }
  function HW(e, t) {
    qn.point = AN, Ks($N = Vi = e, kN = Yi = t);
  }
  function AN(e, t) {
    var n = e - Vi, i = t - Yi, r = an(n * n + i * i);
    sg += r * (Vi + e) / 2, ag += r * (Yi + t) / 2, Ya += r, r = Yi * e - Vi * t, $y += r * (Vi + e), ky += r * (Yi + t), Ql += r * 3, Ks(Vi = e, Yi = t);
  }
  function CN(e) {
    this._context = e;
  }
  CN.prototype = {
    _radius: 4.5,
    pointRadius: function(e) {
      return this._radius = e, this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      this._line === 0 && this._context.closePath(), this._point = NaN;
    },
    point: function(e, t) {
      switch (this._point) {
        case 0: {
          this._context.moveTo(e, t), this._point = 1;
          break;
        }
        case 1: {
          this._context.lineTo(e, t);
          break;
        }
        default: {
          this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, sn);
          break;
        }
      }
    },
    result: kt
  };
  var Ay = new rn(), $0, FN, MN, Zl, ec, Ic = {
    point: kt,
    lineStart: function() {
      Ic.point = GW;
    },
    lineEnd: function() {
      $0 && TN(FN, MN), Ic.point = kt;
    },
    polygonStart: function() {
      $0 = !0;
    },
    polygonEnd: function() {
      $0 = null;
    },
    result: function() {
      var e = +Ay;
      return Ay = new rn(), e;
    }
  };
  function GW(e, t) {
    Ic.point = TN, FN = Zl = e, MN = ec = t;
  }
  function TN(e, t) {
    Zl -= e, ec -= t, Ay.add(an(Zl * Zl + ec * ec)), Zl = e, ec = t;
  }
  let h$, ug, g$, p$;
  class m$ {
    constructor(t) {
      this._append = t == null ? DN : VW(t), this._radius = 4.5, this._ = "";
    }
    pointRadius(t) {
      return this._radius = +t, this;
    }
    polygonStart() {
      this._line = 0;
    }
    polygonEnd() {
      this._line = NaN;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {
      this._line === 0 && (this._ += "Z"), this._point = NaN;
    }
    point(t, n) {
      switch (this._point) {
        case 0: {
          this._append`M${t},${n}`, this._point = 1;
          break;
        }
        case 1: {
          this._append`L${t},${n}`;
          break;
        }
        default: {
          if (this._append`M${t},${n}`, this._radius !== g$ || this._append !== ug) {
            const i = this._radius, r = this._;
            this._ = "", this._append`m0,${i}a${i},${i} 0 1,1 0,${-2 * i}a${i},${i} 0 1,1 0,${2 * i}z`, g$ = i, ug = this._append, p$ = this._, this._ = r;
          }
          this._ += p$;
          break;
        }
      }
    }
    result() {
      const t = this._;
      return this._ = "", t.length ? t : null;
    }
  }
  function DN(e) {
    let t = 1;
    this._ += e[0];
    for (const n = e.length; t < n; ++t)
      this._ += arguments[t] + e[t];
  }
  function VW(e) {
    const t = Math.floor(e);
    if (!(t >= 0)) throw new RangeError(`invalid digits: ${e}`);
    if (t > 15) return DN;
    if (t !== h$) {
      const n = 10 ** t;
      h$ = t, ug = function(r) {
        let o = 1;
        this._ += r[0];
        for (const s = r.length; o < s; ++o)
          this._ += Math.round(arguments[o] * n) / n + r[o];
      };
    }
    return ug;
  }
  function NN(e, t) {
    let n = 3, i = 4.5, r, o;
    function s(a) {
      return a && (typeof i == "function" && o.pointRadius(+i.apply(this, arguments)), Tr(a, r(o))), o.result();
    }
    return s.area = function(a) {
      return Tr(a, r(Dr)), Dr.result();
    }, s.measure = function(a) {
      return Tr(a, r(Ic)), Ic.result();
    }, s.bounds = function(a) {
      return Tr(a, r(og)), og.result();
    }, s.centroid = function(a) {
      return Tr(a, r(qn)), qn.result();
    }, s.projection = function(a) {
      return arguments.length ? (r = a == null ? (e = null, Lc) : (e = a).stream, s) : e;
    }, s.context = function(a) {
      return arguments.length ? (o = a == null ? (t = null, new m$(n)) : new CN(t = a), typeof i != "function" && o.pointRadius(i), s) : t;
    }, s.pointRadius = function(a) {
      return arguments.length ? (i = typeof a == "function" ? a : (o.pointRadius(+a), +a), s) : i;
    }, s.digits = function(a) {
      if (!arguments.length) return n;
      if (a == null) n = null;
      else {
        const u = Math.floor(a);
        if (!(u >= 0)) throw new RangeError(`invalid digits: ${a}`);
        n = u;
      }
      return t === null && (o = new m$(n)), s;
    }, s.projection(e).digits(n).context(t);
  }
  function Rp(e) {
    return function(t) {
      var n = new Cy();
      for (var i in e) n[i] = e[i];
      return n.stream = t, n;
    };
  }
  function Cy() {
  }
  Cy.prototype = {
    constructor: Cy,
    point: function(e, t) {
      this.stream.point(e, t);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function f2(e, t, n) {
    var i = e.clipExtent && e.clipExtent();
    return e.scale(150).translate([0, 0]), i != null && e.clipExtent(null), Tr(n, e.stream(og)), t(og.result()), i != null && e.clipExtent(i), e;
  }
  function Lp(e, t, n) {
    return f2(e, function(i) {
      var r = t[1][0] - t[0][0], o = t[1][1] - t[0][1], s = Math.min(r / (i[1][0] - i[0][0]), o / (i[1][1] - i[0][1])), a = +t[0][0] + (r - s * (i[1][0] + i[0][0])) / 2, u = +t[0][1] + (o - s * (i[1][1] + i[0][1])) / 2;
      e.scale(150 * s).translate([a, u]);
    }, n);
  }
  function d2(e, t, n) {
    return Lp(e, [[0, 0], t], n);
  }
  function h2(e, t, n) {
    return f2(e, function(i) {
      var r = +t, o = r / (i[1][0] - i[0][0]), s = (r - o * (i[1][0] + i[0][0])) / 2, a = -o * i[0][1];
      e.scale(150 * o).translate([s, a]);
    }, n);
  }
  function g2(e, t, n) {
    return f2(e, function(i) {
      var r = +t, o = r / (i[1][1] - i[0][1]), s = -o * i[0][0], a = (r - o * (i[1][1] + i[0][1])) / 2;
      e.scale(150 * o).translate([s, a]);
    }, n);
  }
  var y$ = 16, YW = ae(30 * ge);
  function b$(e, t) {
    return +t ? KW(e, t) : XW(e);
  }
  function XW(e) {
    return Rp({
      point: function(t, n) {
        t = e(t, n), this.stream.point(t[0], t[1]);
      }
    });
  }
  function KW(e, t) {
    function n(i, r, o, s, a, u, l, c, f, d, h, g, p, m) {
      var y = l - i, b = c - r, v = y * y + b * b;
      if (v > 4 * t && p--) {
        var x = s + d, w = a + h, _ = u + g, E = an(x * x + w * w + _ * _), S = xn(_ /= E), $ = ve(ve(_) - 1) < se || ve(o - f) < se ? (o + f) / 2 : ei(w, x), F = e($, S), A = F[0], D = F[1], k = A - i, M = D - r, C = b * k - y * M;
        (C * C / v > t || ve((y * k + b * M) / v - 0.5) > 0.3 || s * d + a * h + u * g < YW) && (n(i, r, o, s, a, u, A, D, $, x /= E, w /= E, _, p, m), m.point(A, D), n(A, D, $, x, w, _, l, c, f, d, h, g, p, m));
      }
    }
    return function(i) {
      var r, o, s, a, u, l, c, f, d, h, g, p, m = {
        point: y,
        lineStart: b,
        lineEnd: x,
        polygonStart: function() {
          i.polygonStart(), m.lineStart = w;
        },
        polygonEnd: function() {
          i.polygonEnd(), m.lineStart = b;
        }
      };
      function y(S, $) {
        S = e(S, $), i.point(S[0], S[1]);
      }
      function b() {
        f = NaN, m.point = v, i.lineStart();
      }
      function v(S, $) {
        var F = Xs([S, $]), A = e(S, $);
        n(f, d, c, h, g, p, f = A[0], d = A[1], c = S, h = F[0], g = F[1], p = F[2], y$, i), i.point(f, d);
      }
      function x() {
        m.point = y, i.lineEnd();
      }
      function w() {
        b(), m.point = _, m.lineEnd = E;
      }
      function _(S, $) {
        v(r = S, $), o = f, s = d, a = h, u = g, l = p, m.point = v;
      }
      function E() {
        n(f, d, c, h, g, p, o, s, r, a, u, l, y$, i), m.lineEnd = x, x();
      }
      return m;
    };
  }
  var JW = Rp({
    point: function(e, t) {
      this.stream.point(e * ge, t * ge);
    }
  });
  function QW(e) {
    return Rp({
      point: function(t, n) {
        var i = e(t, n);
        return this.stream.point(i[0], i[1]);
      }
    });
  }
  function ZW(e, t, n, i, r) {
    function o(s, a) {
      return s *= i, a *= r, [t + e * s, n - e * a];
    }
    return o.invert = function(s, a) {
      return [(s - t) / e * i, (n - a) / e * r];
    }, o;
  }
  function v$(e, t, n, i, r, o) {
    if (!o) return ZW(e, t, n, i, r);
    var s = ae(o), a = oe(o), u = s * e, l = a * e, c = s / e, f = a / e, d = (a * n - s * t) / e, h = (a * t + s * n) / e;
    function g(p, m) {
      return p *= i, m *= r, [u * p - l * m + t, n - l * p - u * m];
    }
    return g.invert = function(p, m) {
      return [i * (c * p - f * m + d), r * (h - f * p - c * m)];
    }, g;
  }
  function pr(e) {
    return ON(function() {
      return e;
    })();
  }
  function ON(e) {
    var t, n = 150, i = 480, r = 250, o = 0, s = 0, a = 0, u = 0, l = 0, c, f = 0, d = 1, h = 1, g = null, p = u$, m = null, y, b, v, x = Lc, w = 0.5, _, E, S, $, F;
    function A(C) {
      return S(C[0] * ge, C[1] * ge);
    }
    function D(C) {
      return C = S.invert(C[0], C[1]), C && [C[0] * Qe, C[1] * Qe];
    }
    A.stream = function(C) {
      return $ && F === C ? $ : $ = JW(QW(c)(p(_(x(F = C)))));
    }, A.preclip = function(C) {
      return arguments.length ? (p = C, g = void 0, M()) : p;
    }, A.postclip = function(C) {
      return arguments.length ? (x = C, m = y = b = v = null, M()) : x;
    }, A.clipAngle = function(C) {
      return arguments.length ? (p = +C ? OW(g = C * ge) : (g = null, u$), M()) : g * Qe;
    }, A.clipExtent = function(C) {
      return arguments.length ? (x = C == null ? (m = y = b = v = null, Lc) : wN(m = +C[0][0], y = +C[0][1], b = +C[1][0], v = +C[1][1]), M()) : m == null ? null : [[m, y], [b, v]];
    }, A.scale = function(C) {
      return arguments.length ? (n = +C, k()) : n;
    }, A.translate = function(C) {
      return arguments.length ? (i = +C[0], r = +C[1], k()) : [i, r];
    }, A.center = function(C) {
      return arguments.length ? (o = C[0] % 360 * ge, s = C[1] % 360 * ge, k()) : [o * Qe, s * Qe];
    }, A.rotate = function(C) {
      return arguments.length ? (a = C[0] % 360 * ge, u = C[1] % 360 * ge, l = C.length > 2 ? C[2] % 360 * ge : 0, k()) : [a * Qe, u * Qe, l * Qe];
    }, A.angle = function(C) {
      return arguments.length ? (f = C % 360 * ge, k()) : f * Qe;
    }, A.reflectX = function(C) {
      return arguments.length ? (d = C ? -1 : 1, k()) : d < 0;
    }, A.reflectY = function(C) {
      return arguments.length ? (h = C ? -1 : 1, k()) : h < 0;
    }, A.precision = function(C) {
      return arguments.length ? (_ = b$(E, w = C * C), M()) : an(w);
    }, A.fitExtent = function(C, T) {
      return Lp(A, C, T);
    }, A.fitSize = function(C, T) {
      return d2(A, C, T);
    }, A.fitWidth = function(C, T) {
      return h2(A, C, T);
    }, A.fitHeight = function(C, T) {
      return g2(A, C, T);
    };
    function k() {
      var C = v$(n, 0, 0, d, h, f).apply(null, t(o, s)), T = v$(n, i - C[0], r - C[1], d, h, f);
      return c = yN(a, u, l), E = by(t, T), S = by(c, E), _ = b$(E, w), M();
    }
    function M() {
      return $ = F = null, A;
    }
    return function() {
      return t = e.apply(this, arguments), A.invert = t.invert && D, k();
    };
  }
  function p2(e) {
    var t = 0, n = me / 3, i = ON(e), r = i(t, n);
    return r.parallels = function(o) {
      return arguments.length ? i(t = o[0] * ge, n = o[1] * ge) : [t * Qe, n * Qe];
    }, r;
  }
  function eH(e) {
    var t = ae(e);
    function n(i, r) {
      return [i * t, oe(r) / t];
    }
    return n.invert = function(i, r) {
      return [i / t, xn(r * t)];
    }, n;
  }
  function tH(e, t) {
    var n = oe(e), i = (n + oe(t)) / 2;
    if (ve(i) < se) return eH(e);
    var r = 1 + n * (2 * i - n), o = an(r) / i;
    function s(a, u) {
      var l = an(r - 2 * i * oe(u)) / i;
      return [l * oe(a *= i), o - l * ae(a)];
    }
    return s.invert = function(a, u) {
      var l = o - u, c = ei(a, ve(l)) * Hn(l);
      return l * i < 0 && (c -= me * Hn(a) * Hn(l)), [c / i, xn((r - (a * a + l * l) * i * i) / (2 * i))];
    }, s;
  }
  function lg() {
    return p2(tH).scale(155.424).center([0, 33.6442]);
  }
  function RN() {
    return lg().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
  }
  function nH(e) {
    var t = e.length;
    return {
      point: function(n, i) {
        for (var r = -1; ++r < t; ) e[r].point(n, i);
      },
      sphere: function() {
        for (var n = -1; ++n < t; ) e[n].sphere();
      },
      lineStart: function() {
        for (var n = -1; ++n < t; ) e[n].lineStart();
      },
      lineEnd: function() {
        for (var n = -1; ++n < t; ) e[n].lineEnd();
      },
      polygonStart: function() {
        for (var n = -1; ++n < t; ) e[n].polygonStart();
      },
      polygonEnd: function() {
        for (var n = -1; ++n < t; ) e[n].polygonEnd();
      }
    };
  }
  function iH() {
    var e, t, n = RN(), i, r = lg().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), o, s = lg().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), a, u, l = { point: function(d, h) {
      u = [d, h];
    } };
    function c(d) {
      var h = d[0], g = d[1];
      return u = null, i.point(h, g), u || (o.point(h, g), u) || (a.point(h, g), u);
    }
    c.invert = function(d) {
      var h = n.scale(), g = n.translate(), p = (d[0] - g[0]) / h, m = (d[1] - g[1]) / h;
      return (m >= 0.12 && m < 0.234 && p >= -0.425 && p < -0.214 ? r : m >= 0.166 && m < 0.234 && p >= -0.214 && p < -0.115 ? s : n).invert(d);
    }, c.stream = function(d) {
      return e && t === d ? e : e = nH([n.stream(t = d), r.stream(d), s.stream(d)]);
    }, c.precision = function(d) {
      return arguments.length ? (n.precision(d), r.precision(d), s.precision(d), f()) : n.precision();
    }, c.scale = function(d) {
      return arguments.length ? (n.scale(d), r.scale(d * 0.35), s.scale(d), c.translate(n.translate())) : n.scale();
    }, c.translate = function(d) {
      if (!arguments.length) return n.translate();
      var h = n.scale(), g = +d[0], p = +d[1];
      return i = n.translate(d).clipExtent([[g - 0.455 * h, p - 0.238 * h], [g + 0.455 * h, p + 0.238 * h]]).stream(l), o = r.translate([g - 0.307 * h, p + 0.201 * h]).clipExtent([[g - 0.425 * h + se, p + 0.12 * h + se], [g - 0.214 * h - se, p + 0.234 * h - se]]).stream(l), a = s.translate([g - 0.205 * h, p + 0.212 * h]).clipExtent([[g - 0.214 * h + se, p + 0.166 * h + se], [g - 0.115 * h - se, p + 0.234 * h - se]]).stream(l), f();
    }, c.fitExtent = function(d, h) {
      return Lp(c, d, h);
    }, c.fitSize = function(d, h) {
      return d2(c, d, h);
    }, c.fitWidth = function(d, h) {
      return h2(c, d, h);
    }, c.fitHeight = function(d, h) {
      return g2(c, d, h);
    };
    function f() {
      return e = t = null, c;
    }
    return c.scale(1070);
  }
  function LN(e) {
    return function(t, n) {
      var i = ae(t), r = ae(n), o = e(i * r);
      return o === 1 / 0 ? [2, 0] : [
        o * r * oe(t),
        o * oe(n)
      ];
    };
  }
  function Sf(e) {
    return function(t, n) {
      var i = an(t * t + n * n), r = e(i), o = oe(r), s = ae(r);
      return [
        ei(t * o, i * s),
        xn(i && n * o / i)
      ];
    };
  }
  var PN = LN(function(e) {
    return an(2 / (1 + e));
  });
  PN.invert = Sf(function(e) {
    return 2 * xn(e / 2);
  });
  function rH() {
    return pr(PN).scale(124.75).clipAngle(180 - 1e-3);
  }
  var IN = LN(function(e) {
    return (e = sN(e)) && e / oe(e);
  });
  IN.invert = Sf(function(e) {
    return e;
  });
  function oH() {
    return pr(IN).scale(79.4188).clipAngle(180 - 1e-3);
  }
  function Pp(e, t) {
    return [e, Wh(l2((Xe + t) / 2))];
  }
  Pp.invert = function(e, t) {
    return [e, 2 * nl(oN(t)) - Xe];
  };
  function sH() {
    return zN(Pp).scale(961 / sn);
  }
  function zN(e) {
    var t = pr(e), n = t.center, i = t.scale, r = t.translate, o = t.clipExtent, s = null, a, u, l;
    t.scale = function(f) {
      return arguments.length ? (i(f), c()) : i();
    }, t.translate = function(f) {
      return arguments.length ? (r(f), c()) : r();
    }, t.center = function(f) {
      return arguments.length ? (n(f), c()) : n();
    }, t.clipExtent = function(f) {
      return arguments.length ? (f == null ? s = a = u = l = null : (s = +f[0][0], a = +f[0][1], u = +f[1][0], l = +f[1][1]), c()) : s == null ? null : [[s, a], [u, l]];
    };
    function c() {
      var f = me * i(), d = t(kW(t.rotate()).invert([0, 0]));
      return o(s == null ? [[d[0] - f, d[1] - f], [d[0] + f, d[1] + f]] : e === Pp ? [[Math.max(d[0] - f, s), a], [Math.min(d[0] + f, u), l]] : [[s, Math.max(d[1] - f, a)], [u, Math.min(d[1] + f, l)]]);
    }
    return c();
  }
  function gd(e) {
    return l2((Xe + e) / 2);
  }
  function aH(e, t) {
    var n = ae(e), i = e === t ? oe(e) : Wh(n / ae(t)) / Wh(gd(t) / gd(e)), r = n * w0(gd(e), i) / i;
    if (!i) return Pp;
    function o(s, a) {
      r > 0 ? a < -Xe + se && (a = -Xe + se) : a > Xe - se && (a = Xe - se);
      var u = r / w0(gd(a), i);
      return [u * oe(i * s), r - u * ae(i * s)];
    }
    return o.invert = function(s, a) {
      var u = r - a, l = Hn(i) * an(s * s + u * u), c = ei(s, ve(u)) * Hn(u);
      return u * i < 0 && (c -= me * Hn(s) * Hn(u)), [c / i, 2 * nl(w0(r / l, 1 / i)) - Xe];
    }, o;
  }
  function uH() {
    return p2(aH).scale(109.5).parallels([30, 30]);
  }
  function cg(e, t) {
    return [e, t];
  }
  cg.invert = cg;
  function lH() {
    return pr(cg).scale(152.63);
  }
  function cH(e, t) {
    var n = ae(e), i = e === t ? oe(e) : (n - ae(t)) / (t - e), r = n / i + e;
    if (ve(i) < se) return cg;
    function o(s, a) {
      var u = r - a, l = i * s;
      return [u * oe(l), r - u * ae(l)];
    }
    return o.invert = function(s, a) {
      var u = r - a, l = ei(s, ve(u)) * Hn(u);
      return u * i < 0 && (l -= me * Hn(s) * Hn(u)), [l / i, r - Hn(i) * an(s * s + u * u)];
    }, o;
  }
  function fH() {
    return p2(cH).scale(131.154).center([0, 13.9389]);
  }
  var gc = 1.340264, pc = -0.081106, mc = 893e-6, yc = 3796e-6, fg = an(3) / 2, dH = 12;
  function BN(e, t) {
    var n = xn(fg * oe(t)), i = n * n, r = i * i * i;
    return [
      e * ae(n) / (fg * (gc + 3 * pc * i + r * (7 * mc + 9 * yc * i))),
      n * (gc + pc * i + r * (mc + yc * i))
    ];
  }
  BN.invert = function(e, t) {
    for (var n = t, i = n * n, r = i * i * i, o = 0, s, a, u; o < dH && (a = n * (gc + pc * i + r * (mc + yc * i)) - t, u = gc + 3 * pc * i + r * (7 * mc + 9 * yc * i), n -= s = a / u, i = n * n, r = i * i * i, !(ve(s) < jh)); ++o)
      ;
    return [
      fg * e * (gc + 3 * pc * i + r * (7 * mc + 9 * yc * i)) / ae(n),
      xn(oe(n) / fg)
    ];
  };
  function hH() {
    return pr(BN).scale(177.158);
  }
  function UN(e, t) {
    var n = ae(t), i = ae(e) * n;
    return [n * oe(e) / i, oe(t) / i];
  }
  UN.invert = Sf(nl);
  function gH() {
    return pr(UN).scale(144.049).clipAngle(60);
  }
  function pH() {
    var e = 1, t = 0, n = 0, i = 1, r = 1, o = 0, s, a, u = null, l, c, f, d = 1, h = 1, g = Rp({
      point: function(x, w) {
        var _ = v([x, w]);
        this.stream.point(_[0], _[1]);
      }
    }), p = Lc, m, y;
    function b() {
      return d = e * i, h = e * r, m = y = null, v;
    }
    function v(x) {
      var w = x[0] * d, _ = x[1] * h;
      if (o) {
        var E = _ * s - w * a;
        w = w * s + _ * a, _ = E;
      }
      return [w + t, _ + n];
    }
    return v.invert = function(x) {
      var w = x[0] - t, _ = x[1] - n;
      if (o) {
        var E = _ * s + w * a;
        w = w * s - _ * a, _ = E;
      }
      return [w / d, _ / h];
    }, v.stream = function(x) {
      return m && y === x ? m : m = g(p(y = x));
    }, v.postclip = function(x) {
      return arguments.length ? (p = x, u = l = c = f = null, b()) : p;
    }, v.clipExtent = function(x) {
      return arguments.length ? (p = x == null ? (u = l = c = f = null, Lc) : wN(u = +x[0][0], l = +x[0][1], c = +x[1][0], f = +x[1][1]), b()) : u == null ? null : [[u, l], [c, f]];
    }, v.scale = function(x) {
      return arguments.length ? (e = +x, b()) : e;
    }, v.translate = function(x) {
      return arguments.length ? (t = +x[0], n = +x[1], b()) : [t, n];
    }, v.angle = function(x) {
      return arguments.length ? (o = x % 360 * ge, a = oe(o), s = ae(o), b()) : o * Qe;
    }, v.reflectX = function(x) {
      return arguments.length ? (i = x ? -1 : 1, b()) : i < 0;
    }, v.reflectY = function(x) {
      return arguments.length ? (r = x ? -1 : 1, b()) : r < 0;
    }, v.fitExtent = function(x, w) {
      return Lp(v, x, w);
    }, v.fitSize = function(x, w) {
      return d2(v, x, w);
    }, v.fitWidth = function(x, w) {
      return h2(v, x, w);
    }, v.fitHeight = function(x, w) {
      return g2(v, x, w);
    }, v;
  }
  function jN(e, t) {
    var n = t * t, i = n * n;
    return [
      e * (0.8707 - 0.131979 * n + i * (-0.013791 + i * (3971e-6 * n - 1529e-6 * i))),
      t * (1.007226 + n * (0.015085 + i * (-0.044475 + 0.028874 * n - 5916e-6 * i)))
    ];
  }
  jN.invert = function(e, t) {
    var n = t, i = 25, r;
    do {
      var o = n * n, s = o * o;
      n -= r = (n * (1.007226 + o * (0.015085 + s * (-0.044475 + 0.028874 * o - 5916e-6 * s))) - t) / (1.007226 + o * (0.015085 * 3 + s * (-0.044475 * 7 + 0.028874 * 9 * o - 5916e-6 * 11 * s)));
    } while (ve(r) > se && --i > 0);
    return [
      e / (0.8707 + (o = n * n) * (-0.131979 + o * (-0.013791 + o * o * o * (3971e-6 - 1529e-6 * o)))),
      n
    ];
  };
  function mH() {
    return pr(jN).scale(175.295);
  }
  function qN(e, t) {
    return [ae(t) * oe(e), oe(t)];
  }
  qN.invert = Sf(xn);
  function yH() {
    return pr(qN).scale(249.5).clipAngle(90 + se);
  }
  function WN(e, t) {
    var n = ae(t), i = 1 + ae(e) * n;
    return [n * oe(e) / i, oe(t) / i];
  }
  WN.invert = Sf(function(e) {
    return 2 * nl(e);
  });
  function bH() {
    return pr(WN).scale(250).clipAngle(142);
  }
  function HN(e, t) {
    return [Wh(l2((Xe + t) / 2)), -e];
  }
  HN.invert = function(e, t) {
    return [-t, 2 * nl(oN(e)) - Xe];
  };
  function vH() {
    var e = zN(HN), t = e.center, n = e.rotate;
    return e.center = function(i) {
      return arguments.length ? t([-i[1], i[0]]) : (i = t(), [i[1], -i[0]]);
    }, e.rotate = function(i) {
      return arguments.length ? n([i[0], i[1], i.length > 2 ? i[2] + 90 : 90]) : (i = n(), [i[0], i[1], i[2] - 90]);
    }, n([0, 0, 90]).scale(159.155);
  }
  var xH = Math.abs, Fy = Math.cos, dg = Math.sin, wH = 1e-6, GN = Math.PI, My = GN / 2, x$ = EH(2);
  function w$(e) {
    return e > 1 ? My : e < -1 ? -My : Math.asin(e);
  }
  function EH(e) {
    return e > 0 ? Math.sqrt(e) : 0;
  }
  function _H(e, t) {
    var n = e * dg(t), i = 30, r;
    do
      t -= r = (t + dg(t) - n) / (1 + Fy(t));
    while (xH(r) > wH && --i > 0);
    return t / 2;
  }
  function SH(e, t, n) {
    function i(r, o) {
      return [e * r * Fy(o = _H(n, o)), t * dg(o)];
    }
    return i.invert = function(r, o) {
      return o = w$(o / t), [r / (e * Fy(o)), w$((2 * o + dg(2 * o)) / n)];
    }, i;
  }
  var $H = SH(x$ / My, x$, GN);
  function kH() {
    return pr($H).scale(169.529);
  }
  const AH = NN(), Ty = [
    // standard properties in d3-geo
    "clipAngle",
    "clipExtent",
    "scale",
    "translate",
    "center",
    "rotate",
    "parallels",
    "precision",
    "reflectX",
    "reflectY",
    // extended properties in d3-geo-projections
    "coefficient",
    "distance",
    "fraction",
    "lobes",
    "parallel",
    "radius",
    "ratio",
    "spacing",
    "tilt"
  ];
  function CH(e, t) {
    return function n() {
      const i = t();
      return i.type = e, i.path = NN().projection(i), i.copy = i.copy || function() {
        const r = n();
        return Ty.forEach((o) => {
          i[o] && r[o](i[o]());
        }), r.path.pointRadius(i.path.pointRadius()), r;
      }, a3(i);
    };
  }
  function m2(e, t) {
    if (!e || typeof e != "string")
      throw new Error("Projection type must be a name string.");
    return e = e.toLowerCase(), arguments.length > 1 ? (hg[e] = CH(e, t), this) : hg[e] || null;
  }
  function VN(e) {
    return e && e.path || AH;
  }
  const hg = {
    // base d3-geo projection types
    albers: RN,
    albersusa: iH,
    azimuthalequalarea: rH,
    azimuthalequidistant: oH,
    conicconformal: uH,
    conicequalarea: lg,
    conicequidistant: fH,
    equalEarth: hH,
    equirectangular: lH,
    gnomonic: gH,
    identity: pH,
    mercator: sH,
    mollweide: kH,
    naturalEarth1: mH,
    orthographic: yH,
    stereographic: bH,
    transversemercator: vH
  };
  for (const e in hg)
    m2(e, hg[e]);
  function FH() {
  }
  const $r = [[], [[[1, 1.5], [0.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [0.5, 1]]], [[[1, 0.5], [1.5, 1]]], [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]], [[[1, 0.5], [1, 1.5]]], [[[1, 0.5], [0.5, 1]]], [[[0.5, 1], [1, 0.5]]], [[[1, 1.5], [1, 0.5]]], [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, 0.5]]], [[[0.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[0.5, 1], [1, 1.5]]], []];
  function YN() {
    var e = 1, t = 1, n = a;
    function i(u, l) {
      return l.map((c) => r(u, c));
    }
    function r(u, l) {
      var c = [], f = [];
      return o(u, l, (d) => {
        n(d, u, l), MH(d) > 0 ? c.push([d]) : f.push(d);
      }), f.forEach((d) => {
        for (var h = 0, g = c.length, p; h < g; ++h)
          if (TH((p = c[h])[0], d) !== -1) {
            p.push(d);
            return;
          }
      }), {
        type: "MultiPolygon",
        value: l,
        coordinates: c
      };
    }
    function o(u, l, c) {
      var f = [], d = [], h, g, p, m, y, b;
      for (h = g = -1, m = u[0] >= l, $r[m << 1].forEach(v); ++h < e - 1; )
        p = m, m = u[h + 1] >= l, $r[p | m << 1].forEach(v);
      for ($r[m << 0].forEach(v); ++g < t - 1; ) {
        for (h = -1, m = u[g * e + e] >= l, y = u[g * e] >= l, $r[m << 1 | y << 2].forEach(v); ++h < e - 1; )
          p = m, m = u[g * e + e + h + 1] >= l, b = y, y = u[g * e + h + 1] >= l, $r[p | m << 1 | y << 2 | b << 3].forEach(v);
        $r[m | y << 3].forEach(v);
      }
      for (h = -1, y = u[g * e] >= l, $r[y << 2].forEach(v); ++h < e - 1; )
        b = y, y = u[g * e + h + 1] >= l, $r[y << 2 | b << 3].forEach(v);
      $r[y << 3].forEach(v);
      function v(x) {
        var w = [x[0][0] + h, x[0][1] + g], _ = [x[1][0] + h, x[1][1] + g], E = s(w), S = s(_), $, F;
        ($ = d[E]) ? (F = f[S]) ? (delete d[$.end], delete f[F.start], $ === F ? ($.ring.push(_), c($.ring)) : f[$.start] = d[F.end] = {
          start: $.start,
          end: F.end,
          ring: $.ring.concat(F.ring)
        }) : (delete d[$.end], $.ring.push(_), d[$.end = S] = $) : ($ = f[S]) ? (F = d[E]) ? (delete f[$.start], delete d[F.end], $ === F ? ($.ring.push(_), c($.ring)) : f[F.start] = d[$.end] = {
          start: F.start,
          end: $.end,
          ring: F.ring.concat($.ring)
        }) : (delete f[$.start], $.ring.unshift(w), f[$.start = E] = $) : f[E] = d[S] = {
          start: E,
          end: S,
          ring: [w, _]
        };
      }
    }
    function s(u) {
      return u[0] * 2 + u[1] * (e + 1) * 4;
    }
    function a(u, l, c) {
      u.forEach((f) => {
        var d = f[0], h = f[1], g = d | 0, p = h | 0, m, y = l[p * e + g];
        d > 0 && d < e && g === d && (m = l[p * e + g - 1], f[0] = d + (c - m) / (y - m) - 0.5), h > 0 && h < t && p === h && (m = l[(p - 1) * e + g], f[1] = h + (c - m) / (y - m) - 0.5);
      });
    }
    return i.contour = r, i.size = function(u) {
      if (!arguments.length) return [e, t];
      var l = Math.floor(u[0]), c = Math.floor(u[1]);
      return l >= 0 && c >= 0 || R("invalid size"), e = l, t = c, i;
    }, i.smooth = function(u) {
      return arguments.length ? (n = u ? a : FH, i) : n === a;
    }, i;
  }
  function MH(e) {
    for (var t = 0, n = e.length, i = e[n - 1][1] * e[0][0] - e[n - 1][0] * e[0][1]; ++t < n; ) i += e[t - 1][1] * e[t][0] - e[t - 1][0] * e[t][1];
    return i;
  }
  function TH(e, t) {
    for (var n = -1, i = t.length, r; ++n < i; ) if (r = DH(e, t[n])) return r;
    return 0;
  }
  function DH(e, t) {
    for (var n = t[0], i = t[1], r = -1, o = 0, s = e.length, a = s - 1; o < s; a = o++) {
      var u = e[o], l = u[0], c = u[1], f = e[a], d = f[0], h = f[1];
      if (NH(u, f, t)) return 0;
      c > i != h > i && n < (d - l) * (i - c) / (h - c) + l && (r = -r);
    }
    return r;
  }
  function NH(e, t, n) {
    var i;
    return OH(e, t, n) && RH(e[i = +(e[0] === t[0])], n[i], t[i]);
  }
  function OH(e, t, n) {
    return (t[0] - e[0]) * (n[1] - e[1]) === (n[0] - e[0]) * (t[1] - e[1]);
  }
  function RH(e, t, n) {
    return e <= t && t <= n || n <= t && t <= e;
  }
  function XN(e, t, n) {
    return function(i) {
      var r = nr(i), o = n ? Math.min(r[0], 0) : r[0], s = r[1], a = s - o, u = t ? Ro(o, s, e) : a / (e + 1);
      return Tn(o + u, s, u);
    };
  }
  function y2(e) {
    N.call(this, null, e);
  }
  y2.Definition = {
    type: "Isocontour",
    metadata: {
      generates: !0
    },
    params: [{
      name: "field",
      type: "field"
    }, {
      name: "thresholds",
      type: "number",
      array: !0
    }, {
      name: "levels",
      type: "number"
    }, {
      name: "nice",
      type: "boolean",
      default: !1
    }, {
      name: "resolve",
      type: "enum",
      values: ["shared", "independent"],
      default: "independent"
    }, {
      name: "zero",
      type: "boolean",
      default: !0
    }, {
      name: "smooth",
      type: "boolean",
      default: !0
    }, {
      name: "scale",
      type: "number",
      expr: !0
    }, {
      name: "translate",
      type: "number",
      array: !0,
      expr: !0
    }, {
      name: "as",
      type: "string",
      null: !0,
      default: "contour"
    }]
  };
  G(y2, N, {
    transform(e, t) {
      if (this.value && !t.changed() && !e.modified())
        return t.StopPropagation;
      var n = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = t.materialize(t.SOURCE).source, r = e.field || Ht, o = YN().smooth(e.smooth !== !1), s = e.thresholds || LH(i, r, e), a = e.as === null ? null : e.as || "contour", u = [];
      return i.forEach((l) => {
        const c = r(l), f = o.size([c.width, c.height])(c.values, P(s) ? s : s(c.values));
        PH(f, c, l, e), f.forEach((d) => {
          u.push(ep(l, Ce(a != null ? {
            [a]: d
          } : d)));
        });
      }), this.value && (n.rem = this.value), this.value = n.source = n.add = u, n;
    }
  });
  function LH(e, t, n) {
    const i = XN(n.levels || 10, n.nice, n.zero !== !1);
    return n.resolve !== "shared" ? i : i(e.map((r) => Rs(t(r).values)));
  }
  function PH(e, t, n, i) {
    let r = i.scale || t.scale, o = i.translate || t.translate;
    if (fe(r) && (r = r(n, i)), fe(o) && (o = o(n, i)), (r === 1 || r == null) && !o) return;
    const s = ($e(r) ? r : r[0]) || 1, a = ($e(r) ? r : r[1]) || 1, u = o && o[0] || 0, l = o && o[1] || 0;
    e.forEach(KN(t, s, a, u, l));
  }
  function KN(e, t, n, i, r) {
    const o = e.x1 || 0, s = e.y1 || 0, a = t * n < 0;
    function u(f) {
      f.forEach(l);
    }
    function l(f) {
      a && f.reverse(), f.forEach(c);
    }
    function c(f) {
      f[0] = (f[0] - o) * t + i, f[1] = (f[1] - s) * n + r;
    }
    return function(f) {
      return f.coordinates.forEach(u), f;
    };
  }
  function E$(e, t, n) {
    const i = e >= 0 ? e : lv(t, n);
    return Math.round((Math.sqrt(4 * i * i + 1) - 1) / 2);
  }
  function k0(e) {
    return fe(e) ? e : Gt(+e);
  }
  function JN() {
    var e = (u) => u[0], t = (u) => u[1], n = qu, i = [-1, -1], r = 960, o = 500, s = 2;
    function a(u, l) {
      const c = E$(i[0], u, e) >> s, f = E$(i[1], u, t) >> s, d = c ? c + 2 : 0, h = f ? f + 2 : 0, g = 2 * d + (r >> s), p = 2 * h + (o >> s), m = new Float32Array(g * p), y = new Float32Array(g * p);
      let b = m;
      u.forEach((x) => {
        const w = d + (+e(x) >> s), _ = h + (+t(x) >> s);
        w >= 0 && w < g && _ >= 0 && _ < p && (m[w + _ * g] += +n(x));
      }), c > 0 && f > 0 ? (Na(g, p, m, y, c), Oa(g, p, y, m, f), Na(g, p, m, y, c), Oa(g, p, y, m, f), Na(g, p, m, y, c), Oa(g, p, y, m, f)) : c > 0 ? (Na(g, p, m, y, c), Na(g, p, y, m, c), Na(g, p, m, y, c), b = y) : f > 0 && (Oa(g, p, m, y, f), Oa(g, p, y, m, f), Oa(g, p, m, y, f), b = y);
      const v = l ? Math.pow(2, -2 * s) : 1 / fF(b);
      for (let x = 0, w = g * p; x < w; ++x) b[x] *= v;
      return {
        values: b,
        scale: 1 << s,
        width: g,
        height: p,
        x1: d,
        y1: h,
        x2: d + (r >> s),
        y2: h + (o >> s)
      };
    }
    return a.x = function(u) {
      return arguments.length ? (e = k0(u), a) : e;
    }, a.y = function(u) {
      return arguments.length ? (t = k0(u), a) : t;
    }, a.weight = function(u) {
      return arguments.length ? (n = k0(u), a) : n;
    }, a.size = function(u) {
      if (!arguments.length) return [r, o];
      var l = +u[0], c = +u[1];
      return l >= 0 && c >= 0 || R("invalid size"), r = l, o = c, a;
    }, a.cellSize = function(u) {
      return arguments.length ? ((u = +u) >= 1 || R("invalid cell size"), s = Math.floor(Math.log(u) / Math.LN2), a) : 1 << s;
    }, a.bandwidth = function(u) {
      return arguments.length ? (u = X(u), u.length === 1 && (u = [+u[0], +u[0]]), u.length !== 2 && R("invalid bandwidth"), i = u, a) : i;
    }, a;
  }
  function Na(e, t, n, i, r) {
    const o = (r << 1) + 1;
    for (let s = 0; s < t; ++s)
      for (let a = 0, u = 0; a < e + r; ++a)
        a < e && (u += n[a + s * e]), a >= r && (a >= o && (u -= n[a - o + s * e]), i[a - r + s * e] = u / Math.min(a + 1, e - 1 + o - a, o));
  }
  function Oa(e, t, n, i, r) {
    const o = (r << 1) + 1;
    for (let s = 0; s < e; ++s)
      for (let a = 0, u = 0; a < t + r; ++a)
        a < t && (u += n[s + a * e]), a >= r && (a >= o && (u -= n[s + (a - o) * e]), i[s + (a - r) * e] = u / Math.min(a + 1, t - 1 + o - a, o));
  }
  function b2(e) {
    N.call(this, null, e);
  }
  b2.Definition = {
    type: "KDE2D",
    metadata: {
      generates: !0
    },
    params: [{
      name: "size",
      type: "number",
      array: !0,
      length: 2,
      required: !0
    }, {
      name: "x",
      type: "field",
      required: !0
    }, {
      name: "y",
      type: "field",
      required: !0
    }, {
      name: "weight",
      type: "field"
    }, {
      name: "groupby",
      type: "field",
      array: !0
    }, {
      name: "cellSize",
      type: "number"
    }, {
      name: "bandwidth",
      type: "number",
      array: !0,
      length: 2
    }, {
      name: "counts",
      type: "boolean",
      default: !1
    }, {
      name: "as",
      type: "string",
      default: "grid"
    }]
  };
  const IH = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
  function QN(e, t) {
    return IH.forEach((n) => t[n] != null ? e[n](t[n]) : 0), e;
  }
  G(b2, N, {
    transform(e, t) {
      if (this.value && !t.changed() && !e.modified()) return t.StopPropagation;
      var n = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = t.materialize(t.SOURCE).source, r = zH(i, e.groupby), o = (e.groupby || []).map(Je), s = QN(JN(), e), a = e.as || "grid", u = [];
      function l(c, f) {
        for (let d = 0; d < o.length; ++d) c[o[d]] = f[d];
        return c;
      }
      return u = r.map((c) => Ce(l({
        [a]: s(c, e.counts)
      }, c.dims))), this.value && (n.rem = this.value), this.value = n.source = n.add = u, n;
    }
  });
  function zH(e, t) {
    var n = [], i = (c) => c(a), r, o, s, a, u, l;
    if (t == null)
      n.push(e);
    else
      for (r = {}, o = 0, s = e.length; o < s; ++o)
        a = e[o], u = t.map(i), l = r[u], l || (r[u] = l = [], l.dims = u, n.push(l)), l.push(a);
    return n;
  }
  function v2(e) {
    N.call(this, null, e);
  }
  v2.Definition = {
    type: "Contour",
    metadata: {
      generates: !0
    },
    params: [{
      name: "size",
      type: "number",
      array: !0,
      length: 2,
      required: !0
    }, {
      name: "values",
      type: "number",
      array: !0
    }, {
      name: "x",
      type: "field"
    }, {
      name: "y",
      type: "field"
    }, {
      name: "weight",
      type: "field"
    }, {
      name: "cellSize",
      type: "number"
    }, {
      name: "bandwidth",
      type: "number"
    }, {
      name: "count",
      type: "number"
    }, {
      name: "nice",
      type: "boolean",
      default: !1
    }, {
      name: "thresholds",
      type: "number",
      array: !0
    }, {
      name: "smooth",
      type: "boolean",
      default: !0
    }]
  };
  G(v2, N, {
    transform(e, t) {
      if (this.value && !t.changed() && !e.modified())
        return t.StopPropagation;
      var n = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = YN().smooth(e.smooth !== !1), r = e.values, o = e.thresholds || XN(e.count || 10, e.nice, !!r), s = e.size, a, u;
      return r || (r = t.materialize(t.SOURCE).source, a = QN(JN(), e)(r, !0), u = KN(a, a.scale || 1, a.scale || 1, 0, 0), s = [a.width, a.height], r = a.values), o = P(o) ? o : o(r), r = i.size(s)(r, o), u && r.forEach(u), this.value && (n.rem = this.value), this.value = n.source = n.add = (r || []).map(Ce), n;
    }
  });
  const Dy = "Feature", x2 = "FeatureCollection", BH = "MultiPoint";
  function w2(e) {
    N.call(this, null, e);
  }
  w2.Definition = {
    type: "GeoJSON",
    metadata: {},
    params: [{
      name: "fields",
      type: "field",
      array: !0,
      length: 2
    }, {
      name: "geojson",
      type: "field"
    }]
  };
  G(w2, N, {
    transform(e, t) {
      var n = this._features, i = this._points, r = e.fields, o = r && r[0], s = r && r[1], a = e.geojson || !r && Ht, u = t.ADD, l;
      l = e.modified() || t.changed(t.REM) || t.modified(Ut(a)) || o && t.modified(Ut(o)) || s && t.modified(Ut(s)), (!this.value || l) && (u = t.SOURCE, this._features = n = [], this._points = i = []), a && t.visit(u, (c) => n.push(a(c))), o && s && (t.visit(u, (c) => {
        var f = o(c), d = s(c);
        f != null && d != null && (f = +f) === f && (d = +d) === d && i.push([f, d]);
      }), n = n.concat({
        type: Dy,
        geometry: {
          type: BH,
          coordinates: i
        }
      })), this.value = {
        type: x2,
        features: n
      };
    }
  });
  function E2(e) {
    N.call(this, null, e);
  }
  E2.Definition = {
    type: "GeoPath",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "projection",
      type: "projection"
    }, {
      name: "field",
      type: "field"
    }, {
      name: "pointRadius",
      type: "number",
      expr: !0
    }, {
      name: "as",
      type: "string",
      default: "path"
    }]
  };
  G(E2, N, {
    transform(e, t) {
      var n = t.fork(t.ALL), i = this.value, r = e.field || Ht, o = e.as || "path", s = n.SOURCE;
      !i || e.modified() ? (this.value = i = VN(e.projection), n.materialize().reflow()) : s = r === Ht || t.modified(r.fields) ? n.ADD_MOD : n.ADD;
      const a = UH(i, e.pointRadius);
      return n.visit(s, (u) => u[o] = i(r(u))), i.pointRadius(a), n.modifies(o);
    }
  });
  function UH(e, t) {
    const n = e.pointRadius();
    return e.context(null), t != null && e.pointRadius(t), n;
  }
  function _2(e) {
    N.call(this, null, e);
  }
  _2.Definition = {
    type: "GeoPoint",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "projection",
      type: "projection",
      required: !0
    }, {
      name: "fields",
      type: "field",
      array: !0,
      required: !0,
      length: 2
    }, {
      name: "as",
      type: "string",
      array: !0,
      length: 2,
      default: ["x", "y"]
    }]
  };
  G(_2, N, {
    transform(e, t) {
      var n = e.projection, i = e.fields[0], r = e.fields[1], o = e.as || ["x", "y"], s = o[0], a = o[1], u;
      function l(c) {
        const f = n([i(c), r(c)]);
        f ? (c[s] = f[0], c[a] = f[1]) : (c[s] = void 0, c[a] = void 0);
      }
      return e.modified() ? t = t.materialize().reflow(!0).visit(t.SOURCE, l) : (u = t.modified(i.fields) || t.modified(r.fields), t.visit(u ? t.ADD_MOD : t.ADD, l)), t.modifies(o);
    }
  });
  function S2(e) {
    N.call(this, null, e);
  }
  S2.Definition = {
    type: "GeoShape",
    metadata: {
      modifies: !0,
      nomod: !0
    },
    params: [{
      name: "projection",
      type: "projection"
    }, {
      name: "field",
      type: "field",
      default: "datum"
    }, {
      name: "pointRadius",
      type: "number",
      expr: !0
    }, {
      name: "as",
      type: "string",
      default: "shape"
    }]
  };
  G(S2, N, {
    transform(e, t) {
      var n = t.fork(t.ALL), i = this.value, r = e.as || "shape", o = n.ADD;
      return (!i || e.modified()) && (this.value = i = jH(VN(e.projection), e.field || Kn("datum"), e.pointRadius), n.materialize().reflow(), o = n.SOURCE), n.visit(o, (s) => s[r] = i), n.modifies(r);
    }
  });
  function jH(e, t, n) {
    const i = n == null ? (r) => e(t(r)) : (r) => {
      var o = e.pointRadius(), s = e.pointRadius(n)(t(r));
      return e.pointRadius(o), s;
    };
    return i.context = (r) => (e.context(r), i), i;
  }
  function $2(e) {
    N.call(this, [], e), this.generator = LW();
  }
  $2.Definition = {
    type: "Graticule",
    metadata: {
      changes: !0,
      generates: !0
    },
    params: [{
      name: "extent",
      type: "array",
      array: !0,
      length: 2,
      content: {
        type: "number",
        array: !0,
        length: 2
      }
    }, {
      name: "extentMajor",
      type: "array",
      array: !0,
      length: 2,
      content: {
        type: "number",
        array: !0,
        length: 2
      }
    }, {
      name: "extentMinor",
      type: "array",
      array: !0,
      length: 2,
      content: {
        type: "number",
        array: !0,
        length: 2
      }
    }, {
      name: "step",
      type: "number",
      array: !0,
      length: 2
    }, {
      name: "stepMajor",
      type: "number",
      array: !0,
      length: 2,
      default: [90, 360]
    }, {
      name: "stepMinor",
      type: "number",
      array: !0,
      length: 2,
      default: [10, 10]
    }, {
      name: "precision",
      type: "number",
      default: 2.5
    }]
  };
  G($2, N, {
    transform(e, t) {
      var n = this.value, i = this.generator, r;
      if (!n.length || e.modified())
        for (const o in e)
          fe(i[o]) && i[o](e[o]);
      return r = i(), n.length ? t.mod.push(sM(n[0], r)) : t.add.push(Ce(r)), n[0] = r, t;
    }
  });
  function k2(e) {
    N.call(this, null, e);
  }
  k2.Definition = {
    type: "heatmap",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "field",
      type: "field"
    }, {
      name: "color",
      type: "string",
      expr: !0
    }, {
      name: "opacity",
      type: "number",
      expr: !0
    }, {
      name: "resolve",
      type: "enum",
      values: ["shared", "independent"],
      default: "independent"
    }, {
      name: "as",
      type: "string",
      default: "image"
    }]
  };
  G(k2, N, {
    transform(e, t) {
      if (!t.changed() && !e.modified())
        return t.StopPropagation;
      var n = t.materialize(t.SOURCE).source, i = e.resolve === "shared", r = e.field || Ht, o = WH(e.opacity, e), s = qH(e.color, e), a = e.as || "image", u = {
        $x: 0,
        $y: 0,
        $value: 0,
        $max: i ? Rs(n.map((l) => Rs(r(l).values))) : 0
      };
      return n.forEach((l) => {
        const c = r(l), f = ce({}, l, u);
        i || (f.$max = Rs(c.values || [])), l[a] = HH(c, f, s.dep ? s : Gt(s(f)), o.dep ? o : Gt(o(f)));
      }), t.reflow(!0).modifies(a);
    }
  });
  function qH(e, t) {
    let n;
    return fe(e) ? (n = (i) => Io(e(i, t)), n.dep = ZN(e)) : n = Gt(Io(e || "#888")), n;
  }
  function WH(e, t) {
    let n;
    return fe(e) ? (n = (i) => e(i, t), n.dep = ZN(e)) : e ? n = Gt(e) : (n = (i) => i.$value / i.$max || 0, n.dep = !0), n;
  }
  function ZN(e) {
    if (!fe(e)) return !1;
    const t = wi(Ut(e));
    return t.$x || t.$y || t.$value || t.$max;
  }
  function HH(e, t, n, i) {
    const r = e.width, o = e.height, s = e.x1 || 0, a = e.y1 || 0, u = e.x2 || r, l = e.y2 || o, c = e.values, f = c ? (m) => c[m] : bo, d = To(u - s, l - a), h = d.getContext("2d"), g = h.getImageData(0, 0, u - s, l - a), p = g.data;
    for (let m = a, y = 0; m < l; ++m) {
      t.$y = m - a;
      for (let b = s, v = m * r; b < u; ++b, y += 4) {
        t.$x = b - s, t.$value = f(b + v);
        const x = n(t);
        p[y + 0] = x.r, p[y + 1] = x.g, p[y + 2] = x.b, p[y + 3] = ~~(255 * i(t));
      }
    }
    return h.putImageData(g, 0, 0), d;
  }
  function eO(e) {
    N.call(this, null, e), this.modified(!0);
  }
  G(eO, N, {
    transform(e, t) {
      let n = this.value;
      return !n || e.modified("type") ? (this.value = n = VH(e.type), Ty.forEach((i) => {
        e[i] != null && _$(n, i, e[i]);
      })) : Ty.forEach((i) => {
        e.modified(i) && _$(n, i, e[i]);
      }), e.pointRadius != null && n.path.pointRadius(e.pointRadius), e.fit && GH(n, e), t.fork(t.NO_SOURCE | t.NO_FIELDS);
    }
  });
  function GH(e, t) {
    const n = YH(t.fit);
    t.extent ? e.fitExtent(t.extent, n) : t.size && e.fitSize(t.size, n);
  }
  function VH(e) {
    const t = m2((e || "mercator").toLowerCase());
    return t || R("Unrecognized projection type: " + e), t();
  }
  function _$(e, t, n) {
    fe(e[t]) && e[t](n);
  }
  function YH(e) {
    return e = X(e), e.length === 1 ? e[0] : {
      type: x2,
      features: e.reduce((t, n) => t.concat(XH(n)), [])
    };
  }
  function XH(e) {
    return e.type === x2 ? e.features : X(e).filter((t) => t != null).map((t) => t.type === Dy ? t : {
      type: Dy,
      geometry: t
    });
  }
  const KH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    contour: v2,
    geojson: w2,
    geopath: E2,
    geopoint: _2,
    geoshape: S2,
    graticule: $2,
    heatmap: k2,
    isocontour: y2,
    kde2d: b2,
    projection: eO
  }, Symbol.toStringTag, { value: "Module" }));
  function JH(e, t) {
    var n, i = 1;
    e == null && (e = 0), t == null && (t = 0);
    function r() {
      var o, s = n.length, a, u = 0, l = 0;
      for (o = 0; o < s; ++o)
        a = n[o], u += a.x, l += a.y;
      for (u = (u / s - e) * i, l = (l / s - t) * i, o = 0; o < s; ++o)
        a = n[o], a.x -= u, a.y -= l;
    }
    return r.initialize = function(o) {
      n = o;
    }, r.x = function(o) {
      return arguments.length ? (e = +o, r) : e;
    }, r.y = function(o) {
      return arguments.length ? (t = +o, r) : t;
    }, r.strength = function(o) {
      return arguments.length ? (i = +o, r) : i;
    }, r;
  }
  function QH(e) {
    const t = +this._x.call(null, e), n = +this._y.call(null, e);
    return tO(this.cover(t, n), t, n, e);
  }
  function tO(e, t, n, i) {
    if (isNaN(t) || isNaN(n)) return e;
    var r, o = e._root, s = { data: i }, a = e._x0, u = e._y0, l = e._x1, c = e._y1, f, d, h, g, p, m, y, b;
    if (!o) return e._root = s, e;
    for (; o.length; )
      if ((p = t >= (f = (a + l) / 2)) ? a = f : l = f, (m = n >= (d = (u + c) / 2)) ? u = d : c = d, r = o, !(o = o[y = m << 1 | p])) return r[y] = s, e;
    if (h = +e._x.call(null, o.data), g = +e._y.call(null, o.data), t === h && n === g) return s.next = o, r ? r[y] = s : e._root = s, e;
    do
      r = r ? r[y] = new Array(4) : e._root = new Array(4), (p = t >= (f = (a + l) / 2)) ? a = f : l = f, (m = n >= (d = (u + c) / 2)) ? u = d : c = d;
    while ((y = m << 1 | p) === (b = (g >= d) << 1 | h >= f));
    return r[b] = o, r[y] = s, e;
  }
  function ZH(e) {
    var t, n, i = e.length, r, o, s = new Array(i), a = new Array(i), u = 1 / 0, l = 1 / 0, c = -1 / 0, f = -1 / 0;
    for (n = 0; n < i; ++n)
      isNaN(r = +this._x.call(null, t = e[n])) || isNaN(o = +this._y.call(null, t)) || (s[n] = r, a[n] = o, r < u && (u = r), r > c && (c = r), o < l && (l = o), o > f && (f = o));
    if (u > c || l > f) return this;
    for (this.cover(u, l).cover(c, f), n = 0; n < i; ++n)
      tO(this, s[n], a[n], e[n]);
    return this;
  }
  function eG(e, t) {
    if (isNaN(e = +e) || isNaN(t = +t)) return this;
    var n = this._x0, i = this._y0, r = this._x1, o = this._y1;
    if (isNaN(n))
      r = (n = Math.floor(e)) + 1, o = (i = Math.floor(t)) + 1;
    else {
      for (var s = r - n || 1, a = this._root, u, l; n > e || e >= r || i > t || t >= o; )
        switch (l = (t < i) << 1 | e < n, u = new Array(4), u[l] = a, a = u, s *= 2, l) {
          case 0:
            r = n + s, o = i + s;
            break;
          case 1:
            n = r - s, o = i + s;
            break;
          case 2:
            r = n + s, i = o - s;
            break;
          case 3:
            n = r - s, i = o - s;
            break;
        }
      this._root && this._root.length && (this._root = a);
    }
    return this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = o, this;
  }
  function tG() {
    var e = [];
    return this.visit(function(t) {
      if (!t.length) do
        e.push(t.data);
      while (t = t.next);
    }), e;
  }
  function nG(e) {
    return arguments.length ? this.cover(+e[0][0], +e[0][1]).cover(+e[1][0], +e[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
  }
  function en(e, t, n, i, r) {
    this.node = e, this.x0 = t, this.y0 = n, this.x1 = i, this.y1 = r;
  }
  function iG(e, t, n) {
    var i, r = this._x0, o = this._y0, s, a, u, l, c = this._x1, f = this._y1, d = [], h = this._root, g, p;
    for (h && d.push(new en(h, r, o, c, f)), n == null ? n = 1 / 0 : (r = e - n, o = t - n, c = e + n, f = t + n, n *= n); g = d.pop(); )
      if (!(!(h = g.node) || (s = g.x0) > c || (a = g.y0) > f || (u = g.x1) < r || (l = g.y1) < o))
        if (h.length) {
          var m = (s + u) / 2, y = (a + l) / 2;
          d.push(
            new en(h[3], m, y, u, l),
            new en(h[2], s, y, m, l),
            new en(h[1], m, a, u, y),
            new en(h[0], s, a, m, y)
          ), (p = (t >= y) << 1 | e >= m) && (g = d[d.length - 1], d[d.length - 1] = d[d.length - 1 - p], d[d.length - 1 - p] = g);
        } else {
          var b = e - +this._x.call(null, h.data), v = t - +this._y.call(null, h.data), x = b * b + v * v;
          if (x < n) {
            var w = Math.sqrt(n = x);
            r = e - w, o = t - w, c = e + w, f = t + w, i = h.data;
          }
        }
    return i;
  }
  function rG(e) {
    if (isNaN(c = +this._x.call(null, e)) || isNaN(f = +this._y.call(null, e))) return this;
    var t, n = this._root, i, r, o, s = this._x0, a = this._y0, u = this._x1, l = this._y1, c, f, d, h, g, p, m, y;
    if (!n) return this;
    if (n.length) for (; ; ) {
      if ((g = c >= (d = (s + u) / 2)) ? s = d : u = d, (p = f >= (h = (a + l) / 2)) ? a = h : l = h, t = n, !(n = n[m = p << 1 | g])) return this;
      if (!n.length) break;
      (t[m + 1 & 3] || t[m + 2 & 3] || t[m + 3 & 3]) && (i = t, y = m);
    }
    for (; n.data !== e; ) if (r = n, !(n = n.next)) return this;
    return (o = n.next) && delete n.next, r ? (o ? r.next = o : delete r.next, this) : t ? (o ? t[m] = o : delete t[m], (n = t[0] || t[1] || t[2] || t[3]) && n === (t[3] || t[2] || t[1] || t[0]) && !n.length && (i ? i[y] = n : this._root = n), this) : (this._root = o, this);
  }
  function oG(e) {
    for (var t = 0, n = e.length; t < n; ++t) this.remove(e[t]);
    return this;
  }
  function sG() {
    return this._root;
  }
  function aG() {
    var e = 0;
    return this.visit(function(t) {
      if (!t.length) do
        ++e;
      while (t = t.next);
    }), e;
  }
  function uG(e) {
    var t = [], n, i = this._root, r, o, s, a, u;
    for (i && t.push(new en(i, this._x0, this._y0, this._x1, this._y1)); n = t.pop(); )
      if (!e(i = n.node, o = n.x0, s = n.y0, a = n.x1, u = n.y1) && i.length) {
        var l = (o + a) / 2, c = (s + u) / 2;
        (r = i[3]) && t.push(new en(r, l, c, a, u)), (r = i[2]) && t.push(new en(r, o, c, l, u)), (r = i[1]) && t.push(new en(r, l, s, a, c)), (r = i[0]) && t.push(new en(r, o, s, l, c));
      }
    return this;
  }
  function lG(e) {
    var t = [], n = [], i;
    for (this._root && t.push(new en(this._root, this._x0, this._y0, this._x1, this._y1)); i = t.pop(); ) {
      var r = i.node;
      if (r.length) {
        var o, s = i.x0, a = i.y0, u = i.x1, l = i.y1, c = (s + u) / 2, f = (a + l) / 2;
        (o = r[0]) && t.push(new en(o, s, a, c, f)), (o = r[1]) && t.push(new en(o, c, a, u, f)), (o = r[2]) && t.push(new en(o, s, f, c, l)), (o = r[3]) && t.push(new en(o, c, f, u, l));
      }
      n.push(i);
    }
    for (; i = n.pop(); )
      e(i.node, i.x0, i.y0, i.x1, i.y1);
    return this;
  }
  function cG(e) {
    return e[0];
  }
  function fG(e) {
    return arguments.length ? (this._x = e, this) : this._x;
  }
  function dG(e) {
    return e[1];
  }
  function hG(e) {
    return arguments.length ? (this._y = e, this) : this._y;
  }
  function A2(e, t, n) {
    var i = new C2(t ?? cG, n ?? dG, NaN, NaN, NaN, NaN);
    return e == null ? i : i.addAll(e);
  }
  function C2(e, t, n, i, r, o) {
    this._x = e, this._y = t, this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = o, this._root = void 0;
  }
  function S$(e) {
    for (var t = { data: e.data }, n = t; e = e.next; ) n = n.next = { data: e.data };
    return t;
  }
  var ln = A2.prototype = C2.prototype;
  ln.copy = function() {
    var e = new C2(this._x, this._y, this._x0, this._y0, this._x1, this._y1), t = this._root, n, i;
    if (!t) return e;
    if (!t.length) return e._root = S$(t), e;
    for (n = [{ source: t, target: e._root = new Array(4) }]; t = n.pop(); )
      for (var r = 0; r < 4; ++r)
        (i = t.source[r]) && (i.length ? n.push({ source: i, target: t.target[r] = new Array(4) }) : t.target[r] = S$(i));
    return e;
  };
  ln.add = QH;
  ln.addAll = ZH;
  ln.cover = eG;
  ln.data = tG;
  ln.extent = nG;
  ln.find = iG;
  ln.remove = rG;
  ln.removeAll = oG;
  ln.root = sG;
  ln.size = aG;
  ln.visit = uG;
  ln.visitAfter = lG;
  ln.x = fG;
  ln.y = hG;
  function tn(e) {
    return function() {
      return e;
    };
  }
  function $o(e) {
    return (e() - 0.5) * 1e-6;
  }
  function gG(e) {
    return e.x + e.vx;
  }
  function pG(e) {
    return e.y + e.vy;
  }
  function mG(e) {
    var t, n, i, r = 1, o = 1;
    typeof e != "function" && (e = tn(e == null ? 1 : +e));
    function s() {
      for (var l, c = t.length, f, d, h, g, p, m, y = 0; y < o; ++y)
        for (f = A2(t, gG, pG).visitAfter(a), l = 0; l < c; ++l)
          d = t[l], p = n[d.index], m = p * p, h = d.x + d.vx, g = d.y + d.vy, f.visit(b);
      function b(v, x, w, _, E) {
        var S = v.data, $ = v.r, F = p + $;
        if (S) {
          if (S.index > d.index) {
            var A = h - S.x - S.vx, D = g - S.y - S.vy, k = A * A + D * D;
            k < F * F && (A === 0 && (A = $o(i), k += A * A), D === 0 && (D = $o(i), k += D * D), k = (F - (k = Math.sqrt(k))) / k * r, d.vx += (A *= k) * (F = ($ *= $) / (m + $)), d.vy += (D *= k) * F, S.vx -= A * (F = 1 - F), S.vy -= D * F);
          }
          return;
        }
        return x > h + F || _ < h - F || w > g + F || E < g - F;
      }
    }
    function a(l) {
      if (l.data) return l.r = n[l.data.index];
      for (var c = l.r = 0; c < 4; ++c)
        l[c] && l[c].r > l.r && (l.r = l[c].r);
    }
    function u() {
      if (t) {
        var l, c = t.length, f;
        for (n = new Array(c), l = 0; l < c; ++l) f = t[l], n[f.index] = +e(f, l, t);
      }
    }
    return s.initialize = function(l, c) {
      t = l, i = c, u();
    }, s.iterations = function(l) {
      return arguments.length ? (o = +l, s) : o;
    }, s.strength = function(l) {
      return arguments.length ? (r = +l, s) : r;
    }, s.radius = function(l) {
      return arguments.length ? (e = typeof l == "function" ? l : tn(+l), u(), s) : e;
    }, s;
  }
  function yG(e) {
    return e.index;
  }
  function $$(e, t) {
    var n = e.get(t);
    if (!n) throw new Error("node not found: " + t);
    return n;
  }
  function bG(e) {
    var t = yG, n = f, i, r = tn(30), o, s, a, u, l, c = 1;
    e == null && (e = []);
    function f(m) {
      return 1 / Math.min(a[m.source.index], a[m.target.index]);
    }
    function d(m) {
      for (var y = 0, b = e.length; y < c; ++y)
        for (var v = 0, x, w, _, E, S, $, F; v < b; ++v)
          x = e[v], w = x.source, _ = x.target, E = _.x + _.vx - w.x - w.vx || $o(l), S = _.y + _.vy - w.y - w.vy || $o(l), $ = Math.sqrt(E * E + S * S), $ = ($ - o[v]) / $ * m * i[v], E *= $, S *= $, _.vx -= E * (F = u[v]), _.vy -= S * F, w.vx += E * (F = 1 - F), w.vy += S * F;
    }
    function h() {
      if (s) {
        var m, y = s.length, b = e.length, v = new Map(s.map((w, _) => [t(w, _, s), w])), x;
        for (m = 0, a = new Array(y); m < b; ++m)
          x = e[m], x.index = m, typeof x.source != "object" && (x.source = $$(v, x.source)), typeof x.target != "object" && (x.target = $$(v, x.target)), a[x.source.index] = (a[x.source.index] || 0) + 1, a[x.target.index] = (a[x.target.index] || 0) + 1;
        for (m = 0, u = new Array(b); m < b; ++m)
          x = e[m], u[m] = a[x.source.index] / (a[x.source.index] + a[x.target.index]);
        i = new Array(b), g(), o = new Array(b), p();
      }
    }
    function g() {
      if (s)
        for (var m = 0, y = e.length; m < y; ++m)
          i[m] = +n(e[m], m, e);
    }
    function p() {
      if (s)
        for (var m = 0, y = e.length; m < y; ++m)
          o[m] = +r(e[m], m, e);
    }
    return d.initialize = function(m, y) {
      s = m, l = y, h();
    }, d.links = function(m) {
      return arguments.length ? (e = m, h(), d) : e;
    }, d.id = function(m) {
      return arguments.length ? (t = m, d) : t;
    }, d.iterations = function(m) {
      return arguments.length ? (c = +m, d) : c;
    }, d.strength = function(m) {
      return arguments.length ? (n = typeof m == "function" ? m : tn(+m), g(), d) : n;
    }, d.distance = function(m) {
      return arguments.length ? (r = typeof m == "function" ? m : tn(+m), p(), d) : r;
    }, d;
  }
  var vG = { value: () => {
  } };
  function nO() {
    for (var e = 0, t = arguments.length, n = {}, i; e < t; ++e) {
      if (!(i = arguments[e] + "") || i in n || /[\s.]/.test(i)) throw new Error("illegal type: " + i);
      n[i] = [];
    }
    return new Kd(n);
  }
  function Kd(e) {
    this._ = e;
  }
  function xG(e, t) {
    return e.trim().split(/^|\s+/).map(function(n) {
      var i = "", r = n.indexOf(".");
      if (r >= 0 && (i = n.slice(r + 1), n = n.slice(0, r)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
      return { type: n, name: i };
    });
  }
  Kd.prototype = nO.prototype = {
    constructor: Kd,
    on: function(e, t) {
      var n = this._, i = xG(e + "", n), r, o = -1, s = i.length;
      if (arguments.length < 2) {
        for (; ++o < s; ) if ((r = (e = i[o]).type) && (r = wG(n[r], e.name))) return r;
        return;
      }
      if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
      for (; ++o < s; )
        if (r = (e = i[o]).type) n[r] = k$(n[r], e.name, t);
        else if (t == null) for (r in n) n[r] = k$(n[r], e.name, null);
      return this;
    },
    copy: function() {
      var e = {}, t = this._;
      for (var n in t) e[n] = t[n].slice();
      return new Kd(e);
    },
    call: function(e, t) {
      if ((r = arguments.length - 2) > 0) for (var n = new Array(r), i = 0, r, o; i < r; ++i) n[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
      for (o = this._[e], i = 0, r = o.length; i < r; ++i) o[i].value.apply(t, n);
    },
    apply: function(e, t, n) {
      if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
      for (var i = this._[e], r = 0, o = i.length; r < o; ++r) i[r].value.apply(t, n);
    }
  };
  function wG(e, t) {
    for (var n = 0, i = e.length, r; n < i; ++n)
      if ((r = e[n]).name === t)
        return r.value;
  }
  function k$(e, t, n) {
    for (var i = 0, r = e.length; i < r; ++i)
      if (e[i].name === t) {
        e[i] = vG, e = e.slice(0, i).concat(e.slice(i + 1));
        break;
      }
    return n != null && e.push({ name: t, value: n }), e;
  }
  var Su = 0, tc = 0, Al = 0, iO = 1e3, gg, nc, pg = 0, Js = 0, Ip = 0, zc = typeof performance == "object" && performance.now ? performance : Date, rO = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
    setTimeout(e, 17);
  };
  function F2() {
    return Js || (rO(EG), Js = zc.now() + Ip);
  }
  function EG() {
    Js = 0;
  }
  function mg() {
    this._call = this._time = this._next = null;
  }
  mg.prototype = oO.prototype = {
    constructor: mg,
    restart: function(e, t, n) {
      if (typeof e != "function") throw new TypeError("callback is not a function");
      n = (n == null ? F2() : +n) + (t == null ? 0 : +t), !this._next && nc !== this && (nc ? nc._next = this : gg = this, nc = this), this._call = e, this._time = n, Ny();
    },
    stop: function() {
      this._call && (this._call = null, this._time = 1 / 0, Ny());
    }
  };
  function oO(e, t, n) {
    var i = new mg();
    return i.restart(e, t, n), i;
  }
  function _G() {
    F2(), ++Su;
    for (var e = gg, t; e; )
      (t = Js - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
    --Su;
  }
  function A$() {
    Js = (pg = zc.now()) + Ip, Su = tc = 0;
    try {
      _G();
    } finally {
      Su = 0, $G(), Js = 0;
    }
  }
  function SG() {
    var e = zc.now(), t = e - pg;
    t > iO && (Ip -= t, pg = e);
  }
  function $G() {
    for (var e, t = gg, n, i = 1 / 0; t; )
      t._call ? (i > t._time && (i = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : gg = n);
    nc = e, Ny(i);
  }
  function Ny(e) {
    if (!Su) {
      tc && (tc = clearTimeout(tc));
      var t = e - Js;
      t > 24 ? (e < 1 / 0 && (tc = setTimeout(A$, e - zc.now() - Ip)), Al && (Al = clearInterval(Al))) : (Al || (pg = zc.now(), Al = setInterval(SG, iO)), Su = 1, rO(A$));
    }
  }
  function kG(e, t, n) {
    var i = new mg(), r = t;
    return t == null ? (i.restart(e, t, n), i) : (i._restart = i.restart, i.restart = function(o, s, a) {
      s = +s, a = a == null ? F2() : +a, i._restart(function u(l) {
        l += r, i._restart(u, r += s, a), o(l);
      }, s, a);
    }, i.restart(e, t, n), i);
  }
  const AG = 1664525, CG = 1013904223, C$ = 4294967296;
  function FG() {
    let e = 1;
    return () => (e = (AG * e + CG) % C$) / C$;
  }
  function MG(e) {
    return e.x;
  }
  function TG(e) {
    return e.y;
  }
  var DG = 10, NG = Math.PI * (3 - Math.sqrt(5));
  function OG(e) {
    var t, n = 1, i = 1e-3, r = 1 - Math.pow(i, 1 / 300), o = 0, s = 0.6, a = /* @__PURE__ */ new Map(), u = oO(f), l = nO("tick", "end"), c = FG();
    e == null && (e = []);
    function f() {
      d(), l.call("tick", t), n < i && (u.stop(), l.call("end", t));
    }
    function d(p) {
      var m, y = e.length, b;
      p === void 0 && (p = 1);
      for (var v = 0; v < p; ++v)
        for (n += (o - n) * r, a.forEach(function(x) {
          x(n);
        }), m = 0; m < y; ++m)
          b = e[m], b.fx == null ? b.x += b.vx *= s : (b.x = b.fx, b.vx = 0), b.fy == null ? b.y += b.vy *= s : (b.y = b.fy, b.vy = 0);
      return t;
    }
    function h() {
      for (var p = 0, m = e.length, y; p < m; ++p) {
        if (y = e[p], y.index = p, y.fx != null && (y.x = y.fx), y.fy != null && (y.y = y.fy), isNaN(y.x) || isNaN(y.y)) {
          var b = DG * Math.sqrt(0.5 + p), v = p * NG;
          y.x = b * Math.cos(v), y.y = b * Math.sin(v);
        }
        (isNaN(y.vx) || isNaN(y.vy)) && (y.vx = y.vy = 0);
      }
    }
    function g(p) {
      return p.initialize && p.initialize(e, c), p;
    }
    return h(), t = {
      tick: d,
      restart: function() {
        return u.restart(f), t;
      },
      stop: function() {
        return u.stop(), t;
      },
      nodes: function(p) {
        return arguments.length ? (e = p, h(), a.forEach(g), t) : e;
      },
      alpha: function(p) {
        return arguments.length ? (n = +p, t) : n;
      },
      alphaMin: function(p) {
        return arguments.length ? (i = +p, t) : i;
      },
      alphaDecay: function(p) {
        return arguments.length ? (r = +p, t) : +r;
      },
      alphaTarget: function(p) {
        return arguments.length ? (o = +p, t) : o;
      },
      velocityDecay: function(p) {
        return arguments.length ? (s = 1 - p, t) : 1 - s;
      },
      randomSource: function(p) {
        return arguments.length ? (c = p, a.forEach(g), t) : c;
      },
      force: function(p, m) {
        return arguments.length > 1 ? (m == null ? a.delete(p) : a.set(p, g(m)), t) : a.get(p);
      },
      find: function(p, m, y) {
        var b = 0, v = e.length, x, w, _, E, S;
        for (y == null ? y = 1 / 0 : y *= y, b = 0; b < v; ++b)
          E = e[b], x = p - E.x, w = m - E.y, _ = x * x + w * w, _ < y && (S = E, y = _);
        return S;
      },
      on: function(p, m) {
        return arguments.length > 1 ? (l.on(p, m), t) : l.on(p);
      }
    };
  }
  function RG() {
    var e, t, n, i, r = tn(-30), o, s = 1, a = 1 / 0, u = 0.81;
    function l(h) {
      var g, p = e.length, m = A2(e, MG, TG).visitAfter(f);
      for (i = h, g = 0; g < p; ++g) t = e[g], m.visit(d);
    }
    function c() {
      if (e) {
        var h, g = e.length, p;
        for (o = new Array(g), h = 0; h < g; ++h) p = e[h], o[p.index] = +r(p, h, e);
      }
    }
    function f(h) {
      var g = 0, p, m, y = 0, b, v, x;
      if (h.length) {
        for (b = v = x = 0; x < 4; ++x)
          (p = h[x]) && (m = Math.abs(p.value)) && (g += p.value, y += m, b += m * p.x, v += m * p.y);
        h.x = b / y, h.y = v / y;
      } else {
        p = h, p.x = p.data.x, p.y = p.data.y;
        do
          g += o[p.data.index];
        while (p = p.next);
      }
      h.value = g;
    }
    function d(h, g, p, m) {
      if (!h.value) return !0;
      var y = h.x - t.x, b = h.y - t.y, v = m - g, x = y * y + b * b;
      if (v * v / u < x)
        return x < a && (y === 0 && (y = $o(n), x += y * y), b === 0 && (b = $o(n), x += b * b), x < s && (x = Math.sqrt(s * x)), t.vx += y * h.value * i / x, t.vy += b * h.value * i / x), !0;
      if (h.length || x >= a) return;
      (h.data !== t || h.next) && (y === 0 && (y = $o(n), x += y * y), b === 0 && (b = $o(n), x += b * b), x < s && (x = Math.sqrt(s * x)));
      do
        h.data !== t && (v = o[h.data.index] * i / x, t.vx += y * v, t.vy += b * v);
      while (h = h.next);
    }
    return l.initialize = function(h, g) {
      e = h, n = g, c();
    }, l.strength = function(h) {
      return arguments.length ? (r = typeof h == "function" ? h : tn(+h), c(), l) : r;
    }, l.distanceMin = function(h) {
      return arguments.length ? (s = h * h, l) : Math.sqrt(s);
    }, l.distanceMax = function(h) {
      return arguments.length ? (a = h * h, l) : Math.sqrt(a);
    }, l.theta = function(h) {
      return arguments.length ? (u = h * h, l) : Math.sqrt(u);
    }, l;
  }
  function LG(e) {
    var t = tn(0.1), n, i, r;
    typeof e != "function" && (e = tn(e == null ? 0 : +e));
    function o(a) {
      for (var u = 0, l = n.length, c; u < l; ++u)
        c = n[u], c.vx += (r[u] - c.x) * i[u] * a;
    }
    function s() {
      if (n) {
        var a, u = n.length;
        for (i = new Array(u), r = new Array(u), a = 0; a < u; ++a)
          i[a] = isNaN(r[a] = +e(n[a], a, n)) ? 0 : +t(n[a], a, n);
      }
    }
    return o.initialize = function(a) {
      n = a, s();
    }, o.strength = function(a) {
      return arguments.length ? (t = typeof a == "function" ? a : tn(+a), s(), o) : t;
    }, o.x = function(a) {
      return arguments.length ? (e = typeof a == "function" ? a : tn(+a), s(), o) : e;
    }, o;
  }
  function PG(e) {
    var t = tn(0.1), n, i, r;
    typeof e != "function" && (e = tn(e == null ? 0 : +e));
    function o(a) {
      for (var u = 0, l = n.length, c; u < l; ++u)
        c = n[u], c.vy += (r[u] - c.y) * i[u] * a;
    }
    function s() {
      if (n) {
        var a, u = n.length;
        for (i = new Array(u), r = new Array(u), a = 0; a < u; ++a)
          i[a] = isNaN(r[a] = +e(n[a], a, n)) ? 0 : +t(n[a], a, n);
      }
    }
    return o.initialize = function(a) {
      n = a, s();
    }, o.strength = function(a) {
      return arguments.length ? (t = typeof a == "function" ? a : tn(+a), s(), o) : t;
    }, o.y = function(a) {
      return arguments.length ? (e = typeof a == "function" ? a : tn(+a), s(), o) : e;
    }, o;
  }
  const F$ = {
    center: JH,
    collide: mG,
    nbody: RG,
    link: bG,
    x: LG,
    y: PG
  }, ic = "forces", Oy = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"], IG = ["static", "iterations"], sO = ["x", "y", "vx", "vy"];
  function M2(e) {
    N.call(this, null, e);
  }
  M2.Definition = {
    type: "Force",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "static",
      type: "boolean",
      default: !1
    }, {
      name: "restart",
      type: "boolean",
      default: !1
    }, {
      name: "iterations",
      type: "number",
      default: 300
    }, {
      name: "alpha",
      type: "number",
      default: 1
    }, {
      name: "alphaMin",
      type: "number",
      default: 1e-3
    }, {
      name: "alphaTarget",
      type: "number",
      default: 0
    }, {
      name: "velocityDecay",
      type: "number",
      default: 0.4
    }, {
      name: "forces",
      type: "param",
      array: !0,
      params: [{
        key: {
          force: "center"
        },
        params: [{
          name: "x",
          type: "number",
          default: 0
        }, {
          name: "y",
          type: "number",
          default: 0
        }]
      }, {
        key: {
          force: "collide"
        },
        params: [{
          name: "radius",
          type: "number",
          expr: !0
        }, {
          name: "strength",
          type: "number",
          default: 0.7
        }, {
          name: "iterations",
          type: "number",
          default: 1
        }]
      }, {
        key: {
          force: "nbody"
        },
        params: [{
          name: "strength",
          type: "number",
          default: -30,
          expr: !0
        }, {
          name: "theta",
          type: "number",
          default: 0.9
        }, {
          name: "distanceMin",
          type: "number",
          default: 1
        }, {
          name: "distanceMax",
          type: "number"
        }]
      }, {
        key: {
          force: "link"
        },
        params: [{
          name: "links",
          type: "data"
        }, {
          name: "id",
          type: "field"
        }, {
          name: "distance",
          type: "number",
          default: 30,
          expr: !0
        }, {
          name: "strength",
          type: "number",
          expr: !0
        }, {
          name: "iterations",
          type: "number",
          default: 1
        }]
      }, {
        key: {
          force: "x"
        },
        params: [{
          name: "strength",
          type: "number",
          default: 0.1
        }, {
          name: "x",
          type: "field"
        }]
      }, {
        key: {
          force: "y"
        },
        params: [{
          name: "strength",
          type: "number",
          default: 0.1
        }, {
          name: "y",
          type: "field"
        }]
      }]
    }, {
      name: "as",
      type: "string",
      array: !0,
      modify: !1,
      default: sO
    }]
  };
  G(M2, N, {
    transform(e, t) {
      var n = this.value, i = t.changed(t.ADD_REM), r = e.modified(Oy), o = e.iterations || 300;
      if (n ? (i && (t.modifies("index"), n.nodes(t.source)), (r || t.changed(t.MOD)) && aO(n, e, 0, t)) : (this.value = n = BG(t.source, e), n.on("tick", zG(t.dataflow, this)), e.static || (i = !0, n.tick()), t.modifies("index")), r || i || e.modified(IG) || t.changed() && e.restart) {
        if (n.alpha(Math.max(n.alpha(), e.alpha || 1)).alphaDecay(1 - Math.pow(n.alphaMin(), 1 / o)), e.static)
          for (n.stop(); --o >= 0; ) n.tick();
        else if (n.stopped() && n.restart(), !i) return t.StopPropagation;
      }
      return this.finish(e, t);
    },
    finish(e, t) {
      const n = t.dataflow;
      for (let a = this._argops, u = 0, l = a.length, c; u < l; ++u)
        if (c = a[u], !(c.name !== ic || c.op._argval.force !== "link")) {
          for (var i = c.op._argops, r = 0, o = i.length, s; r < o; ++r)
            if (i[r].name === "links" && (s = i[r].op.source)) {
              n.pulse(s, n.changeset().reflow());
              break;
            }
        }
      return t.reflow(e.modified()).modifies(sO);
    }
  });
  function zG(e, t) {
    return () => e.touch(t).run();
  }
  function BG(e, t) {
    const n = OG(e), i = n.stop, r = n.restart;
    let o = !1;
    return n.stopped = () => o, n.restart = () => (o = !1, r()), n.stop = () => (o = !0, i()), aO(n, t, !0).on("end", () => o = !0);
  }
  function aO(e, t, n, i) {
    var r = X(t.forces), o, s, a, u;
    for (o = 0, s = Oy.length; o < s; ++o)
      a = Oy[o], a !== ic && t.modified(a) && e[a](t[a]);
    for (o = 0, s = r.length; o < s; ++o)
      u = ic + o, a = n || t.modified(ic, o) ? jG(r[o]) : i && UG(r[o], i) ? e.force(u) : null, a && e.force(u, a);
    for (s = e.numForces || 0; o < s; ++o)
      e.force(ic + o, null);
    return e.numForces = r.length, e;
  }
  function UG(e, t) {
    var n, i;
    for (n in e)
      if (fe(i = e[n]) && t.modified(Ut(i))) return 1;
    return 0;
  }
  function jG(e) {
    var t, n;
    J(F$, e.force) || R("Unrecognized force: " + e.force), t = F$[e.force]();
    for (n in e)
      fe(t[n]) && qG(t[n], e[n], e);
    return t;
  }
  function qG(e, t, n) {
    e(fe(t) ? (i) => t(i, n) : t);
  }
  const WG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    force: M2
  }, Symbol.toStringTag, { value: "Module" }));
  function HG(e, t) {
    return e.parent === t.parent ? 1 : 2;
  }
  function GG(e) {
    return e.reduce(VG, 0) / e.length;
  }
  function VG(e, t) {
    return e + t.x;
  }
  function YG(e) {
    return 1 + e.reduce(XG, 0);
  }
  function XG(e, t) {
    return Math.max(e, t.y);
  }
  function KG(e) {
    for (var t; t = e.children; ) e = t[0];
    return e;
  }
  function JG(e) {
    for (var t; t = e.children; ) e = t[t.length - 1];
    return e;
  }
  function QG() {
    var e = HG, t = 1, n = 1, i = !1;
    function r(o) {
      var s, a = 0;
      o.eachAfter(function(d) {
        var h = d.children;
        h ? (d.x = GG(h), d.y = YG(h)) : (d.x = s ? a += e(d, s) : 0, d.y = 0, s = d);
      });
      var u = KG(o), l = JG(o), c = u.x - e(u, l) / 2, f = l.x + e(l, u) / 2;
      return o.eachAfter(i ? function(d) {
        d.x = (d.x - o.x) * t, d.y = (o.y - d.y) * n;
      } : function(d) {
        d.x = (d.x - c) / (f - c) * t, d.y = (1 - (o.y ? d.y / o.y : 1)) * n;
      });
    }
    return r.separation = function(o) {
      return arguments.length ? (e = o, r) : e;
    }, r.size = function(o) {
      return arguments.length ? (i = !1, t = +o[0], n = +o[1], r) : i ? null : [t, n];
    }, r.nodeSize = function(o) {
      return arguments.length ? (i = !0, t = +o[0], n = +o[1], r) : i ? [t, n] : null;
    }, r;
  }
  function ZG(e) {
    var t = 0, n = e.children, i = n && n.length;
    if (!i) t = 1;
    else for (; --i >= 0; ) t += n[i].value;
    e.value = t;
  }
  function eV() {
    return this.eachAfter(ZG);
  }
  function tV(e, t) {
    let n = -1;
    for (const i of this)
      e.call(t, i, ++n, this);
    return this;
  }
  function nV(e, t) {
    for (var n = this, i = [n], r, o, s = -1; n = i.pop(); )
      if (e.call(t, n, ++s, this), r = n.children)
        for (o = r.length - 1; o >= 0; --o)
          i.push(r[o]);
    return this;
  }
  function iV(e, t) {
    for (var n = this, i = [n], r = [], o, s, a, u = -1; n = i.pop(); )
      if (r.push(n), o = n.children)
        for (s = 0, a = o.length; s < a; ++s)
          i.push(o[s]);
    for (; n = r.pop(); )
      e.call(t, n, ++u, this);
    return this;
  }
  function rV(e, t) {
    let n = -1;
    for (const i of this)
      if (e.call(t, i, ++n, this))
        return i;
  }
  function oV(e) {
    return this.eachAfter(function(t) {
      for (var n = +e(t.data) || 0, i = t.children, r = i && i.length; --r >= 0; ) n += i[r].value;
      t.value = n;
    });
  }
  function sV(e) {
    return this.eachBefore(function(t) {
      t.children && t.children.sort(e);
    });
  }
  function aV(e) {
    for (var t = this, n = uV(t, e), i = [t]; t !== n; )
      t = t.parent, i.push(t);
    for (var r = i.length; e !== n; )
      i.splice(r, 0, e), e = e.parent;
    return i;
  }
  function uV(e, t) {
    if (e === t) return e;
    var n = e.ancestors(), i = t.ancestors(), r = null;
    for (e = n.pop(), t = i.pop(); e === t; )
      r = e, e = n.pop(), t = i.pop();
    return r;
  }
  function lV() {
    for (var e = this, t = [e]; e = e.parent; )
      t.push(e);
    return t;
  }
  function cV() {
    return Array.from(this);
  }
  function fV() {
    var e = [];
    return this.eachBefore(function(t) {
      t.children || e.push(t);
    }), e;
  }
  function dV() {
    var e = this, t = [];
    return e.each(function(n) {
      n !== e && t.push({ source: n.parent, target: n });
    }), t;
  }
  function* hV() {
    var e = this, t, n = [e], i, r, o;
    do
      for (t = n.reverse(), n = []; e = t.pop(); )
        if (yield e, i = e.children)
          for (r = 0, o = i.length; r < o; ++r)
            n.push(i[r]);
    while (n.length);
  }
  function T2(e, t) {
    e instanceof Map ? (e = [void 0, e], t === void 0 && (t = mV)) : t === void 0 && (t = pV);
    for (var n = new $u(e), i, r = [n], o, s, a, u; i = r.pop(); )
      if ((s = t(i.data)) && (u = (s = Array.from(s)).length))
        for (i.children = s, a = u - 1; a >= 0; --a)
          r.push(o = s[a] = new $u(s[a])), o.parent = i, o.depth = i.depth + 1;
    return n.eachBefore(uO);
  }
  function gV() {
    return T2(this).eachBefore(yV);
  }
  function pV(e) {
    return e.children;
  }
  function mV(e) {
    return Array.isArray(e) ? e[1] : null;
  }
  function yV(e) {
    e.data.value !== void 0 && (e.value = e.data.value), e.data = e.data.data;
  }
  function uO(e) {
    var t = 0;
    do
      e.height = t;
    while ((e = e.parent) && e.height < ++t);
  }
  function $u(e) {
    this.data = e, this.depth = this.height = 0, this.parent = null;
  }
  $u.prototype = T2.prototype = {
    constructor: $u,
    count: eV,
    each: tV,
    eachAfter: iV,
    eachBefore: nV,
    find: rV,
    sum: oV,
    sort: sV,
    path: aV,
    ancestors: lV,
    descendants: cV,
    leaves: fV,
    links: dV,
    copy: gV,
    [Symbol.iterator]: hV
  };
  function Jd(e) {
    return e == null ? null : lO(e);
  }
  function lO(e) {
    if (typeof e != "function") throw new Error();
    return e;
  }
  function Fs() {
    return 0;
  }
  function ja(e) {
    return function() {
      return e;
    };
  }
  const bV = 1664525, vV = 1013904223, M$ = 4294967296;
  function xV() {
    let e = 1;
    return () => (e = (bV * e + vV) % M$) / M$;
  }
  function wV(e) {
    return typeof e == "object" && "length" in e ? e : Array.from(e);
  }
  function EV(e, t) {
    let n = e.length, i, r;
    for (; n; )
      r = t() * n-- | 0, i = e[n], e[n] = e[r], e[r] = i;
    return e;
  }
  function _V(e, t) {
    for (var n = 0, i = (e = EV(Array.from(e), t)).length, r = [], o, s; n < i; )
      o = e[n], s && cO(s, o) ? ++n : (s = $V(r = SV(r, o)), n = 0);
    return s;
  }
  function SV(e, t) {
    var n, i;
    if (A0(t, e)) return [t];
    for (n = 0; n < e.length; ++n)
      if (pd(t, e[n]) && A0(rc(e[n], t), e))
        return [e[n], t];
    for (n = 0; n < e.length - 1; ++n)
      for (i = n + 1; i < e.length; ++i)
        if (pd(rc(e[n], e[i]), t) && pd(rc(e[n], t), e[i]) && pd(rc(e[i], t), e[n]) && A0(fO(e[n], e[i], t), e))
          return [e[n], e[i], t];
    throw new Error();
  }
  function pd(e, t) {
    var n = e.r - t.r, i = t.x - e.x, r = t.y - e.y;
    return n < 0 || n * n < i * i + r * r;
  }
  function cO(e, t) {
    var n = e.r - t.r + Math.max(e.r, t.r, 1) * 1e-9, i = t.x - e.x, r = t.y - e.y;
    return n > 0 && n * n > i * i + r * r;
  }
  function A0(e, t) {
    for (var n = 0; n < t.length; ++n)
      if (!cO(e, t[n]))
        return !1;
    return !0;
  }
  function $V(e) {
    switch (e.length) {
      case 1:
        return kV(e[0]);
      case 2:
        return rc(e[0], e[1]);
      case 3:
        return fO(e[0], e[1], e[2]);
    }
  }
  function kV(e) {
    return {
      x: e.x,
      y: e.y,
      r: e.r
    };
  }
  function rc(e, t) {
    var n = e.x, i = e.y, r = e.r, o = t.x, s = t.y, a = t.r, u = o - n, l = s - i, c = a - r, f = Math.sqrt(u * u + l * l);
    return {
      x: (n + o + u / f * c) / 2,
      y: (i + s + l / f * c) / 2,
      r: (f + r + a) / 2
    };
  }
  function fO(e, t, n) {
    var i = e.x, r = e.y, o = e.r, s = t.x, a = t.y, u = t.r, l = n.x, c = n.y, f = n.r, d = i - s, h = i - l, g = r - a, p = r - c, m = u - o, y = f - o, b = i * i + r * r - o * o, v = b - s * s - a * a + u * u, x = b - l * l - c * c + f * f, w = h * g - d * p, _ = (g * x - p * v) / (w * 2) - i, E = (p * m - g * y) / w, S = (h * v - d * x) / (w * 2) - r, $ = (d * y - h * m) / w, F = E * E + $ * $ - 1, A = 2 * (o + _ * E + S * $), D = _ * _ + S * S - o * o, k = -(Math.abs(F) > 1e-6 ? (A + Math.sqrt(A * A - 4 * F * D)) / (2 * F) : D / A);
    return {
      x: i + _ + E * k,
      y: r + S + $ * k,
      r: k
    };
  }
  function T$(e, t, n) {
    var i = e.x - t.x, r, o, s = e.y - t.y, a, u, l = i * i + s * s;
    l ? (o = t.r + n.r, o *= o, u = e.r + n.r, u *= u, o > u ? (r = (l + u - o) / (2 * l), a = Math.sqrt(Math.max(0, u / l - r * r)), n.x = e.x - r * i - a * s, n.y = e.y - r * s + a * i) : (r = (l + o - u) / (2 * l), a = Math.sqrt(Math.max(0, o / l - r * r)), n.x = t.x + r * i - a * s, n.y = t.y + r * s + a * i)) : (n.x = t.x + n.r, n.y = t.y);
  }
  function D$(e, t) {
    var n = e.r + t.r - 1e-6, i = t.x - e.x, r = t.y - e.y;
    return n > 0 && n * n > i * i + r * r;
  }
  function N$(e) {
    var t = e._, n = e.next._, i = t.r + n.r, r = (t.x * n.r + n.x * t.r) / i, o = (t.y * n.r + n.y * t.r) / i;
    return r * r + o * o;
  }
  function md(e) {
    this._ = e, this.next = null, this.previous = null;
  }
  function AV(e, t) {
    if (!(o = (e = wV(e)).length)) return 0;
    var n, i, r, o, s, a, u, l, c, f, d;
    if (n = e[0], n.x = 0, n.y = 0, !(o > 1)) return n.r;
    if (i = e[1], n.x = -i.r, i.x = n.r, i.y = 0, !(o > 2)) return n.r + i.r;
    T$(i, n, r = e[2]), n = new md(n), i = new md(i), r = new md(r), n.next = r.previous = i, i.next = n.previous = r, r.next = i.previous = n;
    e: for (u = 3; u < o; ++u) {
      T$(n._, i._, r = e[u]), r = new md(r), l = i.next, c = n.previous, f = i._.r, d = n._.r;
      do
        if (f <= d) {
          if (D$(l._, r._)) {
            i = l, n.next = i, i.previous = n, --u;
            continue e;
          }
          f += l._.r, l = l.next;
        } else {
          if (D$(c._, r._)) {
            n = c, n.next = i, i.previous = n, --u;
            continue e;
          }
          d += c._.r, c = c.previous;
        }
      while (l !== c.next);
      for (r.previous = n, r.next = i, n.next = i.previous = i = r, s = N$(n); (r = r.next) !== i; )
        (a = N$(r)) < s && (n = r, s = a);
      i = n.next;
    }
    for (n = [i._], r = i; (r = r.next) !== i; ) n.push(r._);
    for (r = _V(n, t), u = 0; u < o; ++u) n = e[u], n.x -= r.x, n.y -= r.y;
    return r.r;
  }
  function CV(e) {
    return Math.sqrt(e.value);
  }
  function FV() {
    var e = null, t = 1, n = 1, i = Fs;
    function r(o) {
      const s = xV();
      return o.x = t / 2, o.y = n / 2, e ? o.eachBefore(O$(e)).eachAfter(C0(i, 0.5, s)).eachBefore(R$(1)) : o.eachBefore(O$(CV)).eachAfter(C0(Fs, 1, s)).eachAfter(C0(i, o.r / Math.min(t, n), s)).eachBefore(R$(Math.min(t, n) / (2 * o.r))), o;
    }
    return r.radius = function(o) {
      return arguments.length ? (e = Jd(o), r) : e;
    }, r.size = function(o) {
      return arguments.length ? (t = +o[0], n = +o[1], r) : [t, n];
    }, r.padding = function(o) {
      return arguments.length ? (i = typeof o == "function" ? o : ja(+o), r) : i;
    }, r;
  }
  function O$(e) {
    return function(t) {
      t.children || (t.r = Math.max(0, +e(t) || 0));
    };
  }
  function C0(e, t, n) {
    return function(i) {
      if (r = i.children) {
        var r, o, s = r.length, a = e(i) * t || 0, u;
        if (a) for (o = 0; o < s; ++o) r[o].r += a;
        if (u = AV(r, n), a) for (o = 0; o < s; ++o) r[o].r -= a;
        i.r = u + a;
      }
    };
  }
  function R$(e) {
    return function(t) {
      var n = t.parent;
      t.r *= e, n && (t.x = n.x + e * t.x, t.y = n.y + e * t.y);
    };
  }
  function dO(e) {
    e.x0 = Math.round(e.x0), e.y0 = Math.round(e.y0), e.x1 = Math.round(e.x1), e.y1 = Math.round(e.y1);
  }
  function $f(e, t, n, i, r) {
    for (var o = e.children, s, a = -1, u = o.length, l = e.value && (i - t) / e.value; ++a < u; )
      s = o[a], s.y0 = n, s.y1 = r, s.x0 = t, s.x1 = t += s.value * l;
  }
  function MV() {
    var e = 1, t = 1, n = 0, i = !1;
    function r(s) {
      var a = s.height + 1;
      return s.x0 = s.y0 = n, s.x1 = e, s.y1 = t / a, s.eachBefore(o(t, a)), i && s.eachBefore(dO), s;
    }
    function o(s, a) {
      return function(u) {
        u.children && $f(u, u.x0, s * (u.depth + 1) / a, u.x1, s * (u.depth + 2) / a);
        var l = u.x0, c = u.y0, f = u.x1 - n, d = u.y1 - n;
        f < l && (l = f = (l + f) / 2), d < c && (c = d = (c + d) / 2), u.x0 = l, u.y0 = c, u.x1 = f, u.y1 = d;
      };
    }
    return r.round = function(s) {
      return arguments.length ? (i = !!s, r) : i;
    }, r.size = function(s) {
      return arguments.length ? (e = +s[0], t = +s[1], r) : [e, t];
    }, r.padding = function(s) {
      return arguments.length ? (n = +s, r) : n;
    }, r;
  }
  var TV = { depth: -1 }, L$ = {}, F0 = {};
  function DV(e) {
    return e.id;
  }
  function NV(e) {
    return e.parentId;
  }
  function P$() {
    var e = DV, t = NV, n;
    function i(r) {
      var o = Array.from(r), s = e, a = t, u, l, c, f, d, h, g, p, m = /* @__PURE__ */ new Map();
      if (n != null) {
        const y = o.map((x, w) => OV(n(x, w, r))), b = y.map(I$), v = new Set(y).add("");
        for (const x of b)
          v.has(x) || (v.add(x), y.push(x), b.push(I$(x)), o.push(F0));
        s = (x, w) => y[w], a = (x, w) => b[w];
      }
      for (c = 0, u = o.length; c < u; ++c)
        l = o[c], h = o[c] = new $u(l), (g = s(l, c, r)) != null && (g += "") && (p = h.id = g, m.set(p, m.has(p) ? L$ : h)), (g = a(l, c, r)) != null && (g += "") && (h.parent = g);
      for (c = 0; c < u; ++c)
        if (h = o[c], g = h.parent) {
          if (d = m.get(g), !d) throw new Error("missing: " + g);
          if (d === L$) throw new Error("ambiguous: " + g);
          d.children ? d.children.push(h) : d.children = [h], h.parent = d;
        } else {
          if (f) throw new Error("multiple roots");
          f = h;
        }
      if (!f) throw new Error("no root");
      if (n != null) {
        for (; f.data === F0 && f.children.length === 1; )
          f = f.children[0], --u;
        for (let y = o.length - 1; y >= 0 && (h = o[y], h.data === F0); --y)
          h.data = null;
      }
      if (f.parent = TV, f.eachBefore(function(y) {
        y.depth = y.parent.depth + 1, --u;
      }).eachBefore(uO), f.parent = null, u > 0) throw new Error("cycle");
      return f;
    }
    return i.id = function(r) {
      return arguments.length ? (e = Jd(r), i) : e;
    }, i.parentId = function(r) {
      return arguments.length ? (t = Jd(r), i) : t;
    }, i.path = function(r) {
      return arguments.length ? (n = Jd(r), i) : n;
    }, i;
  }
  function OV(e) {
    e = `${e}`;
    let t = e.length;
    return Ry(e, t - 1) && !Ry(e, t - 2) && (e = e.slice(0, -1)), e[0] === "/" ? e : `/${e}`;
  }
  function I$(e) {
    let t = e.length;
    if (t < 2) return "";
    for (; --t > 1 && !Ry(e, t); ) ;
    return e.slice(0, t);
  }
  function Ry(e, t) {
    if (e[t] === "/") {
      let n = 0;
      for (; t > 0 && e[--t] === "\\"; ) ++n;
      if (!(n & 1)) return !0;
    }
    return !1;
  }
  function RV(e, t) {
    return e.parent === t.parent ? 1 : 2;
  }
  function M0(e) {
    var t = e.children;
    return t ? t[0] : e.t;
  }
  function T0(e) {
    var t = e.children;
    return t ? t[t.length - 1] : e.t;
  }
  function LV(e, t, n) {
    var i = n / (t.i - e.i);
    t.c -= i, t.s += n, e.c += i, t.z += n, t.m += n;
  }
  function PV(e) {
    for (var t = 0, n = 0, i = e.children, r = i.length, o; --r >= 0; )
      o = i[r], o.z += t, o.m += t, t += o.s + (n += o.c);
  }
  function IV(e, t, n) {
    return e.a.parent === t.parent ? e.a : n;
  }
  function Qd(e, t) {
    this._ = e, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t;
  }
  Qd.prototype = Object.create($u.prototype);
  function zV(e) {
    for (var t = new Qd(e, 0), n, i = [t], r, o, s, a; n = i.pop(); )
      if (o = n._.children)
        for (n.children = new Array(a = o.length), s = a - 1; s >= 0; --s)
          i.push(r = n.children[s] = new Qd(o[s], s)), r.parent = n;
    return (t.parent = new Qd(null, 0)).children = [t], t;
  }
  function BV() {
    var e = RV, t = 1, n = 1, i = null;
    function r(l) {
      var c = zV(l);
      if (c.eachAfter(o), c.parent.m = -c.z, c.eachBefore(s), i) l.eachBefore(u);
      else {
        var f = l, d = l, h = l;
        l.eachBefore(function(b) {
          b.x < f.x && (f = b), b.x > d.x && (d = b), b.depth > h.depth && (h = b);
        });
        var g = f === d ? 1 : e(f, d) / 2, p = g - f.x, m = t / (d.x + g + p), y = n / (h.depth || 1);
        l.eachBefore(function(b) {
          b.x = (b.x + p) * m, b.y = b.depth * y;
        });
      }
      return l;
    }
    function o(l) {
      var c = l.children, f = l.parent.children, d = l.i ? f[l.i - 1] : null;
      if (c) {
        PV(l);
        var h = (c[0].z + c[c.length - 1].z) / 2;
        d ? (l.z = d.z + e(l._, d._), l.m = l.z - h) : l.z = h;
      } else d && (l.z = d.z + e(l._, d._));
      l.parent.A = a(l, d, l.parent.A || f[0]);
    }
    function s(l) {
      l._.x = l.z + l.parent.m, l.m += l.parent.m;
    }
    function a(l, c, f) {
      if (c) {
        for (var d = l, h = l, g = c, p = d.parent.children[0], m = d.m, y = h.m, b = g.m, v = p.m, x; g = T0(g), d = M0(d), g && d; )
          p = M0(p), h = T0(h), h.a = l, x = g.z + b - d.z - m + e(g._, d._), x > 0 && (LV(IV(g, l, f), l, x), m += x, y += x), b += g.m, m += d.m, v += p.m, y += h.m;
        g && !T0(h) && (h.t = g, h.m += b - y), d && !M0(p) && (p.t = d, p.m += m - v, f = l);
      }
      return f;
    }
    function u(l) {
      l.x *= t, l.y = l.depth * n;
    }
    return r.separation = function(l) {
      return arguments.length ? (e = l, r) : e;
    }, r.size = function(l) {
      return arguments.length ? (i = !1, t = +l[0], n = +l[1], r) : i ? null : [t, n];
    }, r.nodeSize = function(l) {
      return arguments.length ? (i = !0, t = +l[0], n = +l[1], r) : i ? [t, n] : null;
    }, r;
  }
  function zp(e, t, n, i, r) {
    for (var o = e.children, s, a = -1, u = o.length, l = e.value && (r - n) / e.value; ++a < u; )
      s = o[a], s.x0 = t, s.x1 = i, s.y0 = n, s.y1 = n += s.value * l;
  }
  var hO = (1 + Math.sqrt(5)) / 2;
  function gO(e, t, n, i, r, o) {
    for (var s = [], a = t.children, u, l, c = 0, f = 0, d = a.length, h, g, p = t.value, m, y, b, v, x, w, _; c < d; ) {
      h = r - n, g = o - i;
      do
        m = a[f++].value;
      while (!m && f < d);
      for (y = b = m, w = Math.max(g / h, h / g) / (p * e), _ = m * m * w, x = Math.max(b / _, _ / y); f < d; ++f) {
        if (m += l = a[f].value, l < y && (y = l), l > b && (b = l), _ = m * m * w, v = Math.max(b / _, _ / y), v > x) {
          m -= l;
          break;
        }
        x = v;
      }
      s.push(u = { value: m, dice: h < g, children: a.slice(c, f) }), u.dice ? $f(u, n, i, r, p ? i += g * m / p : o) : zp(u, n, i, p ? n += h * m / p : r, o), p -= m, c = f;
    }
    return s;
  }
  const pO = function e(t) {
    function n(i, r, o, s, a) {
      gO(t, i, r, o, s, a);
    }
    return n.ratio = function(i) {
      return e((i = +i) > 1 ? i : 1);
    }, n;
  }(hO);
  function UV() {
    var e = pO, t = !1, n = 1, i = 1, r = [0], o = Fs, s = Fs, a = Fs, u = Fs, l = Fs;
    function c(d) {
      return d.x0 = d.y0 = 0, d.x1 = n, d.y1 = i, d.eachBefore(f), r = [0], t && d.eachBefore(dO), d;
    }
    function f(d) {
      var h = r[d.depth], g = d.x0 + h, p = d.y0 + h, m = d.x1 - h, y = d.y1 - h;
      m < g && (g = m = (g + m) / 2), y < p && (p = y = (p + y) / 2), d.x0 = g, d.y0 = p, d.x1 = m, d.y1 = y, d.children && (h = r[d.depth + 1] = o(d) / 2, g += l(d) - h, p += s(d) - h, m -= a(d) - h, y -= u(d) - h, m < g && (g = m = (g + m) / 2), y < p && (p = y = (p + y) / 2), e(d, g, p, m, y));
    }
    return c.round = function(d) {
      return arguments.length ? (t = !!d, c) : t;
    }, c.size = function(d) {
      return arguments.length ? (n = +d[0], i = +d[1], c) : [n, i];
    }, c.tile = function(d) {
      return arguments.length ? (e = lO(d), c) : e;
    }, c.padding = function(d) {
      return arguments.length ? c.paddingInner(d).paddingOuter(d) : c.paddingInner();
    }, c.paddingInner = function(d) {
      return arguments.length ? (o = typeof d == "function" ? d : ja(+d), c) : o;
    }, c.paddingOuter = function(d) {
      return arguments.length ? c.paddingTop(d).paddingRight(d).paddingBottom(d).paddingLeft(d) : c.paddingTop();
    }, c.paddingTop = function(d) {
      return arguments.length ? (s = typeof d == "function" ? d : ja(+d), c) : s;
    }, c.paddingRight = function(d) {
      return arguments.length ? (a = typeof d == "function" ? d : ja(+d), c) : a;
    }, c.paddingBottom = function(d) {
      return arguments.length ? (u = typeof d == "function" ? d : ja(+d), c) : u;
    }, c.paddingLeft = function(d) {
      return arguments.length ? (l = typeof d == "function" ? d : ja(+d), c) : l;
    }, c;
  }
  function jV(e, t, n, i, r) {
    var o = e.children, s, a = o.length, u, l = new Array(a + 1);
    for (l[0] = u = s = 0; s < a; ++s)
      l[s + 1] = u += o[s].value;
    c(0, a, e.value, t, n, i, r);
    function c(f, d, h, g, p, m, y) {
      if (f >= d - 1) {
        var b = o[f];
        b.x0 = g, b.y0 = p, b.x1 = m, b.y1 = y;
        return;
      }
      for (var v = l[f], x = h / 2 + v, w = f + 1, _ = d - 1; w < _; ) {
        var E = w + _ >>> 1;
        l[E] < x ? w = E + 1 : _ = E;
      }
      x - l[w - 1] < l[w] - x && f + 1 < w && --w;
      var S = l[w] - v, $ = h - S;
      if (m - g > y - p) {
        var F = h ? (g * $ + m * S) / h : m;
        c(f, w, S, g, p, F, y), c(w, d, $, F, p, m, y);
      } else {
        var A = h ? (p * $ + y * S) / h : y;
        c(f, w, S, g, p, m, A), c(w, d, $, g, A, m, y);
      }
    }
  }
  function qV(e, t, n, i, r) {
    (e.depth & 1 ? zp : $f)(e, t, n, i, r);
  }
  const WV = function e(t) {
    function n(i, r, o, s, a) {
      if ((u = i._squarify) && u.ratio === t)
        for (var u, l, c, f, d = -1, h, g = u.length, p = i.value; ++d < g; ) {
          for (l = u[d], c = l.children, f = l.value = 0, h = c.length; f < h; ++f) l.value += c[f].value;
          l.dice ? $f(l, r, o, s, p ? o += (a - o) * l.value / p : a) : zp(l, r, o, p ? r += (s - r) * l.value / p : s, a), p -= l.value;
        }
      else
        i._squarify = u = gO(t, i, r, o, s, a), u.ratio = t;
    }
    return n.ratio = function(i) {
      return e((i = +i) > 1 ? i : 1);
    }, n;
  }(hO);
  function Ly(e, t, n) {
    const i = {};
    return e.each((r) => {
      const o = r.data;
      n(o) && (i[t(o)] = r);
    }), e.lookup = i, e;
  }
  function D2(e) {
    N.call(this, null, e);
  }
  D2.Definition = {
    type: "Nest",
    metadata: {
      treesource: !0,
      changes: !0
    },
    params: [{
      name: "keys",
      type: "field",
      array: !0
    }, {
      name: "generate",
      type: "boolean"
    }]
  };
  const HV = (e) => e.values;
  G(D2, N, {
    transform(e, t) {
      t.source || R("Nest transform requires an upstream data source.");
      var n = e.generate, i = e.modified(), r = t.clone(), o = this.value;
      return (!o || i || t.changed()) && (o && o.each((s) => {
        s.children && Zg(s.data) && r.rem.push(s.data);
      }), this.value = o = T2({
        values: X(e.keys).reduce((s, a) => (s.key(a), s), GV()).entries(r.source)
      }, HV), n && o.each((s) => {
        s.children && (s = Ce(s.data), r.add.push(s), r.source.push(s));
      }), Ly(o, re, re)), r.source.root = o, r;
    }
  });
  function GV() {
    const e = [], t = {
      entries: (r) => i(n(r, 0), 0),
      key: (r) => (e.push(r), t)
    };
    function n(r, o) {
      if (o >= e.length)
        return r;
      const s = r.length, a = e[o++], u = {}, l = {};
      let c = -1, f, d, h;
      for (; ++c < s; )
        f = a(d = r[c]) + "", (h = u[f]) ? h.push(d) : u[f] = [d];
      for (f in u)
        l[f] = n(u[f], o);
      return l;
    }
    function i(r, o) {
      if (++o > e.length) return r;
      const s = [];
      for (const a in r)
        s.push({
          key: a,
          values: i(r[a], o)
        });
      return s;
    }
    return t;
  }
  function Zr(e) {
    N.call(this, null, e);
  }
  const VV = (e, t) => e.parent === t.parent ? 1 : 2;
  G(Zr, N, {
    transform(e, t) {
      (!t.source || !t.source.root) && R(this.constructor.name + " transform requires a backing tree data source.");
      const n = this.layout(e.method), i = this.fields, r = t.source.root, o = e.as || i;
      e.field ? r.sum(e.field) : r.count(), e.sort && r.sort(ha(e.sort, (s) => s.data)), YV(n, this.params, e), n.separation && n.separation(e.separation !== !1 ? VV : qu);
      try {
        this.value = n(r);
      } catch (s) {
        R(s);
      }
      return r.each((s) => XV(s, i, o)), t.reflow(e.modified()).modifies(o).modifies("leaf");
    }
  });
  function YV(e, t, n) {
    for (let i, r = 0, o = t.length; r < o; ++r)
      i = t[r], i in n && e[i](n[i]);
  }
  function XV(e, t, n) {
    const i = e.data, r = t.length - 1;
    for (let o = 0; o < r; ++o)
      i[n[o]] = e[t[o]];
    i[n[r]] = e.children ? e.children.length : 0;
  }
  const Py = ["x", "y", "r", "depth", "children"];
  function N2(e) {
    Zr.call(this, e);
  }
  N2.Definition = {
    type: "Pack",
    metadata: {
      tree: !0,
      modifies: !0
    },
    params: [{
      name: "field",
      type: "field"
    }, {
      name: "sort",
      type: "compare"
    }, {
      name: "padding",
      type: "number",
      default: 0
    }, {
      name: "radius",
      type: "field",
      default: null
    }, {
      name: "size",
      type: "number",
      array: !0,
      length: 2
    }, {
      name: "as",
      type: "string",
      array: !0,
      length: Py.length,
      default: Py
    }]
  };
  G(N2, Zr, {
    layout: FV,
    params: ["radius", "size", "padding"],
    fields: Py
  });
  const Iy = ["x0", "y0", "x1", "y1", "depth", "children"];
  function O2(e) {
    Zr.call(this, e);
  }
  O2.Definition = {
    type: "Partition",
    metadata: {
      tree: !0,
      modifies: !0
    },
    params: [{
      name: "field",
      type: "field"
    }, {
      name: "sort",
      type: "compare"
    }, {
      name: "padding",
      type: "number",
      default: 0
    }, {
      name: "round",
      type: "boolean",
      default: !1
    }, {
      name: "size",
      type: "number",
      array: !0,
      length: 2
    }, {
      name: "as",
      type: "string",
      array: !0,
      length: Iy.length,
      default: Iy
    }]
  };
  G(O2, Zr, {
    layout: MV,
    params: ["size", "round", "padding"],
    fields: Iy
  });
  function R2(e) {
    N.call(this, null, e);
  }
  R2.Definition = {
    type: "Stratify",
    metadata: {
      treesource: !0
    },
    params: [{
      name: "key",
      type: "field",
      required: !0
    }, {
      name: "parentKey",
      type: "field",
      required: !0
    }]
  };
  G(R2, N, {
    transform(e, t) {
      t.source || R("Stratify transform requires an upstream data source.");
      let n = this.value;
      const i = e.modified(), r = t.fork(t.ALL).materialize(t.SOURCE), o = !n || i || t.changed(t.ADD_REM) || t.modified(e.key.fields) || t.modified(e.parentKey.fields);
      return r.source = r.source.slice(), o && (n = r.source.length ? Ly(P$().id(e.key).parentId(e.parentKey)(r.source), e.key, Jn) : Ly(P$()([{}]), e.key, e.key)), r.source.root = this.value = n, r;
    }
  });
  const z$ = {
    tidy: BV,
    cluster: QG
  }, zy = ["x", "y", "depth", "children"];
  function L2(e) {
    Zr.call(this, e);
  }
  L2.Definition = {
    type: "Tree",
    metadata: {
      tree: !0,
      modifies: !0
    },
    params: [{
      name: "field",
      type: "field"
    }, {
      name: "sort",
      type: "compare"
    }, {
      name: "method",
      type: "enum",
      default: "tidy",
      values: ["tidy", "cluster"]
    }, {
      name: "size",
      type: "number",
      array: !0,
      length: 2
    }, {
      name: "nodeSize",
      type: "number",
      array: !0,
      length: 2
    }, {
      name: "separation",
      type: "boolean",
      default: !0
    }, {
      name: "as",
      type: "string",
      array: !0,
      length: zy.length,
      default: zy
    }]
  };
  G(L2, Zr, {
    /**
     * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.
     */
    layout(e) {
      const t = e || "tidy";
      if (J(z$, t)) return z$[t]();
      R("Unrecognized Tree layout method: " + t);
    },
    params: ["size", "nodeSize"],
    fields: zy
  });
  function P2(e) {
    N.call(this, [], e);
  }
  P2.Definition = {
    type: "TreeLinks",
    metadata: {
      tree: !0,
      generates: !0,
      changes: !0
    },
    params: []
  };
  G(P2, N, {
    transform(e, t) {
      const n = this.value, i = t.source && t.source.root, r = t.fork(t.NO_SOURCE), o = {};
      return i || R("TreeLinks transform requires a tree data source."), t.changed(t.ADD_REM) ? (r.rem = n, t.visit(t.SOURCE, (s) => o[re(s)] = 1), i.each((s) => {
        const a = s.data, u = s.parent && s.parent.data;
        u && o[re(a)] && o[re(u)] && r.add.push(Ce({
          source: u,
          target: a
        }));
      }), this.value = r.add) : t.changed(t.MOD) && (t.visit(t.MOD, (s) => o[re(s)] = 1), n.forEach((s) => {
        (o[re(s.source)] || o[re(s.target)]) && r.mod.push(s);
      })), r;
    }
  });
  const B$ = {
    binary: jV,
    dice: $f,
    slice: zp,
    slicedice: qV,
    squarify: pO,
    resquarify: WV
  }, By = ["x0", "y0", "x1", "y1", "depth", "children"];
  function I2(e) {
    Zr.call(this, e);
  }
  I2.Definition = {
    type: "Treemap",
    metadata: {
      tree: !0,
      modifies: !0
    },
    params: [{
      name: "field",
      type: "field"
    }, {
      name: "sort",
      type: "compare"
    }, {
      name: "method",
      type: "enum",
      default: "squarify",
      values: ["squarify", "resquarify", "binary", "dice", "slice", "slicedice"]
    }, {
      name: "padding",
      type: "number",
      default: 0
    }, {
      name: "paddingInner",
      type: "number",
      default: 0
    }, {
      name: "paddingOuter",
      type: "number",
      default: 0
    }, {
      name: "paddingTop",
      type: "number",
      default: 0
    }, {
      name: "paddingRight",
      type: "number",
      default: 0
    }, {
      name: "paddingBottom",
      type: "number",
      default: 0
    }, {
      name: "paddingLeft",
      type: "number",
      default: 0
    }, {
      name: "ratio",
      type: "number",
      default: 1.618033988749895
    }, {
      name: "round",
      type: "boolean",
      default: !1
    }, {
      name: "size",
      type: "number",
      array: !0,
      length: 2
    }, {
      name: "as",
      type: "string",
      array: !0,
      length: By.length,
      default: By
    }]
  };
  G(I2, Zr, {
    /**
     * Treemap layout generator. Adds 'method' and 'ratio' parameters
     * to configure the underlying tile method.
     */
    layout() {
      const e = UV();
      return e.ratio = (t) => {
        const n = e.tile();
        n.ratio && e.tile(n.ratio(t));
      }, e.method = (t) => {
        J(B$, t) ? e.tile(B$[t]) : R("Unrecognized Treemap layout method: " + t);
      }, e;
    },
    params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
    fields: By
  });
  const KV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    nest: D2,
    pack: N2,
    partition: O2,
    stratify: R2,
    tree: L2,
    treelinks: P2,
    treemap: I2
  }, Symbol.toStringTag, { value: "Module" })), D0 = 4278190080;
  function JV(e, t) {
    const n = e.bitmap();
    return (t || []).forEach((i) => n.set(e(i.boundary[0]), e(i.boundary[3]))), [n, void 0];
  }
  function QV(e, t, n, i, r) {
    const o = e.width, s = e.height, a = i || r, u = To(o, s).getContext("2d"), l = To(o, s).getContext("2d"), c = a && To(o, s).getContext("2d");
    n.forEach((S) => Zd(u, S, !1)), Zd(l, t, !1), a && Zd(c, t, !0);
    const f = N0(u, o, s), d = N0(l, o, s), h = a && N0(c, o, s), g = e.bitmap(), p = a && e.bitmap();
    let m, y, b, v, x, w, _, E;
    for (y = 0; y < s; ++y)
      for (m = 0; m < o; ++m)
        x = y * o + m, w = f[x] & D0, E = d[x] & D0, _ = a && h[x] & D0, (w || _ || E) && (b = e(m), v = e(y), !r && (w || E) && g.set(b, v), a && (w || _) && p.set(b, v));
    return [g, p];
  }
  function N0(e, t, n) {
    return new Uint32Array(e.getImageData(0, 0, t, n).data.buffer);
  }
  function Zd(e, t, n) {
    if (!t.length) return;
    const i = t[0].mark.marktype;
    i === "group" ? t.forEach((r) => {
      r.items.forEach((o) => Zd(e, o.items, n));
    }) : In[i].draw(e, {
      items: n ? t.map(ZV) : t
    });
  }
  function ZV(e) {
    const t = ep(e, {});
    return t.stroke && t.strokeOpacity !== 0 || t.fill && t.fillOpacity !== 0 ? {
      ...t,
      strokeOpacity: 1,
      stroke: "#000",
      fillOpacity: 0
    } : t;
  }
  const kr = 5, Vt = 31, Bc = 32, mo = new Uint32Array(Bc + 1), di = new Uint32Array(Bc + 1);
  di[0] = 0;
  mo[0] = ~di[0];
  for (let e = 1; e <= Bc; ++e)
    di[e] = di[e - 1] << 1 | 1, mo[e] = ~di[e];
  function eY(e, t) {
    const n = new Uint32Array(~~((e * t + Bc) / Bc));
    function i(o, s) {
      n[o] |= s;
    }
    function r(o, s) {
      n[o] &= s;
    }
    return {
      array: n,
      get: (o, s) => {
        const a = s * e + o;
        return n[a >>> kr] & 1 << (a & Vt);
      },
      set: (o, s) => {
        const a = s * e + o;
        i(a >>> kr, 1 << (a & Vt));
      },
      clear: (o, s) => {
        const a = s * e + o;
        r(a >>> kr, ~(1 << (a & Vt)));
      },
      getRange: (o, s, a, u) => {
        let l = u, c, f, d, h;
        for (; l >= s; --l)
          if (c = l * e + o, f = l * e + a, d = c >>> kr, h = f >>> kr, d === h) {
            if (n[d] & mo[c & Vt] & di[(f & Vt) + 1])
              return !0;
          } else {
            if (n[d] & mo[c & Vt] || n[h] & di[(f & Vt) + 1]) return !0;
            for (let g = d + 1; g < h; ++g)
              if (n[g]) return !0;
          }
        return !1;
      },
      setRange: (o, s, a, u) => {
        let l, c, f, d, h;
        for (; s <= u; ++s)
          if (l = s * e + o, c = s * e + a, f = l >>> kr, d = c >>> kr, f === d)
            i(f, mo[l & Vt] & di[(c & Vt) + 1]);
          else
            for (i(f, mo[l & Vt]), i(d, di[(c & Vt) + 1]), h = f + 1; h < d; ++h) i(h, 4294967295);
      },
      clearRange: (o, s, a, u) => {
        let l, c, f, d, h;
        for (; s <= u; ++s)
          if (l = s * e + o, c = s * e + a, f = l >>> kr, d = c >>> kr, f === d)
            r(f, di[l & Vt] | mo[(c & Vt) + 1]);
          else
            for (r(f, di[l & Vt]), r(d, mo[(c & Vt) + 1]), h = f + 1; h < d; ++h) r(h, 0);
      },
      outOfBounds: (o, s, a, u) => o < 0 || s < 0 || u >= t || a >= e
    };
  }
  function tY(e, t, n) {
    const i = Math.max(1, Math.sqrt(e * t / 1e6)), r = ~~((e + 2 * n + i) / i), o = ~~((t + 2 * n + i) / i), s = (a) => ~~((a + n) / i);
    return s.invert = (a) => a * i - n, s.bitmap = () => eY(r, o), s.ratio = i, s.padding = n, s.width = e, s.height = t, s;
  }
  function nY(e, t, n, i) {
    const r = e.width, o = e.height;
    return function(s) {
      const a = s.datum.datum.items[i].items, u = a.length, l = s.datum.fontSize, c = Nn.width(s.datum, s.datum.text);
      let f = 0, d, h, g, p, m, y, b;
      for (let v = 0; v < u; ++v)
        d = a[v].x, g = a[v].y, h = a[v].x2 === void 0 ? d : a[v].x2, p = a[v].y2 === void 0 ? g : a[v].y2, m = (d + h) / 2, y = (g + p) / 2, b = Math.abs(h - d + p - g), b >= f && (f = b, s.x = m, s.y = y);
      return m = c / 2, y = l / 2, d = s.x - m, h = s.x + m, g = s.y - y, p = s.y + y, s.align = "center", d < 0 && h <= r ? s.align = "left" : 0 <= d && r < h && (s.align = "right"), s.baseline = "middle", g < 0 && p <= o ? s.baseline = "top" : 0 <= g && o < p && (s.baseline = "bottom"), !0;
    };
  }
  function yg(e, t, n, i, r, o) {
    let s = n / 2;
    return e - s < 0 || e + s > r || t - (s = i / 2) < 0 || t + s > o;
  }
  function ko(e, t, n, i, r, o, s, a) {
    const u = r * o / (i * 2), l = e(t - u), c = e(t + u), f = e(n - (o = o / 2)), d = e(n + o);
    return s.outOfBounds(l, f, c, d) || s.getRange(l, f, c, d) || a && a.getRange(l, f, c, d);
  }
  function iY(e, t, n, i) {
    const r = e.width, o = e.height, s = t[0], a = t[1];
    function u(l, c, f, d, h) {
      const g = e.invert(l), p = e.invert(c);
      let m = f, y = o, b;
      if (!yg(g, p, d, h, r, o) && !ko(e, g, p, h, d, m, s, a) && !ko(e, g, p, h, d, h, s, null)) {
        for (; y - m >= 1; )
          b = (m + y) / 2, ko(e, g, p, h, d, b, s, a) ? y = b : m = b;
        if (m > f)
          return [g, p, m, !0];
      }
    }
    return function(l) {
      const c = l.datum.datum.items[i].items, f = c.length, d = l.datum.fontSize, h = Nn.width(l.datum, l.datum.text);
      let g = n ? d : 0, p = !1, m = !1, y = 0, b, v, x, w, _, E, S, $, F, A, D, k, M, C, T, L, I;
      for (let z = 0; z < f; ++z) {
        for (b = c[z].x, x = c[z].y, v = c[z].x2 === void 0 ? b : c[z].x2, w = c[z].y2 === void 0 ? x : c[z].y2, b > v && (I = b, b = v, v = I), x > w && (I = x, x = w, w = I), F = e(b), D = e(v), A = ~~((F + D) / 2), k = e(x), C = e(w), M = ~~((k + C) / 2), S = A; S >= F; --S)
          for ($ = M; $ >= k; --$)
            L = u(S, $, g, h, d), L && ([l.x, l.y, g, p] = L);
        for (S = A; S <= D; ++S)
          for ($ = M; $ <= C; ++$)
            L = u(S, $, g, h, d), L && ([l.x, l.y, g, p] = L);
        !p && !n && (T = Math.abs(v - b + w - x), _ = (b + v) / 2, E = (x + w) / 2, T >= y && !yg(_, E, h, d, r, o) && !ko(e, _, E, d, h, d, s, null) && (y = T, l.x = _, l.y = E, m = !0));
      }
      return p || m ? (_ = h / 2, E = d / 2, s.setRange(e(l.x - _), e(l.y - E), e(l.x + _), e(l.y + E)), l.align = "center", l.baseline = "middle", !0) : !1;
    };
  }
  const rY = [-1, -1, 1, 1], oY = [-1, 1, -1, 1];
  function sY(e, t, n, i) {
    const r = e.width, o = e.height, s = t[0], a = t[1], u = e.bitmap();
    return function(l) {
      const c = l.datum.datum.items[i].items, f = c.length, d = l.datum.fontSize, h = Nn.width(l.datum, l.datum.text), g = [];
      let p = n ? d : 0, m = !1, y = !1, b = 0, v, x, w, _, E, S, $, F, A, D, k, M;
      for (let C = 0; C < f; ++C) {
        for (v = c[C].x, w = c[C].y, x = c[C].x2 === void 0 ? v : c[C].x2, _ = c[C].y2 === void 0 ? w : c[C].y2, g.push([e((v + x) / 2), e((w + _) / 2)]); g.length; )
          if ([$, F] = g.pop(), !(s.get($, F) || a.get($, F) || u.get($, F))) {
            u.set($, F);
            for (let T = 0; T < 4; ++T)
              E = $ + rY[T], S = F + oY[T], u.outOfBounds(E, S, E, S) || g.push([E, S]);
            if (E = e.invert($), S = e.invert(F), A = p, D = o, !yg(E, S, h, d, r, o) && !ko(e, E, S, d, h, A, s, a) && !ko(e, E, S, d, h, d, s, null)) {
              for (; D - A >= 1; )
                k = (A + D) / 2, ko(e, E, S, d, h, k, s, a) ? D = k : A = k;
              A > p && (l.x = E, l.y = S, p = A, m = !0);
            }
          }
        !m && !n && (M = Math.abs(x - v + _ - w), E = (v + x) / 2, S = (w + _) / 2, M >= b && !yg(E, S, h, d, r, o) && !ko(e, E, S, d, h, d, s, null) && (b = M, l.x = E, l.y = S, y = !0));
      }
      return m || y ? (E = h / 2, S = d / 2, s.setRange(e(l.x - E), e(l.y - S), e(l.x + E), e(l.y + S)), l.align = "center", l.baseline = "middle", !0) : !1;
    };
  }
  const aY = ["right", "center", "left"], uY = ["bottom", "middle", "top"];
  function lY(e, t, n, i) {
    const r = e.width, o = e.height, s = t[0], a = t[1], u = i.length;
    return function(l) {
      const c = l.boundary, f = l.datum.fontSize;
      if (c[2] < 0 || c[5] < 0 || c[0] > r || c[3] > o)
        return !1;
      let d = l.textWidth ?? 0, h, g, p, m, y, b, v, x, w, _, E, S, $, F, A;
      for (let D = 0; D < u; ++D) {
        if (h = (n[D] & 3) - 1, g = (n[D] >>> 2 & 3) - 1, p = h === 0 && g === 0 || i[D] < 0, m = h && g ? Math.SQRT1_2 : 1, y = i[D] < 0 ? -1 : 1, b = c[1 + h] + i[D] * h * m, E = c[4 + g] + y * f * g / 2 + i[D] * g * m, x = E - f / 2, w = E + f / 2, S = e(b), F = e(x), A = e(w), !d)
          if (U$(S, S, F, A, s, a, b, b, x, w, c, p))
            d = Nn.width(l.datum, l.datum.text);
          else
            continue;
        if (_ = b + y * d * h / 2, b = _ - d / 2, v = _ + d / 2, S = e(b), $ = e(v), U$(S, $, F, A, s, a, b, v, x, w, c, p))
          return l.x = h ? h * y < 0 ? v : b : _, l.y = g ? g * y < 0 ? w : x : E, l.align = aY[h * y + 1], l.baseline = uY[g * y + 1], s.setRange(S, F, $, A), !0;
      }
      return !1;
    };
  }
  function U$(e, t, n, i, r, o, s, a, u, l, c, f) {
    return !(r.outOfBounds(e, n, t, i) || (f && o || r).getRange(e, n, t, i));
  }
  const O0 = 0, R0 = 4, L0 = 8, P0 = 0, I0 = 1, z0 = 2, cY = {
    "top-left": O0 + P0,
    top: O0 + I0,
    "top-right": O0 + z0,
    left: R0 + P0,
    middle: R0 + I0,
    right: R0 + z0,
    "bottom-left": L0 + P0,
    bottom: L0 + I0,
    "bottom-right": L0 + z0
  }, fY = {
    naive: nY,
    "reduced-search": iY,
    floodfill: sY
  };
  function dY(e, t, n, i, r, o, s, a, u, l, c) {
    if (!e.length) return e;
    const f = Math.max(i.length, r.length), d = hY(i, f), h = gY(r, f), g = pY(e[0].datum), p = g === "group" && e[0].datum.items[u].marktype, m = p === "area", y = mY(g, p, a, u), b = l === null || l === 1 / 0, v = m && c === "naive";
    let x = -1, w = -1;
    const _ = e.map((F) => {
      const A = b ? Nn.width(F, F.text) : void 0;
      return x = Math.max(x, A), w = Math.max(w, F.fontSize), {
        datum: F,
        opacity: 0,
        x: void 0,
        y: void 0,
        align: void 0,
        baseline: void 0,
        boundary: y(F),
        textWidth: A
      };
    });
    l = l === null || l === 1 / 0 ? Math.max(x, w) + Math.max(...i) : l;
    const E = tY(t[0], t[1], l);
    let S;
    if (!v) {
      n && _.sort((D, k) => n(D.datum, k.datum));
      let F = !1;
      for (let D = 0; D < h.length && !F; ++D)
        F = h[D] === 5 || d[D] < 0;
      const A = (g && s || m) && e.map((D) => D.datum);
      S = o.length || A ? QV(E, A || [], o, F, m) : JV(E, s && _);
    }
    const $ = m ? fY[c](E, S, s, u) : lY(E, S, h, d);
    return _.forEach((F) => F.opacity = +$(F)), _;
  }
  function hY(e, t) {
    const n = new Float64Array(t), i = e.length;
    for (let r = 0; r < i; ++r) n[r] = e[r] || 0;
    for (let r = i; r < t; ++r) n[r] = n[i - 1];
    return n;
  }
  function gY(e, t) {
    const n = new Int8Array(t), i = e.length;
    for (let r = 0; r < i; ++r) n[r] |= cY[e[r]];
    for (let r = i; r < t; ++r) n[r] = n[i - 1];
    return n;
  }
  function pY(e) {
    return e && e.mark && e.mark.marktype;
  }
  function mY(e, t, n, i) {
    const r = (o) => [o.x, o.x, o.x, o.y, o.y, o.y];
    return e ? e === "line" || e === "area" ? (o) => r(o.datum) : t === "line" ? (o) => {
      const s = o.datum.items[i].items;
      return r(s.length ? s[n === "start" ? 0 : s.length - 1] : {
        x: NaN,
        y: NaN
      });
    } : (o) => {
      const s = o.datum.bounds;
      return [s.x1, (s.x1 + s.x2) / 2, s.x2, s.y1, (s.y1 + s.y2) / 2, s.y2];
    } : r;
  }
  const Uy = ["x", "y", "opacity", "align", "baseline"], mO = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
  function z2(e) {
    N.call(this, null, e);
  }
  z2.Definition = {
    type: "Label",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "size",
      type: "number",
      array: !0,
      length: 2,
      required: !0
    }, {
      name: "sort",
      type: "compare"
    }, {
      name: "anchor",
      type: "string",
      array: !0,
      default: mO
    }, {
      name: "offset",
      type: "number",
      array: !0,
      default: [1]
    }, {
      name: "padding",
      type: "number",
      default: 0,
      null: !0
    }, {
      name: "lineAnchor",
      type: "string",
      values: ["start", "end"],
      default: "end"
    }, {
      name: "markIndex",
      type: "number",
      default: 0
    }, {
      name: "avoidBaseMark",
      type: "boolean",
      default: !0
    }, {
      name: "avoidMarks",
      type: "data",
      array: !0
    }, {
      name: "method",
      type: "string",
      default: "naive"
    }, {
      name: "as",
      type: "string",
      array: !0,
      length: Uy.length,
      default: Uy
    }]
  };
  G(z2, N, {
    transform(e, t) {
      function n(o) {
        const s = e[o];
        return fe(s) && t.modified(s.fields);
      }
      const i = e.modified();
      if (!(i || t.changed(t.ADD_REM) || n("sort"))) return;
      (!e.size || e.size.length !== 2) && R("Size parameter should be specified as a [width, height] array.");
      const r = e.as || Uy;
      return dY(t.materialize(t.SOURCE).source || [], e.size, e.sort, X(e.offset == null ? 1 : e.offset), X(e.anchor || mO), e.avoidMarks || [], e.avoidBaseMark !== !1, e.lineAnchor || "end", e.markIndex || 0, e.padding === void 0 ? 0 : e.padding, e.method || "naive").forEach((o) => {
        const s = o.datum;
        s[r[0]] = o.x, s[r[1]] = o.y, s[r[2]] = o.opacity, s[r[3]] = o.align, s[r[4]] = o.baseline;
      }), t.reflow(i).modifies(r);
    }
  });
  const yY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    label: z2
  }, Symbol.toStringTag, { value: "Module" }));
  function yO(e, t) {
    var n = [], i = function(c) {
      return c(a);
    }, r, o, s, a, u, l;
    if (t == null)
      n.push(e);
    else
      for (r = {}, o = 0, s = e.length; o < s; ++o)
        a = e[o], u = t.map(i), l = r[u], l || (r[u] = l = [], l.dims = u, n.push(l)), l.push(a);
    return n;
  }
  function B2(e) {
    N.call(this, null, e);
  }
  B2.Definition = {
    type: "Loess",
    metadata: {
      generates: !0
    },
    params: [{
      name: "x",
      type: "field",
      required: !0
    }, {
      name: "y",
      type: "field",
      required: !0
    }, {
      name: "groupby",
      type: "field",
      array: !0
    }, {
      name: "bandwidth",
      type: "number",
      default: 0.3
    }, {
      name: "as",
      type: "string",
      array: !0
    }]
  };
  G(B2, N, {
    transform(e, t) {
      const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
      if (!this.value || t.changed() || e.modified()) {
        const i = t.materialize(t.SOURCE).source, r = yO(i, e.groupby), o = (e.groupby || []).map(Je), s = o.length, a = e.as || [Je(e.x), Je(e.y)], u = [];
        r.forEach((l) => {
          SM(l, e.x, e.y, e.bandwidth || 0.3).forEach((c) => {
            const f = {};
            for (let d = 0; d < s; ++d)
              f[o[d]] = l.dims[d];
            f[a[0]] = c[0], f[a[1]] = c[1], u.push(Ce(f));
          });
        }), this.value && (n.rem = this.value), this.value = n.add = n.source = u;
      }
      return n;
    }
  });
  const jy = {
    constant: wv,
    linear: Ev,
    log: xM,
    exp: wM,
    pow: EM,
    quad: _v,
    poly: _M
  }, bY = (e, t) => e === "poly" ? t : e === "quad" ? 2 : 1;
  function U2(e) {
    N.call(this, null, e);
  }
  U2.Definition = {
    type: "Regression",
    metadata: {
      generates: !0
    },
    params: [{
      name: "x",
      type: "field",
      required: !0
    }, {
      name: "y",
      type: "field",
      required: !0
    }, {
      name: "groupby",
      type: "field",
      array: !0
    }, {
      name: "method",
      type: "string",
      default: "linear",
      values: Object.keys(jy)
    }, {
      name: "order",
      type: "number",
      default: 3
    }, {
      name: "extent",
      type: "number",
      array: !0,
      length: 2
    }, {
      name: "params",
      type: "boolean",
      default: !1
    }, {
      name: "as",
      type: "string",
      array: !0
    }]
  };
  G(U2, N, {
    transform(e, t) {
      const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
      if (!this.value || t.changed() || e.modified()) {
        const i = t.materialize(t.SOURCE).source, r = yO(i, e.groupby), o = (e.groupby || []).map(Je), s = e.method || "linear", a = e.order == null ? 3 : e.order, u = bY(s, a), l = e.as || [Je(e.x), Je(e.y)], c = jy[s], f = [];
        let d = e.extent;
        J(jy, s) || R("Invalid regression method: " + s), d != null && s === "log" && d[0] <= 0 && (t.dataflow.warn("Ignoring extent with values <= 0 for log regression."), d = null), r.forEach((h) => {
          if (h.length <= u) {
            t.dataflow.warn("Skipping regression with more parameters than data points.");
            return;
          }
          const p = c(h, e.x, e.y, a);
          if (e.params) {
            f.push(Ce({
              keys: h.dims,
              coef: p.coef,
              rSquared: p.rSquared
            }));
            return;
          }
          const m = d || nr(h, e.x), y = (b) => {
            const v = {};
            for (let x = 0; x < o.length; ++x)
              v[o[x]] = h.dims[x];
            v[l[0]] = b[0], v[l[1]] = b[1], f.push(Ce(v));
          };
          s === "linear" || s === "constant" ? m.forEach((b) => y([b, p.predict(b)])) : ap(p.predict, m, 25, 200).forEach(y);
        }), this.value && (n.rem = this.value), this.value = n.add = n.source = f;
      }
      return n;
    }
  });
  const vY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    loess: B2,
    regression: U2
  }, Symbol.toStringTag, { value: "Module" })), Ur = 11102230246251565e-32, Ot = 134217729, xY = (3 + 8 * Ur) * Ur;
  function B0(e, t, n, i, r) {
    let o, s, a, u, l = t[0], c = i[0], f = 0, d = 0;
    c > l == c > -l ? (o = l, l = t[++f]) : (o = c, c = i[++d]);
    let h = 0;
    if (f < e && d < n)
      for (c > l == c > -l ? (s = l + o, a = o - (s - l), l = t[++f]) : (s = c + o, a = o - (s - c), c = i[++d]), o = s, a !== 0 && (r[h++] = a); f < e && d < n; )
        c > l == c > -l ? (s = o + l, u = s - o, a = o - (s - u) + (l - u), l = t[++f]) : (s = o + c, u = s - o, a = o - (s - u) + (c - u), c = i[++d]), o = s, a !== 0 && (r[h++] = a);
    for (; f < e; )
      s = o + l, u = s - o, a = o - (s - u) + (l - u), l = t[++f], o = s, a !== 0 && (r[h++] = a);
    for (; d < n; )
      s = o + c, u = s - o, a = o - (s - u) + (c - u), c = i[++d], o = s, a !== 0 && (r[h++] = a);
    return (o !== 0 || h === 0) && (r[h++] = o), h;
  }
  function wY(e, t) {
    let n = t[0];
    for (let i = 1; i < e; i++) n += t[i];
    return n;
  }
  function kf(e) {
    return new Float64Array(e);
  }
  const EY = (3 + 16 * Ur) * Ur, _Y = (2 + 12 * Ur) * Ur, SY = (9 + 64 * Ur) * Ur * Ur, Ra = kf(4), j$ = kf(8), q$ = kf(12), W$ = kf(16), Yt = kf(4);
  function $Y(e, t, n, i, r, o, s) {
    let a, u, l, c, f, d, h, g, p, m, y, b, v, x, w, _, E, S;
    const $ = e - r, F = n - r, A = t - o, D = i - o;
    x = $ * D, d = Ot * $, h = d - (d - $), g = $ - h, d = Ot * D, p = d - (d - D), m = D - p, w = g * m - (x - h * p - g * p - h * m), _ = A * F, d = Ot * A, h = d - (d - A), g = A - h, d = Ot * F, p = d - (d - F), m = F - p, E = g * m - (_ - h * p - g * p - h * m), y = w - E, f = w - y, Ra[0] = w - (y + f) + (f - E), b = x + y, f = b - x, v = x - (b - f) + (y - f), y = v - _, f = v - y, Ra[1] = v - (y + f) + (f - _), S = b + y, f = S - b, Ra[2] = b - (S - f) + (y - f), Ra[3] = S;
    let k = wY(4, Ra), M = _Y * s;
    if (k >= M || -k >= M || (f = e - $, a = e - ($ + f) + (f - r), f = n - F, l = n - (F + f) + (f - r), f = t - A, u = t - (A + f) + (f - o), f = i - D, c = i - (D + f) + (f - o), a === 0 && u === 0 && l === 0 && c === 0) || (M = SY * s + xY * Math.abs(k), k += $ * c + D * a - (A * l + F * u), k >= M || -k >= M)) return k;
    x = a * D, d = Ot * a, h = d - (d - a), g = a - h, d = Ot * D, p = d - (d - D), m = D - p, w = g * m - (x - h * p - g * p - h * m), _ = u * F, d = Ot * u, h = d - (d - u), g = u - h, d = Ot * F, p = d - (d - F), m = F - p, E = g * m - (_ - h * p - g * p - h * m), y = w - E, f = w - y, Yt[0] = w - (y + f) + (f - E), b = x + y, f = b - x, v = x - (b - f) + (y - f), y = v - _, f = v - y, Yt[1] = v - (y + f) + (f - _), S = b + y, f = S - b, Yt[2] = b - (S - f) + (y - f), Yt[3] = S;
    const C = B0(4, Ra, 4, Yt, j$);
    x = $ * c, d = Ot * $, h = d - (d - $), g = $ - h, d = Ot * c, p = d - (d - c), m = c - p, w = g * m - (x - h * p - g * p - h * m), _ = A * l, d = Ot * A, h = d - (d - A), g = A - h, d = Ot * l, p = d - (d - l), m = l - p, E = g * m - (_ - h * p - g * p - h * m), y = w - E, f = w - y, Yt[0] = w - (y + f) + (f - E), b = x + y, f = b - x, v = x - (b - f) + (y - f), y = v - _, f = v - y, Yt[1] = v - (y + f) + (f - _), S = b + y, f = S - b, Yt[2] = b - (S - f) + (y - f), Yt[3] = S;
    const T = B0(C, j$, 4, Yt, q$);
    x = a * c, d = Ot * a, h = d - (d - a), g = a - h, d = Ot * c, p = d - (d - c), m = c - p, w = g * m - (x - h * p - g * p - h * m), _ = u * l, d = Ot * u, h = d - (d - u), g = u - h, d = Ot * l, p = d - (d - l), m = l - p, E = g * m - (_ - h * p - g * p - h * m), y = w - E, f = w - y, Yt[0] = w - (y + f) + (f - E), b = x + y, f = b - x, v = x - (b - f) + (y - f), y = v - _, f = v - y, Yt[1] = v - (y + f) + (f - _), S = b + y, f = S - b, Yt[2] = b - (S - f) + (y - f), Yt[3] = S;
    const L = B0(T, q$, 4, Yt, W$);
    return W$[L - 1];
  }
  function yd(e, t, n, i, r, o) {
    const s = (t - o) * (n - r), a = (e - r) * (i - o), u = s - a, l = Math.abs(s + a);
    return Math.abs(u) >= EY * l ? u : -$Y(e, t, n, i, r, o, l);
  }
  const H$ = Math.pow(2, -52), bd = new Uint32Array(512);
  class bg {
    static from(t, n = MY, i = TY) {
      const r = t.length, o = new Float64Array(r * 2);
      for (let s = 0; s < r; s++) {
        const a = t[s];
        o[2 * s] = n(a), o[2 * s + 1] = i(a);
      }
      return new bg(o);
    }
    constructor(t) {
      const n = t.length >> 1;
      if (n > 0 && typeof t[0] != "number") throw new Error("Expected coords to contain numbers.");
      this.coords = t;
      const i = Math.max(2 * n - 5, 0);
      this._triangles = new Uint32Array(i * 3), this._halfedges = new Int32Array(i * 3), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update();
    }
    update() {
      const { coords: t, _hullPrev: n, _hullNext: i, _hullTri: r, _hullHash: o } = this, s = t.length >> 1;
      let a = 1 / 0, u = 1 / 0, l = -1 / 0, c = -1 / 0;
      for (let $ = 0; $ < s; $++) {
        const F = t[2 * $], A = t[2 * $ + 1];
        F < a && (a = F), A < u && (u = A), F > l && (l = F), A > c && (c = A), this._ids[$] = $;
      }
      const f = (a + l) / 2, d = (u + c) / 2;
      let h, g, p;
      for (let $ = 0, F = 1 / 0; $ < s; $++) {
        const A = U0(f, d, t[2 * $], t[2 * $ + 1]);
        A < F && (h = $, F = A);
      }
      const m = t[2 * h], y = t[2 * h + 1];
      for (let $ = 0, F = 1 / 0; $ < s; $++) {
        if ($ === h) continue;
        const A = U0(m, y, t[2 * $], t[2 * $ + 1]);
        A < F && A > 0 && (g = $, F = A);
      }
      let b = t[2 * g], v = t[2 * g + 1], x = 1 / 0;
      for (let $ = 0; $ < s; $++) {
        if ($ === h || $ === g) continue;
        const F = CY(m, y, b, v, t[2 * $], t[2 * $ + 1]);
        F < x && (p = $, x = F);
      }
      let w = t[2 * p], _ = t[2 * p + 1];
      if (x === 1 / 0) {
        for (let A = 0; A < s; A++)
          this._dists[A] = t[2 * A] - t[0] || t[2 * A + 1] - t[1];
        Xa(this._ids, this._dists, 0, s - 1);
        const $ = new Uint32Array(s);
        let F = 0;
        for (let A = 0, D = -1 / 0; A < s; A++) {
          const k = this._ids[A], M = this._dists[k];
          M > D && ($[F++] = k, D = M);
        }
        this.hull = $.subarray(0, F), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
        return;
      }
      if (yd(m, y, b, v, w, _) < 0) {
        const $ = g, F = b, A = v;
        g = p, b = w, v = _, p = $, w = F, _ = A;
      }
      const E = FY(m, y, b, v, w, _);
      this._cx = E.x, this._cy = E.y;
      for (let $ = 0; $ < s; $++)
        this._dists[$] = U0(t[2 * $], t[2 * $ + 1], E.x, E.y);
      Xa(this._ids, this._dists, 0, s - 1), this._hullStart = h;
      let S = 3;
      i[h] = n[p] = g, i[g] = n[h] = p, i[p] = n[g] = h, r[h] = 0, r[g] = 1, r[p] = 2, o.fill(-1), o[this._hashKey(m, y)] = h, o[this._hashKey(b, v)] = g, o[this._hashKey(w, _)] = p, this.trianglesLen = 0, this._addTriangle(h, g, p, -1, -1, -1);
      for (let $ = 0, F, A; $ < this._ids.length; $++) {
        const D = this._ids[$], k = t[2 * D], M = t[2 * D + 1];
        if ($ > 0 && Math.abs(k - F) <= H$ && Math.abs(M - A) <= H$ || (F = k, A = M, D === h || D === g || D === p)) continue;
        let C = 0;
        for (let te = 0, ne = this._hashKey(k, M); te < this._hashSize && (C = o[(ne + te) % this._hashSize], !(C !== -1 && C !== i[C])); te++)
          ;
        C = n[C];
        let T = C, L;
        for (; L = i[T], yd(k, M, t[2 * T], t[2 * T + 1], t[2 * L], t[2 * L + 1]) >= 0; )
          if (T = L, T === C) {
            T = -1;
            break;
          }
        if (T === -1) continue;
        let I = this._addTriangle(T, D, i[T], -1, -1, r[T]);
        r[D] = this._legalize(I + 2), r[T] = I, S++;
        let z = i[T];
        for (; L = i[z], yd(k, M, t[2 * z], t[2 * z + 1], t[2 * L], t[2 * L + 1]) < 0; )
          I = this._addTriangle(z, D, L, r[D], -1, r[z]), r[D] = this._legalize(I + 2), i[z] = z, S--, z = L;
        if (T === C)
          for (; L = n[T], yd(k, M, t[2 * L], t[2 * L + 1], t[2 * T], t[2 * T + 1]) < 0; )
            I = this._addTriangle(L, D, T, -1, r[T], r[L]), this._legalize(I + 2), r[L] = I, i[T] = T, S--, T = L;
        this._hullStart = n[D] = T, i[T] = n[z] = D, i[D] = z, o[this._hashKey(k, M)] = D, o[this._hashKey(t[2 * T], t[2 * T + 1])] = T;
      }
      this.hull = new Uint32Array(S);
      for (let $ = 0, F = this._hullStart; $ < S; $++)
        this.hull[$] = F, F = i[F];
      this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
    }
    _hashKey(t, n) {
      return Math.floor(kY(t - this._cx, n - this._cy) * this._hashSize) % this._hashSize;
    }
    _legalize(t) {
      const { _triangles: n, _halfedges: i, coords: r } = this;
      let o = 0, s = 0;
      for (; ; ) {
        const a = i[t], u = t - t % 3;
        if (s = u + (t + 2) % 3, a === -1) {
          if (o === 0) break;
          t = bd[--o];
          continue;
        }
        const l = a - a % 3, c = u + (t + 1) % 3, f = l + (a + 2) % 3, d = n[s], h = n[t], g = n[c], p = n[f];
        if (AY(
          r[2 * d],
          r[2 * d + 1],
          r[2 * h],
          r[2 * h + 1],
          r[2 * g],
          r[2 * g + 1],
          r[2 * p],
          r[2 * p + 1]
        )) {
          n[t] = p, n[a] = d;
          const y = i[f];
          if (y === -1) {
            let v = this._hullStart;
            do {
              if (this._hullTri[v] === f) {
                this._hullTri[v] = t;
                break;
              }
              v = this._hullPrev[v];
            } while (v !== this._hullStart);
          }
          this._link(t, y), this._link(a, i[s]), this._link(s, f);
          const b = l + (a + 1) % 3;
          o < bd.length && (bd[o++] = b);
        } else {
          if (o === 0) break;
          t = bd[--o];
        }
      }
      return s;
    }
    _link(t, n) {
      this._halfedges[t] = n, n !== -1 && (this._halfedges[n] = t);
    }
    // add a new triangle given vertex indices and adjacent half-edge ids
    _addTriangle(t, n, i, r, o, s) {
      const a = this.trianglesLen;
      return this._triangles[a] = t, this._triangles[a + 1] = n, this._triangles[a + 2] = i, this._link(a, r), this._link(a + 1, o), this._link(a + 2, s), this.trianglesLen += 3, a;
    }
  }
  function kY(e, t) {
    const n = e / (Math.abs(e) + Math.abs(t));
    return (t > 0 ? 3 - n : 1 + n) / 4;
  }
  function U0(e, t, n, i) {
    const r = e - n, o = t - i;
    return r * r + o * o;
  }
  function AY(e, t, n, i, r, o, s, a) {
    const u = e - s, l = t - a, c = n - s, f = i - a, d = r - s, h = o - a, g = u * u + l * l, p = c * c + f * f, m = d * d + h * h;
    return u * (f * m - p * h) - l * (c * m - p * d) + g * (c * h - f * d) < 0;
  }
  function CY(e, t, n, i, r, o) {
    const s = n - e, a = i - t, u = r - e, l = o - t, c = s * s + a * a, f = u * u + l * l, d = 0.5 / (s * l - a * u), h = (l * c - a * f) * d, g = (s * f - u * c) * d;
    return h * h + g * g;
  }
  function FY(e, t, n, i, r, o) {
    const s = n - e, a = i - t, u = r - e, l = o - t, c = s * s + a * a, f = u * u + l * l, d = 0.5 / (s * l - a * u), h = e + (l * c - a * f) * d, g = t + (s * f - u * c) * d;
    return { x: h, y: g };
  }
  function Xa(e, t, n, i) {
    if (i - n <= 20)
      for (let r = n + 1; r <= i; r++) {
        const o = e[r], s = t[o];
        let a = r - 1;
        for (; a >= n && t[e[a]] > s; ) e[a + 1] = e[a--];
        e[a + 1] = o;
      }
    else {
      const r = n + i >> 1;
      let o = n + 1, s = i;
      Cl(e, r, o), t[e[n]] > t[e[i]] && Cl(e, n, i), t[e[o]] > t[e[i]] && Cl(e, o, i), t[e[n]] > t[e[o]] && Cl(e, n, o);
      const a = e[o], u = t[a];
      for (; ; ) {
        do
          o++;
        while (t[e[o]] < u);
        do
          s--;
        while (t[e[s]] > u);
        if (s < o) break;
        Cl(e, o, s);
      }
      e[n + 1] = e[s], e[s] = a, i - o + 1 >= s - n ? (Xa(e, t, o, i), Xa(e, t, n, s - 1)) : (Xa(e, t, n, s - 1), Xa(e, t, o, i));
    }
  }
  function Cl(e, t, n) {
    const i = e[t];
    e[t] = e[n], e[n] = i;
  }
  function MY(e) {
    return e[0];
  }
  function TY(e) {
    return e[1];
  }
  const G$ = 1e-6;
  class Ns {
    constructor() {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null, this._ = "";
    }
    moveTo(t, n) {
      this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
    }
    closePath() {
      this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
    }
    lineTo(t, n) {
      this._ += `L${this._x1 = +t},${this._y1 = +n}`;
    }
    arc(t, n, i) {
      t = +t, n = +n, i = +i;
      const r = t + i, o = n;
      if (i < 0) throw new Error("negative radius");
      this._x1 === null ? this._ += `M${r},${o}` : (Math.abs(this._x1 - r) > G$ || Math.abs(this._y1 - o) > G$) && (this._ += "L" + r + "," + o), i && (this._ += `A${i},${i},0,1,1,${t - i},${n}A${i},${i},0,1,1,${this._x1 = r},${this._y1 = o}`);
    }
    rect(t, n, i, r) {
      this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${+i}v${+r}h${-i}Z`;
    }
    value() {
      return this._ || null;
    }
  }
  class qy {
    constructor() {
      this._ = [];
    }
    moveTo(t, n) {
      this._.push([t, n]);
    }
    closePath() {
      this._.push(this._[0].slice());
    }
    lineTo(t, n) {
      this._.push([t, n]);
    }
    value() {
      return this._.length ? this._ : null;
    }
  }
  let DY = class {
    constructor(t, [n, i, r, o] = [0, 0, 960, 500]) {
      if (!((r = +r) >= (n = +n)) || !((o = +o) >= (i = +i))) throw new Error("invalid bounds");
      this.delaunay = t, this._circumcenters = new Float64Array(t.points.length * 2), this.vectors = new Float64Array(t.points.length * 2), this.xmax = r, this.xmin = n, this.ymax = o, this.ymin = i, this._init();
    }
    update() {
      return this.delaunay.update(), this._init(), this;
    }
    _init() {
      const { delaunay: { points: t, hull: n, triangles: i }, vectors: r } = this;
      let o, s;
      const a = this.circumcenters = this._circumcenters.subarray(0, i.length / 3 * 2);
      for (let p = 0, m = 0, y = i.length, b, v; p < y; p += 3, m += 2) {
        const x = i[p] * 2, w = i[p + 1] * 2, _ = i[p + 2] * 2, E = t[x], S = t[x + 1], $ = t[w], F = t[w + 1], A = t[_], D = t[_ + 1], k = $ - E, M = F - S, C = A - E, T = D - S, L = (k * T - M * C) * 2;
        if (Math.abs(L) < 1e-9) {
          if (o === void 0) {
            o = s = 0;
            for (const z of n) o += t[z * 2], s += t[z * 2 + 1];
            o /= n.length, s /= n.length;
          }
          const I = 1e9 * Math.sign((o - E) * T - (s - S) * C);
          b = (E + A) / 2 - I * T, v = (S + D) / 2 + I * C;
        } else {
          const I = 1 / L, z = k * k + M * M, te = C * C + T * T;
          b = E + (T * z - M * te) * I, v = S + (k * te - C * z) * I;
        }
        a[m] = b, a[m + 1] = v;
      }
      let u = n[n.length - 1], l, c = u * 4, f, d = t[2 * u], h, g = t[2 * u + 1];
      r.fill(0);
      for (let p = 0; p < n.length; ++p)
        u = n[p], l = c, f = d, h = g, c = u * 4, d = t[2 * u], g = t[2 * u + 1], r[l + 2] = r[c] = h - g, r[l + 3] = r[c + 1] = d - f;
    }
    render(t) {
      const n = t == null ? t = new Ns() : void 0, { delaunay: { halfedges: i, inedges: r, hull: o }, circumcenters: s, vectors: a } = this;
      if (o.length <= 1) return null;
      for (let c = 0, f = i.length; c < f; ++c) {
        const d = i[c];
        if (d < c) continue;
        const h = Math.floor(c / 3) * 2, g = Math.floor(d / 3) * 2, p = s[h], m = s[h + 1], y = s[g], b = s[g + 1];
        this._renderSegment(p, m, y, b, t);
      }
      let u, l = o[o.length - 1];
      for (let c = 0; c < o.length; ++c) {
        u = l, l = o[c];
        const f = Math.floor(r[l] / 3) * 2, d = s[f], h = s[f + 1], g = u * 4, p = this._project(d, h, a[g + 2], a[g + 3]);
        p && this._renderSegment(d, h, p[0], p[1], t);
      }
      return n && n.value();
    }
    renderBounds(t) {
      const n = t == null ? t = new Ns() : void 0;
      return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), n && n.value();
    }
    renderCell(t, n) {
      const i = n == null ? n = new Ns() : void 0, r = this._clip(t);
      if (r === null || !r.length) return;
      n.moveTo(r[0], r[1]);
      let o = r.length;
      for (; r[0] === r[o - 2] && r[1] === r[o - 1] && o > 1; ) o -= 2;
      for (let s = 2; s < o; s += 2)
        (r[s] !== r[s - 2] || r[s + 1] !== r[s - 1]) && n.lineTo(r[s], r[s + 1]);
      return n.closePath(), i && i.value();
    }
    *cellPolygons() {
      const { delaunay: { points: t } } = this;
      for (let n = 0, i = t.length / 2; n < i; ++n) {
        const r = this.cellPolygon(n);
        r && (r.index = n, yield r);
      }
    }
    cellPolygon(t) {
      const n = new qy();
      return this.renderCell(t, n), n.value();
    }
    _renderSegment(t, n, i, r, o) {
      let s;
      const a = this._regioncode(t, n), u = this._regioncode(i, r);
      a === 0 && u === 0 ? (o.moveTo(t, n), o.lineTo(i, r)) : (s = this._clipSegment(t, n, i, r, a, u)) && (o.moveTo(s[0], s[1]), o.lineTo(s[2], s[3]));
    }
    contains(t, n, i) {
      return n = +n, n !== n || (i = +i, i !== i) ? !1 : this.delaunay._step(t, n, i) === t;
    }
    *neighbors(t) {
      const n = this._clip(t);
      if (n) for (const i of this.delaunay.neighbors(t)) {
        const r = this._clip(i);
        if (r) {
          e: for (let o = 0, s = n.length; o < s; o += 2)
            for (let a = 0, u = r.length; a < u; a += 2)
              if (n[o] === r[a] && n[o + 1] === r[a + 1] && n[(o + 2) % s] === r[(a + u - 2) % u] && n[(o + 3) % s] === r[(a + u - 1) % u]) {
                yield i;
                break e;
              }
        }
      }
    }
    _cell(t) {
      const { circumcenters: n, delaunay: { inedges: i, halfedges: r, triangles: o } } = this, s = i[t];
      if (s === -1) return null;
      const a = [];
      let u = s;
      do {
        const l = Math.floor(u / 3);
        if (a.push(n[l * 2], n[l * 2 + 1]), u = u % 3 === 2 ? u - 2 : u + 1, o[u] !== t) break;
        u = r[u];
      } while (u !== s && u !== -1);
      return a;
    }
    _clip(t) {
      if (t === 0 && this.delaunay.hull.length === 1)
        return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
      const n = this._cell(t);
      if (n === null) return null;
      const { vectors: i } = this, r = t * 4;
      return this._simplify(i[r] || i[r + 1] ? this._clipInfinite(t, n, i[r], i[r + 1], i[r + 2], i[r + 3]) : this._clipFinite(t, n));
    }
    _clipFinite(t, n) {
      const i = n.length;
      let r = null, o, s, a = n[i - 2], u = n[i - 1], l, c = this._regioncode(a, u), f, d = 0;
      for (let h = 0; h < i; h += 2)
        if (o = a, s = u, a = n[h], u = n[h + 1], l = c, c = this._regioncode(a, u), l === 0 && c === 0)
          f = d, d = 0, r ? r.push(a, u) : r = [a, u];
        else {
          let g, p, m, y, b;
          if (l === 0) {
            if ((g = this._clipSegment(o, s, a, u, l, c)) === null) continue;
            [p, m, y, b] = g;
          } else {
            if ((g = this._clipSegment(a, u, o, s, c, l)) === null) continue;
            [y, b, p, m] = g, f = d, d = this._edgecode(p, m), f && d && this._edge(t, f, d, r, r.length), r ? r.push(p, m) : r = [p, m];
          }
          f = d, d = this._edgecode(y, b), f && d && this._edge(t, f, d, r, r.length), r ? r.push(y, b) : r = [y, b];
        }
      if (r)
        f = d, d = this._edgecode(r[0], r[1]), f && d && this._edge(t, f, d, r, r.length);
      else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2))
        return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
      return r;
    }
    _clipSegment(t, n, i, r, o, s) {
      const a = o < s;
      for (a && ([t, n, i, r, o, s] = [i, r, t, n, s, o]); ; ) {
        if (o === 0 && s === 0) return a ? [i, r, t, n] : [t, n, i, r];
        if (o & s) return null;
        let u, l, c = o || s;
        c & 8 ? (u = t + (i - t) * (this.ymax - n) / (r - n), l = this.ymax) : c & 4 ? (u = t + (i - t) * (this.ymin - n) / (r - n), l = this.ymin) : c & 2 ? (l = n + (r - n) * (this.xmax - t) / (i - t), u = this.xmax) : (l = n + (r - n) * (this.xmin - t) / (i - t), u = this.xmin), o ? (t = u, n = l, o = this._regioncode(t, n)) : (i = u, r = l, s = this._regioncode(i, r));
      }
    }
    _clipInfinite(t, n, i, r, o, s) {
      let a = Array.from(n), u;
      if ((u = this._project(a[0], a[1], i, r)) && a.unshift(u[0], u[1]), (u = this._project(a[a.length - 2], a[a.length - 1], o, s)) && a.push(u[0], u[1]), a = this._clipFinite(t, a))
        for (let l = 0, c = a.length, f, d = this._edgecode(a[c - 2], a[c - 1]); l < c; l += 2)
          f = d, d = this._edgecode(a[l], a[l + 1]), f && d && (l = this._edge(t, f, d, a, l), c = a.length);
      else this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (a = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]);
      return a;
    }
    _edge(t, n, i, r, o) {
      for (; n !== i; ) {
        let s, a;
        switch (n) {
          case 5:
            n = 4;
            continue;
          case 4:
            n = 6, s = this.xmax, a = this.ymin;
            break;
          case 6:
            n = 2;
            continue;
          case 2:
            n = 10, s = this.xmax, a = this.ymax;
            break;
          case 10:
            n = 8;
            continue;
          case 8:
            n = 9, s = this.xmin, a = this.ymax;
            break;
          case 9:
            n = 1;
            continue;
          case 1:
            n = 5, s = this.xmin, a = this.ymin;
            break;
        }
        (r[o] !== s || r[o + 1] !== a) && this.contains(t, s, a) && (r.splice(o, 0, s, a), o += 2);
      }
      return o;
    }
    _project(t, n, i, r) {
      let o = 1 / 0, s, a, u;
      if (r < 0) {
        if (n <= this.ymin) return null;
        (s = (this.ymin - n) / r) < o && (u = this.ymin, a = t + (o = s) * i);
      } else if (r > 0) {
        if (n >= this.ymax) return null;
        (s = (this.ymax - n) / r) < o && (u = this.ymax, a = t + (o = s) * i);
      }
      if (i > 0) {
        if (t >= this.xmax) return null;
        (s = (this.xmax - t) / i) < o && (a = this.xmax, u = n + (o = s) * r);
      } else if (i < 0) {
        if (t <= this.xmin) return null;
        (s = (this.xmin - t) / i) < o && (a = this.xmin, u = n + (o = s) * r);
      }
      return [a, u];
    }
    _edgecode(t, n) {
      return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (n === this.ymin ? 4 : n === this.ymax ? 8 : 0);
    }
    _regioncode(t, n) {
      return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (n < this.ymin ? 4 : n > this.ymax ? 8 : 0);
    }
    _simplify(t) {
      if (t && t.length > 4) {
        for (let n = 0; n < t.length; n += 2) {
          const i = (n + 2) % t.length, r = (n + 4) % t.length;
          (t[n] === t[i] && t[i] === t[r] || t[n + 1] === t[i + 1] && t[i + 1] === t[r + 1]) && (t.splice(i, 2), n -= 2);
        }
        t.length || (t = null);
      }
      return t;
    }
  };
  const NY = 2 * Math.PI, La = Math.pow;
  function OY(e) {
    return e[0];
  }
  function RY(e) {
    return e[1];
  }
  function LY(e) {
    const { triangles: t, coords: n } = e;
    for (let i = 0; i < t.length; i += 3) {
      const r = 2 * t[i], o = 2 * t[i + 1], s = 2 * t[i + 2];
      if ((n[s] - n[r]) * (n[o + 1] - n[r + 1]) - (n[o] - n[r]) * (n[s + 1] - n[r + 1]) > 1e-10) return !1;
    }
    return !0;
  }
  function PY(e, t, n) {
    return [e + Math.sin(e + t) * n, t + Math.cos(e - t) * n];
  }
  class j2 {
    static from(t, n = OY, i = RY, r) {
      return new j2("length" in t ? IY(t, n, i, r) : Float64Array.from(zY(t, n, i, r)));
    }
    constructor(t) {
      this._delaunator = new bg(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init();
    }
    update() {
      return this._delaunator.update(), this._init(), this;
    }
    _init() {
      const t = this._delaunator, n = this.points;
      if (t.hull && t.hull.length > 2 && LY(t)) {
        this.collinear = Int32Array.from({ length: n.length / 2 }, (d, h) => h).sort((d, h) => n[2 * d] - n[2 * h] || n[2 * d + 1] - n[2 * h + 1]);
        const u = this.collinear[0], l = this.collinear[this.collinear.length - 1], c = [n[2 * u], n[2 * u + 1], n[2 * l], n[2 * l + 1]], f = 1e-8 * Math.hypot(c[3] - c[1], c[2] - c[0]);
        for (let d = 0, h = n.length / 2; d < h; ++d) {
          const g = PY(n[2 * d], n[2 * d + 1], f);
          n[2 * d] = g[0], n[2 * d + 1] = g[1];
        }
        this._delaunator = new bg(n);
      } else
        delete this.collinear;
      const i = this.halfedges = this._delaunator.halfedges, r = this.hull = this._delaunator.hull, o = this.triangles = this._delaunator.triangles, s = this.inedges.fill(-1), a = this._hullIndex.fill(-1);
      for (let u = 0, l = i.length; u < l; ++u) {
        const c = o[u % 3 === 2 ? u - 2 : u + 1];
        (i[u] === -1 || s[c] === -1) && (s[c] = u);
      }
      for (let u = 0, l = r.length; u < l; ++u)
        a[r[u]] = u;
      r.length <= 2 && r.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = r[0], s[r[0]] = 1, r.length === 2 && (s[r[1]] = 0, this.triangles[1] = r[1], this.triangles[2] = r[1]));
    }
    voronoi(t) {
      return new DY(this, t);
    }
    *neighbors(t) {
      const { inedges: n, hull: i, _hullIndex: r, halfedges: o, triangles: s, collinear: a } = this;
      if (a) {
        const f = a.indexOf(t);
        f > 0 && (yield a[f - 1]), f < a.length - 1 && (yield a[f + 1]);
        return;
      }
      const u = n[t];
      if (u === -1) return;
      let l = u, c = -1;
      do {
        if (yield c = s[l], l = l % 3 === 2 ? l - 2 : l + 1, s[l] !== t) return;
        if (l = o[l], l === -1) {
          const f = i[(r[t] + 1) % i.length];
          f !== c && (yield f);
          return;
        }
      } while (l !== u);
    }
    find(t, n, i = 0) {
      if (t = +t, t !== t || (n = +n, n !== n)) return -1;
      const r = i;
      let o;
      for (; (o = this._step(i, t, n)) >= 0 && o !== i && o !== r; ) i = o;
      return o;
    }
    _step(t, n, i) {
      const { inedges: r, hull: o, _hullIndex: s, halfedges: a, triangles: u, points: l } = this;
      if (r[t] === -1 || !l.length) return (t + 1) % (l.length >> 1);
      let c = t, f = La(n - l[t * 2], 2) + La(i - l[t * 2 + 1], 2);
      const d = r[t];
      let h = d;
      do {
        let g = u[h];
        const p = La(n - l[g * 2], 2) + La(i - l[g * 2 + 1], 2);
        if (p < f && (f = p, c = g), h = h % 3 === 2 ? h - 2 : h + 1, u[h] !== t) break;
        if (h = a[h], h === -1) {
          if (h = o[(s[t] + 1) % o.length], h !== g && La(n - l[h * 2], 2) + La(i - l[h * 2 + 1], 2) < f)
            return h;
          break;
        }
      } while (h !== d);
      return c;
    }
    render(t) {
      const n = t == null ? t = new Ns() : void 0, { points: i, halfedges: r, triangles: o } = this;
      for (let s = 0, a = r.length; s < a; ++s) {
        const u = r[s];
        if (u < s) continue;
        const l = o[s] * 2, c = o[u] * 2;
        t.moveTo(i[l], i[l + 1]), t.lineTo(i[c], i[c + 1]);
      }
      return this.renderHull(t), n && n.value();
    }
    renderPoints(t, n) {
      n === void 0 && (!t || typeof t.moveTo != "function") && (n = t, t = null), n = n == null ? 2 : +n;
      const i = t == null ? t = new Ns() : void 0, { points: r } = this;
      for (let o = 0, s = r.length; o < s; o += 2) {
        const a = r[o], u = r[o + 1];
        t.moveTo(a + n, u), t.arc(a, u, n, 0, NY);
      }
      return i && i.value();
    }
    renderHull(t) {
      const n = t == null ? t = new Ns() : void 0, { hull: i, points: r } = this, o = i[0] * 2, s = i.length;
      t.moveTo(r[o], r[o + 1]);
      for (let a = 1; a < s; ++a) {
        const u = 2 * i[a];
        t.lineTo(r[u], r[u + 1]);
      }
      return t.closePath(), n && n.value();
    }
    hullPolygon() {
      const t = new qy();
      return this.renderHull(t), t.value();
    }
    renderTriangle(t, n) {
      const i = n == null ? n = new Ns() : void 0, { points: r, triangles: o } = this, s = o[t *= 3] * 2, a = o[t + 1] * 2, u = o[t + 2] * 2;
      return n.moveTo(r[s], r[s + 1]), n.lineTo(r[a], r[a + 1]), n.lineTo(r[u], r[u + 1]), n.closePath(), i && i.value();
    }
    *trianglePolygons() {
      const { triangles: t } = this;
      for (let n = 0, i = t.length / 3; n < i; ++n)
        yield this.trianglePolygon(n);
    }
    trianglePolygon(t) {
      const n = new qy();
      return this.renderTriangle(t, n), n.value();
    }
  }
  function IY(e, t, n, i) {
    const r = e.length, o = new Float64Array(r * 2);
    for (let s = 0; s < r; ++s) {
      const a = e[s];
      o[s * 2] = t.call(i, a, s, e), o[s * 2 + 1] = n.call(i, a, s, e);
    }
    return o;
  }
  function* zY(e, t, n, i) {
    let r = 0;
    for (const o of e)
      yield t.call(i, o, r, e), yield n.call(i, o, r, e), ++r;
  }
  function q2(e) {
    N.call(this, null, e);
  }
  q2.Definition = {
    type: "Voronoi",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "x",
      type: "field",
      required: !0
    }, {
      name: "y",
      type: "field",
      required: !0
    }, {
      name: "size",
      type: "number",
      array: !0,
      length: 2
    }, {
      name: "extent",
      type: "array",
      array: !0,
      length: 2,
      default: [[-1e5, -1e5], [1e5, 1e5]],
      content: {
        type: "number",
        array: !0,
        length: 2
      }
    }, {
      name: "as",
      type: "string",
      default: "path"
    }]
  };
  const BY = [-1e5, -1e5, 1e5, 1e5];
  G(q2, N, {
    transform(e, t) {
      const n = e.as || "path", i = t.source;
      if (!i || !i.length) return t;
      let r = e.size;
      r = r ? [0, 0, r[0], r[1]] : (r = e.extent) ? [r[0][0], r[0][1], r[1][0], r[1][1]] : BY;
      const o = this.value = j2.from(i, e.x, e.y).voronoi(r);
      for (let s = 0, a = i.length; s < a; ++s) {
        const u = o.cellPolygon(s);
        i[s][n] = u && !jY(u) ? UY(u) : null;
      }
      return t.reflow(e.modified()).modifies(n);
    }
  });
  function UY(e) {
    const t = e[0][0], n = e[0][1];
    let i = e.length - 1;
    for (; e[i][0] === t && e[i][1] === n; --i) ;
    return "M" + e.slice(0, i + 1).join("L") + "Z";
  }
  function jY(e) {
    return e.length === 2 && e[0][0] === e[1][0] && e[0][1] === e[1][1];
  }
  const qY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    voronoi: q2
  }, Symbol.toStringTag, { value: "Module" }));
  var j0 = Math.PI / 180, oc = 64, eh = 2048;
  function WY() {
    var e = [256, 256], t, n, i, r, o, s, a, u = bO, l = [], c = Math.random, f = {};
    f.layout = function() {
      for (var g = d(To()), p = KY((e[0] >> 5) * e[1]), m = null, y = l.length, b = -1, v = [], x = l.map((_) => ({
        text: t(_),
        font: n(_),
        style: r(_),
        weight: o(_),
        rotate: s(_),
        size: ~~(i(_) + 1e-14),
        padding: a(_),
        xoff: 0,
        yoff: 0,
        x1: 0,
        y1: 0,
        x0: 0,
        y0: 0,
        hasText: !1,
        sprite: null,
        datum: _
      })).sort((_, E) => E.size - _.size); ++b < y; ) {
        var w = x[b];
        w.x = e[0] * (c() + 0.5) >> 1, w.y = e[1] * (c() + 0.5) >> 1, HY(g, w, x, b), w.hasText && h(p, w, m) && (v.push(w), m ? VY(m, w) : m = [{
          x: w.x + w.x0,
          y: w.y + w.y0
        }, {
          x: w.x + w.x1,
          y: w.y + w.y1
        }], w.x -= e[0] >> 1, w.y -= e[1] >> 1);
      }
      return v;
    };
    function d(g) {
      g.width = g.height = 1;
      var p = Math.sqrt(g.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
      g.width = (oc << 5) / p, g.height = eh / p;
      var m = g.getContext("2d");
      return m.fillStyle = m.strokeStyle = "red", m.textAlign = "center", {
        context: m,
        ratio: p
      };
    }
    function h(g, p, m) {
      for (var y = p.x, b = p.y, v = Math.hypot(e[0], e[1]), x = u(e), w = c() < 0.5 ? 1 : -1, _ = -w, E, S, $; (E = x(_ += w)) && (S = ~~E[0], $ = ~~E[1], !(Math.min(Math.abs(S), Math.abs($)) >= v)); )
        if (p.x = y + S, p.y = b + $, !(p.x + p.x0 < 0 || p.y + p.y0 < 0 || p.x + p.x1 > e[0] || p.y + p.y1 > e[1]) && (!m || !GY(p, g, e[0])) && (!m || YY(p, m))) {
          for (var F = p.sprite, A = p.width >> 5, D = e[0] >> 5, k = p.x - (A << 4), M = k & 127, C = 32 - M, T = p.y1 - p.y0, L = (p.y + p.y0) * D + (k >> 5), I, z = 0; z < T; z++) {
            I = 0;
            for (var te = 0; te <= A; te++)
              g[L + te] |= I << C | (te < A ? (I = F[z * A + te]) >>> M : 0);
            L += D;
          }
          return p.sprite = null, !0;
        }
      return !1;
    }
    return f.words = function(g) {
      return arguments.length ? (l = g, f) : l;
    }, f.size = function(g) {
      return arguments.length ? (e = [+g[0], +g[1]], f) : e;
    }, f.font = function(g) {
      return arguments.length ? (n = ds(g), f) : n;
    }, f.fontStyle = function(g) {
      return arguments.length ? (r = ds(g), f) : r;
    }, f.fontWeight = function(g) {
      return arguments.length ? (o = ds(g), f) : o;
    }, f.rotate = function(g) {
      return arguments.length ? (s = ds(g), f) : s;
    }, f.text = function(g) {
      return arguments.length ? (t = ds(g), f) : t;
    }, f.spiral = function(g) {
      return arguments.length ? (u = JY[g] || g, f) : u;
    }, f.fontSize = function(g) {
      return arguments.length ? (i = ds(g), f) : i;
    }, f.padding = function(g) {
      return arguments.length ? (a = ds(g), f) : a;
    }, f.random = function(g) {
      return arguments.length ? (c = g, f) : c;
    }, f;
  }
  function HY(e, t, n, i) {
    if (!t.sprite) {
      var r = e.context, o = e.ratio;
      r.clearRect(0, 0, (oc << 5) / o, eh / o);
      var s = 0, a = 0, u = 0, l = n.length, c, f, d, h, g;
      for (--i; ++i < l; ) {
        if (t = n[i], r.save(), r.font = t.style + " " + t.weight + " " + ~~((t.size + 1) / o) + "px " + t.font, c = r.measureText(t.text + "m").width * o, d = t.size << 1, t.rotate) {
          var p = Math.sin(t.rotate * j0), m = Math.cos(t.rotate * j0), y = c * m, b = c * p, v = d * m, x = d * p;
          c = Math.max(Math.abs(y + x), Math.abs(y - x)) + 31 >> 5 << 5, d = ~~Math.max(Math.abs(b + v), Math.abs(b - v));
        } else
          c = c + 31 >> 5 << 5;
        if (d > u && (u = d), s + c >= oc << 5 && (s = 0, a += u, u = 0), a + d >= eh) break;
        r.translate((s + (c >> 1)) / o, (a + (d >> 1)) / o), t.rotate && r.rotate(t.rotate * j0), r.fillText(t.text, 0, 0), t.padding && (r.lineWidth = 2 * t.padding, r.strokeText(t.text, 0, 0)), r.restore(), t.width = c, t.height = d, t.xoff = s, t.yoff = a, t.x1 = c >> 1, t.y1 = d >> 1, t.x0 = -t.x1, t.y0 = -t.y1, t.hasText = !0, s += c;
      }
      for (var w = r.getImageData(0, 0, (oc << 5) / o, eh / o).data, _ = []; --i >= 0; )
        if (t = n[i], !!t.hasText) {
          for (c = t.width, f = c >> 5, d = t.y1 - t.y0, h = 0; h < d * f; h++) _[h] = 0;
          if (s = t.xoff, s == null) return;
          a = t.yoff;
          var E = 0, S = -1;
          for (g = 0; g < d; g++) {
            for (h = 0; h < c; h++) {
              var $ = f * g + (h >> 5), F = w[(a + g) * (oc << 5) + (s + h) << 2] ? 1 << 31 - h % 32 : 0;
              _[$] |= F, E |= F;
            }
            E ? S = g : (t.y0++, d--, g--, a++);
          }
          t.y1 = t.y0 + S, t.sprite = _.slice(0, (t.y1 - t.y0) * f);
        }
    }
  }
  function GY(e, t, n) {
    n >>= 5;
    for (var i = e.sprite, r = e.width >> 5, o = e.x - (r << 4), s = o & 127, a = 32 - s, u = e.y1 - e.y0, l = (e.y + e.y0) * n + (o >> 5), c, f = 0; f < u; f++) {
      c = 0;
      for (var d = 0; d <= r; d++)
        if ((c << a | (d < r ? (c = i[f * r + d]) >>> s : 0)) & t[l + d]) return !0;
      l += n;
    }
    return !1;
  }
  function VY(e, t) {
    var n = e[0], i = e[1];
    t.x + t.x0 < n.x && (n.x = t.x + t.x0), t.y + t.y0 < n.y && (n.y = t.y + t.y0), t.x + t.x1 > i.x && (i.x = t.x + t.x1), t.y + t.y1 > i.y && (i.y = t.y + t.y1);
  }
  function YY(e, t) {
    return e.x + e.x1 > t[0].x && e.x + e.x0 < t[1].x && e.y + e.y1 > t[0].y && e.y + e.y0 < t[1].y;
  }
  function bO(e) {
    var t = e[0] / e[1];
    return function(n) {
      return [t * (n *= 0.1) * Math.cos(n), n * Math.sin(n)];
    };
  }
  function XY(e) {
    var t = 4, n = t * e[0] / e[1], i = 0, r = 0;
    return function(o) {
      var s = o < 0 ? -1 : 1;
      switch (Math.sqrt(1 + 4 * s * o) - s & 3) {
        case 0:
          i += n;
          break;
        case 1:
          r += t;
          break;
        case 2:
          i -= n;
          break;
        default:
          r -= t;
          break;
      }
      return [i, r];
    };
  }
  function KY(e) {
    for (var t = [], n = -1; ++n < e; ) t[n] = 0;
    return t;
  }
  function ds(e) {
    return typeof e == "function" ? e : function() {
      return e;
    };
  }
  var JY = {
    archimedean: bO,
    rectangular: XY
  };
  const vO = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"], QY = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
  function W2(e) {
    N.call(this, WY(), e);
  }
  W2.Definition = {
    type: "Wordcloud",
    metadata: {
      modifies: !0
    },
    params: [{
      name: "size",
      type: "number",
      array: !0,
      length: 2
    }, {
      name: "font",
      type: "string",
      expr: !0,
      default: "sans-serif"
    }, {
      name: "fontStyle",
      type: "string",
      expr: !0,
      default: "normal"
    }, {
      name: "fontWeight",
      type: "string",
      expr: !0,
      default: "normal"
    }, {
      name: "fontSize",
      type: "number",
      expr: !0,
      default: 14
    }, {
      name: "fontSizeRange",
      type: "number",
      array: "nullable",
      default: [10, 50]
    }, {
      name: "rotate",
      type: "number",
      expr: !0,
      default: 0
    }, {
      name: "text",
      type: "field"
    }, {
      name: "spiral",
      type: "string",
      values: ["archimedean", "rectangular"]
    }, {
      name: "padding",
      type: "number",
      expr: !0
    }, {
      name: "as",
      type: "string",
      array: !0,
      length: 7,
      default: vO
    }]
  };
  G(W2, N, {
    transform(e, t) {
      e.size && !(e.size[0] && e.size[1]) && R("Wordcloud size dimensions must be non-zero.");
      function n(g) {
        const p = e[g];
        return fe(p) && t.modified(p.fields);
      }
      const i = e.modified();
      if (!(i || t.changed(t.ADD_REM) || QY.some(n))) return;
      const r = t.materialize(t.SOURCE).source, o = this.value, s = e.as || vO;
      let a = e.fontSize || 14, u;
      if (fe(a) ? u = e.fontSizeRange : a = Gt(a), u) {
        const g = a, p = Ae("sqrt")().domain(nr(r, g)).range(u);
        a = (m) => p(g(m));
      }
      r.forEach((g) => {
        g[s[0]] = NaN, g[s[1]] = NaN, g[s[3]] = 0;
      });
      const l = o.words(r).text(e.text).size(e.size || [500, 500]).padding(e.padding || 1).spiral(e.spiral || "archimedean").rotate(e.rotate || 0).font(e.font || "sans-serif").fontStyle(e.fontStyle || "normal").fontWeight(e.fontWeight || "normal").fontSize(a).random(Zn).layout(), c = o.size(), f = c[0] >> 1, d = c[1] >> 1, h = l.length;
      for (let g = 0, p, m; g < h; ++g)
        p = l[g], m = p.datum, m[s[0]] = p.x + f, m[s[1]] = p.y + d, m[s[2]] = p.font, m[s[3]] = p.size, m[s[4]] = p.style, m[s[5]] = p.weight, m[s[6]] = p.rotate;
      return t.reflow(i).modifies(s);
    }
  });
  const ZY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    wordcloud: W2
  }, Symbol.toStringTag, { value: "Module" })), eX = (e) => new Uint8Array(e), tX = (e) => new Uint16Array(e), bc = (e) => new Uint32Array(e);
  function nX() {
    let e = 8, t = [], n = bc(0), i = vd(0, e), r = vd(0, e);
    return {
      data: () => t,
      seen: () => n = iX(n, t.length),
      add(o) {
        for (let s = 0, a = t.length, u = o.length, l; s < u; ++s)
          l = o[s], l._index = a++, t.push(l);
      },
      remove(o, s) {
        const a = t.length, u = Array(a - o), l = t;
        let c, f, d;
        for (f = 0; !s[f] && f < a; ++f)
          u[f] = t[f], l[f] = f;
        for (d = f; f < a; ++f)
          c = t[f], s[f] ? l[f] = -1 : (l[f] = d, i[d] = i[f], r[d] = r[f], u[d] = c, c._index = d++), i[f] = 0;
        return t = u, l;
      },
      size: () => t.length,
      curr: () => i,
      prev: () => r,
      reset: (o) => r[o] = i[o],
      all: () => e < 257 ? 255 : e < 65537 ? 65535 : 4294967295,
      set(o, s) {
        i[o] |= s;
      },
      clear(o, s) {
        i[o] &= ~s;
      },
      resize(o, s) {
        const a = i.length;
        (o > a || s > e) && (e = Math.max(s, e), i = vd(o, e, i), r = vd(o, e));
      }
    };
  }
  function iX(e, t, n) {
    return e.length >= t ? e : (n = n || new e.constructor(t), n.set(e), n);
  }
  function vd(e, t, n) {
    const i = (t < 257 ? eX : t < 65537 ? tX : bc)(e);
    return n && i.set(n), i;
  }
  function V$(e, t, n) {
    const i = 1 << t;
    return {
      one: i,
      zero: ~i,
      range: n.slice(),
      bisect: e.bisect,
      index: e.index,
      size: e.size,
      onAdd(r, o) {
        const s = this, a = s.bisect(s.range, r.value), u = r.index, l = a[0], c = a[1], f = u.length;
        let d;
        for (d = 0; d < l; ++d) o[u[d]] |= i;
        for (d = c; d < f; ++d) o[u[d]] |= i;
        return s;
      }
    };
  }
  function Y$() {
    let e = bc(0), t = [], n = 0;
    function i(a, u, l) {
      if (!u.length) return [];
      const c = n, f = u.length, d = bc(f);
      let h = Array(f), g, p, m;
      for (m = 0; m < f; ++m)
        h[m] = a(u[m]), d[m] = m;
      if (h = rX(h, d), c)
        g = t, p = e, t = Array(c + f), e = bc(c + f), oX(l, g, p, c, h, d, f, t, e);
      else {
        if (l > 0) for (m = 0; m < f; ++m)
          d[m] += l;
        t = h, e = d;
      }
      return n = c + f, {
        index: d,
        value: h
      };
    }
    function r(a, u) {
      const l = n;
      let c, f, d;
      for (f = 0; !u[e[f]] && f < l; ++f) ;
      for (d = f; f < l; ++f)
        u[c = e[f]] || (e[d] = c, t[d] = t[f], ++d);
      n = l - a;
    }
    function o(a) {
      for (let u = 0, l = n; u < l; ++u)
        e[u] = a[e[u]];
    }
    function s(a, u) {
      let l;
      return u ? l = u.length : (u = t, l = n), [lP(u, a[0], 0, l), Oo(u, a[1], 0, l)];
    }
    return {
      insert: i,
      remove: r,
      bisect: s,
      reindex: o,
      index: () => e,
      size: () => n
    };
  }
  function rX(e, t) {
    return e.sort.call(t, (n, i) => {
      const r = e[n], o = e[i];
      return r < o ? -1 : r > o ? 1 : 0;
    }), dP(e, t);
  }
  function oX(e, t, n, i, r, o, s, a, u) {
    let l = 0, c = 0, f;
    for (f = 0; l < i && c < s; ++f)
      t[l] < r[c] ? (a[f] = t[l], u[f] = n[l++]) : (a[f] = r[c], u[f] = o[c++] + e);
    for (; l < i; ++l, ++f)
      a[f] = t[l], u[f] = n[l];
    for (; c < s; ++c, ++f)
      a[f] = r[c], u[f] = o[c] + e;
  }
  function H2(e) {
    N.call(this, nX(), e), this._indices = null, this._dims = null;
  }
  H2.Definition = {
    type: "CrossFilter",
    metadata: {},
    params: [{
      name: "fields",
      type: "field",
      array: !0,
      required: !0
    }, {
      name: "query",
      type: "array",
      array: !0,
      required: !0,
      content: {
        type: "number",
        array: !0,
        length: 2
      }
    }]
  };
  G(H2, N, {
    transform(e, t) {
      if (this._dims) {
        var n = e.modified("fields") || e.fields.some((i) => t.modified(i.fields));
        return n ? this.reinit(e, t) : this.eval(e, t);
      } else
        return this.init(e, t);
    },
    init(e, t) {
      const n = e.fields, i = e.query, r = this._indices = {}, o = this._dims = [], s = i.length;
      let a = 0, u, l;
      for (; a < s; ++a)
        u = n[a].fname, l = r[u] || (r[u] = Y$()), o.push(V$(l, a, i[a]));
      return this.eval(e, t);
    },
    reinit(e, t) {
      const n = t.materialize().fork(), i = e.fields, r = e.query, o = this._indices, s = this._dims, a = this.value, u = a.curr(), l = a.prev(), c = a.all(), f = n.rem = n.add, d = n.mod, h = r.length, g = {};
      let p, m, y, b, v, x, w, _, E;
      if (l.set(u), t.rem.length && (v = this.remove(e, t, n)), t.add.length && a.add(t.add), t.mod.length)
        for (x = {}, b = t.mod, w = 0, _ = b.length; w < _; ++w)
          x[b[w]._index] = 1;
      for (w = 0; w < h; ++w)
        E = i[w], (!s[w] || e.modified("fields", w) || t.modified(E.fields)) && (y = E.fname, (p = g[y]) || (o[y] = m = Y$(), g[y] = p = m.insert(E, t.source, 0)), s[w] = V$(m, w, r[w]).onAdd(p, u));
      for (w = 0, _ = a.data().length; w < _; ++w)
        v[w] || (l[w] !== u[w] ? f.push(w) : x[w] && u[w] !== c && d.push(w));
      return a.mask = (1 << h) - 1, n;
    },
    eval(e, t) {
      const n = t.materialize().fork(), i = this._dims.length;
      let r = 0;
      return t.rem.length && (this.remove(e, t, n), r |= (1 << i) - 1), e.modified("query") && !e.modified("fields") && (r |= this.update(e, t, n)), t.add.length && (this.insert(e, t, n), r |= (1 << i) - 1), t.mod.length && (this.modify(t, n), r |= (1 << i) - 1), this.value.mask = r, n;
    },
    insert(e, t, n) {
      const i = t.add, r = this.value, o = this._dims, s = this._indices, a = e.fields, u = {}, l = n.add, c = r.size() + i.length, f = o.length;
      let d = r.size(), h, g, p;
      r.resize(c, f), r.add(i);
      const m = r.curr(), y = r.prev(), b = r.all();
      for (h = 0; h < f; ++h)
        g = a[h].fname, p = u[g] || (u[g] = s[g].insert(a[h], i, d)), o[h].onAdd(p, m);
      for (; d < c; ++d)
        y[d] = b, m[d] !== b && l.push(d);
    },
    modify(e, t) {
      const n = t.mod, i = this.value, r = i.curr(), o = i.all(), s = e.mod;
      let a, u, l;
      for (a = 0, u = s.length; a < u; ++a)
        l = s[a]._index, r[l] !== o && n.push(l);
    },
    remove(e, t, n) {
      const i = this._indices, r = this.value, o = r.curr(), s = r.prev(), a = r.all(), u = {}, l = n.rem, c = t.rem;
      let f, d, h, g;
      for (f = 0, d = c.length; f < d; ++f)
        h = c[f]._index, u[h] = 1, s[h] = g = o[h], o[h] = a, g !== a && l.push(h);
      for (h in i)
        i[h].remove(d, u);
      return this.reindex(t, d, u), u;
    },
    // reindex filters and indices after propagation completes
    reindex(e, t, n) {
      const i = this._indices, r = this.value;
      e.runAfter(() => {
        const o = r.remove(t, n);
        for (const s in i) i[s].reindex(o);
      });
    },
    update(e, t, n) {
      const i = this._dims, r = e.query, o = t.stamp, s = i.length;
      let a = 0, u, l;
      for (n.filters = 0, l = 0; l < s; ++l)
        e.modified("query", l) && (u = l, ++a);
      if (a === 1)
        a = i[u].one, this.incrementOne(i[u], r[u], n.add, n.rem);
      else
        for (l = 0, a = 0; l < s; ++l)
          e.modified("query", l) && (a |= i[l].one, this.incrementAll(i[l], r[l], o, n.add), n.rem = n.add);
      return a;
    },
    incrementAll(e, t, n, i) {
      const r = this.value, o = r.seen(), s = r.curr(), a = r.prev(), u = e.index(), l = e.bisect(e.range), c = e.bisect(t), f = c[0], d = c[1], h = l[0], g = l[1], p = e.one;
      let m, y, b;
      if (f < h)
        for (m = f, y = Math.min(h, d); m < y; ++m)
          b = u[m], o[b] !== n && (a[b] = s[b], o[b] = n, i.push(b)), s[b] ^= p;
      else if (f > h)
        for (m = h, y = Math.min(f, g); m < y; ++m)
          b = u[m], o[b] !== n && (a[b] = s[b], o[b] = n, i.push(b)), s[b] ^= p;
      if (d > g)
        for (m = Math.max(f, g), y = d; m < y; ++m)
          b = u[m], o[b] !== n && (a[b] = s[b], o[b] = n, i.push(b)), s[b] ^= p;
      else if (d < g)
        for (m = Math.max(h, d), y = g; m < y; ++m)
          b = u[m], o[b] !== n && (a[b] = s[b], o[b] = n, i.push(b)), s[b] ^= p;
      e.range = t.slice();
    },
    incrementOne(e, t, n, i) {
      const r = this.value, o = r.curr(), s = e.index(), a = e.bisect(e.range), u = e.bisect(t), l = u[0], c = u[1], f = a[0], d = a[1], h = e.one;
      let g, p, m;
      if (l < f)
        for (g = l, p = Math.min(f, c); g < p; ++g)
          m = s[g], o[m] ^= h, n.push(m);
      else if (l > f)
        for (g = f, p = Math.min(l, d); g < p; ++g)
          m = s[g], o[m] ^= h, i.push(m);
      if (c > d)
        for (g = Math.max(l, d), p = c; g < p; ++g)
          m = s[g], o[m] ^= h, n.push(m);
      else if (c < d)
        for (g = Math.max(f, c), p = d; g < p; ++g)
          m = s[g], o[m] ^= h, i.push(m);
      e.range = t.slice();
    }
  });
  function G2(e) {
    N.call(this, null, e);
  }
  G2.Definition = {
    type: "ResolveFilter",
    metadata: {},
    params: [{
      name: "ignore",
      type: "number",
      required: !0,
      description: "A bit mask indicating which filters to ignore."
    }, {
      name: "filter",
      type: "object",
      required: !0,
      description: "Per-tuple filter bitmaps from a CrossFilter transform."
    }]
  };
  G(G2, N, {
    transform(e, t) {
      const n = ~(e.ignore || 0), i = e.filter, r = i.mask;
      if (!(r & n)) return t.StopPropagation;
      const o = t.fork(t.ALL), s = i.data(), a = i.curr(), u = i.prev(), l = (c) => a[c] & n ? null : s[c];
      return o.filter(o.MOD, l), r & r - 1 ? (o.filter(o.ADD, (c) => {
        const f = a[c] & n;
        return !f && f ^ u[c] & n ? s[c] : null;
      }), o.filter(o.REM, (c) => {
        const f = a[c] & n;
        return f && !(f ^ (f ^ u[c] & n)) ? s[c] : null;
      })) : (o.filter(o.ADD, l), o.filter(o.REM, (c) => (a[c] & n) === r ? s[c] : null)), o.filter(o.SOURCE, (c) => l(c._index));
    }
  });
  const sX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    crossfilter: H2,
    resolvefilter: G2
  }, Symbol.toStringTag, { value: "Module" })), aX = "RawCode", Qs = "Literal", uX = "Property", lX = "Identifier", cX = "ArrayExpression", fX = "BinaryExpression", xO = "CallExpression", dX = "ConditionalExpression", hX = "LogicalExpression", gX = "MemberExpression", pX = "ObjectExpression", mX = "UnaryExpression";
  function Ci(e) {
    this.type = e;
  }
  Ci.prototype.visit = function(e) {
    let t, n, i;
    if (e(this)) return 1;
    for (t = yX(this), n = 0, i = t.length; n < i; ++n)
      if (t[n].visit(e)) return 1;
  };
  function yX(e) {
    switch (e.type) {
      case cX:
        return e.elements;
      case fX:
      case hX:
        return [e.left, e.right];
      case xO:
        return [e.callee].concat(e.arguments);
      case dX:
        return [e.test, e.consequent, e.alternate];
      case gX:
        return [e.object, e.property];
      case pX:
        return e.properties;
      case uX:
        return [e.key, e.value];
      case mX:
        return [e.argument];
      case lX:
      case Qs:
      case aX:
      default:
        return [];
    }
  }
  var mr, Z, O, qt, Te, Bp = 1, Af = 2, Zs = 3, ts = 4, Up = 5, ya = 6, dn = 7, Cf = 8, bX = 9;
  mr = {};
  mr[Bp] = "Boolean";
  mr[Af] = "<end>";
  mr[Zs] = "Identifier";
  mr[ts] = "Keyword";
  mr[Up] = "Null";
  mr[ya] = "Numeric";
  mr[dn] = "Punctuator";
  mr[Cf] = "String";
  mr[bX] = "RegularExpression";
  var vX = "ArrayExpression", xX = "BinaryExpression", wX = "CallExpression", EX = "ConditionalExpression", wO = "Identifier", _X = "Literal", SX = "LogicalExpression", $X = "MemberExpression", kX = "ObjectExpression", AX = "Property", CX = "UnaryExpression", gt = "Unexpected token %0", FX = "Unexpected number", MX = "Unexpected string", TX = "Unexpected identifier", DX = "Unexpected reserved word", NX = "Unexpected end of input", Wy = "Invalid regular expression", q0 = "Invalid regular expression: missing /", EO = "Octal literals are not allowed in strict mode.", OX = "Duplicate data property in object literal not allowed in strict mode", At = "ILLEGAL", Uc = "Disabled.", RX = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"), LX = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
  function jp(e, t) {
    if (!e)
      throw new Error("ASSERT: " + t);
  }
  function Mr(e) {
    return e >= 48 && e <= 57;
  }
  function V2(e) {
    return "0123456789abcdefABCDEF".includes(e);
  }
  function vc(e) {
    return "01234567".includes(e);
  }
  function PX(e) {
    return e === 32 || e === 9 || e === 11 || e === 12 || e === 160 || e >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].includes(e);
  }
  function jc(e) {
    return e === 10 || e === 13 || e === 8232 || e === 8233;
  }
  function Ff(e) {
    return e === 36 || e === 95 || // $ (dollar) and _ (underscore)
    e >= 65 && e <= 90 || // A..Z
    e >= 97 && e <= 122 || // a..z
    e === 92 || // \ (backslash)
    e >= 128 && RX.test(String.fromCharCode(e));
  }
  function vg(e) {
    return e === 36 || e === 95 || // $ (dollar) and _ (underscore)
    e >= 65 && e <= 90 || // A..Z
    e >= 97 && e <= 122 || // a..z
    e >= 48 && e <= 57 || // 0..9
    e === 92 || // \ (backslash)
    e >= 128 && LX.test(String.fromCharCode(e));
  }
  const IX = {
    if: 1,
    in: 1,
    do: 1,
    var: 1,
    for: 1,
    new: 1,
    try: 1,
    let: 1,
    this: 1,
    else: 1,
    case: 1,
    void: 1,
    with: 1,
    enum: 1,
    while: 1,
    break: 1,
    catch: 1,
    throw: 1,
    const: 1,
    yield: 1,
    class: 1,
    super: 1,
    return: 1,
    typeof: 1,
    delete: 1,
    switch: 1,
    export: 1,
    import: 1,
    public: 1,
    static: 1,
    default: 1,
    finally: 1,
    extends: 1,
    package: 1,
    private: 1,
    function: 1,
    continue: 1,
    debugger: 1,
    interface: 1,
    protected: 1,
    instanceof: 1,
    implements: 1
  };
  function _O() {
    for (; O < qt; ) {
      const e = Z.charCodeAt(O);
      if (PX(e) || jc(e))
        ++O;
      else
        break;
    }
  }
  function Hy(e) {
    var t, n, i, r = 0;
    for (n = e === "u" ? 4 : 2, t = 0; t < n; ++t)
      O < qt && V2(Z[O]) ? (i = Z[O++], r = r * 16 + "0123456789abcdef".indexOf(i.toLowerCase())) : Se({}, gt, At);
    return String.fromCharCode(r);
  }
  function zX() {
    var e, t, n, i;
    for (e = Z[O], t = 0, e === "}" && Se({}, gt, At); O < qt && (e = Z[O++], !!V2(e)); )
      t = t * 16 + "0123456789abcdef".indexOf(e.toLowerCase());
    return (t > 1114111 || e !== "}") && Se({}, gt, At), t <= 65535 ? String.fromCharCode(t) : (n = (t - 65536 >> 10) + 55296, i = (t - 65536 & 1023) + 56320, String.fromCharCode(n, i));
  }
  function SO() {
    var e, t;
    for (e = Z.charCodeAt(O++), t = String.fromCharCode(e), e === 92 && (Z.charCodeAt(O) !== 117 && Se({}, gt, At), ++O, e = Hy("u"), (!e || e === "\\" || !Ff(e.charCodeAt(0))) && Se({}, gt, At), t = e); O < qt && (e = Z.charCodeAt(O), !!vg(e)); )
      ++O, t += String.fromCharCode(e), e === 92 && (t = t.substr(0, t.length - 1), Z.charCodeAt(O) !== 117 && Se({}, gt, At), ++O, e = Hy("u"), (!e || e === "\\" || !vg(e.charCodeAt(0))) && Se({}, gt, At), t += e);
    return t;
  }
  function BX() {
    var e, t;
    for (e = O++; O < qt; ) {
      if (t = Z.charCodeAt(O), t === 92)
        return O = e, SO();
      if (vg(t))
        ++O;
      else
        break;
    }
    return Z.slice(e, O);
  }
  function UX() {
    var e, t, n;
    return e = O, t = Z.charCodeAt(O) === 92 ? SO() : BX(), t.length === 1 ? n = Zs : IX.hasOwnProperty(t) ? n = ts : t === "null" ? n = Up : t === "true" || t === "false" ? n = Bp : n = Zs, {
      type: n,
      value: t,
      start: e,
      end: O
    };
  }
  function W0() {
    var e = O, t = Z.charCodeAt(O), n, i = Z[O], r, o, s;
    switch (t) {
      case 46:
      case 40:
      case 41:
      case 59:
      case 44:
      case 123:
      case 125:
      case 91:
      case 93:
      case 58:
      case 63:
      case 126:
        return ++O, {
          type: dn,
          value: String.fromCharCode(t),
          start: e,
          end: O
        };
      default:
        if (n = Z.charCodeAt(O + 1), n === 61)
          switch (t) {
            case 43:
            case 45:
            case 47:
            case 60:
            case 62:
            case 94:
            case 124:
            case 37:
            case 38:
            case 42:
              return O += 2, {
                type: dn,
                value: String.fromCharCode(t) + String.fromCharCode(n),
                start: e,
                end: O
              };
            case 33:
            case 61:
              return O += 2, Z.charCodeAt(O) === 61 && ++O, {
                type: dn,
                value: Z.slice(e, O),
                start: e,
                end: O
              };
          }
    }
    if (s = Z.substr(O, 4), s === ">>>=")
      return O += 4, {
        type: dn,
        value: s,
        start: e,
        end: O
      };
    if (o = s.substr(0, 3), o === ">>>" || o === "<<=" || o === ">>=")
      return O += 3, {
        type: dn,
        value: o,
        start: e,
        end: O
      };
    if (r = o.substr(0, 2), i === r[1] && "+-<>&|".includes(i) || r === "=>")
      return O += 2, {
        type: dn,
        value: r,
        start: e,
        end: O
      };
    if (r === "//" && Se({}, gt, At), "<>=!+-*%&|^/".includes(i))
      return ++O, {
        type: dn,
        value: i,
        start: e,
        end: O
      };
    Se({}, gt, At);
  }
  function jX(e) {
    let t = "";
    for (; O < qt && V2(Z[O]); )
      t += Z[O++];
    return t.length === 0 && Se({}, gt, At), Ff(Z.charCodeAt(O)) && Se({}, gt, At), {
      type: ya,
      value: parseInt("0x" + t, 16),
      start: e,
      end: O
    };
  }
  function qX(e) {
    let t = "0" + Z[O++];
    for (; O < qt && vc(Z[O]); )
      t += Z[O++];
    return (Ff(Z.charCodeAt(O)) || Mr(Z.charCodeAt(O))) && Se({}, gt, At), {
      type: ya,
      value: parseInt(t, 8),
      octal: !0,
      start: e,
      end: O
    };
  }
  function X$() {
    var e, t, n;
    if (n = Z[O], jp(Mr(n.charCodeAt(0)) || n === ".", "Numeric literal must start with a decimal digit or a decimal point"), t = O, e = "", n !== ".") {
      if (e = Z[O++], n = Z[O], e === "0") {
        if (n === "x" || n === "X")
          return ++O, jX(t);
        if (vc(n))
          return qX(t);
        n && Mr(n.charCodeAt(0)) && Se({}, gt, At);
      }
      for (; Mr(Z.charCodeAt(O)); )
        e += Z[O++];
      n = Z[O];
    }
    if (n === ".") {
      for (e += Z[O++]; Mr(Z.charCodeAt(O)); )
        e += Z[O++];
      n = Z[O];
    }
    if (n === "e" || n === "E")
      if (e += Z[O++], n = Z[O], (n === "+" || n === "-") && (e += Z[O++]), Mr(Z.charCodeAt(O)))
        for (; Mr(Z.charCodeAt(O)); )
          e += Z[O++];
      else
        Se({}, gt, At);
    return Ff(Z.charCodeAt(O)) && Se({}, gt, At), {
      type: ya,
      value: parseFloat(e),
      start: t,
      end: O
    };
  }
  function WX() {
    var e = "", t, n, i, r, o = !1;
    for (t = Z[O], jp(t === "'" || t === '"', "String literal must starts with a quote"), n = O, ++O; O < qt; )
      if (i = Z[O++], i === t) {
        t = "";
        break;
      } else if (i === "\\")
        if (i = Z[O++], !i || !jc(i.charCodeAt(0)))
          switch (i) {
            case "u":
            case "x":
              Z[O] === "{" ? (++O, e += zX()) : e += Hy(i);
              break;
            case "n":
              e += `
`;
              break;
            case "r":
              e += "\r";
              break;
            case "t":
              e += "	";
              break;
            case "b":
              e += "\b";
              break;
            case "f":
              e += "\f";
              break;
            case "v":
              e += "\v";
              break;
            default:
              vc(i) ? (r = "01234567".indexOf(i), r !== 0 && (o = !0), O < qt && vc(Z[O]) && (o = !0, r = r * 8 + "01234567".indexOf(Z[O++]), "0123".includes(i) && O < qt && vc(Z[O]) && (r = r * 8 + "01234567".indexOf(Z[O++]))), e += String.fromCharCode(r)) : e += i;
              break;
          }
        else
          i === "\r" && Z[O] === `
` && ++O;
      else {
        if (jc(i.charCodeAt(0)))
          break;
        e += i;
      }
    return t !== "" && Se({}, gt, At), {
      type: Cf,
      value: e,
      octal: o,
      start: n,
      end: O
    };
  }
  function HX(e, t) {
    let n = e;
    t.includes("u") && (n = n.replace(/\\u\{([0-9a-fA-F]+)\}/g, (i, r) => {
      if (parseInt(r, 16) <= 1114111)
        return "x";
      Se({}, Wy);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x"));
    try {
      new RegExp(n);
    } catch {
      Se({}, Wy);
    }
    try {
      return new RegExp(e, t);
    } catch {
      return null;
    }
  }
  function GX() {
    var e, t, n, i, r;
    for (e = Z[O], jp(e === "/", "Regular expression literal must start with a slash"), t = Z[O++], n = !1, i = !1; O < qt; )
      if (e = Z[O++], t += e, e === "\\")
        e = Z[O++], jc(e.charCodeAt(0)) && Se({}, q0), t += e;
      else if (jc(e.charCodeAt(0)))
        Se({}, q0);
      else if (n)
        e === "]" && (n = !1);
      else if (e === "/") {
        i = !0;
        break;
      } else e === "[" && (n = !0);
    return i || Se({}, q0), r = t.substr(1, t.length - 2), {
      value: r,
      literal: t
    };
  }
  function VX() {
    var e, t, n;
    for (t = "", n = ""; O < qt && (e = Z[O], !!vg(e.charCodeAt(0))); )
      ++O, e === "\\" && O < qt ? Se({}, gt, At) : (n += e, t += e);
    return n.search(/[^gimuy]/g) >= 0 && Se({}, Wy, n), {
      value: n,
      literal: t
    };
  }
  function YX() {
    var e, t, n, i;
    return Te = null, _O(), e = O, t = GX(), n = VX(), i = HX(t.value, n.value), {
      literal: t.literal + n.literal,
      value: i,
      regex: {
        pattern: t.value,
        flags: n.value
      },
      start: e,
      end: O
    };
  }
  function XX(e) {
    return e.type === Zs || e.type === ts || e.type === Bp || e.type === Up;
  }
  function $O() {
    if (_O(), O >= qt)
      return {
        type: Af,
        start: O,
        end: O
      };
    const e = Z.charCodeAt(O);
    return Ff(e) ? UX() : e === 40 || e === 41 || e === 59 ? W0() : e === 39 || e === 34 ? WX() : e === 46 ? Mr(Z.charCodeAt(O + 1)) ? X$() : W0() : Mr(e) ? X$() : W0();
  }
  function gn() {
    const e = Te;
    return O = e.end, Te = $O(), O = e.end, e;
  }
  function kO() {
    const e = O;
    Te = $O(), O = e;
  }
  function KX(e) {
    const t = new Ci(vX);
    return t.elements = e, t;
  }
  function K$(e, t, n) {
    const i = new Ci(e === "||" || e === "&&" ? SX : xX);
    return i.operator = e, i.left = t, i.right = n, i;
  }
  function JX(e, t) {
    const n = new Ci(wX);
    return n.callee = e, n.arguments = t, n;
  }
  function QX(e, t, n) {
    const i = new Ci(EX);
    return i.test = e, i.consequent = t, i.alternate = n, i;
  }
  function Y2(e) {
    const t = new Ci(wO);
    return t.name = e, t;
  }
  function sc(e) {
    const t = new Ci(_X);
    return t.value = e.value, t.raw = Z.slice(e.start, e.end), e.regex && (t.raw === "//" && (t.raw = "/(?:)/"), t.regex = e.regex), t;
  }
  function J$(e, t, n) {
    const i = new Ci($X);
    return i.computed = e === "[", i.object = t, i.property = n, i.computed || (n.member = !0), i;
  }
  function ZX(e) {
    const t = new Ci(kX);
    return t.properties = e, t;
  }
  function Q$(e, t, n) {
    const i = new Ci(AX);
    return i.key = t, i.value = n, i.kind = e, i;
  }
  function eK(e, t) {
    const n = new Ci(CX);
    return n.operator = e, n.argument = t, n.prefix = !0, n;
  }
  function Se(e, t) {
    var n, i = Array.prototype.slice.call(arguments, 2), r = t.replace(/%(\d)/g, (o, s) => (jp(s < i.length, "Message reference must be in range"), i[s]));
    throw n = new Error(r), n.index = O, n.description = r, n;
  }
  function qp(e) {
    e.type === Af && Se(e, NX), e.type === ya && Se(e, FX), e.type === Cf && Se(e, MX), e.type === Zs && Se(e, TX), e.type === ts && Se(e, DX), Se(e, gt, e.value);
  }
  function Wt(e) {
    const t = gn();
    (t.type !== dn || t.value !== e) && qp(t);
  }
  function Be(e) {
    return Te.type === dn && Te.value === e;
  }
  function H0(e) {
    return Te.type === ts && Te.value === e;
  }
  function tK() {
    const e = [];
    for (O = Te.start, Wt("["); !Be("]"); )
      Be(",") ? (gn(), e.push(null)) : (e.push(ea()), Be("]") || Wt(","));
    return gn(), KX(e);
  }
  function Z$() {
    O = Te.start;
    const e = gn();
    return e.type === Cf || e.type === ya ? (e.octal && Se(e, EO), sc(e)) : Y2(e.value);
  }
  function nK() {
    var e, t, n, i;
    if (O = Te.start, e = Te, e.type === Zs)
      return n = Z$(), Wt(":"), i = ea(), Q$("init", n, i);
    if (e.type === Af || e.type === dn)
      qp(e);
    else
      return t = Z$(), Wt(":"), i = ea(), Q$("init", t, i);
  }
  function iK() {
    var e = [], t, n, i, r = {}, o = String;
    for (O = Te.start, Wt("{"); !Be("}"); )
      t = nK(), t.key.type === wO ? n = t.key.name : n = o(t.key.value), i = "$" + n, Object.prototype.hasOwnProperty.call(r, i) ? Se({}, OX) : r[i] = !0, e.push(t), Be("}") || Wt(",");
    return Wt("}"), ZX(e);
  }
  function rK() {
    Wt("(");
    const e = X2();
    return Wt(")"), e;
  }
  const oK = {
    if: 1
  };
  function sK() {
    var e, t, n;
    if (Be("("))
      return rK();
    if (Be("["))
      return tK();
    if (Be("{"))
      return iK();
    if (e = Te.type, O = Te.start, e === Zs || oK[Te.value])
      n = Y2(gn().value);
    else if (e === Cf || e === ya)
      Te.octal && Se(Te, EO), n = sc(gn());
    else {
      if (e === ts)
        throw new Error(Uc);
      e === Bp ? (t = gn(), t.value = t.value === "true", n = sc(t)) : e === Up ? (t = gn(), t.value = null, n = sc(t)) : Be("/") || Be("/=") ? (n = sc(YX()), kO()) : qp(gn());
    }
    return n;
  }
  function aK() {
    const e = [];
    if (Wt("("), !Be(")"))
      for (; O < qt && (e.push(ea()), !Be(")")); )
        Wt(",");
    return Wt(")"), e;
  }
  function uK() {
    O = Te.start;
    const e = gn();
    return XX(e) || qp(e), Y2(e.value);
  }
  function lK() {
    return Wt("."), uK();
  }
  function cK() {
    Wt("[");
    const e = X2();
    return Wt("]"), e;
  }
  function fK() {
    var e, t, n;
    for (e = sK(); ; )
      if (Be("."))
        n = lK(), e = J$(".", e, n);
      else if (Be("("))
        t = aK(), e = JX(e, t);
      else if (Be("["))
        n = cK(), e = J$("[", e, n);
      else
        break;
    return e;
  }
  function ek() {
    const e = fK();
    if (Te.type === dn && (Be("++") || Be("--")))
      throw new Error(Uc);
    return e;
  }
  function th() {
    var e, t;
    if (Te.type !== dn && Te.type !== ts)
      t = ek();
    else {
      if (Be("++") || Be("--"))
        throw new Error(Uc);
      if (Be("+") || Be("-") || Be("~") || Be("!"))
        e = gn(), t = th(), t = eK(e.value, t);
      else {
        if (H0("delete") || H0("void") || H0("typeof"))
          throw new Error(Uc);
        t = ek();
      }
    }
    return t;
  }
  function tk(e) {
    let t = 0;
    if (e.type !== dn && e.type !== ts)
      return 0;
    switch (e.value) {
      case "||":
        t = 1;
        break;
      case "&&":
        t = 2;
        break;
      case "|":
        t = 3;
        break;
      case "^":
        t = 4;
        break;
      case "&":
        t = 5;
        break;
      case "==":
      case "!=":
      case "===":
      case "!==":
        t = 6;
        break;
      case "<":
      case ">":
      case "<=":
      case ">=":
      case "instanceof":
      case "in":
        t = 7;
        break;
      case "<<":
      case ">>":
      case ">>>":
        t = 8;
        break;
      case "+":
      case "-":
        t = 9;
        break;
      case "*":
      case "/":
      case "%":
        t = 11;
        break;
    }
    return t;
  }
  function dK() {
    var e, t, n, i, r, o, s, a, u, l;
    if (e = Te, u = th(), i = Te, r = tk(i), r === 0)
      return u;
    for (i.prec = r, gn(), t = [e, Te], s = th(), o = [u, i, s]; (r = tk(Te)) > 0; ) {
      for (; o.length > 2 && r <= o[o.length - 2].prec; )
        s = o.pop(), a = o.pop().value, u = o.pop(), t.pop(), n = K$(a, u, s), o.push(n);
      i = gn(), i.prec = r, o.push(i), t.push(Te), n = th(), o.push(n);
    }
    for (l = o.length - 1, n = o[l], t.pop(); l > 1; )
      t.pop(), n = K$(o[l - 1].value, o[l - 2], n), l -= 2;
    return n;
  }
  function ea() {
    var e, t, n;
    return e = dK(), Be("?") && (gn(), t = ea(), Wt(":"), n = ea(), e = QX(e, t, n)), e;
  }
  function X2() {
    const e = ea();
    if (Be(","))
      throw new Error(Uc);
    return e;
  }
  function K2(e) {
    Z = e, O = 0, qt = Z.length, Te = null, kO();
    const t = X2();
    if (Te.type !== Af)
      throw new Error("Unexpect token after expression.");
    return t;
  }
  var AO = {
    NaN: "NaN",
    E: "Math.E",
    LN2: "Math.LN2",
    LN10: "Math.LN10",
    LOG2E: "Math.LOG2E",
    LOG10E: "Math.LOG10E",
    PI: "Math.PI",
    SQRT1_2: "Math.SQRT1_2",
    SQRT2: "Math.SQRT2",
    MIN_VALUE: "Number.MIN_VALUE",
    MAX_VALUE: "Number.MAX_VALUE"
  };
  function CO(e) {
    function t(s, a, u, l) {
      let c = e(a[0]);
      return u && (c = u + "(" + c + ")", u.lastIndexOf("new ", 0) === 0 && (c = "(" + c + ")")), c + "." + s + (l < 0 ? "" : l === 0 ? "()" : "(" + a.slice(1).map(e).join(",") + ")");
    }
    function n(s, a, u) {
      return (l) => t(s, l, a, u);
    }
    const i = "new Date", r = "String", o = "RegExp";
    return {
      // MATH functions
      isNaN: "Number.isNaN",
      isFinite: "Number.isFinite",
      abs: "Math.abs",
      acos: "Math.acos",
      asin: "Math.asin",
      atan: "Math.atan",
      atan2: "Math.atan2",
      ceil: "Math.ceil",
      cos: "Math.cos",
      exp: "Math.exp",
      floor: "Math.floor",
      hypot: "Math.hypot",
      log: "Math.log",
      max: "Math.max",
      min: "Math.min",
      pow: "Math.pow",
      random: "Math.random",
      round: "Math.round",
      sin: "Math.sin",
      sqrt: "Math.sqrt",
      tan: "Math.tan",
      clamp: function(s) {
        s.length < 3 && R("Missing arguments to clamp function."), s.length > 3 && R("Too many arguments to clamp function.");
        const a = s.map(e);
        return "Math.max(" + a[1] + ", Math.min(" + a[2] + "," + a[0] + "))";
      },
      // DATE functions
      now: "Date.now",
      utc: "Date.UTC",
      datetime: i,
      date: n("getDate", i, 0),
      day: n("getDay", i, 0),
      year: n("getFullYear", i, 0),
      month: n("getMonth", i, 0),
      hours: n("getHours", i, 0),
      minutes: n("getMinutes", i, 0),
      seconds: n("getSeconds", i, 0),
      milliseconds: n("getMilliseconds", i, 0),
      time: n("getTime", i, 0),
      timezoneoffset: n("getTimezoneOffset", i, 0),
      utcdate: n("getUTCDate", i, 0),
      utcday: n("getUTCDay", i, 0),
      utcyear: n("getUTCFullYear", i, 0),
      utcmonth: n("getUTCMonth", i, 0),
      utchours: n("getUTCHours", i, 0),
      utcminutes: n("getUTCMinutes", i, 0),
      utcseconds: n("getUTCSeconds", i, 0),
      utcmilliseconds: n("getUTCMilliseconds", i, 0),
      // sequence functions
      length: n("length", null, -1),
      // STRING functions
      parseFloat: "parseFloat",
      parseInt: "parseInt",
      upper: n("toUpperCase", r, 0),
      lower: n("toLowerCase", r, 0),
      substring: n("substring", r),
      split: n("split", r),
      trim: n("trim", r, 0),
      // REGEXP functions
      regexp: o,
      test: n("test", o),
      // Control Flow functions
      if: function(s) {
        s.length < 3 && R("Missing arguments to if function."), s.length > 3 && R("Too many arguments to if function.");
        const a = s.map(e);
        return "(" + a[0] + "?" + a[1] + ":" + a[2] + ")";
      }
    };
  }
  function hK(e) {
    const t = e && e.length - 1;
    return t && (e[0] === '"' && e[t] === '"' || e[0] === "'" && e[t] === "'") ? e.slice(1, -1) : e;
  }
  function FO(e) {
    e = e || {};
    const t = e.allowed ? wi(e.allowed) : {}, n = e.forbidden ? wi(e.forbidden) : {}, i = e.constants || AO, r = (e.functions || CO)(f), o = e.globalvar, s = e.fieldvar, a = fe(o) ? o : (g) => `${o}["${g}"]`;
    let u = {}, l = {}, c = 0;
    function f(g) {
      if (K(g)) return g;
      const p = d[g.type];
      return p == null && R("Unsupported type: " + g.type), p(g);
    }
    const d = {
      Literal: (g) => g.raw,
      Identifier: (g) => {
        const p = g.name;
        return c > 0 ? p : J(n, p) ? R("Illegal identifier: " + p) : J(i, p) ? i[p] : J(t, p) ? p : (u[p] = 1, a(p));
      },
      MemberExpression: (g) => {
        const p = !g.computed, m = f(g.object);
        p && (c += 1);
        const y = f(g.property);
        return m === s && (l[hK(y)] = 1), p && (c -= 1), m + (p ? "." + y : "[" + y + "]");
      },
      CallExpression: (g) => {
        g.callee.type !== "Identifier" && R("Illegal callee type: " + g.callee.type);
        const p = g.callee.name, m = g.arguments, y = J(r, p) && r[p];
        return y || R("Unrecognized function: " + p), fe(y) ? y(m) : y + "(" + m.map(f).join(",") + ")";
      },
      ArrayExpression: (g) => "[" + g.elements.map(f).join(",") + "]",
      BinaryExpression: (g) => "(" + f(g.left) + " " + g.operator + " " + f(g.right) + ")",
      UnaryExpression: (g) => "(" + g.operator + f(g.argument) + ")",
      ConditionalExpression: (g) => "(" + f(g.test) + "?" + f(g.consequent) + ":" + f(g.alternate) + ")",
      LogicalExpression: (g) => "(" + f(g.left) + g.operator + f(g.right) + ")",
      ObjectExpression: (g) => "{" + g.properties.map(f).join(",") + "}",
      Property: (g) => {
        c += 1;
        const p = f(g.key);
        return c -= 1, p + ":" + f(g.value);
      }
    };
    function h(g) {
      const p = {
        code: f(g),
        globals: Object.keys(u),
        fields: Object.keys(l)
      };
      return u = {}, l = {}, p;
    }
    return h.functions = r, h.constants = i, h;
  }
  const nk = Symbol("vega_selection_getter");
  function MO(e) {
    return (!e.getter || !e.getter[nk]) && (e.getter = Kn(e.field), e.getter[nk] = !0), e.getter;
  }
  const J2 = "intersect", ik = "union", gK = "vlMulti", pK = "vlPoint", rk = "or", mK = "and", Hi = "_vgsid_", qc = Kn(Hi), yK = "E", bK = "R", vK = "R-E", xK = "R-LE", wK = "R-RE", xg = "index:unit";
  function ok(e, t) {
    for (var n = t.fields, i = t.values, r = n.length, o = 0, s, a; o < r; ++o)
      if (a = n[o], s = MO(a)(e), Co(s) && (s = zt(s)), Co(i[o]) && (i[o] = zt(i[o])), P(i[o]) && Co(i[o][0]) && (i[o] = i[o].map(zt)), a.type === yK) {
        if (P(i[o]) ? i[o].indexOf(s) < 0 : s !== i[o])
          return !1;
      } else if (a.type === bK) {
        if (!Ha(s, i[o])) return !1;
      } else if (a.type === wK) {
        if (!Ha(s, i[o], !0, !1)) return !1;
      } else if (a.type === vK) {
        if (!Ha(s, i[o], !1, !1)) return !1;
      } else if (a.type === xK && !Ha(s, i[o], !1, !0))
        return !1;
    return !0;
  }
  function EK(e, t, n) {
    for (var i = this.context.data[e], r = i ? i.values.value : [], o = i ? i[xg] && i[xg].value : void 0, s = n === J2, a = r.length, u = 0, l, c, f, d, h; u < a; ++u)
      if (l = r[u], o && s) {
        if (c = c || {}, f = c[d = l.unit] || 0, f === -1) continue;
        if (h = ok(t, l), c[d] = h ? -1 : ++f, h && o.size === 1) return !0;
        if (!h && f === o.get(d).count) return !1;
      } else if (h = ok(t, l), s ^ h) return h;
    return a && s;
  }
  const TO = Vu(qc), _K = TO.left, SK = TO.right;
  function $K(e, t, n) {
    const i = this.context.data[e], r = i ? i.values.value : [], o = i ? i[xg] && i[xg].value : void 0, s = n === J2, a = qc(t), u = _K(r, a);
    if (u === r.length || qc(r[u]) !== a) return !1;
    if (o && s) {
      if (o.size === 1) return !0;
      if (SK(r, a) - u < o.size) return !1;
    }
    return !0;
  }
  function kK(e, t) {
    return e.map((n) => ce(t.fields ? {
      values: t.fields.map((i) => MO(i)(n.datum))
    } : {
      [Hi]: qc(n.datum)
    }, t));
  }
  function AK(e, t, n, i) {
    for (var r = this.context.data[e], o = r ? r.values.value : [], s = {}, a = {}, u = {}, l, c, f, d, h, g, p, m, y, b, v = o.length, x = 0, w, _; x < v; ++x)
      if (l = o[x], d = l.unit, c = l.fields, f = l.values, c && f) {
        for (w = 0, _ = c.length; w < _; ++w)
          h = c[w], p = s[h.field] || (s[h.field] = {}), m = p[d] || (p[d] = []), u[h.field] = y = h.type.charAt(0), b = G0[`${y}_union`], p[d] = b(m, X(f[w]));
        n && (m = a[d] || (a[d] = []), m.push(X(f).reduce((E, S, $) => (E[c[$].field] = S, E), {})));
      } else
        h = Hi, g = qc(l), p = s[h] || (s[h] = {}), m = p[d] || (p[d] = []), m.push(g), n && (m = a[d] || (a[d] = []), m.push({
          [Hi]: g
        }));
    if (t = t || ik, s[Hi] ? s[Hi] = G0[`${Hi}_${t}`](...Object.values(s[Hi])) : Object.keys(s).forEach((E) => {
      s[E] = Object.keys(s[E]).map((S) => s[E][S]).reduce((S, $) => S === void 0 ? $ : G0[`${u[E]}_${t}`](S, $));
    }), o = Object.keys(a), n && o.length) {
      const E = i ? pK : gK;
      s[E] = t === ik ? {
        [rk]: o.reduce((S, $) => (S.push(...a[$]), S), [])
      } : {
        [mK]: o.map((S) => ({
          [rk]: a[S]
        }))
      };
    }
    return s;
  }
  var G0 = {
    [`${Hi}_union`]: wP,
    [`${Hi}_intersect`]: vP,
    E_union: function(e, t) {
      if (!e.length) return t;
      for (var n = 0, i = t.length; n < i; ++n) e.indexOf(t[n]) < 0 && e.push(t[n]);
      return e;
    },
    E_intersect: function(e, t) {
      return e.length ? e.filter((n) => t.indexOf(n) >= 0) : t;
    },
    R_union: function(e, t) {
      var n = zt(t[0]), i = zt(t[1]);
      return n > i && (n = t[1], i = t[0]), e.length ? (e[0] > n && (e[0] = n), e[1] < i && (e[1] = i), e) : [n, i];
    },
    R_intersect: function(e, t) {
      var n = zt(t[0]), i = zt(t[1]);
      return n > i && (n = t[1], i = t[0]), e.length ? i < e[0] || e[1] < n ? [] : (e[0] < n && (e[0] = n), e[1] > i && (e[1] = i), e) : [n, i];
    }
  };
  const CK = ":", FK = "@";
  function Q2(e, t, n, i) {
    t[0].type !== Qs && R("First argument to selection functions must be a string literal.");
    const r = t[0].value, o = t.length >= 2 && xe(t).value, s = "unit", a = FK + s, u = CK + r;
    o === J2 && !J(i, a) && (i[a] = n.getData(r).indataRef(n, s)), J(i, u) || (i[u] = n.getData(r).tuplesRef());
  }
  function DO(e) {
    const t = this.context.data[e];
    return t ? t.values.value : [];
  }
  function MK(e, t, n) {
    const i = this.context.data[e]["index:" + t], r = i ? i.value.get(n) : void 0;
    return r && r.count;
  }
  function TK(e, t) {
    const n = this.context.dataflow, i = this.context.data[e], r = i.input;
    return n.pulse(r, n.changeset().remove(Jn).insert(t)), 1;
  }
  function DK(e, t, n) {
    if (e) {
      const i = this.context.dataflow, r = e.mark.source;
      i.pulse(r, i.changeset().encode(e, t));
    }
    return n !== void 0 ? n : e;
  }
  const Mf = (e) => function(t, n) {
    const i = this.context.dataflow.locale();
    return t === null ? "null" : i[e](n)(t);
  }, NK = Mf("format"), NO = Mf("timeFormat"), OK = Mf("utcFormat"), RK = Mf("timeParse"), LK = Mf("utcParse"), xd = new Date(2e3, 0, 1);
  function Wp(e, t, n) {
    return !Number.isInteger(e) || !Number.isInteger(t) ? "" : (xd.setYear(2e3), xd.setMonth(e), xd.setDate(t), NO.call(this, xd, n));
  }
  function PK(e) {
    return Wp.call(this, e, 1, "%B");
  }
  function IK(e) {
    return Wp.call(this, e, 1, "%b");
  }
  function zK(e) {
    return Wp.call(this, 0, 2 + e, "%A");
  }
  function BK(e) {
    return Wp.call(this, 0, 2 + e, "%a");
  }
  const UK = ":", jK = "@", Gy = "%", OO = "$";
  function Z2(e, t, n, i) {
    t[0].type !== Qs && R("First argument to data functions must be a string literal.");
    const r = t[0].value, o = UK + r;
    if (!J(o, i))
      try {
        i[o] = n.getData(r).tuplesRef();
      } catch {
      }
  }
  function qK(e, t, n, i) {
    t[0].type !== Qs && R("First argument to indata must be a string literal."), t[1].type !== Qs && R("Second argument to indata must be a string literal.");
    const r = t[0].value, o = t[1].value, s = jK + o;
    J(s, i) || (i[s] = n.getData(r).indataRef(n, o));
  }
  function on(e, t, n, i) {
    if (t[0].type === Qs)
      sk(n, i, t[0].value);
    else
      for (e in n.scales)
        sk(n, i, e);
  }
  function sk(e, t, n) {
    const i = Gy + n;
    if (!J(t, i))
      try {
        t[i] = e.scaleRef(n);
      } catch {
      }
  }
  function yr(e, t) {
    if (fe(e))
      return e;
    if (K(e)) {
      const n = t.scales[e];
      return n && eB(n.value) ? n.value : void 0;
    }
  }
  function WK(e, t, n) {
    t.__bandwidth = (r) => r && r.bandwidth ? r.bandwidth() : 0, n._bandwidth = on, n._range = on, n._scale = on;
    const i = (r) => "_[" + (r.type === Qs ? H(Gy + r.value) : H(Gy) + "+" + e(r)) + "]";
    return {
      _bandwidth: (r) => `this.__bandwidth(${i(r[0])})`,
      _range: (r) => `${i(r[0])}.range()`,
      _scale: (r) => `${i(r[0])}(${e(r[1])})`
    };
  }
  function ew(e, t) {
    return function(n, i, r) {
      if (n) {
        const o = yr(n, (r || this).context);
        return o && o.path[e](i);
      } else
        return t(i);
    };
  }
  const HK = ew("area", pW), GK = ew("bounds", vW), VK = ew("centroid", $W);
  function YK(e, t) {
    const n = yr(e, (t || this).context);
    return n && n.scale();
  }
  function XK(e) {
    const t = this.context.group;
    let n = !1;
    if (t) for (; e; ) {
      if (e === t) {
        n = !0;
        break;
      }
      e = e.mark.group;
    }
    return n;
  }
  function tw(e, t, n) {
    try {
      e[t].apply(e, ["EXPRESSION"].concat([].slice.call(n)));
    } catch (i) {
      e.warn(i);
    }
    return n[n.length - 1];
  }
  function KK() {
    return tw(this.context.dataflow, "warn", arguments);
  }
  function JK() {
    return tw(this.context.dataflow, "info", arguments);
  }
  function QK() {
    return tw(this.context.dataflow, "debug", arguments);
  }
  function V0(e) {
    const t = e / 255;
    return t <= 0.03928 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
  }
  function Vy(e) {
    const t = Io(e), n = V0(t.r), i = V0(t.g), r = V0(t.b);
    return 0.2126 * n + 0.7152 * i + 0.0722 * r;
  }
  function ZK(e, t) {
    const n = Vy(e), i = Vy(t), r = Math.max(n, i), o = Math.min(n, i);
    return (r + 0.05) / (o + 0.05);
  }
  function eJ() {
    const e = [].slice.call(arguments);
    return e.unshift({}), ce(...e);
  }
  function RO(e, t) {
    return e === t || e !== e && t !== t ? !0 : P(e) ? P(t) && e.length === t.length ? tJ(e, t) : !1 : Y(e) && Y(t) ? LO(e, t) : !1;
  }
  function tJ(e, t) {
    for (let n = 0, i = e.length; n < i; ++n)
      if (!RO(e[n], t[n])) return !1;
    return !0;
  }
  function LO(e, t) {
    for (const n in e)
      if (!RO(e[n], t[n])) return !1;
    return !0;
  }
  function ak(e) {
    return (t) => LO(e, t);
  }
  function nJ(e, t, n, i, r, o) {
    const s = this.context.dataflow, a = this.context.data[e], u = a.input, l = s.stamp();
    let c = a.changes, f, d;
    if (s._trigger === !1 || !(u.value.length || t || i))
      return 0;
    if ((!c || c.stamp < l) && (a.changes = c = s.changeset(), c.stamp = l, s.runAfter(() => {
      a.modified = !0, s.pulse(u, c).run();
    }, !0, 1)), n && (f = n === !0 ? Jn : P(n) || Zg(n) ? n : ak(n), c.remove(f)), t && c.insert(t), i && (f = ak(i), u.value.some(f) ? c.remove(f) : c.insert(i)), r)
      for (d in o)
        c.modify(r, d, o[d]);
    return 1;
  }
  function iJ(e) {
    const t = e.touches, n = t[0].clientX - t[1].clientX, i = t[0].clientY - t[1].clientY;
    return Math.hypot(n, i);
  }
  function rJ(e) {
    const t = e.touches;
    return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
  }
  const uk = {};
  function oJ(e, t) {
    const n = uk[t] || (uk[t] = Kn(t));
    return P(e) ? e.map(n) : n(e);
  }
  function nw(e) {
    return P(e) || ArrayBuffer.isView(e) ? e : null;
  }
  function iw(e) {
    return nw(e) || (K(e) ? e : null);
  }
  function sJ(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      n[i - 1] = arguments[i];
    return nw(e).join(...n);
  }
  function aJ(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      n[i - 1] = arguments[i];
    return iw(e).indexOf(...n);
  }
  function uJ(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      n[i - 1] = arguments[i];
    return iw(e).lastIndexOf(...n);
  }
  function lJ(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      n[i - 1] = arguments[i];
    return iw(e).slice(...n);
  }
  function cJ(e, t, n) {
    return fe(n) && R("Function argument passed to replace."), String(e).replace(t, n);
  }
  function fJ(e) {
    return nw(e).slice().reverse();
  }
  function dJ(e, t, n) {
    return px(e || 0, t || 0, n || 0);
  }
  function hJ(e, t) {
    const n = yr(e, (t || this).context);
    return n && n.bandwidth ? n.bandwidth() : 0;
  }
  function gJ(e, t) {
    const n = yr(e, (t || this).context);
    return n ? n.copy() : void 0;
  }
  function pJ(e, t) {
    const n = yr(e, (t || this).context);
    return n ? n.domain() : [];
  }
  function mJ(e, t, n) {
    const i = yr(e, (n || this).context);
    return i ? P(t) ? (i.invertRange || i.invert)(t) : (i.invert || i.invertExtent)(t) : void 0;
  }
  function yJ(e, t) {
    const n = yr(e, (t || this).context);
    return n && n.range ? n.range() : [];
  }
  function bJ(e, t, n) {
    const i = yr(e, (n || this).context);
    return i ? i(t) : void 0;
  }
  function vJ(e, t, n, i, r) {
    e = yr(e, (r || this).context);
    const o = k3(t, n);
    let s = e.domain(), a = s[0], u = xe(s), l = Ht;
    return u - a ? l = g3(e, a, u) : e = (e.interpolator ? Ae("sequential")().interpolator(e.interpolator()) : Ae("linear")().interpolate(e.interpolate()).range(e.range())).domain([a = 0, u = 1]), e.ticks && (s = e.ticks(+i || 15), a !== s[0] && s.unshift(a), u !== xe(s) && s.push(u)), s.forEach((c) => o.stop(l(c), e(c))), o;
  }
  function xJ(e, t, n) {
    const i = yr(e, (n || this).context);
    return function(r) {
      return i ? i.path.context(r)(t) : "";
    };
  }
  function wJ(e) {
    let t = null;
    return function(n) {
      return n ? Nc(n, t = t || bu(e)) : e;
    };
  }
  const PO = (e) => e.data;
  function IO(e, t) {
    const n = DO.call(t, e);
    return n.root && n.root.lookup || {};
  }
  function EJ(e, t, n) {
    const i = IO(e, this), r = i[t], o = i[n];
    return r && o ? r.path(o).map(PO) : void 0;
  }
  function _J(e, t) {
    const n = IO(e, this)[t];
    return n ? n.ancestors().map(PO) : void 0;
  }
  const zO = () => typeof window < "u" && window || null;
  function SJ() {
    const e = zO();
    return e ? e.screen : {};
  }
  function $J() {
    const e = zO();
    return e ? [e.innerWidth, e.innerHeight] : [void 0, void 0];
  }
  function kJ() {
    const e = this.context.dataflow, t = e.container && e.container();
    return t ? [t.clientWidth, t.clientHeight] : [void 0, void 0];
  }
  function BO(e, t, n) {
    if (!e) return [];
    const [i, r] = e, o = new nt().set(i[0], i[1], r[0], r[1]), s = n || this.context.dataflow.scenegraph().root;
    return _D(s, o, AJ(t));
  }
  function AJ(e) {
    let t = null;
    if (e) {
      const n = X(e.marktype), i = X(e.markname);
      t = (r) => (!n.length || n.some((o) => r.marktype === o)) && (!i.length || i.some((o) => r.name === o));
    }
    return t;
  }
  function CJ(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5;
    e = X(e);
    const r = e[e.length - 1];
    return r === void 0 || Math.hypot(r[0] - t, r[1] - n) > i ? [...e, [t, n]] : e;
  }
  function FJ(e) {
    return X(e).reduce((t, n, i) => {
      let [r, o] = n;
      return t += i == 0 ? `M ${r},${o} ` : i === e.length - 1 ? " Z" : `L ${r},${o} `;
    }, "");
  }
  function MJ(e, t, n) {
    const {
      x: i,
      y: r,
      mark: o
    } = n, s = new nt().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
    for (const [u, l] of t)
      u < s.x1 && (s.x1 = u), u > s.x2 && (s.x2 = u), l < s.y1 && (s.y1 = l), l > s.y2 && (s.y2 = l);
    return s.translate(i, r), BO([[s.x1, s.y1], [s.x2, s.y2]], e, o).filter((u) => TJ(u.x, u.y, t));
  }
  function TJ(e, t, n) {
    let i = 0;
    for (let r = 0, o = n.length - 1; r < n.length; o = r++) {
      const [s, a] = n[o], [u, l] = n[r];
      l > t != a > t && e < (s - u) * (t - l) / (a - l) + u && i++;
    }
    return i & 1;
  }
  const Wc = {
    random() {
      return Zn();
    },
    // override default
    cumulativeNormal: rp,
    cumulativeLogNormal: pv,
    cumulativeUniform: vv,
    densityNormal: cv,
    densityLogNormal: gv,
    densityUniform: bv,
    quantileNormal: op,
    quantileLogNormal: mv,
    quantileUniform: xv,
    sampleNormal: ip,
    sampleLogNormal: hv,
    sampleUniform: yv,
    isArray: P,
    isBoolean: Ko,
    isDate: Co,
    isDefined(e) {
      return e !== void 0;
    },
    isNumber: $e,
    isObject: Y,
    isRegExp: VC,
    isString: K,
    isTuple: Zg,
    isValid(e) {
      return e != null && e === e;
    },
    toBoolean: qb,
    toDate(e) {
      return Wb(e);
    },
    // suppress extra arguments
    toNumber: zt,
    toString: Hb,
    indexof: aJ,
    join: sJ,
    lastindexof: uJ,
    replace: cJ,
    reverse: fJ,
    slice: lJ,
    flush: HC,
    lerp: YC,
    merge: eJ,
    pad: JC,
    peek: xe,
    pluck: oJ,
    span: nf,
    inrange: Ha,
    truncate: QC,
    rgb: Io,
    lab: kh,
    hcl: Ah,
    hsl: Sh,
    luminance: Vy,
    contrast: ZK,
    sequence: Tn,
    format: NK,
    utcFormat: OK,
    utcParse: LK,
    utcOffset: TF,
    utcSequence: OF,
    timeFormat: NO,
    timeParse: RK,
    timeOffset: MF,
    timeSequence: NF,
    timeUnitSpecifier: vF,
    monthFormat: PK,
    monthAbbrevFormat: IK,
    dayFormat: zK,
    dayAbbrevFormat: BK,
    quarter: UC,
    utcquarter: jC,
    week: wF,
    utcweek: SF,
    dayofyear: xF,
    utcdayofyear: _F,
    warn: KK,
    info: JK,
    debug: QK,
    extent(e) {
      return nr(e);
    },
    // suppress extra arguments
    inScope: XK,
    intersect: BO,
    clampRange: qC,
    pinchDistance: iJ,
    pinchAngle: rJ,
    screen: SJ,
    containerSize: kJ,
    windowSize: $J,
    bandspace: dJ,
    setdata: TK,
    pathShape: wJ,
    panLinear: PC,
    panLog: IC,
    panPow: zC,
    panSymlog: BC,
    zoomLinear: Pb,
    zoomLog: Ib,
    zoomPow: fh,
    zoomSymlog: zb,
    encode: DK,
    modify: nJ,
    lassoAppend: CJ,
    lassoPath: FJ,
    intersectLasso: MJ
  }, DJ = ["view", "item", "group", "xy", "x", "y"], NJ = "event.vega.", UO = "this.", rw = {}, jO = {
    forbidden: ["_"],
    allowed: ["datum", "event", "item"],
    fieldvar: "datum",
    globalvar: (e) => `_[${H(OO + e)}]`,
    functions: OJ,
    constants: AO,
    visitors: rw
  }, Yy = FO(jO);
  function OJ(e) {
    const t = CO(e);
    DJ.forEach((n) => t[n] = NJ + n);
    for (const n in Wc)
      t[n] = UO + n;
    return ce(t, WK(e, Wc, rw)), t;
  }
  function tt(e, t, n) {
    return arguments.length === 1 ? Wc[e] : (Wc[e] = t, n && (rw[e] = n), Yy && (Yy.functions[e] = UO + e), this);
  }
  tt("bandwidth", hJ, on);
  tt("copy", gJ, on);
  tt("domain", pJ, on);
  tt("range", yJ, on);
  tt("invert", mJ, on);
  tt("scale", bJ, on);
  tt("gradient", vJ, on);
  tt("geoArea", HK, on);
  tt("geoBounds", GK, on);
  tt("geoCentroid", VK, on);
  tt("geoShape", xJ, on);
  tt("geoScale", YK, on);
  tt("indata", MK, qK);
  tt("data", DO, Z2);
  tt("treePath", EJ, Z2);
  tt("treeAncestors", _J, Z2);
  tt("vlSelectionTest", EK, Q2);
  tt("vlSelectionIdTest", $K, Q2);
  tt("vlSelectionResolve", AK, Q2);
  tt("vlSelectionTuples", kK);
  function ar(e, t) {
    const n = {};
    let i;
    try {
      e = K(e) ? e : H(e) + "", i = K2(e);
    } catch {
      R("Expression parse error: " + e);
    }
    i.visit((o) => {
      if (o.type !== xO) return;
      const s = o.callee.name, a = jO.visitors[s];
      a && a(s, o.arguments, t, n);
    });
    const r = Yy(i);
    return r.globals.forEach((o) => {
      const s = OO + o;
      !J(n, s) && t.getSignal(o) && (n[s] = t.signalRef(o));
    }), {
      $expr: ce({
        code: r.code
      }, t.options.ast ? {
        ast: i
      } : null),
      $fields: r.fields,
      $params: n
    };
  }
  function RJ(e) {
    const t = this, n = e.operators || [];
    return e.background && (t.background = e.background), e.eventConfig && (t.eventConfig = e.eventConfig), e.locale && (t.locale = e.locale), n.forEach((i) => t.parseOperator(i)), n.forEach((i) => t.parseOperatorParameters(i)), (e.streams || []).forEach((i) => t.parseStream(i)), (e.updates || []).forEach((i) => t.parseUpdate(i)), t.resolve();
  }
  const LJ = wi(["rule"]), lk = wi(["group", "image", "rect"]);
  function PJ(e, t) {
    let n = "";
    return LJ[t] || (e.x2 && (e.x ? (lk[t] && (n += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;"), n += "o.width=o.x2-o.x;") : n += "o.x=o.x2-(o.width||0);"), e.xc && (n += "o.x=o.xc-(o.width||0)/2;"), e.y2 && (e.y ? (lk[t] && (n += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;"), n += "o.height=o.y2-o.y;") : n += "o.y=o.y2-(o.height||0);"), e.yc && (n += "o.y=o.yc-(o.height||0)/2;")), n;
  }
  function ow(e) {
    return (e + "").toLowerCase();
  }
  function IJ(e) {
    return ow(e) === "operator";
  }
  function zJ(e) {
    return ow(e) === "collect";
  }
  function Fl(e, t, n) {
    n.endsWith(";") || (n = "return(" + n + ");");
    const i = Function(...t.concat(n));
    return e && e.functions ? i.bind(e.functions) : i;
  }
  function BJ(e, t, n, i) {
    return `((u = ${e}) < (v = ${t}) || u == null) && v != null ? ${n}
  : (u > v || v == null) && u != null ? ${i}
  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${n}
  : v !== v && u === u ? ${i} : `;
  }
  var UJ = {
    /**
     * Parse an expression used to update an operator value.
     */
    operator: (e, t) => Fl(e, ["_"], t.code),
    /**
     * Parse an expression provided as an operator parameter value.
     */
    parameter: (e, t) => Fl(e, ["datum", "_"], t.code),
    /**
     * Parse an expression applied to an event stream.
     */
    event: (e, t) => Fl(e, ["event"], t.code),
    /**
     * Parse an expression used to handle an event-driven operator update.
     */
    handler: (e, t) => {
      const n = `var datum=event.item&&event.item.datum;return ${t.code};`;
      return Fl(e, ["_", "event"], n);
    },
    /**
     * Parse an expression that performs visual encoding.
     */
    encode: (e, t) => {
      const {
        marktype: n,
        channels: i
      } = t;
      let r = "var o=item,datum=o.datum,m=0,$;";
      for (const o in i) {
        const s = "o[" + H(o) + "]";
        r += `$=${i[o].code};if(${s}!==$)${s}=$,m=1;`;
      }
      return r += PJ(i, n), r += "return m;", Fl(e, ["item", "_"], r);
    },
    /**
     * Optimized code generators for access and comparison.
     */
    codegen: {
      get(e) {
        const t = `[${e.map(H).join("][")}]`, n = Function("_", `return _${t};`);
        return n.path = t, n;
      },
      comparator(e, t) {
        let n;
        const i = (o, s) => {
          const a = t[s];
          let u, l;
          return o.path ? (u = `a${o.path}`, l = `b${o.path}`) : ((n = n || {})["f" + s] = o, u = `this.f${s}(a)`, l = `this.f${s}(b)`), BJ(u, l, -a, a);
        }, r = Function("a", "b", "var u, v; return " + e.map(i).join("") + "0;");
        return n ? r.bind(n) : r;
      }
    }
  };
  function jJ(e) {
    const t = this;
    IJ(e.type) || !e.type ? t.operator(e, e.update ? t.operatorExpression(e.update) : null) : t.transform(e, e.type);
  }
  function qJ(e) {
    const t = this;
    if (e.params) {
      const n = t.get(e.id);
      n || R("Invalid operator id: " + e.id), t.dataflow.connect(n, n.parameters(t.parseParameters(e.params), e.react, e.initonly));
    }
  }
  function WJ(e, t) {
    t = t || {};
    const n = this;
    for (const i in e) {
      const r = e[i];
      t[i] = P(r) ? r.map((o) => ck(o, n, t)) : ck(r, n, t);
    }
    return t;
  }
  function ck(e, t, n) {
    if (!e || !Y(e)) return e;
    for (let i = 0, r = fk.length, o; i < r; ++i)
      if (o = fk[i], J(e, o.key))
        return o.parse(e, t, n);
    return e;
  }
  var fk = [{
    key: "$ref",
    parse: HJ
  }, {
    key: "$key",
    parse: VJ
  }, {
    key: "$expr",
    parse: GJ
  }, {
    key: "$field",
    parse: YJ
  }, {
    key: "$encode",
    parse: KJ
  }, {
    key: "$compare",
    parse: XJ
  }, {
    key: "$context",
    parse: JJ
  }, {
    key: "$subflow",
    parse: QJ
  }, {
    key: "$tupleid",
    parse: ZJ
  }];
  function HJ(e, t) {
    return t.get(e.$ref) || R("Operator not defined: " + e.$ref);
  }
  function GJ(e, t, n) {
    e.$params && t.parseParameters(e.$params, n);
    const i = "e:" + e.$expr.code;
    return t.fn[i] || (t.fn[i] = Sn(t.parameterExpression(e.$expr), e.$fields));
  }
  function VJ(e, t) {
    const n = "k:" + e.$key + "_" + !!e.$flat;
    return t.fn[n] || (t.fn[n] = jb(e.$key, e.$flat, t.expr.codegen));
  }
  function YJ(e, t) {
    if (!e.$field) return null;
    const n = "f:" + e.$field + "_" + e.$name;
    return t.fn[n] || (t.fn[n] = Kn(e.$field, e.$name, t.expr.codegen));
  }
  function XJ(e, t) {
    const n = "c:" + e.$compare + "_" + e.$order, i = X(e.$compare).map((r) => r && r.$tupleid ? re : r);
    return t.fn[n] || (t.fn[n] = Bb(i, e.$order, t.expr.codegen));
  }
  function KJ(e, t) {
    const n = e.$encode, i = {};
    for (const r in n) {
      const o = n[r];
      i[r] = Sn(t.encodeExpression(o.$expr), o.$fields), i[r].output = o.$output;
    }
    return i;
  }
  function JJ(e, t) {
    return t;
  }
  function QJ(e, t) {
    const n = e.$subflow;
    return function(i, r, o) {
      const s = t.fork().parse(n), a = s.get(n.operators[0].id), u = s.signals.parent;
      return u && u.set(o), a.detachSubflow = () => t.detach(s), a;
    };
  }
  function ZJ() {
    return re;
  }
  function eQ(e) {
    var t = this, n = e.filter != null ? t.eventExpression(e.filter) : void 0, i = e.stream != null ? t.get(e.stream) : void 0, r;
    e.source ? i = t.events(e.source, e.type, n) : e.merge && (r = e.merge.map((o) => t.get(o)), i = r[0].merge.apply(r[0], r.slice(1))), e.between && (r = e.between.map((o) => t.get(o)), i = i.between(r[0], r[1])), e.filter && (i = i.filter(n)), e.throttle != null && (i = i.throttle(+e.throttle)), e.debounce != null && (i = i.debounce(+e.debounce)), i == null && R("Invalid stream definition: " + JSON.stringify(e)), e.consume && i.consume(!0), t.stream(e, i);
  }
  function tQ(e) {
    var t = this, n = Y(n = e.source) ? n.$ref : n, i = t.get(n), r = null, o = e.update, s = void 0;
    i || R("Source not defined: " + e.source), r = e.target && e.target.$expr ? t.eventExpression(e.target.$expr) : t.get(e.target), o && o.$expr && (o.$params && (s = t.parseParameters(o.$params)), o = t.handlerExpression(o.$expr)), t.update(e, i, r, o, s);
  }
  const nQ = {
    skip: !0
  };
  function iQ(e) {
    var t = this, n = {};
    if (e.signals) {
      var i = n.signals = {};
      Object.keys(t.signals).forEach((o) => {
        const s = t.signals[o];
        e.signals(o, s) && (i[o] = s.value);
      });
    }
    if (e.data) {
      var r = n.data = {};
      Object.keys(t.data).forEach((o) => {
        const s = t.data[o];
        e.data(o, s) && (r[o] = s.input.value);
      });
    }
    return t.subcontext && e.recurse !== !1 && (n.subcontext = t.subcontext.map((o) => o.getState(e))), n;
  }
  function rQ(e) {
    var t = this, n = t.dataflow, i = e.data, r = e.signals;
    Object.keys(r || {}).forEach((o) => {
      n.update(t.signals[o], r[o], nQ);
    }), Object.keys(i || {}).forEach((o) => {
      n.pulse(t.data[o].input, n.changeset().remove(Jn).insert(i[o]));
    }), (e.subcontext || []).forEach((o, s) => {
      const a = t.subcontext[s];
      a && a.setState(o);
    });
  }
  function qO(e, t, n, i) {
    return new WO(e, t, n, i);
  }
  function WO(e, t, n, i) {
    this.dataflow = e, this.transforms = t, this.events = e.events.bind(e), this.expr = i || UJ, this.signals = {}, this.scales = {}, this.nodes = {}, this.data = {}, this.fn = {}, n && (this.functions = Object.create(n), this.functions.context = this);
  }
  function dk(e) {
    this.dataflow = e.dataflow, this.transforms = e.transforms, this.events = e.events, this.expr = e.expr, this.signals = Object.create(e.signals), this.scales = Object.create(e.scales), this.nodes = Object.create(e.nodes), this.data = Object.create(e.data), this.fn = Object.create(e.fn), e.functions && (this.functions = Object.create(e.functions), this.functions.context = this);
  }
  WO.prototype = dk.prototype = {
    fork() {
      const e = new dk(this);
      return (this.subcontext || (this.subcontext = [])).push(e), e;
    },
    detach(e) {
      this.subcontext = this.subcontext.filter((n) => n !== e);
      const t = Object.keys(e.nodes);
      for (const n of t) e.nodes[n]._targets = null;
      for (const n of t) e.nodes[n].detach();
      e.nodes = null;
    },
    get(e) {
      return this.nodes[e];
    },
    set(e, t) {
      return this.nodes[e] = t;
    },
    add(e, t) {
      const n = this, i = n.dataflow, r = e.value;
      if (n.set(e.id, t), zJ(e.type) && r && (r.$ingest ? i.ingest(t, r.$ingest, r.$format) : r.$request ? i.preload(t, r.$request, r.$format) : i.pulse(t, i.changeset().insert(r))), e.root && (n.root = t), e.parent) {
        let o = n.get(e.parent.$ref);
        o ? (i.connect(o, [t]), t.targets().add(o)) : (n.unresolved = n.unresolved || []).push(() => {
          o = n.get(e.parent.$ref), i.connect(o, [t]), t.targets().add(o);
        });
      }
      if (e.signal && (n.signals[e.signal] = t), e.scale && (n.scales[e.scale] = t), e.data)
        for (const o in e.data) {
          const s = n.data[o] || (n.data[o] = {});
          e.data[o].forEach((a) => s[a] = t);
        }
    },
    resolve() {
      return (this.unresolved || []).forEach((e) => e()), delete this.unresolved, this;
    },
    operator(e, t) {
      this.add(e, this.dataflow.add(e.value, t));
    },
    transform(e, t) {
      this.add(e, this.dataflow.add(this.transforms[ow(t)]));
    },
    stream(e, t) {
      this.set(e.id, t);
    },
    update(e, t, n, i, r) {
      this.dataflow.on(t, n, i, r, e.options);
    },
    // expression parsing
    operatorExpression(e) {
      return this.expr.operator(this, e);
    },
    parameterExpression(e) {
      return this.expr.parameter(this, e);
    },
    eventExpression(e) {
      return this.expr.event(this, e);
    },
    handlerExpression(e) {
      return this.expr.handler(this, e);
    },
    encodeExpression(e) {
      return this.expr.encode(this, e);
    },
    // parse methods
    parse: RJ,
    parseOperator: jJ,
    parseOperatorParameters: qJ,
    parseParameters: WJ,
    parseStream: eQ,
    parseUpdate: tQ,
    // state methods
    getState: iQ,
    setState: rQ
  };
  function oQ(e) {
    const t = e.container();
    t && (t.setAttribute("role", "graphics-document"), t.setAttribute("aria-roleDescription", "visualization"), HO(t, e.description()));
  }
  function HO(e, t) {
    e && (t == null ? e.removeAttribute("aria-label") : e.setAttribute("aria-label", t));
  }
  function sQ(e) {
    e.add(null, (t) => (e._background = t.bg, e._resize = 1, t.bg), {
      bg: e._signals.background
    });
  }
  const Y0 = "default";
  function aQ(e) {
    const t = e._signals.cursor || (e._signals.cursor = e.add({
      user: Y0,
      item: null
    }));
    e.on(e.events("view", "pointermove"), t, (n, i) => {
      const r = t.value, o = r ? K(r) ? r : r.user : Y0, s = i.item && i.item.cursor || null;
      return r && o === r.user && s == r.item ? r : {
        user: o,
        item: s
      };
    }), e.add(null, function(n) {
      let i = n.cursor, r = this.value;
      return K(i) || (r = i.item, i = i.user), Xy(e, i && i !== Y0 ? i : r || i), r;
    }, {
      cursor: t
    });
  }
  function Xy(e, t) {
    const n = e.globalCursor() ? typeof document < "u" && document.body : e.container();
    if (n)
      return t == null ? n.style.removeProperty("cursor") : n.style.cursor = t;
  }
  function wg(e, t) {
    var n = e._runtime.data;
    return J(n, t) || R("Unrecognized data set: " + t), n[t];
  }
  function uQ(e, t) {
    return arguments.length < 2 ? wg(this, e).values.value : Hp.call(this, e, ga().remove(Jn).insert(t));
  }
  function Hp(e, t) {
    aM(t) || R("Second argument to changes must be a changeset.");
    const n = wg(this, e);
    return n.modified = !0, this.pulse(n.input, t);
  }
  function lQ(e, t) {
    return Hp.call(this, e, ga().insert(t));
  }
  function cQ(e, t) {
    return Hp.call(this, e, ga().remove(t));
  }
  function GO(e) {
    var t = e.padding();
    return Math.max(0, e._viewWidth + t.left + t.right);
  }
  function VO(e) {
    var t = e.padding();
    return Math.max(0, e._viewHeight + t.top + t.bottom);
  }
  function Gp(e) {
    var t = e.padding(), n = e._origin;
    return [t.left + n[0], t.top + n[1]];
  }
  function fQ(e) {
    var t = Gp(e), n = GO(e), i = VO(e);
    e._renderer.background(e.background()), e._renderer.resize(n, i, t), e._handler.origin(t), e._resizeListeners.forEach((r) => {
      try {
        r(n, i);
      } catch (o) {
        e.error(o);
      }
    });
  }
  function dQ(e, t, n) {
    var i = e._renderer, r = i && i.canvas(), o, s, a;
    return r && (a = Gp(e), s = t.changedTouches ? t.changedTouches[0] : t, o = Dp(s, r), o[0] -= a[0], o[1] -= a[1]), t.dataflow = e, t.item = n, t.vega = hQ(e, n, o), t;
  }
  function hQ(e, t, n) {
    const i = t ? t.mark.marktype === "group" ? t : t.mark.group : null;
    function r(s) {
      var a = i, u;
      if (s) {
        for (u = t; u; u = u.mark.group)
          if (u.mark.name === s) {
            a = u;
            break;
          }
      }
      return a && a.mark && a.mark.interactive ? a : {};
    }
    function o(s) {
      if (!s) return n;
      K(s) && (s = r(s));
      const a = n.slice();
      for (; s; )
        a[0] -= s.x || 0, a[1] -= s.y || 0, s = s.mark && s.mark.group;
      return a;
    }
    return {
      view: Gt(e),
      item: Gt(t || {}),
      group: r,
      xy: o,
      x: (s) => o(s)[0],
      y: (s) => o(s)[1]
    };
  }
  const hk = "view", gQ = "timer", pQ = "window", mQ = {
    trap: !1
  };
  function yQ(e) {
    const t = ce({
      defaults: {}
    }, e), n = (i, r) => {
      r.forEach((o) => {
        P(i[o]) && (i[o] = wi(i[o]));
      });
    };
    return n(t.defaults, ["prevent", "allow"]), n(t, ["view", "window", "selector"]), t;
  }
  function YO(e, t, n, i) {
    e._eventListeners.push({
      type: n,
      sources: X(t),
      handler: i
    });
  }
  function bQ(e, t) {
    var n = e._eventConfig.defaults, i = n.prevent, r = n.allow;
    return i === !1 || r === !0 ? !1 : i === !0 || r === !1 ? !0 : i ? i[t] : r ? !r[t] : e.preventDefault();
  }
  function wd(e, t, n) {
    const i = e._eventConfig && e._eventConfig[t];
    return i === !1 || Y(i) && !i[n] ? (e.warn(`Blocked ${t} ${n} event listener.`), !1) : !0;
  }
  function vQ(e, t, n) {
    var i = this, r = new np(n), o = function(l, c) {
      i.runAsync(null, () => {
        e === hk && bQ(i, t) && l.preventDefault(), r.receive(dQ(i, l, c));
      });
    }, s;
    if (e === gQ)
      wd(i, "timer", t) && i.timer(o, t);
    else if (e === hk)
      wd(i, "view", t) && i.addEventListener(t, o, mQ);
    else if (e === pQ ? wd(i, "window", t) && typeof window < "u" && (s = [window]) : typeof document < "u" && wd(i, "selector", t) && (s = Array.from(document.querySelectorAll(e))), !s)
      i.warn("Can not resolve event source: " + e);
    else {
      for (var a = 0, u = s.length; a < u; ++a)
        s[a].addEventListener(t, o);
      YO(i, s, t, o);
    }
    return r;
  }
  function gk(e) {
    return e.item;
  }
  function pk(e) {
    return e.item.mark.source;
  }
  function mk(e) {
    return function(t, n) {
      return n.vega.view().changeset().encode(n.item, e);
    };
  }
  function xQ(e, t) {
    return e = [e || "hover"], t = [t || "update", e[0]], this.on(this.events("view", "pointerover", gk), pk, mk(e)), this.on(this.events("view", "pointerout", gk), pk, mk(t)), this;
  }
  function wQ() {
    var e = this._tooltip, t = this._timers, n = this._handler.handlers(), i = this._eventListeners, r, o, s, a, u;
    for (r = t.length; --r >= 0; )
      t[r].stop();
    for (r = i.length; --r >= 0; )
      for (s = i[r], o = s.sources.length; --o >= 0; )
        s.sources[o].removeEventListener(s.type, s.handler);
    for (e && e.call(this, this._handler, null, null, null), r = n.length; --r >= 0; )
      u = n[r].type, a = n[r].handler, this._handler.off(u, a);
    return this;
  }
  function On(e, t, n) {
    const i = document.createElement(e);
    for (const r in t) i.setAttribute(r, t[r]);
    return n != null && (i.textContent = n), i;
  }
  const EQ = "vega-bind", _Q = "vega-bind-name", SQ = "vega-bind-radio";
  function $Q(e, t, n) {
    if (!t) return;
    const i = n.param;
    let r = n.state;
    return r || (r = n.state = {
      elements: null,
      active: !1,
      set: null,
      update: (s) => {
        s != e.signal(i.signal) && e.runAsync(null, () => {
          r.source = !0, e.signal(i.signal, s);
        });
      }
    }, i.debounce && (r.update = Ub(i.debounce, r.update))), (i.input == null && i.element ? kQ : CQ)(r, t, i, e), r.active || (e.on(e._signals[i.signal], null, () => {
      r.source ? r.source = !1 : r.set(e.signal(i.signal));
    }), r.active = !0), r;
  }
  function kQ(e, t, n, i) {
    const r = n.event || "input", o = () => e.update(t.value);
    i.signal(n.signal, t.value), t.addEventListener(r, o), YO(i, t, r, o), e.set = (s) => {
      t.value = s, t.dispatchEvent(AQ(r));
    };
  }
  function AQ(e) {
    return typeof Event < "u" ? new Event(e) : {
      type: e
    };
  }
  function CQ(e, t, n, i) {
    const r = i.signal(n.signal), o = On("div", {
      class: EQ
    }), s = n.input === "radio" ? o : o.appendChild(On("label"));
    s.appendChild(On("span", {
      class: _Q
    }, n.name || n.signal)), t.appendChild(o);
    let a = FQ;
    switch (n.input) {
      case "checkbox":
        a = MQ;
        break;
      case "select":
        a = TQ;
        break;
      case "radio":
        a = DQ;
        break;
      case "range":
        a = NQ;
        break;
    }
    a(e, s, n, r);
  }
  function FQ(e, t, n, i) {
    const r = On("input");
    for (const o in n)
      o !== "signal" && o !== "element" && r.setAttribute(o === "input" ? "type" : o, n[o]);
    r.setAttribute("name", n.signal), r.value = i, t.appendChild(r), r.addEventListener("input", () => e.update(r.value)), e.elements = [r], e.set = (o) => r.value = o;
  }
  function MQ(e, t, n, i) {
    const r = {
      type: "checkbox",
      name: n.signal
    };
    i && (r.checked = !0);
    const o = On("input", r);
    t.appendChild(o), o.addEventListener("change", () => e.update(o.checked)), e.elements = [o], e.set = (s) => o.checked = !!s || null;
  }
  function TQ(e, t, n, i) {
    const r = On("select", {
      name: n.signal
    }), o = n.labels || [];
    n.options.forEach((s, a) => {
      const u = {
        value: s
      };
      Eg(s, i) && (u.selected = !0), r.appendChild(On("option", u, (o[a] || s) + ""));
    }), t.appendChild(r), r.addEventListener("change", () => {
      e.update(n.options[r.selectedIndex]);
    }), e.elements = [r], e.set = (s) => {
      for (let a = 0, u = n.options.length; a < u; ++a)
        if (Eg(n.options[a], s)) {
          r.selectedIndex = a;
          return;
        }
    };
  }
  function DQ(e, t, n, i) {
    const r = On("span", {
      class: SQ
    }), o = n.labels || [];
    t.appendChild(r), e.elements = n.options.map((s, a) => {
      const u = {
        type: "radio",
        name: n.signal,
        value: s
      };
      Eg(s, i) && (u.checked = !0);
      const l = On("input", u);
      l.addEventListener("change", () => e.update(s));
      const c = On("label", {}, (o[a] || s) + "");
      return c.prepend(l), r.appendChild(c), l;
    }), e.set = (s) => {
      const a = e.elements, u = a.length;
      for (let l = 0; l < u; ++l)
        Eg(a[l].value, s) && (a[l].checked = !0);
    };
  }
  function NQ(e, t, n, i) {
    i = i !== void 0 ? i : (+n.max + +n.min) / 2;
    const r = n.max != null ? n.max : Math.max(100, +i) || 100, o = n.min || Math.min(0, r, +i) || 0, s = n.step || Ro(o, r, 100), a = On("input", {
      type: "range",
      name: n.signal,
      min: o,
      max: r,
      step: s
    });
    a.value = i;
    const u = On("span", {}, +i);
    t.appendChild(a), t.appendChild(u);
    const l = () => {
      u.textContent = a.value, e.update(+a.value);
    };
    a.addEventListener("input", l), a.addEventListener("change", l), e.elements = [a], e.set = (c) => {
      a.value = c, u.textContent = c;
    };
  }
  function Eg(e, t) {
    return e === t || e + "" == t + "";
  }
  function XO(e, t, n, i, r, o) {
    return t = t || new i(e.loader()), t.initialize(n, GO(e), VO(e), Gp(e), r, o).background(e.background());
  }
  function sw(e, t) {
    return t ? function() {
      try {
        t.apply(this, arguments);
      } catch (n) {
        e.error(n);
      }
    } : null;
  }
  function OQ(e, t, n, i) {
    const r = new i(e.loader(), sw(e, e.tooltip())).scene(e.scenegraph().root).initialize(n, Gp(e), e);
    return t && t.handlers().forEach((o) => {
      r.on(o.type, o.handler);
    }), r;
  }
  function RQ(e, t) {
    const n = this, i = n._renderType, r = n._eventConfig.bind, o = Np(i);
    e = n._el = e ? X0(n, e, !0) : null, oQ(n), o || n.error("Unrecognized renderer type: " + i);
    const s = o.handler || Ef, a = e ? o.renderer : o.headless;
    return n._renderer = a ? XO(n, n._renderer, e, a) : null, n._handler = OQ(n, n._handler, e, s), n._redraw = !0, e && r !== "none" && (t = t ? n._elBind = X0(n, t, !0) : e.appendChild(On("form", {
      class: "vega-bindings"
    })), n._bind.forEach((u) => {
      u.param.element && r !== "container" && (u.element = X0(n, u.param.element, !!u.param.input));
    }), n._bind.forEach((u) => {
      $Q(n, u.element || t, u);
    })), n;
  }
  function X0(e, t, n) {
    if (typeof t == "string")
      if (typeof document < "u") {
        if (t = document.querySelector(t), !t)
          return e.error("Signal bind element not found: " + t), null;
      } else
        return e.error("DOM document instance not found."), null;
    if (t && n)
      try {
        t.textContent = "";
      } catch (i) {
        t = null, e.error(i);
      }
    return t;
  }
  const Ml = (e) => +e || 0, LQ = (e) => ({
    top: e,
    bottom: e,
    left: e,
    right: e
  });
  function yk(e) {
    return Y(e) ? {
      top: Ml(e.top),
      bottom: Ml(e.bottom),
      left: Ml(e.left),
      right: Ml(e.right)
    } : LQ(Ml(e));
  }
  async function aw(e, t, n, i) {
    const r = Np(t), o = r && r.headless;
    return o || R("Unrecognized renderer type: " + t), await e.runAsync(), XO(e, null, null, o, n, i).renderAsync(e._scenegraph.root);
  }
  async function PQ(e, t) {
    e !== Eo.Canvas && e !== Eo.SVG && e !== Eo.PNG && R("Unrecognized image type: " + e);
    const n = await aw(this, e, t);
    return e === Eo.SVG ? IQ(n.svg(), "image/svg+xml") : n.canvas().toDataURL("image/png");
  }
  function IQ(e, t) {
    const n = new Blob([e], {
      type: t
    });
    return window.URL.createObjectURL(n);
  }
  async function zQ(e, t) {
    return (await aw(this, Eo.Canvas, e, t)).canvas();
  }
  async function BQ(e) {
    return (await aw(this, Eo.SVG, e)).svg();
  }
  function UQ(e, t, n) {
    return qO(e, du, Wc, n).parse(t);
  }
  function jQ(e) {
    var t = this._runtime.scales;
    return J(t, e) || R("Unrecognized scale or projection: " + e), t[e].value;
  }
  var KO = "width", JO = "height", uw = "padding", bk = {
    skip: !0
  };
  function QO(e, t) {
    var n = e.autosize(), i = e.padding();
    return t - (n && n.contains === uw ? i.left + i.right : 0);
  }
  function ZO(e, t) {
    var n = e.autosize(), i = e.padding();
    return t - (n && n.contains === uw ? i.top + i.bottom : 0);
  }
  function qQ(e) {
    var t = e._signals, n = t[KO], i = t[JO], r = t[uw];
    function o() {
      e._autosize = e._resize = 1;
    }
    e._resizeWidth = e.add(null, (a) => {
      e._width = a.size, e._viewWidth = QO(e, a.size), o();
    }, {
      size: n
    }), e._resizeHeight = e.add(null, (a) => {
      e._height = a.size, e._viewHeight = ZO(e, a.size), o();
    }, {
      size: i
    });
    const s = e.add(null, o, {
      pad: r
    });
    e._resizeWidth.rank = n.rank + 1, e._resizeHeight.rank = i.rank + 1, s.rank = r.rank + 1;
  }
  function WQ(e, t, n, i, r, o) {
    this.runAfter((s) => {
      let a = 0;
      s._autosize = 0, s.width() !== n && (a = 1, s.signal(KO, n, bk), s._resizeWidth.skip(!0)), s.height() !== i && (a = 1, s.signal(JO, i, bk), s._resizeHeight.skip(!0)), s._viewWidth !== e && (s._resize = 1, s._viewWidth = e), s._viewHeight !== t && (s._resize = 1, s._viewHeight = t), (s._origin[0] !== r[0] || s._origin[1] !== r[1]) && (s._resize = 1, s._origin = r), a && s.run("enter"), o && s.runAfter((u) => u.resize());
    }, !1, 1);
  }
  function HQ(e) {
    return this._runtime.getState(e || {
      data: GQ,
      signals: VQ,
      recurse: !0
    });
  }
  function GQ(e, t) {
    return t.modified && P(t.input.value) && !e.startsWith("_:vega:_");
  }
  function VQ(e, t) {
    return !(e === "parent" || t instanceof du.proxy);
  }
  function YQ(e) {
    return this.runAsync(null, (t) => {
      t._trigger = !1, t._runtime.setState(e);
    }, (t) => {
      t._trigger = !0;
    }), this;
  }
  function XQ(e, t) {
    function n(i) {
      e({
        timestamp: Date.now(),
        elapsed: i
      });
    }
    this._timers.push(kG(n, t));
  }
  function KQ(e, t, n, i) {
    const r = e.element();
    r && r.setAttribute("title", JQ(i));
  }
  function JQ(e) {
    return e == null ? "" : P(e) ? eR(e) : Y(e) && !Co(e) ? QQ(e) : e + "";
  }
  function QQ(e) {
    return Object.keys(e).map((t) => {
      const n = e[t];
      return t + ": " + (P(n) ? eR(n) : tR(n));
    }).join(`
`);
  }
  function eR(e) {
    return "[" + e.map(tR).join(", ") + "]";
  }
  function tR(e) {
    return P(e) ? "[…]" : Y(e) && !Co(e) ? "{…}" : e;
  }
  function ZQ() {
    if (this.renderer() === "canvas" && this._renderer._canvas) {
      let e = null;
      const t = () => {
        e != null && e();
        const n = matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
        n.addEventListener("change", t), e = () => {
          n.removeEventListener("change", t);
        }, this._renderer._canvas.getContext("2d").pixelRatio = window.devicePixelRatio || 1, this._redraw = !0, this._resize = 1, this.resize().runAsync();
      };
      t();
    }
  }
  function nR(e, t) {
    const n = this;
    if (t = t || {}, Ja.call(n), t.loader && n.loader(t.loader), t.logger && n.logger(t.logger), t.logLevel != null && n.logLevel(t.logLevel), t.locale || e.locale) {
      const o = ce({}, e.locale, t.locale);
      n.locale(JF(o.number, o.time));
    }
    n._el = null, n._elBind = null, n._renderType = t.renderer || Eo.Canvas, n._scenegraph = new K3();
    const i = n._scenegraph.root;
    n._renderer = null, n._tooltip = t.tooltip || KQ, n._redraw = !0, n._handler = new Ef().scene(i), n._globalCursor = !1, n._preventDefault = !1, n._timers = [], n._eventListeners = [], n._resizeListeners = [], n._eventConfig = yQ(e.eventConfig), n.globalCursor(n._eventConfig.globalCursor);
    const r = UQ(n, e, t.expr);
    n._runtime = r, n._signals = r.signals, n._bind = (e.bindings || []).map((o) => ({
      state: null,
      param: ce({}, o)
    })), r.root && r.root.set(i), i.source = r.data.root.input, n.pulse(r.data.root.input, n.changeset().insert(i.items)), n._width = n.width(), n._height = n.height(), n._viewWidth = QO(n, n._width), n._viewHeight = ZO(n, n._height), n._origin = [0, 0], n._resize = 0, n._autosize = 1, qQ(n), sQ(n), aQ(n), n.description(e.description), t.hover && n.hover(), t.container && n.initialize(t.container, t.bind), t.watchPixelRatio && n._watchPixelRatio();
  }
  function Ed(e, t) {
    return J(e._signals, t) ? e._signals[t] : R("Unrecognized signal name: " + H(t));
  }
  function iR(e, t) {
    const n = (e._targets || []).filter((i) => i._update && i._update.handler === t);
    return n.length ? n[0] : null;
  }
  function vk(e, t, n, i) {
    let r = iR(n, i);
    return r || (r = sw(e, () => i(t, n.value)), r.handler = i, e.on(n, null, r)), e;
  }
  function xk(e, t, n) {
    const i = iR(t, n);
    return i && t._targets.remove(i), e;
  }
  G(nR, Ja, {
    // -- DATAFLOW / RENDERING ----
    async evaluate(e, t, n) {
      if (await Ja.prototype.evaluate.call(this, e, t), this._redraw || this._resize)
        try {
          this._renderer && (this._resize && (this._resize = 0, fQ(this)), await this._renderer.renderAsync(this._scenegraph.root)), this._redraw = !1;
        } catch (i) {
          this.error(i);
        }
      return n && Id(this, n), this;
    },
    dirty(e) {
      this._redraw = !0, this._renderer && this._renderer.dirty(e);
    },
    // -- GET / SET ----
    description(e) {
      if (arguments.length) {
        const t = e != null ? e + "" : null;
        return t !== this._desc && HO(this._el, this._desc = t), this;
      }
      return this._desc;
    },
    container() {
      return this._el;
    },
    scenegraph() {
      return this._scenegraph;
    },
    origin() {
      return this._origin.slice();
    },
    signal(e, t, n) {
      const i = Ed(this, e);
      return arguments.length === 1 ? i.value : this.update(i, t, n);
    },
    width(e) {
      return arguments.length ? this.signal("width", e) : this.signal("width");
    },
    height(e) {
      return arguments.length ? this.signal("height", e) : this.signal("height");
    },
    padding(e) {
      return arguments.length ? this.signal("padding", yk(e)) : yk(this.signal("padding"));
    },
    autosize(e) {
      return arguments.length ? this.signal("autosize", e) : this.signal("autosize");
    },
    background(e) {
      return arguments.length ? this.signal("background", e) : this.signal("background");
    },
    renderer(e) {
      return arguments.length ? (Np(e) || R("Unrecognized renderer type: " + e), e !== this._renderType && (this._renderType = e, this._resetRenderer()), this) : this._renderType;
    },
    tooltip(e) {
      return arguments.length ? (e !== this._tooltip && (this._tooltip = e, this._resetRenderer()), this) : this._tooltip;
    },
    loader(e) {
      return arguments.length ? (e !== this._loader && (Ja.prototype.loader.call(this, e), this._resetRenderer()), this) : this._loader;
    },
    resize() {
      return this._autosize = 1, this.touch(Ed(this, "autosize"));
    },
    _resetRenderer() {
      this._renderer && (this._renderer = null, this.initialize(this._el, this._elBind));
    },
    // -- SIZING ----
    _resizeView: WQ,
    // -- EVENT HANDLING ----
    addEventListener(e, t, n) {
      let i = t;
      return n && n.trap === !1 || (i = sw(this, t), i.raw = t), this._handler.on(e, i), this;
    },
    removeEventListener(e, t) {
      for (var n = this._handler.handlers(e), i = n.length, r, o; --i >= 0; )
        if (o = n[i].type, r = n[i].handler, e === o && (t === r || t === r.raw)) {
          this._handler.off(o, r);
          break;
        }
      return this;
    },
    addResizeListener(e) {
      const t = this._resizeListeners;
      return t.includes(e) || t.push(e), this;
    },
    removeResizeListener(e) {
      var t = this._resizeListeners, n = t.indexOf(e);
      return n >= 0 && t.splice(n, 1), this;
    },
    addSignalListener(e, t) {
      return vk(this, e, Ed(this, e), t);
    },
    removeSignalListener(e, t) {
      return xk(this, Ed(this, e), t);
    },
    addDataListener(e, t) {
      return vk(this, e, wg(this, e).values, t);
    },
    removeDataListener(e, t) {
      return xk(this, wg(this, e).values, t);
    },
    globalCursor(e) {
      if (arguments.length) {
        if (this._globalCursor !== !!e) {
          const t = Xy(this, null);
          this._globalCursor = !!e, t && Xy(this, t);
        }
        return this;
      } else
        return this._globalCursor;
    },
    preventDefault(e) {
      return arguments.length ? (this._preventDefault = e, this) : this._preventDefault;
    },
    timer: XQ,
    events: vQ,
    finalize: wQ,
    hover: xQ,
    // -- DATA ----
    data: uQ,
    change: Hp,
    insert: lQ,
    remove: cQ,
    // -- SCALES --
    scale: jQ,
    // -- INITIALIZATION ----
    initialize: RQ,
    // -- HEADLESS RENDERING ----
    toImageURL: PQ,
    toCanvas: zQ,
    toSVG: BQ,
    // -- SAVE / RESTORE STATE ----
    getState: HQ,
    setState: YQ,
    // RE-RENDER ON ZOOM
    _watchPixelRatio: ZQ
  });
  const eZ = "view", _g = "[", Sg = "]", rR = "{", oR = "}", tZ = ":", sR = ",", nZ = "@", iZ = ">", rZ = /[[\]{}]/, oZ = {
    "*": 1,
    arc: 1,
    area: 1,
    group: 1,
    image: 1,
    line: 1,
    path: 1,
    rect: 1,
    rule: 1,
    shape: 1,
    symbol: 1,
    text: 1,
    trail: 1
  };
  let aR, uR;
  function ns(e, t, n) {
    return aR = t || eZ, uR = n || oZ, lR(e.trim()).map(Ky);
  }
  function sZ(e) {
    return uR[e];
  }
  function xc(e, t, n, i, r) {
    const o = e.length;
    let s = 0, a;
    for (; t < o; ++t) {
      if (a = e[t], !s && a === n) return t;
      r && r.indexOf(a) >= 0 ? --s : i && i.indexOf(a) >= 0 && ++s;
    }
    return t;
  }
  function lR(e) {
    const t = [], n = e.length;
    let i = 0, r = 0;
    for (; r < n; )
      r = xc(e, r, sR, _g + rR, Sg + oR), t.push(e.substring(i, r).trim()), i = ++r;
    if (t.length === 0)
      throw "Empty event selector: " + e;
    return t;
  }
  function Ky(e) {
    return e[0] === "[" ? aZ(e) : uZ(e);
  }
  function aZ(e) {
    const t = e.length;
    let n = 1, i;
    if (n = xc(e, n, Sg, _g, Sg), n === t)
      throw "Empty between selector: " + e;
    if (i = lR(e.substring(1, n)), i.length !== 2)
      throw "Between selector must have two elements: " + e;
    if (e = e.slice(n + 1).trim(), e[0] !== iZ)
      throw "Expected '>' after between selector: " + e;
    i = i.map(Ky);
    const r = Ky(e.slice(1).trim());
    return r.between ? {
      between: i,
      stream: r
    } : (r.between = i, r);
  }
  function uZ(e) {
    const t = {
      source: aR
    }, n = [];
    let i = [0, 0], r = 0, o = 0, s = e.length, a = 0, u, l;
    if (e[s - 1] === oR) {
      if (a = e.lastIndexOf(rR), a >= 0) {
        try {
          i = lZ(e.substring(a + 1, s - 1));
        } catch {
          throw "Invalid throttle specification: " + e;
        }
        e = e.slice(0, a).trim(), s = e.length;
      } else throw "Unmatched right brace: " + e;
      a = 0;
    }
    if (!s) throw e;
    if (e[0] === nZ && (r = ++a), u = xc(e, a, tZ), u < s && (n.push(e.substring(o, u).trim()), o = a = ++u), a = xc(e, a, _g), a === s)
      n.push(e.substring(o, s).trim());
    else if (n.push(e.substring(o, a).trim()), l = [], o = ++a, o === s) throw "Unmatched left bracket: " + e;
    for (; a < s; ) {
      if (a = xc(e, a, Sg), a === s) throw "Unmatched left bracket: " + e;
      if (l.push(e.substring(o, a).trim()), a < s - 1 && e[++a] !== _g) throw "Expected left bracket: " + e;
      o = ++a;
    }
    if (!(s = n.length) || rZ.test(n[s - 1]))
      throw "Invalid event selector: " + e;
    return s > 1 ? (t.type = n[1], r ? t.markname = n[0].slice(1) : sZ(n[0]) ? t.marktype = n[0] : t.source = n[0]) : t.type = n[0], t.type.slice(-1) === "!" && (t.consume = !0, t.type = t.type.slice(0, -1)), l != null && (t.filter = l), i[0] && (t.throttle = i[0]), i[1] && (t.debounce = i[1]), t;
  }
  function lZ(e) {
    const t = e.split(sR);
    if (!e.length || t.length > 2) throw e;
    return t.map((n) => {
      const i = +n;
      if (i !== i) throw e;
      return i;
    });
  }
  function cZ(e) {
    return Y(e) ? e : {
      type: e || "pad"
    };
  }
  const Tl = (e) => +e || 0, fZ = (e) => ({
    top: e,
    bottom: e,
    left: e,
    right: e
  });
  function dZ(e) {
    return Y(e) ? e.signal ? e : {
      top: Tl(e.top),
      bottom: Tl(e.bottom),
      left: Tl(e.left),
      right: Tl(e.right)
    } : fZ(Tl(e));
  }
  const pt = (e) => Y(e) && !P(e) ? ce({}, e) : {
    value: e
  };
  function wk(e, t, n, i) {
    return n != null ? (Y(n) && !P(n) || P(n) && n.length && Y(n[0]) ? e.update[t] = n : e[i || "enter"][t] = {
      value: n
    }, 1) : 0;
  }
  function Mt(e, t, n) {
    for (const i in t)
      wk(e, i, t[i]);
    for (const i in n)
      wk(e, i, n[i], "update");
  }
  function il(e, t, n) {
    for (const i in t)
      n && J(n, i) || (e[i] = ce(e[i] || {}, t[i]));
    return e;
  }
  function qa(e, t) {
    return t && (t.enter && t.enter[e] || t.update && t.update[e]);
  }
  const lw = "mark", cw = "frame", fw = "scope", hZ = "axis", gZ = "axis-domain", pZ = "axis-grid", mZ = "axis-label", yZ = "axis-tick", bZ = "axis-title", vZ = "legend", xZ = "legend-band", wZ = "legend-entry", EZ = "legend-gradient", cR = "legend-label", _Z = "legend-symbol", SZ = "legend-title", $Z = "title", kZ = "title-text", AZ = "title-subtitle";
  function CZ(e, t, n, i, r) {
    const o = {}, s = {};
    let a, u, l, c;
    u = "lineBreak", t === "text" && r[u] != null && !qa(u, e) && K0(o, u, r[u]), (n == "legend" || String(n).startsWith("axis")) && (n = null), c = n === cw ? r.group : n === lw ? ce({}, r.mark, r[t]) : null;
    for (u in c)
      l = qa(u, e) || (u === "fill" || u === "stroke") && (qa("fill", e) || qa("stroke", e)), l || K0(o, u, c[u]);
    X(i).forEach((f) => {
      const d = r.style && r.style[f];
      for (const h in d)
        qa(h, e) || K0(o, h, d[h]);
    }), e = ce({}, e);
    for (u in o)
      c = o[u], c.signal ? (a = a || {})[u] = c : s[u] = c;
    return e.enter = ce(s, e.enter), a && (e.update = ce(a, e.update)), e;
  }
  function K0(e, t, n) {
    e[t] = n && n.signal ? {
      signal: n.signal
    } : {
      value: n
    };
  }
  const fR = (e) => K(e) ? H(e) : e.signal ? `(${e.signal})` : dR(e);
  function Vp(e) {
    if (e.gradient != null)
      return MZ(e);
    let t = e.signal ? `(${e.signal})` : e.color ? FZ(e.color) : e.field != null ? dR(e.field) : e.value !== void 0 ? H(e.value) : void 0;
    return e.scale != null && (t = TZ(e, t)), t === void 0 && (t = null), e.exponent != null && (t = `pow(${t},${nh(e.exponent)})`), e.mult != null && (t += `*${nh(e.mult)}`), e.offset != null && (t += `+${nh(e.offset)}`), e.round && (t = `round(${t})`), t;
  }
  const _d = (e, t, n, i) => `(${e}(${[t, n, i].map(Vp).join(",")})+'')`;
  function FZ(e) {
    return e.c ? _d("hcl", e.h, e.c, e.l) : e.h || e.s ? _d("hsl", e.h, e.s, e.l) : e.l || e.a ? _d("lab", e.l, e.a, e.b) : e.r || e.g || e.b ? _d("rgb", e.r, e.g, e.b) : null;
  }
  function MZ(e) {
    const t = [e.start, e.stop, e.count].map((n) => n == null ? null : H(n));
    for (; t.length && xe(t) == null; ) t.pop();
    return t.unshift(fR(e.gradient)), `gradient(${t.join(",")})`;
  }
  function nh(e) {
    return Y(e) ? "(" + Vp(e) + ")" : e;
  }
  function dR(e) {
    return hR(Y(e) ? e : {
      datum: e
    });
  }
  function hR(e) {
    let t, n, i;
    if (e.signal)
      t = "datum", i = e.signal;
    else if (e.group || e.parent) {
      for (n = Math.max(1, e.level || 1), t = "item"; n-- > 0; )
        t += ".mark.group";
      e.parent ? (i = e.parent, t += ".datum") : i = e.group;
    } else e.datum ? (t = "datum", i = e.datum) : R("Invalid field reference: " + H(e));
    return e.signal || (i = K(i) ? fr(i).map(H).join("][") : hR(i)), t + "[" + i + "]";
  }
  function TZ(e, t) {
    const n = fR(e.scale);
    return e.range != null ? t = `lerp(_range(${n}), ${+e.range})` : (t !== void 0 && (t = `_scale(${n}, ${t})`), e.band && (t = (t ? t + "+" : "") + `_bandwidth(${n})` + (+e.band == 1 ? "" : "*" + nh(e.band)), e.extra && (t = `(datum.extra ? _scale(${n}, datum.extra.value) : ${t})`)), t == null && (t = "0")), t;
  }
  function DZ(e) {
    let t = "";
    return e.forEach((n) => {
      const i = Vp(n);
      t += n.test ? `(${n.test})?${i}:` : i;
    }), xe(t) === ":" && (t += "null"), t;
  }
  function gR(e, t, n, i, r, o) {
    const s = {};
    o = o || {}, o.encoders = {
      $encode: s
    }, e = CZ(e, t, n, i, r.config);
    for (const a in e)
      s[a] = NZ(e[a], t, o, r);
    return o;
  }
  function NZ(e, t, n, i) {
    const r = {}, o = {};
    for (const s in e)
      e[s] != null && (r[s] = RZ(OZ(e[s]), i, n, o));
    return {
      $expr: {
        marktype: t,
        channels: r
      },
      $fields: Object.keys(o),
      $output: Object.keys(e)
    };
  }
  function OZ(e) {
    return P(e) ? DZ(e) : Vp(e);
  }
  function RZ(e, t, n, i) {
    const r = ar(e, t);
    return r.$fields.forEach((o) => i[o] = 1), ce(n, r.$params), r.$expr;
  }
  const LZ = "outer", PZ = ["value", "update", "init", "react", "bind"];
  function Ek(e, t) {
    R(e + ' for "outer" push: ' + H(t));
  }
  function pR(e, t) {
    const n = e.name;
    if (e.push === LZ)
      t.signals[n] || Ek("No prior signal definition", n), PZ.forEach((i) => {
        e[i] !== void 0 && Ek("Invalid property ", i);
      });
    else {
      const i = t.addSignal(n, e.value);
      e.react === !1 && (i.react = !1), e.bind && t.addBinding(n, e.bind);
    }
  }
  function Jy(e, t, n, i) {
    this.id = -1, this.type = e, this.value = t, this.params = n, i && (this.parent = i);
  }
  function Yp(e, t, n, i) {
    return new Jy(e, t, n, i);
  }
  function $g(e, t) {
    return Yp("operator", e, t);
  }
  function ie(e) {
    const t = {
      $ref: e.id
    };
    return e.id < 0 && (e.refs = e.refs || []).push(t), t;
  }
  function Hc(e, t) {
    return t ? {
      $field: e,
      $name: t
    } : {
      $field: e
    };
  }
  const Qy = Hc("key");
  function _k(e, t) {
    return {
      $compare: e,
      $order: t
    };
  }
  function IZ(e, t) {
    const n = {
      $key: e
    };
    return t && (n.$flat = !0), n;
  }
  const zZ = "ascending", BZ = "descending";
  function UZ(e) {
    return Y(e) ? (e.order === BZ ? "-" : "+") + Xp(e.op, e.field) : "";
  }
  function Xp(e, t) {
    return (e && e.signal ? "$" + e.signal : e || "") + (e && t ? "_" : "") + (t && t.signal ? "$" + t.signal : t || "");
  }
  const dw = "scope", Zy = "view";
  function at(e) {
    return e && e.signal;
  }
  function jZ(e) {
    return e && e.expr;
  }
  function ih(e) {
    if (at(e)) return !0;
    if (Y(e)) {
      for (const t in e)
        if (ih(e[t])) return !0;
    }
    return !1;
  }
  function ci(e, t) {
    return e ?? t;
  }
  function zs(e) {
    return e && e.signal || e;
  }
  const Sk = "timer";
  function Gc(e, t) {
    return (e.merge ? WZ : e.stream ? HZ : e.type ? GZ : R("Invalid stream specification: " + H(e)))(e, t);
  }
  function qZ(e) {
    return e === dw ? Zy : e || Zy;
  }
  function WZ(e, t) {
    const n = e.merge.map((r) => Gc(r, t)), i = hw({
      merge: n
    }, e, t);
    return t.addStream(i).id;
  }
  function HZ(e, t) {
    const n = Gc(e.stream, t), i = hw({
      stream: n
    }, e, t);
    return t.addStream(i).id;
  }
  function GZ(e, t) {
    let n;
    e.type === Sk ? (n = t.event(Sk, e.throttle), e = {
      between: e.between,
      filter: e.filter
    }) : n = t.event(qZ(e.source), e.type);
    const i = hw({
      stream: n
    }, e, t);
    return Object.keys(i).length === 1 ? n : t.addStream(i).id;
  }
  function hw(e, t, n) {
    let i = t.between;
    return i && (i.length !== 2 && R('Stream "between" parameter must have 2 entries: ' + H(t)), e.between = [Gc(i[0], n), Gc(i[1], n)]), i = t.filter ? [].concat(t.filter) : [], (t.marktype || t.markname || t.markrole) && i.push(VZ(t.marktype, t.markname, t.markrole)), t.source === dw && i.push("inScope(event.item)"), i.length && (e.filter = ar("(" + i.join(")&&(") + ")", n).$expr), (i = t.throttle) != null && (e.throttle = +i), (i = t.debounce) != null && (e.debounce = +i), t.consume && (e.consume = !0), e;
  }
  function VZ(e, t, n) {
    const i = "event.item";
    return i + (e && e !== "*" ? "&&" + i + ".mark.marktype==='" + e + "'" : "") + (n ? "&&" + i + ".mark.role==='" + n + "'" : "") + (t ? "&&" + i + ".mark.name==='" + t + "'" : "");
  }
  const YZ = {
    code: "_.$value",
    ast: {
      type: "Identifier",
      value: "value"
    }
  };
  function XZ(e, t, n) {
    const i = e.encode, r = {
      target: n
    };
    let o = e.events, s = e.update, a = [];
    o || R("Signal update missing events specification."), K(o) && (o = ns(o, t.isSubscope() ? dw : Zy)), o = X(o).filter((u) => u.signal || u.scale ? (a.push(u), 0) : 1), a.length > 1 && (a = [JZ(a)]), o.length && a.push(o.length > 1 ? {
      merge: o
    } : o[0]), i != null && (s && R("Signal encode and update are mutually exclusive."), s = "encode(item()," + H(i) + ")"), r.update = K(s) ? ar(s, t) : s.expr != null ? ar(s.expr, t) : s.value != null ? s.value : s.signal != null ? {
      $expr: YZ,
      $params: {
        $value: t.signalRef(s.signal)
      }
    } : R("Invalid signal update specification."), e.force && (r.options = {
      force: !0
    }), a.forEach((u) => t.addUpdate(ce(KZ(u, t), r)));
  }
  function KZ(e, t) {
    return {
      source: e.signal ? t.signalRef(e.signal) : e.scale ? t.scaleRef(e.scale) : Gc(e, t)
    };
  }
  function JZ(e) {
    return {
      signal: "[" + e.map((t) => t.scale ? 'scale("' + t.scale + '")' : t.signal) + "]"
    };
  }
  function QZ(e, t) {
    const n = t.getSignal(e.name);
    let i = e.update;
    e.init && (i ? R("Signals can not include both init and update expressions.") : (i = e.init, n.initonly = !0)), i && (i = ar(i, t), n.update = i.$expr, n.params = i.$params), e.on && e.on.forEach((r) => XZ(r, t, n.id));
  }
  const Le = (e) => (t, n, i) => Yp(e, n, t || void 0, i), mR = Le("aggregate"), ZZ = Le("axisticks"), yR = Le("bound"), Fi = Le("collect"), $k = Le("compare"), eee = Le("datajoin"), bR = Le("encode"), tee = Le("expression"), nee = Le("facet"), iee = Le("field"), ree = Le("key"), oee = Le("legendentries"), see = Le("load"), aee = Le("mark"), uee = Le("multiextent"), lee = Le("multivalues"), cee = Le("overlap"), fee = Le("params"), vR = Le("prefacet"), dee = Le("projection"), hee = Le("proxy"), gee = Le("relay"), xR = Le("render"), pee = Le("scale"), ba = Le("sieve"), mee = Le("sortitems"), wR = Le("viewlayout"), yee = Le("values");
  let bee = 0;
  const ER = {
    min: "min",
    max: "max",
    count: "sum"
  };
  function vee(e, t) {
    const n = e.type || "linear";
    u3(n) || R("Unrecognized scale type: " + H(n)), t.addScale(e.name, {
      type: n,
      domain: void 0
    });
  }
  function xee(e, t) {
    const n = t.getScale(e.name).params;
    let i;
    n.domain = _R(e.domain, e, t), e.range != null && (n.range = $R(e, t, n)), e.interpolate != null && Mee(e.interpolate, n), e.nice != null && (n.nice = Fee(e.nice, t)), e.bins != null && (n.bins = Cee(e.bins, t));
    for (i in e)
      J(n, i) || i === "name" || (n[i] = Gn(e[i], t));
  }
  function Gn(e, t) {
    return Y(e) ? e.signal ? t.signalRef(e.signal) : R("Unsupported object: " + H(e)) : e;
  }
  function rh(e, t) {
    return e.signal ? t.signalRef(e.signal) : e.map((n) => Gn(n, t));
  }
  function Kp(e) {
    R("Can not find data set: " + H(e));
  }
  function _R(e, t, n) {
    if (!e) {
      (t.domainMin != null || t.domainMax != null) && R("No scale domain defined for domainMin/domainMax to override.");
      return;
    }
    return e.signal ? n.signalRef(e.signal) : (P(e) ? wee : e.fields ? _ee : Eee)(e, t, n);
  }
  function wee(e, t, n) {
    return e.map((i) => Gn(i, n));
  }
  function Eee(e, t, n) {
    const i = n.getData(e.data);
    return i || Kp(e.data), yu(t.type) ? i.valuesRef(n, e.field, SR(e.sort, !1)) : f3(t.type) ? i.domainRef(n, e.field) : i.extentRef(n, e.field);
  }
  function _ee(e, t, n) {
    const i = e.data, r = e.fields.reduce((o, s) => (s = K(s) ? {
      data: i,
      field: s
    } : P(s) || s.signal ? See(s, n) : s, o.push(s), o), []);
    return (yu(t.type) ? $ee : f3(t.type) ? kee : Aee)(e, n, r);
  }
  function See(e, t) {
    const n = "_:vega:_" + bee++, i = Fi({});
    if (P(e))
      i.value = {
        $ingest: e
      };
    else if (e.signal) {
      const r = "setdata(" + H(n) + "," + e.signal + ")";
      i.params.input = t.signalRef(r);
    }
    return t.addDataPipeline(n, [i, ba({})]), {
      data: n,
      field: "data"
    };
  }
  function $ee(e, t, n) {
    const i = SR(e.sort, !0);
    let r, o;
    const s = n.map((l) => {
      const c = t.getData(l.data);
      return c || Kp(l.data), c.countsRef(t, l.field, i);
    }), a = {
      groupby: Qy,
      pulse: s
    };
    i && (r = i.op || "count", o = i.field ? Xp(r, i.field) : "count", a.ops = [ER[r]], a.fields = [t.fieldRef(o)], a.as = [o]), r = t.add(mR(a));
    const u = t.add(Fi({
      pulse: ie(r)
    }));
    return o = t.add(yee({
      field: Qy,
      sort: t.sortRef(i),
      pulse: ie(u)
    })), ie(o);
  }
  function SR(e, t) {
    return e && (!e.field && !e.op ? Y(e) ? e.field = "key" : e = {
      field: "key"
    } : !e.field && e.op !== "count" ? R("No field provided for sort aggregate op: " + e.op) : t && e.field && e.op && !ER[e.op] && R("Multiple domain scales can not be sorted using " + e.op)), e;
  }
  function kee(e, t, n) {
    const i = n.map((r) => {
      const o = t.getData(r.data);
      return o || Kp(r.data), o.domainRef(t, r.field);
    });
    return ie(t.add(lee({
      values: i
    })));
  }
  function Aee(e, t, n) {
    const i = n.map((r) => {
      const o = t.getData(r.data);
      return o || Kp(r.data), o.extentRef(t, r.field);
    });
    return ie(t.add(uee({
      extents: i
    })));
  }
  function Cee(e, t) {
    return e.signal || P(e) ? rh(e, t) : t.objectProperty(e);
  }
  function Fee(e, t) {
    return e.signal ? t.signalRef(e.signal) : Y(e) ? {
      interval: Gn(e.interval),
      step: Gn(e.step)
    } : Gn(e);
  }
  function Mee(e, t) {
    t.interpolate = Gn(e.type || e), e.gamma != null && (t.interpolateGamma = Gn(e.gamma));
  }
  function $R(e, t, n) {
    const i = t.config.range;
    let r = e.range;
    if (r.signal)
      return t.signalRef(r.signal);
    if (K(r)) {
      if (i && J(i, r))
        return e = ce({}, e, {
          range: i[r]
        }), $R(e, t, n);
      r === "width" ? r = [0, {
        signal: "width"
      }] : r === "height" ? r = yu(e.type) ? [0, {
        signal: "height"
      }] : [{
        signal: "height"
      }, 0] : R("Unrecognized scale range value: " + H(r));
    } else if (r.scheme) {
      n.scheme = P(r.scheme) ? rh(r.scheme, t) : Gn(r.scheme, t), r.extent && (n.schemeExtent = rh(r.extent, t)), r.count && (n.schemeCount = Gn(r.count, t));
      return;
    } else if (r.step) {
      n.rangeStep = Gn(r.step, t);
      return;
    } else {
      if (yu(e.type) && !P(r))
        return _R(r, e, t);
      P(r) || R("Unsupported range type: " + H(r));
    }
    return r.map((o) => (P(o) ? rh : Gn)(o, t));
  }
  function Tee(e, t) {
    const n = t.config.projection || {}, i = {};
    for (const r in e)
      r !== "name" && (i[r] = eb(e[r], r, t));
    for (const r in n)
      i[r] == null && (i[r] = eb(n[r], r, t));
    t.addProjection(e.name, i);
  }
  function eb(e, t, n) {
    return P(e) ? e.map((i) => eb(i, t, n)) : Y(e) ? e.signal ? n.signalRef(e.signal) : t === "fit" ? e : R("Unsupported parameter object: " + H(e)) : e;
  }
  const Mi = "top", rl = "left", ol = "right", qo = "bottom", kR = "center", Dee = "vertical", Nee = "start", Oee = "middle", Ree = "end", tb = "index", gw = "label", Lee = "offset", ku = "perc", Pee = "perc2", Yn = "value", Tf = "guide-label", pw = "guide-title", Iee = "group-title", zee = "group-subtitle", kk = "symbol", oh = "gradient", nb = "discrete", ib = "size", Bee = "shape", Uee = "fill", jee = "stroke", qee = "strokeWidth", Wee = "strokeDash", Hee = "opacity", mw = [ib, Bee, Uee, jee, qee, Wee, Hee], Df = {
    name: 1,
    style: 1,
    interactive: 1
  }, Ee = {
    value: 0
  }, Xn = {
    value: 1
  }, Jp = "group", AR = "rect", yw = "rule", Gee = "symbol", va = "text";
  function Vc(e) {
    return e.type = Jp, e.interactive = e.interactive || !1, e;
  }
  function $n(e, t) {
    const n = (i, r) => ci(e[i], ci(t[i], r));
    return n.isVertical = (i) => Dee === ci(e.direction, t.direction || (i ? t.symbolDirection : t.gradientDirection)), n.gradientLength = () => ci(e.gradientLength, t.gradientLength || t.gradientWidth), n.gradientThickness = () => ci(e.gradientThickness, t.gradientThickness || t.gradientHeight), n.entryColumns = () => ci(e.columns, ci(t.columns, +n.isVertical(!0))), n;
  }
  function CR(e, t) {
    const n = t && (t.update && t.update[e] || t.enter && t.enter[e]);
    return n && n.signal ? n : n ? n.value : null;
  }
  function Vee(e, t, n) {
    const i = t.config.style[n];
    return i && i[e];
  }
  function Qp(e, t, n) {
    return `item.anchor === '${Nee}' ? ${e} : item.anchor === '${Ree}' ? ${t} : ${n}`;
  }
  const bw = Qp(H(rl), H(ol), H(kR));
  function Yee(e) {
    const t = e("tickBand");
    let n = e("tickOffset"), i, r;
    return t ? t.signal ? (i = {
      signal: `(${t.signal}) === 'extent' ? 1 : 0.5`
    }, r = {
      signal: `(${t.signal}) === 'extent'`
    }, Y(n) || (n = {
      signal: `(${t.signal}) === 'extent' ? 0 : ${n}`
    })) : t === "extent" ? (i = 1, r = !0, n = 0) : (i = 0.5, r = !1) : (i = e("bandPosition"), r = e("tickExtra")), {
      extra: r,
      band: i,
      offset: n
    };
  }
  function FR(e, t) {
    return t ? e ? Y(e) ? Object.assign({}, e, {
      offset: FR(e.offset, t)
    }) : {
      value: e,
      offset: t
    } : t : e;
  }
  function zn(e, t) {
    return t ? (e.name = t.name, e.style = t.style || e.style, e.interactive = !!t.interactive, e.encode = il(e.encode, t, Df)) : e.interactive = !1, e;
  }
  function Xee(e, t, n, i) {
    const r = $n(e, n), o = r.isVertical(), s = r.gradientThickness(), a = r.gradientLength();
    let u, l, c, f, d;
    o ? (l = [0, 1], c = [0, 0], f = s, d = a) : (l = [0, 0], c = [1, 0], f = a, d = s);
    const h = {
      enter: u = {
        opacity: Ee,
        x: Ee,
        y: Ee,
        width: pt(f),
        height: pt(d)
      },
      update: ce({}, u, {
        opacity: Xn,
        fill: {
          gradient: t,
          start: l,
          stop: c
        }
      }),
      exit: {
        opacity: Ee
      }
    };
    return Mt(h, {
      stroke: r("gradientStrokeColor"),
      strokeWidth: r("gradientStrokeWidth")
    }, {
      // update
      opacity: r("gradientOpacity")
    }), zn({
      type: AR,
      role: EZ,
      encode: h
    }, i);
  }
  function Kee(e, t, n, i, r) {
    const o = $n(e, n), s = o.isVertical(), a = o.gradientThickness(), u = o.gradientLength();
    let l, c, f, d, h = "";
    s ? (l = "y", f = "y2", c = "x", d = "width", h = "1-") : (l = "x", f = "x2", c = "y", d = "height");
    const g = {
      opacity: Ee,
      fill: {
        scale: t,
        field: Yn
      }
    };
    g[l] = {
      signal: h + "datum." + ku,
      mult: u
    }, g[c] = Ee, g[f] = {
      signal: h + "datum." + Pee,
      mult: u
    }, g[d] = pt(a);
    const p = {
      enter: g,
      update: ce({}, g, {
        opacity: Xn
      }),
      exit: {
        opacity: Ee
      }
    };
    return Mt(p, {
      stroke: o("gradientStrokeColor"),
      strokeWidth: o("gradientStrokeWidth")
    }, {
      // update
      opacity: o("gradientOpacity")
    }), zn({
      type: AR,
      role: xZ,
      key: Yn,
      from: r,
      encode: p
    }, i);
  }
  const Jee = `datum.${ku}<=0?"${rl}":datum.${ku}>=1?"${ol}":"${kR}"`, Qee = `datum.${ku}<=0?"${qo}":datum.${ku}>=1?"${Mi}":"${Oee}"`;
  function Ak(e, t, n, i) {
    const r = $n(e, t), o = r.isVertical(), s = pt(r.gradientThickness()), a = r.gradientLength();
    let u = r("labelOverlap"), l, c, f, d, h = "";
    const g = {
      enter: l = {
        opacity: Ee
      },
      update: c = {
        opacity: Xn,
        text: {
          field: gw
        }
      },
      exit: {
        opacity: Ee
      }
    };
    return Mt(g, {
      fill: r("labelColor"),
      fillOpacity: r("labelOpacity"),
      font: r("labelFont"),
      fontSize: r("labelFontSize"),
      fontStyle: r("labelFontStyle"),
      fontWeight: r("labelFontWeight"),
      limit: ci(e.labelLimit, t.gradientLabelLimit)
    }), o ? (l.align = {
      value: "left"
    }, l.baseline = c.baseline = {
      signal: Qee
    }, f = "y", d = "x", h = "1-") : (l.align = c.align = {
      signal: Jee
    }, l.baseline = {
      value: "top"
    }, f = "x", d = "y"), l[f] = c[f] = {
      signal: h + "datum." + ku,
      mult: a
    }, l[d] = c[d] = s, s.offset = ci(e.labelOffset, t.gradientLabelOffset) || 0, u = u ? {
      separation: r("labelSeparation"),
      method: u,
      order: "datum." + tb
    } : void 0, zn({
      type: va,
      role: cR,
      style: Tf,
      key: Yn,
      from: i,
      encode: g,
      overlap: u
    }, n);
  }
  function Zee(e, t, n, i, r) {
    const o = $n(e, t), s = n.entries, a = !!(s && s.interactive), u = s ? s.name : void 0, l = o("clipHeight"), c = o("symbolOffset"), f = {
      data: "value"
    }, d = `(${r}) ? datum.${Lee} : datum.${ib}`, h = l ? pt(l) : {
      field: ib
    }, g = `datum.${tb}`, p = `max(1, ${r})`;
    let m, y, b, v, x;
    h.mult = 0.5, m = {
      enter: y = {
        opacity: Ee,
        x: {
          signal: d,
          mult: 0.5,
          offset: c
        },
        y: h
      },
      update: b = {
        opacity: Xn,
        x: y.x,
        y: y.y
      },
      exit: {
        opacity: Ee
      }
    };
    let w = null, _ = null;
    e.fill || (w = t.symbolBaseFillColor, _ = t.symbolBaseStrokeColor), Mt(m, {
      fill: o("symbolFillColor", w),
      shape: o("symbolType"),
      size: o("symbolSize"),
      stroke: o("symbolStrokeColor", _),
      strokeDash: o("symbolDash"),
      strokeDashOffset: o("symbolDashOffset"),
      strokeWidth: o("symbolStrokeWidth")
    }, {
      // update
      opacity: o("symbolOpacity")
    }), mw.forEach((F) => {
      e[F] && (b[F] = y[F] = {
        scale: e[F],
        field: Yn
      });
    });
    const E = zn({
      type: Gee,
      role: _Z,
      key: Yn,
      from: f,
      clip: l ? !0 : void 0,
      encode: m
    }, n.symbols), S = pt(c);
    S.offset = o("labelOffset"), m = {
      enter: y = {
        opacity: Ee,
        x: {
          signal: d,
          offset: S
        },
        y: h
      },
      update: b = {
        opacity: Xn,
        text: {
          field: gw
        },
        x: y.x,
        y: y.y
      },
      exit: {
        opacity: Ee
      }
    }, Mt(m, {
      align: o("labelAlign"),
      baseline: o("labelBaseline"),
      fill: o("labelColor"),
      fillOpacity: o("labelOpacity"),
      font: o("labelFont"),
      fontSize: o("labelFontSize"),
      fontStyle: o("labelFontStyle"),
      fontWeight: o("labelFontWeight"),
      limit: o("labelLimit")
    });
    const $ = zn({
      type: va,
      role: cR,
      style: Tf,
      key: Yn,
      from: f,
      encode: m
    }, n.labels);
    return m = {
      enter: {
        noBound: {
          value: !l
        },
        // ignore width/height in bounds calc
        width: Ee,
        height: l ? pt(l) : Ee,
        opacity: Ee
      },
      exit: {
        opacity: Ee
      },
      update: b = {
        opacity: Xn,
        row: {
          signal: null
        },
        column: {
          signal: null
        }
      }
    }, o.isVertical(!0) ? (v = `ceil(item.mark.items.length / ${p})`, b.row.signal = `${g}%${v}`, b.column.signal = `floor(${g} / ${v})`, x = {
      field: ["row", g]
    }) : (b.row.signal = `floor(${g} / ${p})`, b.column.signal = `${g} % ${p}`, x = {
      field: g
    }), b.column.signal = `(${r})?${b.column.signal}:${g}`, i = {
      facet: {
        data: i,
        name: "value",
        groupby: tb
      }
    }, Vc({
      role: fw,
      from: i,
      encode: il(m, s, Df),
      marks: [E, $],
      name: u,
      interactive: a,
      sort: x
    });
  }
  function ete(e, t) {
    const n = $n(e, t);
    return {
      align: n("gridAlign"),
      columns: n.entryColumns(),
      center: {
        row: !0,
        column: !1
      },
      padding: {
        row: n("rowPadding"),
        column: n("columnPadding")
      }
    };
  }
  const vw = 'item.orient === "left"', xw = 'item.orient === "right"', Zp = `(${vw} || ${xw})`, tte = `datum.vgrad && ${Zp}`, nte = Qp('"top"', '"bottom"', '"middle"'), ite = Qp('"right"', '"left"', '"center"'), rte = `datum.vgrad && ${xw} ? (${ite}) : (${Zp} && !(datum.vgrad && ${vw})) ? "left" : ${bw}`, ote = `item._anchor || (${Zp} ? "middle" : "start")`, ste = `${tte} ? (${vw} ? -90 : 90) : 0`, ate = `${Zp} ? (datum.vgrad ? (${xw} ? "bottom" : "top") : ${nte}) : "top"`;
  function ute(e, t, n, i) {
    const r = $n(e, t), o = {
      enter: {
        opacity: Ee
      },
      update: {
        opacity: Xn,
        x: {
          field: {
            group: "padding"
          }
        },
        y: {
          field: {
            group: "padding"
          }
        }
      },
      exit: {
        opacity: Ee
      }
    };
    return Mt(o, {
      orient: r("titleOrient"),
      _anchor: r("titleAnchor"),
      anchor: {
        signal: ote
      },
      angle: {
        signal: ste
      },
      align: {
        signal: rte
      },
      baseline: {
        signal: ate
      },
      text: e.title,
      fill: r("titleColor"),
      fillOpacity: r("titleOpacity"),
      font: r("titleFont"),
      fontSize: r("titleFontSize"),
      fontStyle: r("titleFontStyle"),
      fontWeight: r("titleFontWeight"),
      limit: r("titleLimit"),
      lineHeight: r("titleLineHeight")
    }, {
      // require update
      align: r("titleAlign"),
      baseline: r("titleBaseline")
    }), zn({
      type: va,
      role: SZ,
      style: pw,
      from: i,
      encode: o
    }, n);
  }
  function lte(e, t) {
    let n;
    return Y(e) && (e.signal ? n = e.signal : e.path ? n = "pathShape(" + Ck(e.path) + ")" : e.sphere && (n = "geoShape(" + Ck(e.sphere) + ', {type: "Sphere"})')), n ? t.signalRef(n) : !!e;
  }
  function Ck(e) {
    return Y(e) && e.signal ? e.signal : H(e);
  }
  function MR(e) {
    const t = e.role || "";
    return t.startsWith("axis") || t.startsWith("legend") || t.startsWith("title") ? t : e.type === Jp ? fw : t || lw;
  }
  function cte(e) {
    return {
      marktype: e.type,
      name: e.name || void 0,
      role: e.role || MR(e),
      zindex: +e.zindex || void 0,
      aria: e.aria,
      description: e.description
    };
  }
  function fte(e, t) {
    return e && e.signal ? t.signalRef(e.signal) : e !== !1;
  }
  function ww(e, t) {
    const n = cM(e.type);
    n || R("Unrecognized transform type: " + H(e.type));
    const i = Yp(n.type.toLowerCase(), null, TR(n, e, t));
    return e.signal && t.addSignal(e.signal, t.proxy(i)), i.metadata = n.metadata || {}, i;
  }
  function TR(e, t, n) {
    const i = {}, r = e.params.length;
    for (let o = 0; o < r; ++o) {
      const s = e.params[o];
      i[s.name] = dte(s, t, n);
    }
    return i;
  }
  function dte(e, t, n) {
    const i = e.type, r = t[e.name];
    if (i === "index")
      return hte(e, t, n);
    if (r === void 0) {
      e.required && R("Missing required " + H(t.type) + " parameter: " + H(e.name));
      return;
    } else {
      if (i === "param")
        return gte(e, t, n);
      if (i === "projection")
        return n.projectionRef(t[e.name]);
    }
    return e.array && !at(r) ? r.map((o) => Fk(e, o, n)) : Fk(e, r, n);
  }
  function Fk(e, t, n) {
    const i = e.type;
    if (at(t))
      return Tk(i) ? R("Expression references can not be signals.") : J0(i) ? n.fieldRef(t) : Dk(i) ? n.compareRef(t) : n.signalRef(t.signal);
    {
      const r = e.expr || J0(i);
      return r && pte(t) ? n.exprRef(t.expr, t.as) : r && mte(t) ? Hc(t.field, t.as) : Tk(i) ? ar(t, n) : yte(i) ? ie(n.getData(t).values) : J0(i) ? Hc(t) : Dk(i) ? n.compareRef(t) : t;
    }
  }
  function hte(e, t, n) {
    return K(t.from) || R('Lookup "from" parameter must be a string literal.'), n.getData(t.from).lookupRef(n, t.key);
  }
  function gte(e, t, n) {
    const i = t[e.name];
    return e.array ? (P(i) || R("Expected an array of sub-parameters. Instead: " + H(i)), i.map((r) => Mk(e, r, n))) : Mk(e, i, n);
  }
  function Mk(e, t, n) {
    const i = e.params.length;
    let r;
    for (let s = 0; s < i; ++s) {
      r = e.params[s];
      for (const a in r.key)
        if (r.key[a] !== t[a]) {
          r = null;
          break;
        }
      if (r) break;
    }
    r || R("Unsupported parameter: " + H(t));
    const o = ce(TR(r, t, n), r.key);
    return ie(n.add(fee(o)));
  }
  const pte = (e) => e && e.expr, mte = (e) => e && e.field, yte = (e) => e === "data", Tk = (e) => e === "expr", J0 = (e) => e === "field", Dk = (e) => e === "compare";
  function bte(e, t, n) {
    let i, r, o, s, a;
    return e ? (i = e.facet) && (t || R("Only group marks can be faceted."), i.field != null ? s = a = sh(i, n) : (e.data ? a = ie(n.getData(e.data).aggregate) : (o = ww(ce({
      type: "aggregate",
      groupby: X(i.groupby)
    }, i.aggregate), n), o.params.key = n.keyRef(i.groupby), o.params.pulse = sh(i, n), s = a = ie(n.add(o))), r = n.keyRef(i.groupby, !0))) : s = ie(n.add(Fi(null, [{}]))), s || (s = sh(e, n)), {
      key: r,
      pulse: s,
      parent: a
    };
  }
  function sh(e, t) {
    return e.$ref ? e : e.data && e.data.$ref ? e.data : ie(t.getData(e.data).output);
  }
  function ta(e, t, n, i, r) {
    this.scope = e, this.input = t, this.output = n, this.values = i, this.aggregate = r, this.index = {};
  }
  ta.fromEntries = function(e, t) {
    const n = t.length, i = t[n - 1], r = t[n - 2];
    let o = t[0], s = null, a = 1;
    for (o && o.type === "load" && (o = t[1]), e.add(t[0]); a < n; ++a)
      t[a].params.pulse = ie(t[a - 1]), e.add(t[a]), t[a].type === "aggregate" && (s = t[a]);
    return new ta(e, o, r, i, s);
  };
  function DR(e) {
    return K(e) ? e : null;
  }
  function Nk(e, t, n) {
    const i = Xp(n.op, n.field);
    let r;
    if (t.ops) {
      for (let o = 0, s = t.as.length; o < s; ++o)
        if (t.as[o] === i) return;
    } else
      t.ops = ["count"], t.fields = [null], t.as = ["count"];
    n.op && (t.ops.push((r = n.op.signal) ? e.signalRef(r) : n.op), t.fields.push(e.fieldRef(n.field)), t.as.push(i));
  }
  function Dl(e, t, n, i, r, o, s) {
    const a = t[n] || (t[n] = {}), u = UZ(o);
    let l = DR(r), c, f;
    if (l != null && (e = t.scope, l = l + (u ? "|" + u : ""), c = a[l]), !c) {
      const d = o ? {
        field: Qy,
        pulse: t.countsRef(e, r, o)
      } : {
        field: e.fieldRef(r),
        pulse: ie(t.output)
      };
      u && (d.sort = e.sortRef(o)), f = e.add(Yp(i, void 0, d)), s && (t.index[r] = f), c = ie(f), l != null && (a[l] = c);
    }
    return c;
  }
  ta.prototype = {
    countsRef(e, t, n) {
      const i = this, r = i.counts || (i.counts = {}), o = DR(t);
      let s, a, u;
      return o != null && (e = i.scope, s = r[o]), s ? n && n.field && Nk(e, s.agg.params, n) : (u = {
        groupby: e.fieldRef(t, "key"),
        pulse: ie(i.output)
      }, n && n.field && Nk(e, u, n), a = e.add(mR(u)), s = e.add(Fi({
        pulse: ie(a)
      })), s = {
        agg: a,
        ref: ie(s)
      }, o != null && (r[o] = s)), s.ref;
    },
    tuplesRef() {
      return ie(this.values);
    },
    extentRef(e, t) {
      return Dl(e, this, "extent", "extent", t, !1);
    },
    domainRef(e, t) {
      return Dl(e, this, "domain", "values", t, !1);
    },
    valuesRef(e, t, n) {
      return Dl(e, this, "vals", "values", t, n || !0);
    },
    lookupRef(e, t) {
      return Dl(e, this, "lookup", "tupleindex", t, !1);
    },
    indataRef(e, t) {
      return Dl(e, this, "indata", "tupleindex", t, !0, !0);
    }
  };
  function vte(e, t, n) {
    const i = e.from.facet, r = i.name, o = sh(i, t);
    let s;
    i.name || R("Facet must have a name: " + H(i)), i.data || R("Facet must reference a data set: " + H(i)), i.field ? s = t.add(vR({
      field: t.fieldRef(i.field),
      pulse: o
    })) : i.groupby ? s = t.add(nee({
      key: t.keyRef(i.groupby),
      group: ie(t.proxy(n.parent)),
      pulse: o
    })) : R("Facet must specify groupby or field: " + H(i));
    const a = t.fork(), u = a.add(Fi()), l = a.add(ba({
      pulse: ie(u)
    }));
    a.addData(r, new ta(a, u, u, l)), a.addSignal("parent", null), s.params.subflow = {
      $subflow: a.parse(e).toRuntime()
    };
  }
  function xte(e, t, n) {
    const i = t.add(vR({
      pulse: n.pulse
    })), r = t.fork();
    r.add(ba()), r.addSignal("parent", null), i.params.subflow = {
      $subflow: r.parse(e).toRuntime()
    };
  }
  function NR(e, t, n) {
    const i = e.remove, r = e.insert, o = e.toggle, s = e.modify, a = e.values, u = t.add($g()), l = "if(" + e.trigger + ',modify("' + n + '",' + [r, i, o, s, a].map((f) => f ?? "null").join(",") + "),0)", c = ar(l, t);
    u.update = c.$expr, u.params = c.$params;
  }
  function em(e, t) {
    const n = MR(e), i = e.type === Jp, r = e.from && e.from.facet, o = e.overlap;
    let s = e.layout || n === fw || n === cw, a, u, l, c, f, d, h;
    const g = n === lw || s || r, p = bte(e.from, i, t);
    u = t.add(eee({
      key: p.key || (e.key ? Hc(e.key) : void 0),
      pulse: p.pulse,
      clean: !i
    }));
    const m = ie(u);
    u = l = t.add(Fi({
      pulse: m
    })), u = t.add(aee({
      markdef: cte(e),
      interactive: fte(e.interactive, t),
      clip: lte(e.clip, t),
      context: {
        $context: !0
      },
      groups: t.lookup(),
      parent: t.signals.parent ? t.signalRef("parent") : null,
      index: t.markpath(),
      pulse: ie(u)
    }));
    const y = ie(u);
    u = c = t.add(bR(gR(e.encode, e.type, n, e.style, t, {
      mod: !1,
      pulse: y
    }))), u.params.parent = t.encode(), e.transform && e.transform.forEach((_) => {
      const E = ww(_, t), S = E.metadata;
      (S.generates || S.changes) && R("Mark transforms should not generate new data."), S.nomod || (c.params.mod = !0), E.params.pulse = ie(u), t.add(u = E);
    }), e.sort && (u = t.add(mee({
      sort: t.compareRef(e.sort),
      pulse: ie(u)
    })));
    const b = ie(u);
    (r || s) && (s = t.add(wR({
      layout: t.objectProperty(e.layout),
      legends: t.legends,
      mark: y,
      pulse: b
    })), d = ie(s));
    const v = t.add(yR({
      mark: y,
      pulse: d || b
    }));
    h = ie(v), i && (g && (a = t.operators, a.pop(), s && a.pop()), t.pushState(b, d || h, m), r ? vte(e, t, p) : g ? xte(e, t, p) : t.parse(e), t.popState(), g && (s && a.push(s), a.push(v))), o && (h = wte(o, h, t));
    const x = t.add(xR({
      pulse: h
    })), w = t.add(ba({
      pulse: ie(x)
    }, void 0, t.parent()));
    e.name != null && (f = e.name, t.addData(f, new ta(t, l, x, w)), e.on && e.on.forEach((_) => {
      (_.insert || _.remove || _.toggle) && R("Marks only support modify triggers."), NR(_, t, f);
    }));
  }
  function wte(e, t, n) {
    const i = e.method, r = e.bound, o = e.separation, s = {
      separation: at(o) ? n.signalRef(o.signal) : o,
      method: at(i) ? n.signalRef(i.signal) : i,
      pulse: t
    };
    if (e.order && (s.sort = n.compareRef({
      field: e.order
    })), r) {
      const a = r.tolerance;
      s.boundTolerance = at(a) ? n.signalRef(a.signal) : +a, s.boundScale = n.scaleRef(r.scale), s.boundOrient = r.orient;
    }
    return ie(n.add(cee(s)));
  }
  function Ete(e, t) {
    const n = t.config.legend, i = e.encode || {}, r = $n(e, n), o = i.legend || {}, s = o.name || void 0, a = o.interactive, u = o.style, l = {};
    let c = 0, f, d, h;
    mw.forEach((v) => e[v] ? (l[v] = e[v], c = c || e[v]) : 0), c || R("Missing valid scale for legend.");
    const g = _te(e, t.scaleType(c)), p = {
      title: e.title != null,
      scales: l,
      type: g,
      vgrad: g !== "symbol" && r.isVertical()
    }, m = ie(t.add(Fi(null, [p]))), y = {
      enter: {
        x: {
          value: 0
        },
        y: {
          value: 0
        }
      }
    }, b = ie(t.add(oee(d = {
      type: g,
      scale: t.scaleRef(c),
      count: t.objectProperty(r("tickCount")),
      limit: t.property(r("symbolLimit")),
      values: t.objectProperty(e.values),
      minstep: t.property(e.tickMinStep),
      formatType: t.property(e.formatType),
      formatSpecifier: t.property(e.format)
    })));
    return g === oh ? (h = [Xee(e, c, n, i.gradient), Ak(e, n, i.labels, b)], d.count = d.count || t.signalRef(`max(2,2*floor((${zs(r.gradientLength())})/100))`)) : g === nb ? h = [Kee(e, c, n, i.gradient, b), Ak(e, n, i.labels, b)] : (f = ete(e, n), h = [Zee(e, n, i, b, zs(f.columns))], d.size = kte(e, t, h[0].marks)), h = [Vc({
      role: wZ,
      from: m,
      encode: y,
      marks: h,
      layout: f,
      interactive: a
    })], p.title && h.push(ute(e, n, i.title, m)), em(Vc({
      role: vZ,
      from: m,
      encode: il($te(r, e, n), o, Df),
      marks: h,
      aria: r("aria"),
      description: r("description"),
      zindex: r("zindex"),
      name: s,
      interactive: a,
      style: u
    }), t);
  }
  function _te(e, t) {
    let n = e.type || kk;
    return !e.type && Ste(e) === 1 && (e.fill || e.stroke) && (n = xx(t) ? oh : Y1(t) ? nb : kk), n !== oh ? n : Y1(t) ? nb : oh;
  }
  function Ste(e) {
    return mw.reduce((t, n) => t + (e[n] ? 1 : 0), 0);
  }
  function $te(e, t, n) {
    const i = {
      enter: {},
      update: {}
    };
    return Mt(i, {
      orient: e("orient"),
      offset: e("offset"),
      padding: e("padding"),
      titlePadding: e("titlePadding"),
      cornerRadius: e("cornerRadius"),
      fill: e("fillColor"),
      stroke: e("strokeColor"),
      strokeWidth: n.strokeWidth,
      strokeDash: n.strokeDash,
      x: e("legendX"),
      y: e("legendY"),
      // accessibility support
      format: t.format,
      formatType: t.formatType
    }), i;
  }
  function kte(e, t, n) {
    const i = zs(Ok("size", e, n)), r = zs(Ok("strokeWidth", e, n)), o = zs(Ate(n[1].encode, t, Tf));
    return ar(`max(ceil(sqrt(${i})+${r}),${o})`, t);
  }
  function Ok(e, t, n) {
    return t[e] ? `scale("${t[e]}",datum)` : CR(e, n[0].encode);
  }
  function Ate(e, t, n) {
    return CR("fontSize", e) || Vee("fontSize", t, n);
  }
  const Cte = `item.orient==="${rl}"?-90:item.orient==="${ol}"?90:0`;
  function Fte(e, t) {
    e = K(e) ? {
      text: e
    } : e;
    const n = $n(e, t.config.title), i = e.encode || {}, r = i.group || {}, o = r.name || void 0, s = r.interactive, a = r.style, u = [], l = {}, c = ie(t.add(Fi(null, [l])));
    return u.push(Dte(e, n, Mte(e), c)), e.subtitle && u.push(Nte(e, n, i.subtitle, c)), em(Vc({
      role: $Z,
      from: c,
      encode: Tte(n, r),
      marks: u,
      aria: n("aria"),
      description: n("description"),
      zindex: n("zindex"),
      name: o,
      interactive: s,
      style: a
    }), t);
  }
  function Mte(e) {
    const t = e.encode;
    return t && t.title || ce({
      name: e.name,
      interactive: e.interactive,
      style: e.style
    }, t);
  }
  function Tte(e, t) {
    const n = {
      enter: {},
      update: {}
    };
    return Mt(n, {
      orient: e("orient"),
      anchor: e("anchor"),
      align: {
        signal: bw
      },
      angle: {
        signal: Cte
      },
      limit: e("limit"),
      frame: e("frame"),
      offset: e("offset") || 0,
      padding: e("subtitlePadding")
    }), il(n, t, Df);
  }
  function Dte(e, t, n, i) {
    const r = {
      value: 0
    }, o = e.text, s = {
      enter: {
        opacity: r
      },
      update: {
        opacity: {
          value: 1
        }
      },
      exit: {
        opacity: r
      }
    };
    return Mt(s, {
      text: o,
      align: {
        signal: "item.mark.group.align"
      },
      angle: {
        signal: "item.mark.group.angle"
      },
      limit: {
        signal: "item.mark.group.limit"
      },
      baseline: "top",
      dx: t("dx"),
      dy: t("dy"),
      fill: t("color"),
      font: t("font"),
      fontSize: t("fontSize"),
      fontStyle: t("fontStyle"),
      fontWeight: t("fontWeight"),
      lineHeight: t("lineHeight")
    }, {
      // update
      align: t("align"),
      angle: t("angle"),
      baseline: t("baseline")
    }), zn({
      type: va,
      role: kZ,
      style: Iee,
      from: i,
      encode: s
    }, n);
  }
  function Nte(e, t, n, i) {
    const r = {
      value: 0
    }, o = e.subtitle, s = {
      enter: {
        opacity: r
      },
      update: {
        opacity: {
          value: 1
        }
      },
      exit: {
        opacity: r
      }
    };
    return Mt(s, {
      text: o,
      align: {
        signal: "item.mark.group.align"
      },
      angle: {
        signal: "item.mark.group.angle"
      },
      limit: {
        signal: "item.mark.group.limit"
      },
      baseline: "top",
      dx: t("dx"),
      dy: t("dy"),
      fill: t("subtitleColor"),
      font: t("subtitleFont"),
      fontSize: t("subtitleFontSize"),
      fontStyle: t("subtitleFontStyle"),
      fontWeight: t("subtitleFontWeight"),
      lineHeight: t("subtitleLineHeight")
    }, {
      // update
      align: t("align"),
      angle: t("angle"),
      baseline: t("baseline")
    }), zn({
      type: va,
      role: AZ,
      style: zee,
      from: i,
      encode: s
    }, n);
  }
  function Ote(e, t) {
    const n = [];
    e.transform && e.transform.forEach((i) => {
      n.push(ww(i, t));
    }), e.on && e.on.forEach((i) => {
      NR(i, t, e.name);
    }), t.addDataPipeline(e.name, Rte(e, t, n));
  }
  function Rte(e, t, n) {
    const i = [];
    let r = null, o = !1, s = !1, a, u, l, c, f;
    for (e.values ? at(e.values) || ih(e.format) ? (i.push(Rk(t, e)), i.push(r = hs())) : i.push(r = hs({
      $ingest: e.values,
      $format: e.format
    })) : e.url ? ih(e.url) || ih(e.format) ? (i.push(Rk(t, e)), i.push(r = hs())) : i.push(r = hs({
      $request: e.url,
      $format: e.format
    })) : e.source && (r = a = X(e.source).map((d) => ie(t.getData(d).output)), i.push(null)), u = 0, l = n.length; u < l; ++u)
      c = n[u], f = c.metadata, !r && !f.source && i.push(r = hs()), i.push(c), f.generates && (s = !0), f.modifies && !s && (o = !0), f.source ? r = c : f.changes && (r = null);
    return a && (l = a.length - 1, i[0] = gee({
      derive: o,
      pulse: l ? a : a[0]
    }), (o || l) && i.splice(1, 0, hs())), r || i.push(hs()), i.push(ba({})), i;
  }
  function hs(e) {
    const t = Fi({}, e);
    return t.metadata = {
      source: !0
    }, t;
  }
  function Rk(e, t) {
    return see({
      url: t.url ? e.property(t.url) : void 0,
      async: t.async ? e.property(t.async) : void 0,
      values: t.values ? e.property(t.values) : void 0,
      format: e.objectProperty(t.format)
    });
  }
  const OR = (e) => e === qo || e === Mi, tm = (e, t, n) => at(e) ? zte(e.signal, t, n) : e === rl || e === Mi ? t : n, mt = (e, t, n) => at(e) ? Pte(e.signal, t, n) : OR(e) ? t : n, vi = (e, t, n) => at(e) ? Ite(e.signal, t, n) : OR(e) ? n : t, RR = (e, t, n) => at(e) ? Bte(e.signal, t, n) : e === Mi ? {
    value: t
  } : {
    value: n
  }, Lte = (e, t, n) => at(e) ? Ute(e.signal, t, n) : e === ol ? {
    value: t
  } : {
    value: n
  }, Pte = (e, t, n) => LR(`${e} === '${Mi}' || ${e} === '${qo}'`, t, n), Ite = (e, t, n) => LR(`${e} !== '${Mi}' && ${e} !== '${qo}'`, t, n), zte = (e, t, n) => Ew(`${e} === '${rl}' || ${e} === '${Mi}'`, t, n), Bte = (e, t, n) => Ew(`${e} === '${Mi}'`, t, n), Ute = (e, t, n) => Ew(`${e} === '${ol}'`, t, n), LR = (e, t, n) => (t = t != null ? pt(t) : t, n = n != null ? pt(n) : n, Lk(t) && Lk(n) ? (t = t ? t.signal || H(t.value) : null, n = n ? n.signal || H(n.value) : null, {
    signal: `${e} ? (${t}) : (${n})`
  }) : [ce({
    test: e
  }, t)].concat(n || [])), Lk = (e) => e == null || Object.keys(e).length === 1, Ew = (e, t, n) => ({
    signal: `${e} ? (${Ka(t)}) : (${Ka(n)})`
  }), jte = (e, t, n, i, r) => ({
    signal: (i != null ? `${e} === '${rl}' ? (${Ka(i)}) : ` : "") + (n != null ? `${e} === '${qo}' ? (${Ka(n)}) : ` : "") + (r != null ? `${e} === '${ol}' ? (${Ka(r)}) : ` : "") + (t != null ? `${e} === '${Mi}' ? (${Ka(t)}) : ` : "") + "(null)"
  }), Ka = (e) => at(e) ? e.signal : e == null ? null : H(e), qte = (e, t) => t === 0 ? 0 : at(e) ? {
    signal: `(${e.signal}) * ${t}`
  } : {
    value: e * t
  }, tu = (e, t) => {
    const n = e.signal;
    return n && n.endsWith("(null)") ? {
      signal: n.slice(0, -6) + t.signal
    } : e;
  };
  function Pa(e, t, n, i) {
    let r;
    if (t && J(t, e))
      return t[e];
    if (J(n, e))
      return n[e];
    if (e.startsWith("title")) {
      switch (e) {
        case "titleColor":
          r = "fill";
          break;
        case "titleFont":
        case "titleFontSize":
        case "titleFontWeight":
          r = e[5].toLowerCase() + e.slice(6);
      }
      return i[pw][r];
    } else if (e.startsWith("label")) {
      switch (e) {
        case "labelColor":
          r = "fill";
          break;
        case "labelFont":
        case "labelFontSize":
          r = e[5].toLowerCase() + e.slice(6);
      }
      return i[Tf][r];
    }
    return null;
  }
  function Pk(e) {
    const t = {};
    for (const n of e)
      if (n)
        for (const i in n) t[i] = 1;
    return Object.keys(t);
  }
  function Wte(e, t) {
    var n = t.config, i = n.style, r = n.axis, o = t.scaleType(e.scale) === "band" && n.axisBand, s = e.orient, a, u, l;
    if (at(s)) {
      const f = Pk([n.axisX, n.axisY]), d = Pk([n.axisTop, n.axisBottom, n.axisLeft, n.axisRight]);
      a = {};
      for (l of f)
        a[l] = mt(s, Pa(l, n.axisX, r, i), Pa(l, n.axisY, r, i));
      u = {};
      for (l of d)
        u[l] = jte(s.signal, Pa(l, n.axisTop, r, i), Pa(l, n.axisBottom, r, i), Pa(l, n.axisLeft, r, i), Pa(l, n.axisRight, r, i));
    } else
      a = s === Mi || s === qo ? n.axisX : n.axisY, u = n["axis" + s[0].toUpperCase() + s.slice(1)];
    return a || u || o ? ce({}, r, a, u, o) : r;
  }
  function Hte(e, t, n, i) {
    const r = $n(e, t), o = e.orient;
    let s, a;
    const u = {
      enter: s = {
        opacity: Ee
      },
      update: a = {
        opacity: Xn
      },
      exit: {
        opacity: Ee
      }
    };
    Mt(u, {
      stroke: r("domainColor"),
      strokeCap: r("domainCap"),
      strokeDash: r("domainDash"),
      strokeDashOffset: r("domainDashOffset"),
      strokeWidth: r("domainWidth"),
      strokeOpacity: r("domainOpacity")
    });
    const l = Ik(e, 0), c = Ik(e, 1);
    return s.x = a.x = mt(o, l, Ee), s.x2 = a.x2 = mt(o, c), s.y = a.y = vi(o, l, Ee), s.y2 = a.y2 = vi(o, c), zn({
      type: yw,
      role: gZ,
      from: i,
      encode: u
    }, n);
  }
  function Ik(e, t) {
    return {
      scale: e.scale,
      range: t
    };
  }
  function Gte(e, t, n, i, r) {
    const o = $n(e, t), s = e.orient, a = e.gridScale, u = tm(s, 1, -1), l = Vte(e.offset, u);
    let c, f, d;
    const h = {
      enter: c = {
        opacity: Ee
      },
      update: d = {
        opacity: Xn
      },
      exit: f = {
        opacity: Ee
      }
    };
    Mt(h, {
      stroke: o("gridColor"),
      strokeCap: o("gridCap"),
      strokeDash: o("gridDash"),
      strokeDashOffset: o("gridDashOffset"),
      strokeOpacity: o("gridOpacity"),
      strokeWidth: o("gridWidth")
    });
    const g = {
      scale: e.scale,
      field: Yn,
      band: r.band,
      extra: r.extra,
      offset: r.offset,
      round: o("tickRound")
    }, p = mt(s, {
      signal: "height"
    }, {
      signal: "width"
    }), m = a ? {
      scale: a,
      range: 0,
      mult: u,
      offset: l
    } : {
      value: 0,
      offset: l
    }, y = a ? {
      scale: a,
      range: 1,
      mult: u,
      offset: l
    } : ce(p, {
      mult: u,
      offset: l
    });
    return c.x = d.x = mt(s, g, m), c.y = d.y = vi(s, g, m), c.x2 = d.x2 = vi(s, y), c.y2 = d.y2 = mt(s, y), f.x = mt(s, g), f.y = vi(s, g), zn({
      type: yw,
      role: pZ,
      key: Yn,
      from: i,
      encode: h
    }, n);
  }
  function Vte(e, t) {
    if (t !== 1) if (!Y(e))
      e = at(t) ? {
        signal: `(${t.signal}) * (${e || 0})`
      } : t * (e || 0);
    else {
      let n = e = ce({}, e);
      for (; n.mult != null; )
        if (Y(n.mult))
          n = n.mult = ce({}, n.mult);
        else
          return n.mult = at(t) ? {
            signal: `(${n.mult}) * (${t.signal})`
          } : n.mult * t, e;
      n.mult = t;
    }
    return e;
  }
  function Yte(e, t, n, i, r, o) {
    const s = $n(e, t), a = e.orient, u = tm(a, -1, 1);
    let l, c, f;
    const d = {
      enter: l = {
        opacity: Ee
      },
      update: f = {
        opacity: Xn
      },
      exit: c = {
        opacity: Ee
      }
    };
    Mt(d, {
      stroke: s("tickColor"),
      strokeCap: s("tickCap"),
      strokeDash: s("tickDash"),
      strokeDashOffset: s("tickDashOffset"),
      strokeOpacity: s("tickOpacity"),
      strokeWidth: s("tickWidth")
    });
    const h = pt(r);
    h.mult = u;
    const g = {
      scale: e.scale,
      field: Yn,
      band: o.band,
      extra: o.extra,
      offset: o.offset,
      round: s("tickRound")
    };
    return f.y = l.y = mt(a, Ee, g), f.y2 = l.y2 = mt(a, h), c.x = mt(a, g), f.x = l.x = vi(a, Ee, g), f.x2 = l.x2 = vi(a, h), c.y = vi(a, g), zn({
      type: yw,
      role: yZ,
      key: Yn,
      from: i,
      encode: d
    }, n);
  }
  function Q0(e, t, n, i, r) {
    return {
      signal: 'flush(range("' + e + '"), scale("' + e + '", datum.value), ' + t + "," + n + "," + i + "," + r + ")"
    };
  }
  function Xte(e, t, n, i, r, o) {
    const s = $n(e, t), a = e.orient, u = e.scale, l = tm(a, -1, 1), c = zs(s("labelFlush")), f = zs(s("labelFlushOffset")), d = s("labelAlign"), h = s("labelBaseline");
    let g = c === 0 || !!c, p;
    const m = pt(r);
    m.mult = l, m.offset = pt(s("labelPadding") || 0), m.offset.mult = l;
    const y = {
      scale: u,
      field: Yn,
      band: 0.5,
      offset: FR(o.offset, s("labelOffset"))
    }, b = mt(a, g ? Q0(u, c, '"left"', '"right"', '"center"') : {
      value: "center"
    }, Lte(a, "left", "right")), v = mt(a, RR(a, "bottom", "top"), g ? Q0(u, c, '"top"', '"bottom"', '"middle"') : {
      value: "middle"
    }), x = Q0(u, c, `-(${f})`, f, 0);
    g = g && f;
    const w = {
      opacity: Ee,
      x: mt(a, y, m),
      y: vi(a, y, m)
    }, _ = {
      enter: w,
      update: p = {
        opacity: Xn,
        text: {
          field: gw
        },
        x: w.x,
        y: w.y,
        align: b,
        baseline: v
      },
      exit: {
        opacity: Ee,
        x: w.x,
        y: w.y
      }
    };
    Mt(_, {
      dx: !d && g ? mt(a, x) : null,
      dy: !h && g ? vi(a, x) : null
    }), Mt(_, {
      angle: s("labelAngle"),
      fill: s("labelColor"),
      fillOpacity: s("labelOpacity"),
      font: s("labelFont"),
      fontSize: s("labelFontSize"),
      fontWeight: s("labelFontWeight"),
      fontStyle: s("labelFontStyle"),
      limit: s("labelLimit"),
      lineHeight: s("labelLineHeight")
    }, {
      align: d,
      baseline: h
    });
    const E = s("labelBound");
    let S = s("labelOverlap");
    return S = S || E ? {
      separation: s("labelSeparation"),
      method: S,
      order: "datum.index",
      bound: E ? {
        scale: u,
        orient: a,
        tolerance: E
      } : null
    } : void 0, p.align !== b && (p.align = tu(p.align, b)), p.baseline !== v && (p.baseline = tu(p.baseline, v)), zn({
      type: va,
      role: mZ,
      style: Tf,
      key: Yn,
      from: i,
      encode: _,
      overlap: S
    }, n);
  }
  function Kte(e, t, n, i) {
    const r = $n(e, t), o = e.orient, s = tm(o, -1, 1);
    let a, u;
    const l = {
      enter: a = {
        opacity: Ee,
        anchor: pt(r("titleAnchor", null)),
        align: {
          signal: bw
        }
      },
      update: u = ce({}, a, {
        opacity: Xn,
        text: pt(e.title)
      }),
      exit: {
        opacity: Ee
      }
    }, c = {
      signal: `lerp(range("${e.scale}"), ${Qp(0, 1, 0.5)})`
    };
    return u.x = mt(o, c), u.y = vi(o, c), a.angle = mt(o, Ee, qte(s, 90)), a.baseline = mt(o, RR(o, qo, Mi), {
      value: qo
    }), u.angle = a.angle, u.baseline = a.baseline, Mt(l, {
      fill: r("titleColor"),
      fillOpacity: r("titleOpacity"),
      font: r("titleFont"),
      fontSize: r("titleFontSize"),
      fontStyle: r("titleFontStyle"),
      fontWeight: r("titleFontWeight"),
      limit: r("titleLimit"),
      lineHeight: r("titleLineHeight")
    }, {
      // require update
      align: r("titleAlign"),
      angle: r("titleAngle"),
      baseline: r("titleBaseline")
    }), Jte(r, o, l, n), l.update.align = tu(l.update.align, a.align), l.update.angle = tu(l.update.angle, a.angle), l.update.baseline = tu(l.update.baseline, a.baseline), zn({
      type: va,
      role: bZ,
      style: pw,
      from: i,
      encode: l
    }, n);
  }
  function Jte(e, t, n, i) {
    const r = (a, u) => a != null ? (n.update[u] = tu(pt(a), n.update[u]), !1) : !qa(u, i), o = r(e("titleX"), "x"), s = r(e("titleY"), "y");
    n.enter.auto = s === o ? pt(s) : mt(t, pt(s), pt(o));
  }
  function Qte(e, t) {
    const n = Wte(e, t), i = e.encode || {}, r = i.axis || {}, o = r.name || void 0, s = r.interactive, a = r.style, u = $n(e, n), l = Yee(u), c = {
      scale: e.scale,
      ticks: !!u("ticks"),
      labels: !!u("labels"),
      grid: !!u("grid"),
      domain: !!u("domain"),
      title: e.title != null
    }, f = ie(t.add(Fi({}, [c]))), d = ie(t.add(ZZ({
      scale: t.scaleRef(e.scale),
      extra: t.property(l.extra),
      count: t.objectProperty(e.tickCount),
      values: t.objectProperty(e.values),
      minstep: t.property(e.tickMinStep),
      formatType: t.property(e.formatType),
      formatSpecifier: t.property(e.format)
    }))), h = [];
    let g;
    return c.grid && h.push(Gte(e, n, i.grid, d, l)), c.ticks && (g = u("tickSize"), h.push(Yte(e, n, i.ticks, d, g, l))), c.labels && (g = c.ticks ? g : 0, h.push(Xte(e, n, i.labels, d, g, l))), c.domain && h.push(Hte(e, n, i.domain, f)), c.title && h.push(Kte(e, n, i.title, f)), em(Vc({
      role: hZ,
      from: f,
      encode: il(Zte(u, e), r, Df),
      marks: h,
      aria: u("aria"),
      description: u("description"),
      zindex: u("zindex"),
      name: o,
      interactive: s,
      style: a
    }), t);
  }
  function Zte(e, t) {
    const n = {
      enter: {},
      update: {}
    };
    return Mt(n, {
      orient: e("orient"),
      offset: e("offset") || 0,
      position: ci(t.position, 0),
      titlePadding: e("titlePadding"),
      minExtent: e("minExtent"),
      maxExtent: e("maxExtent"),
      range: {
        signal: `abs(span(range("${t.scale}")))`
      },
      translate: e("translate"),
      // accessibility support
      format: t.format,
      formatType: t.formatType
    }), n;
  }
  function PR(e, t, n) {
    const i = X(e.signals), r = X(e.scales);
    return n || i.forEach((o) => pR(o, t)), X(e.projections).forEach((o) => Tee(o, t)), r.forEach((o) => vee(o, t)), X(e.data).forEach((o) => Ote(o, t)), r.forEach((o) => xee(o, t)), (n || i).forEach((o) => QZ(o, t)), X(e.axes).forEach((o) => Qte(o, t)), X(e.marks).forEach((o) => em(o, t)), X(e.legends).forEach((o) => Ete(o, t)), e.title && Fte(e.title, t), t.parseLambdas(), t;
  }
  const ene = (e) => il({
    enter: {
      x: {
        value: 0
      },
      y: {
        value: 0
      }
    },
    update: {
      width: {
        signal: "width"
      },
      height: {
        signal: "height"
      }
    }
  }, e);
  function tne(e, t) {
    const n = t.config, i = ie(t.root = t.add($g())), r = nne(e, n);
    r.forEach((l) => pR(l, t)), t.description = e.description || n.description, t.eventConfig = n.events, t.legends = t.objectProperty(n.legend && n.legend.layout), t.locale = n.locale;
    const o = t.add(Fi()), s = t.add(bR(gR(ene(e.encode), Jp, cw, e.style, t, {
      pulse: ie(o)
    }))), a = t.add(wR({
      layout: t.objectProperty(e.layout),
      legends: t.legends,
      autosize: t.signalRef("autosize"),
      mark: i,
      pulse: ie(s)
    }));
    t.operators.pop(), t.pushState(ie(s), ie(a), null), PR(e, t, r), t.operators.push(a);
    let u = t.add(yR({
      mark: i,
      pulse: ie(a)
    }));
    return u = t.add(xR({
      pulse: ie(u)
    })), u = t.add(ba({
      pulse: ie(u)
    })), t.addData("root", new ta(t, o, o, u)), t;
  }
  function Nl(e, t) {
    return t && t.signal ? {
      name: e,
      update: t.signal
    } : {
      name: e,
      value: t
    };
  }
  function nne(e, t) {
    const n = (s) => ci(e[s], t[s]), i = [Nl("background", n("background")), Nl("autosize", cZ(n("autosize"))), Nl("padding", dZ(n("padding"))), Nl("width", n("width") || 0), Nl("height", n("height") || 0)], r = i.reduce((s, a) => (s[a.name] = a, s), {}), o = {};
    return X(e.signals).forEach((s) => {
      J(r, s.name) ? s = ce(r[s.name], s) : i.push(s), o[s.name] = s;
    }), X(t.signals).forEach((s) => {
      !J(o, s.name) && !J(r, s.name) && i.push(s);
    }), i;
  }
  function IR(e, t) {
    this.config = e || {}, this.options = t || {}, this.bindings = [], this.field = {}, this.signals = {}, this.lambdas = {}, this.scales = {}, this.events = {}, this.data = {}, this.streams = [], this.updates = [], this.operators = [], this.eventConfig = null, this.locale = null, this._id = 0, this._subid = 0, this._nextsub = [0], this._parent = [], this._encode = [], this._lookup = [], this._markpath = [];
  }
  function zk(e) {
    this.config = e.config, this.options = e.options, this.legends = e.legends, this.field = Object.create(e.field), this.signals = Object.create(e.signals), this.lambdas = Object.create(e.lambdas), this.scales = Object.create(e.scales), this.events = Object.create(e.events), this.data = Object.create(e.data), this.streams = [], this.updates = [], this.operators = [], this._id = 0, this._subid = ++e._nextsub[0], this._nextsub = e._nextsub, this._parent = e._parent.slice(), this._encode = e._encode.slice(), this._lookup = e._lookup.slice(), this._markpath = e._markpath;
  }
  IR.prototype = zk.prototype = {
    parse(e) {
      return PR(e, this);
    },
    fork() {
      return new zk(this);
    },
    isSubscope() {
      return this._subid > 0;
    },
    toRuntime() {
      return this.finish(), {
        description: this.description,
        operators: this.operators,
        streams: this.streams,
        updates: this.updates,
        bindings: this.bindings,
        eventConfig: this.eventConfig,
        locale: this.locale
      };
    },
    id() {
      return (this._subid ? this._subid + ":" : 0) + this._id++;
    },
    add(e) {
      return this.operators.push(e), e.id = this.id(), e.refs && (e.refs.forEach((t) => {
        t.$ref = e.id;
      }), e.refs = null), e;
    },
    proxy(e) {
      const t = e instanceof Jy ? ie(e) : e;
      return this.add(hee({
        value: t
      }));
    },
    addStream(e) {
      return this.streams.push(e), e.id = this.id(), e;
    },
    addUpdate(e) {
      return this.updates.push(e), e;
    },
    // Apply metadata
    finish() {
      let e, t;
      this.root && (this.root.root = !0);
      for (e in this.signals)
        this.signals[e].signal = e;
      for (e in this.scales)
        this.scales[e].scale = e;
      function n(i, r, o) {
        let s, a;
        i && (s = i.data || (i.data = {}), a = s[r] || (s[r] = []), a.push(o));
      }
      for (e in this.data) {
        t = this.data[e], n(t.input, e, "input"), n(t.output, e, "output"), n(t.values, e, "values");
        for (const i in t.index)
          n(t.index[i], e, "index:" + i);
      }
      return this;
    },
    // ----
    pushState(e, t, n) {
      this._encode.push(ie(this.add(ba({
        pulse: e
      })))), this._parent.push(t), this._lookup.push(n ? ie(this.proxy(n)) : null), this._markpath.push(-1);
    },
    popState() {
      this._encode.pop(), this._parent.pop(), this._lookup.pop(), this._markpath.pop();
    },
    parent() {
      return xe(this._parent);
    },
    encode() {
      return xe(this._encode);
    },
    lookup() {
      return xe(this._lookup);
    },
    markpath() {
      const e = this._markpath;
      return ++e[e.length - 1];
    },
    // ----
    fieldRef(e, t) {
      if (K(e)) return Hc(e, t);
      e.signal || R("Unsupported field reference: " + H(e));
      const n = e.signal;
      let i = this.field[n];
      if (!i) {
        const r = {
          name: this.signalRef(n)
        };
        t && (r.as = t), this.field[n] = i = ie(this.add(iee(r)));
      }
      return i;
    },
    compareRef(e) {
      let t = !1;
      const n = (o) => at(o) ? (t = !0, this.signalRef(o.signal)) : jZ(o) ? (t = !0, this.exprRef(o.expr)) : o, i = X(e.field).map(n), r = X(e.order).map(n);
      return t ? ie(this.add($k({
        fields: i,
        orders: r
      }))) : _k(i, r);
    },
    keyRef(e, t) {
      let n = !1;
      const i = (o) => at(o) ? (n = !0, ie(r[o.signal])) : o, r = this.signals;
      return e = X(e).map(i), n ? ie(this.add(ree({
        fields: e,
        flat: t
      }))) : IZ(e, t);
    },
    sortRef(e) {
      if (!e) return e;
      const t = Xp(e.op, e.field), n = e.order || zZ;
      return n.signal ? ie(this.add($k({
        fields: t,
        orders: this.signalRef(n.signal)
      }))) : _k(t, n);
    },
    // ----
    event(e, t) {
      const n = e + ":" + t;
      if (!this.events[n]) {
        const i = this.id();
        this.streams.push({
          id: i,
          source: e,
          type: t
        }), this.events[n] = i;
      }
      return this.events[n];
    },
    // ----
    hasOwnSignal(e) {
      return J(this.signals, e);
    },
    addSignal(e, t) {
      this.hasOwnSignal(e) && R("Duplicate signal name: " + H(e));
      const n = t instanceof Jy ? t : this.add($g(t));
      return this.signals[e] = n;
    },
    getSignal(e) {
      return this.signals[e] || R("Unrecognized signal name: " + H(e)), this.signals[e];
    },
    signalRef(e) {
      return this.signals[e] ? ie(this.signals[e]) : (J(this.lambdas, e) || (this.lambdas[e] = this.add($g(null))), ie(this.lambdas[e]));
    },
    parseLambdas() {
      const e = Object.keys(this.lambdas);
      for (let t = 0, n = e.length; t < n; ++t) {
        const i = e[t], r = ar(i, this), o = this.lambdas[i];
        o.params = r.$params, o.update = r.$expr;
      }
    },
    property(e) {
      return e && e.signal ? this.signalRef(e.signal) : e;
    },
    objectProperty(e) {
      return !e || !Y(e) ? e : this.signalRef(e.signal || _w(e));
    },
    exprRef(e, t) {
      const n = {
        expr: ar(e, this)
      };
      return t && (n.expr.$name = t), ie(this.add(tee(n)));
    },
    addBinding(e, t) {
      this.bindings || R("Nested signals do not support binding: " + H(e)), this.bindings.push(ce({
        signal: e
      }, t));
    },
    // ----
    addScaleProj(e, t) {
      J(this.scales, e) && R("Duplicate scale or projection name: " + H(e)), this.scales[e] = this.add(t);
    },
    addScale(e, t) {
      this.addScaleProj(e, pee(t));
    },
    addProjection(e, t) {
      this.addScaleProj(e, dee(t));
    },
    getScale(e) {
      return this.scales[e] || R("Unrecognized scale name: " + H(e)), this.scales[e];
    },
    scaleRef(e) {
      return ie(this.getScale(e));
    },
    scaleType(e) {
      return this.getScale(e).params.type;
    },
    projectionRef(e) {
      return this.scaleRef(e);
    },
    projectionType(e) {
      return this.scaleType(e);
    },
    // ----
    addData(e, t) {
      return J(this.data, e) && R("Duplicate data set name: " + H(e)), this.data[e] = t;
    },
    getData(e) {
      return this.data[e] || R("Undefined data set name: " + H(e)), this.data[e];
    },
    addDataPipeline(e, t) {
      return J(this.data, e) && R("Duplicate data set name: " + H(e)), this.addData(e, ta.fromEntries(this, t));
    }
  };
  function _w(e) {
    return (P(e) ? ine : rne)(e);
  }
  function ine(e) {
    const t = e.length;
    let n = "[";
    for (let i = 0; i < t; ++i) {
      const r = e[i];
      n += (i > 0 ? "," : "") + (Y(r) ? r.signal || _w(r) : H(r));
    }
    return n + "]";
  }
  function rne(e) {
    let t = "{", n = 0, i, r;
    for (i in e)
      r = e[i], t += (++n > 1 ? "," : "") + H(i) + ":" + (Y(r) ? r.signal || _w(r) : H(r));
    return t + "}";
  }
  function one() {
    const e = "sans-serif", i = "#4c78a8", r = "#000", o = "#888", s = "#ddd";
    return {
      // default visualization description
      description: "Vega visualization",
      // default padding around visualization
      padding: 0,
      // default for automatic sizing; options: 'none', 'pad', 'fit'
      // or provide an object (e.g., {'type': 'pad', 'resize': true})
      autosize: "pad",
      // default view background color
      // covers the entire view component
      background: null,
      // default event handling configuration
      // preventDefault for view-sourced event types except 'wheel'
      events: {
        defaults: {
          allow: ["wheel"]
        }
      },
      // defaults for top-level group marks
      // accepts mark properties (fill, stroke, etc)
      // covers the data rectangle within group width/height
      group: null,
      // defaults for basic mark types
      // each subset accepts mark properties (fill, stroke, etc)
      mark: null,
      arc: {
        fill: i
      },
      area: {
        fill: i
      },
      image: null,
      line: {
        stroke: i,
        strokeWidth: 2
      },
      path: {
        stroke: i
      },
      rect: {
        fill: i
      },
      rule: {
        stroke: r
      },
      shape: {
        stroke: i
      },
      symbol: {
        fill: i,
        size: 64
      },
      text: {
        fill: r,
        font: e,
        fontSize: 11
      },
      trail: {
        fill: i,
        size: 2
      },
      // style definitions
      style: {
        // axis & legend labels
        "guide-label": {
          fill: r,
          font: e,
          fontSize: 10
        },
        // axis & legend titles
        "guide-title": {
          fill: r,
          font: e,
          fontSize: 11,
          fontWeight: "bold"
        },
        // headers, including chart title
        "group-title": {
          fill: r,
          font: e,
          fontSize: 13,
          fontWeight: "bold"
        },
        // chart subtitle
        "group-subtitle": {
          fill: r,
          font: e,
          fontSize: 12
        },
        // defaults for styled point marks in Vega-Lite
        point: {
          size: 30,
          strokeWidth: 2,
          shape: "circle"
        },
        circle: {
          size: 30,
          strokeWidth: 2
        },
        square: {
          size: 30,
          strokeWidth: 2,
          shape: "square"
        },
        // defaults for styled group marks in Vega-Lite
        cell: {
          fill: "transparent",
          stroke: s
        },
        view: {
          fill: "transparent"
        }
      },
      // defaults for title
      title: {
        orient: "top",
        anchor: "middle",
        offset: 4,
        subtitlePadding: 3
      },
      // defaults for axes
      axis: {
        minExtent: 0,
        maxExtent: 200,
        bandPosition: 0.5,
        domain: !0,
        domainWidth: 1,
        domainColor: o,
        grid: !1,
        gridWidth: 1,
        gridColor: s,
        labels: !0,
        labelAngle: 0,
        labelLimit: 180,
        labelOffset: 0,
        labelPadding: 2,
        ticks: !0,
        tickColor: o,
        tickOffset: 0,
        tickRound: !0,
        tickSize: 5,
        tickWidth: 1,
        titlePadding: 4
      },
      // correction for centering bias
      axisBand: {
        tickOffset: -0.5
      },
      // defaults for cartographic projection
      projection: {
        type: "mercator"
      },
      // defaults for legends
      legend: {
        orient: "right",
        padding: 0,
        gridAlign: "each",
        columnPadding: 10,
        rowPadding: 2,
        symbolDirection: "vertical",
        gradientDirection: "vertical",
        gradientLength: 200,
        gradientThickness: 16,
        gradientStrokeColor: s,
        gradientStrokeWidth: 0,
        gradientLabelOffset: 2,
        labelAlign: "left",
        labelBaseline: "middle",
        labelLimit: 160,
        labelOffset: 4,
        labelOverlap: !0,
        symbolLimit: 30,
        symbolType: "circle",
        symbolSize: 100,
        symbolOffset: 0,
        symbolStrokeWidth: 1.5,
        symbolBaseFillColor: "transparent",
        symbolBaseStrokeColor: o,
        titleLimit: 180,
        titleOrient: "top",
        titlePadding: 5,
        layout: {
          offset: 18,
          direction: "horizontal",
          left: {
            direction: "vertical"
          },
          right: {
            direction: "vertical"
          }
        }
      },
      // defaults for scale ranges
      range: {
        category: {
          scheme: "tableau10"
        },
        ordinal: {
          scheme: "blues"
        },
        heatmap: {
          scheme: "yellowgreenblue"
        },
        ramp: {
          scheme: "blues"
        },
        diverging: {
          scheme: "blueorange",
          extent: [1, 0]
        },
        symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
      }
    };
  }
  function sne(e, t, n) {
    return Y(e) || R("Input Vega specification must be an object."), t = Wu(one(), t, e.config), tne(e, new IR(t, n)).toRuntime();
  }
  var ane = "5.30.0";
  ce(du, n9, Nq, fW, KH, WG, yY, KV, vY, qY, ZY, sX);
  const une = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Bounds: nt,
    CanvasHandler: Ef,
    CanvasRenderer: zh,
    DATE: vn,
    DAY: It,
    DAYOFYEAR: or,
    Dataflow: Ja,
    Debug: DC,
    Error: Ob,
    EventStream: np,
    Gradient: k3,
    GroupItem: $p,
    HOURS: Ln,
    Handler: Hx,
    HybridHandler: yD,
    HybridRenderer: oy,
    Info: TC,
    Item: Sp,
    MILLISECONDS: Ei,
    MINUTES: Pn,
    MONTH: jt,
    Marks: In,
    MultiPulse: ov,
    None: MC,
    Operator: Ie,
    Parameters: tp,
    Pulse: Mo,
    QUARTER: bn,
    RenderType: Eo,
    Renderer: wf,
    ResourceLoader: N3,
    SECONDS: Qn,
    SVGHandler: rD,
    SVGRenderer: Jx,
    SVGStringRenderer: mD,
    Scenegraph: K3,
    TIME_UNITS: Xb,
    Transform: N,
    View: nR,
    WEEK: ot,
    Warn: Rb,
    YEAR: Ct,
    accessor: Sn,
    accessorFields: Ut,
    accessorName: Je,
    array: X,
    ascending: Wg,
    bandwidthNRD: lv,
    bin: hM,
    bootstrapCI: gM,
    boundClip: AD,
    boundContext: yf,
    boundItem: ey,
    boundMark: G3,
    boundStroke: Qr,
    changeset: ga,
    clampRange: qC,
    codegenExpression: FO,
    compare: Bb,
    constant: Gt,
    cumulativeLogNormal: pv,
    cumulativeNormal: rp,
    cumulativeUniform: vv,
    dayofyear: xF,
    debounce: Ub,
    defaultLocale: ev,
    definition: cM,
    densityLogNormal: gv,
    densityNormal: cv,
    densityUniform: bv,
    domChild: rt,
    domClear: jn,
    domCreate: xo,
    domFind: Wx,
    dotbin: pM,
    error: R,
    expressionFunction: tt,
    extend: ce,
    extent: nr,
    extentIndex: WC,
    falsy: lo,
    fastmap: Gu,
    field: Kn,
    flush: HC,
    font: Mp,
    fontFamily: xf,
    fontSize: gr,
    format: Pd,
    formatLocale: yh,
    formats: iv,
    hasOwnProperty: J,
    id: tf,
    identity: Ht,
    inferType: ZF,
    inferTypes: eM,
    ingest: Ce,
    inherits: G,
    inrange: Ha,
    interpolate: wx,
    interpolateColors: Ep,
    interpolateRange: d3,
    intersect: _D,
    intersectBoxLine: Ga,
    intersectPath: Fx,
    intersectPoint: Mx,
    intersectRule: R3,
    isArray: P,
    isBoolean: Ko,
    isDate: Co,
    isFunction: fe,
    isIterable: GC,
    isNumber: $e,
    isObject: Y,
    isRegExp: VC,
    isString: K,
    isTuple: Zg,
    key: jb,
    lerp: YC,
    lineHeight: Bo,
    loader: Jg,
    locale: JF,
    logger: Lb,
    lruCache: XC,
    markup: Kx,
    merge: KC,
    mergeConfig: Wu,
    multiLineOffset: Ux,
    one: qu,
    pad: JC,
    panLinear: PC,
    panLog: IC,
    panPow: zC,
    panSymlog: BC,
    parse: sne,
    parseExpression: K2,
    parseSelector: ns,
    path: lp,
    pathCurves: kx,
    pathEqual: CD,
    pathParse: bu,
    pathRectangle: F3,
    pathRender: Nc,
    pathSymbols: C3,
    pathTrail: M3,
    peek: xe,
    point: Dp,
    projection: m2,
    quantileLogNormal: mv,
    quantileNormal: op,
    quantileUniform: xv,
    quantiles: av,
    quantizeInterpolator: h3,
    quarter: UC,
    quartiles: uv,
    get random() {
      return Zn;
    },
    randomInteger: s8,
    randomKDE: dv,
    randomLCG: o8,
    randomLogNormal: yM,
    randomMixture: bM,
    randomNormal: fv,
    randomUniform: vM,
    read: iM,
    regressionConstant: wv,
    regressionExp: wM,
    regressionLinear: Ev,
    regressionLoess: SM,
    regressionLog: xM,
    regressionPoly: _M,
    regressionPow: EM,
    regressionQuad: _v,
    renderModule: Np,
    repeat: Bl,
    resetDefaultLocale: nz,
    resetSVGClipId: D3,
    resetSVGDefIds: Jj,
    responseType: nM,
    runtimeContext: qO,
    sampleCurve: ap,
    sampleLogNormal: hv,
    sampleNormal: ip,
    sampleUniform: yv,
    scale: Ae,
    sceneEqual: Qx,
    sceneFromJSON: Y3,
    scenePickVisit: Th,
    sceneToJSON: V3,
    sceneVisit: _i,
    sceneZOrder: Tx,
    scheme: Ex,
    serializeXML: dD,
    setHybridRendererOptions: Vj,
    setRandom: i8,
    span: nf,
    splitAccessPath: fr,
    stringValue: H,
    textMetrics: Nn,
    timeBin: PF,
    timeFloor: AF,
    timeFormatLocale: Ac,
    timeInterval: Ku,
    timeOffset: MF,
    timeSequence: NF,
    timeUnitSpecifier: vF,
    timeUnits: Kb,
    toBoolean: qb,
    toDate: Wb,
    toNumber: zt,
    toSet: wi,
    toString: Hb,
    transform: fM,
    transforms: du,
    truncate: QC,
    truthy: Jn,
    tupleid: re,
    typeParsers: L1,
    utcFloor: CF,
    utcInterval: Ju,
    utcOffset: TF,
    utcSequence: OF,
    utcdayofyear: _F,
    utcquarter: jC,
    utcweek: SF,
    version: ane,
    visitArray: ho,
    week: wF,
    writeConfig: Hu,
    zero: bo,
    zoomLinear: Pb,
    zoomLog: Ib,
    zoomPow: fh,
    zoomSymlog: zb
  }, Symbol.toStringTag, { value: "Module" }));
  function lne(e, t, n) {
    let i;
    t.x2 && (t.x ? (n && e.x > e.x2 && (i = e.x, e.x = e.x2, e.x2 = i), e.width = e.x2 - e.x) : e.x = e.x2 - (e.width || 0)), t.xc && (e.x = e.xc - (e.width || 0) / 2), t.y2 && (t.y ? (n && e.y > e.y2 && (i = e.y, e.y = e.y2, e.y2 = i), e.height = e.y2 - e.y) : e.y = e.y2 - (e.height || 0)), t.yc && (e.y = e.yc - (e.height || 0) / 2);
  }
  var cne = {
    NaN: NaN,
    E: Math.E,
    LN2: Math.LN2,
    LN10: Math.LN10,
    LOG2E: Math.LOG2E,
    LOG10E: Math.LOG10E,
    PI: Math.PI,
    SQRT1_2: Math.SQRT1_2,
    SQRT2: Math.SQRT2,
    MIN_VALUE: Number.MIN_VALUE,
    MAX_VALUE: Number.MAX_VALUE
  }, fne = {
    "*": (e, t) => e * t,
    "+": (e, t) => e + t,
    "-": (e, t) => e - t,
    "/": (e, t) => e / t,
    "%": (e, t) => e % t,
    ">": (e, t) => e > t,
    "<": (e, t) => e < t,
    "<=": (e, t) => e <= t,
    ">=": (e, t) => e >= t,
    "==": (e, t) => e == t,
    "!=": (e, t) => e != t,
    "===": (e, t) => e === t,
    "!==": (e, t) => e !== t,
    "&": (e, t) => e & t,
    "|": (e, t) => e | t,
    "^": (e, t) => e ^ t,
    "<<": (e, t) => e << t,
    ">>": (e, t) => e >> t,
    ">>>": (e, t) => e >>> t
  }, dne = {
    "+": (e) => +e,
    "-": (e) => -e,
    "~": (e) => ~e,
    "!": (e) => !e
  };
  const hne = Array.prototype.slice, gs = (e, t, n) => {
    const i = n ? n(t[0]) : t[0];
    return i[e].apply(i, hne.call(t, 1));
  }, gne = (e, t, n, i, r, o, s) => new Date(e, t || 0, n ?? 1, i || 0, r || 0, o || 0, s || 0);
  var pne = {
    // math functions
    isNaN: Number.isNaN,
    isFinite: Number.isFinite,
    abs: Math.abs,
    acos: Math.acos,
    asin: Math.asin,
    atan: Math.atan,
    atan2: Math.atan2,
    ceil: Math.ceil,
    cos: Math.cos,
    exp: Math.exp,
    floor: Math.floor,
    log: Math.log,
    max: Math.max,
    min: Math.min,
    pow: Math.pow,
    random: Math.random,
    round: Math.round,
    sin: Math.sin,
    sqrt: Math.sqrt,
    tan: Math.tan,
    clamp: (e, t, n) => Math.max(t, Math.min(n, e)),
    // date functions
    now: Date.now,
    utc: Date.UTC,
    datetime: gne,
    date: (e) => new Date(e).getDate(),
    day: (e) => new Date(e).getDay(),
    year: (e) => new Date(e).getFullYear(),
    month: (e) => new Date(e).getMonth(),
    hours: (e) => new Date(e).getHours(),
    minutes: (e) => new Date(e).getMinutes(),
    seconds: (e) => new Date(e).getSeconds(),
    milliseconds: (e) => new Date(e).getMilliseconds(),
    time: (e) => new Date(e).getTime(),
    timezoneoffset: (e) => new Date(e).getTimezoneOffset(),
    utcdate: (e) => new Date(e).getUTCDate(),
    utcday: (e) => new Date(e).getUTCDay(),
    utcyear: (e) => new Date(e).getUTCFullYear(),
    utcmonth: (e) => new Date(e).getUTCMonth(),
    utchours: (e) => new Date(e).getUTCHours(),
    utcminutes: (e) => new Date(e).getUTCMinutes(),
    utcseconds: (e) => new Date(e).getUTCSeconds(),
    utcmilliseconds: (e) => new Date(e).getUTCMilliseconds(),
    // sequence functions
    length: (e) => e.length,
    join: function() {
      return gs("join", arguments);
    },
    indexof: function() {
      return gs("indexOf", arguments);
    },
    lastindexof: function() {
      return gs("lastIndexOf", arguments);
    },
    slice: function() {
      return gs("slice", arguments);
    },
    reverse: (e) => e.slice().reverse(),
    // string functions
    parseFloat,
    parseInt,
    upper: (e) => String(e).toUpperCase(),
    lower: (e) => String(e).toLowerCase(),
    substring: function() {
      return gs("substring", arguments, String);
    },
    split: function() {
      return gs("split", arguments, String);
    },
    replace: function() {
      return gs("replace", arguments, String);
    },
    trim: (e) => String(e).trim(),
    // regexp functions
    regexp: RegExp,
    test: (e, t) => RegExp(e).test(t)
  };
  const mne = ["view", "item", "group", "xy", "x", "y"], rb = /* @__PURE__ */ new Set([Function, eval, setTimeout, setInterval]);
  typeof setImmediate == "function" && rb.add(setImmediate);
  const yne = {
    Literal: (e, t) => t.value,
    Identifier: (e, t) => {
      const n = t.name;
      return e.memberDepth > 0 ? n : n === "datum" ? e.datum : n === "event" ? e.event : n === "item" ? e.item : cne[n] || e.params["$" + n];
    },
    MemberExpression: (e, t) => {
      const n = !t.computed, i = e(t.object);
      n && (e.memberDepth += 1);
      const r = e(t.property);
      if (n && (e.memberDepth -= 1), rb.has(i[r])) {
        console.error(`Prevented interpretation of member "${r}" which could lead to insecure code execution`);
        return;
      }
      return i[r];
    },
    CallExpression: (e, t) => {
      const n = t.arguments;
      let i = t.callee.name;
      return i.startsWith("_") && (i = i.slice(1)), i === "if" ? e(n[0]) ? e(n[1]) : e(n[2]) : (e.fn[i] || pne[i]).apply(e.fn, n.map(e));
    },
    ArrayExpression: (e, t) => t.elements.map(e),
    BinaryExpression: (e, t) => fne[t.operator](e(t.left), e(t.right)),
    UnaryExpression: (e, t) => dne[t.operator](e(t.argument)),
    ConditionalExpression: (e, t) => e(t.test) ? e(t.consequent) : e(t.alternate),
    LogicalExpression: (e, t) => t.operator === "&&" ? e(t.left) && e(t.right) : e(t.left) || e(t.right),
    ObjectExpression: (e, t) => t.properties.reduce((n, i) => {
      e.memberDepth += 1;
      const r = e(i.key);
      return e.memberDepth -= 1, rb.has(e(i.value)) ? console.error(`Prevented interpretation of property "${r}" which could lead to insecure code execution`) : n[r] = e(i.value), n;
    }, {})
  };
  function Ol(e, t, n, i, r, o) {
    const s = (a) => yne[a.type](s, a);
    return s.memberDepth = 0, s.fn = Object.create(t), s.params = n, s.datum = i, s.event = r, s.item = o, mne.forEach((a) => s.fn[a] = function() {
      return r.vega[a](...arguments);
    }), s(e);
  }
  var bne = {
    /**
     * Parse an expression used to update an operator value.
     */
    operator(e, t) {
      const n = t.ast, i = e.functions;
      return (r) => Ol(n, i, r);
    },
    /**
     * Parse an expression provided as an operator parameter value.
     */
    parameter(e, t) {
      const n = t.ast, i = e.functions;
      return (r, o) => Ol(n, i, o, r);
    },
    /**
     * Parse an expression applied to an event stream.
     */
    event(e, t) {
      const n = t.ast, i = e.functions;
      return (r) => Ol(n, i, void 0, void 0, r);
    },
    /**
     * Parse an expression used to handle an event-driven operator update.
     */
    handler(e, t) {
      const n = t.ast, i = e.functions;
      return (r, o) => {
        const s = o.item && o.item.datum;
        return Ol(n, i, r, s, o);
      };
    },
    /**
     * Parse an expression that performs visual encoding.
     */
    encode(e, t) {
      const {
        marktype: n,
        channels: i
      } = t, r = e.functions, o = n === "group" || n === "image" || n === "rect";
      return (s, a) => {
        const u = s.datum;
        let l = 0, c;
        for (const f in i)
          c = Ol(i[f].ast, r, a, u, void 0, s), s[f] !== c && (s[f] = c, l = 1);
        return n !== "rule" && lne(s, i, o), l;
      };
    }
  };
  const vne = "vega-lite", xne = 'Dominik Moritz, Kanit "Ham" Wongsuphasawat, Arvind Satyanarayan, Jeffrey Heer', wne = "5.21.0", Ene = [
    "Kanit Wongsuphasawat (http://kanitw.yellowpigz.com)",
    "Dominik Moritz (https://www.domoritz.de)",
    "Arvind Satyanarayan (https://arvindsatya.com)",
    "Jeffrey Heer (https://jheer.org)"
  ], _ne = "https://vega.github.io/vega-lite/", Sne = "Vega-Lite is a concise high-level language for interactive visualization.", $ne = [
    "vega",
    "chart",
    "visualization"
  ], kne = "build/vega-lite.js", Ane = "build/vega-lite.min.js", Cne = "build/vega-lite.min.js", Fne = "build/src/index", Mne = "build/src/index.d.ts", Tne = {
    vl2pdf: "./bin/vl2pdf",
    vl2png: "./bin/vl2png",
    vl2svg: "./bin/vl2svg",
    vl2vg: "./bin/vl2vg"
  }, Dne = [
    "bin",
    "build",
    "src",
    "vega-lite*",
    "tsconfig.json"
  ], Nne = {
    changelog: "conventional-changelog -p angular -r 2",
    prebuild: "yarn clean:build",
    build: "yarn build:only",
    "build:only": "tsc -p tsconfig.build.json && rollup -c",
    "prebuild:examples": "yarn build:only",
    "build:examples": "yarn data && TZ=America/Los_Angeles scripts/build-examples.sh",
    "prebuild:examples-full": "yarn build:only",
    "build:examples-full": "TZ=America/Los_Angeles scripts/build-examples.sh 1",
    "build:example": "TZ=America/Los_Angeles scripts/build-example.sh",
    "build:toc": "yarn build:jekyll && scripts/generate-toc",
    "build:site": "rollup -c site/rollup.config.mjs",
    "build:jekyll": "pushd site && bundle exec jekyll build -q && popd",
    "build:versions": "scripts/update-version.sh",
    clean: "yarn clean:build && del-cli 'site/data/*' 'examples/compiled/*.png' && find site/examples ! -name 'index.md' ! -name 'data' -type f -delete",
    "clean:build": "del-cli 'build/*' !build/vega-lite-schema.json",
    data: "rsync -r node_modules/vega-datasets/data/* site/data",
    "build-editor-preview": "scripts/build-editor-preview.sh",
    schema: "mkdir -p build && ts-json-schema-generator -f tsconfig.json -p src/index.ts -t TopLevelSpec --no-type-check --no-ref-encode > build/vega-lite-schema.json && yarn renameschema && cp build/vega-lite-schema.json site/_data/",
    renameschema: "scripts/rename-schema.sh",
    presite: "yarn data && yarn schema && yarn build:site && yarn build:versions && scripts/create-example-pages.sh",
    site: "yarn site:only",
    "site:only": "pushd site && bundle exec jekyll serve -I -l && popd",
    prettierbase: "prettier '**/*.{md,css,yml}'",
    format: "eslint . --fix && yarn prettierbase --write",
    lint: "eslint . && yarn prettierbase --check",
    test: "yarn jest test/ && yarn lint && yarn schema && yarn jest examples/ && yarn test:runtime",
    "test:cover": "yarn jest --collectCoverage test/",
    "test:inspect": "node --inspect-brk ./node_modules/.bin/jest --runInBand test",
    "test:runtime": "TZ=America/Los_Angeles npx jest test-runtime/ --config test-runtime/jest-config.json",
    "test:runtime:generate": "yarn build:only && del-cli test-runtime/resources && VL_GENERATE_TESTS=true yarn test:runtime",
    watch: "tsc -p tsconfig.build.json -w",
    "watch:site": "yarn build:site -w",
    "watch:test": "yarn jest --watch test/",
    "watch:test:runtime": "TZ=America/Los_Angeles npx jest --watch test-runtime/ --config test-runtime/jest-config.json",
    release: "release-it"
  }, One = {
    type: "git",
    url: "https://github.com/vega/vega-lite.git"
  }, Rne = "BSD-3-Clause", Lne = {
    url: "https://github.com/vega/vega-lite/issues"
  }, Pne = {
    "@babel/core": "^7.24.9",
    "@babel/preset-env": "^7.25.0",
    "@babel/preset-typescript": "^7.24.7",
    "@release-it/conventional-changelog": "^8.0.1",
    "@rollup/plugin-alias": "^5.1.0",
    "@rollup/plugin-babel": "^6.0.4",
    "@rollup/plugin-commonjs": "^26.0.1",
    "@rollup/plugin-json": "^6.1.0",
    "@rollup/plugin-node-resolve": "^15.2.3",
    "@rollup/plugin-terser": "^0.4.4",
    "@types/d3": "^7.4.3",
    "@types/jest": "^29.5.12",
    "@types/pako": "^2.0.3",
    "@typescript-eslint/eslint-plugin": "^7.17.0",
    "@typescript-eslint/parser": "^7.17.0",
    ajv: "^8.17.1",
    "ajv-formats": "^3.0.1",
    cheerio: "^1.0.0-rc.12",
    "conventional-changelog-cli": "^5.0.0",
    d3: "^7.9.0",
    "del-cli": "^5.1.0",
    eslint: "^8.57.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-jest": "^27.9.0",
    "eslint-plugin-prettier": "^5.2.1",
    "fast-json-stable-stringify": "~2.1.0",
    "highlight.js": "^11.10.0",
    jest: "^29.7.0",
    "jest-dev-server": "^10.0.0",
    mkdirp: "^3.0.1",
    pako: "^2.1.0",
    prettier: "^3.3.3",
    puppeteer: "^15.0.0",
    "release-it": "17.6.0",
    rollup: "^4.19.1",
    "rollup-plugin-bundle-size": "^1.0.3",
    serve: "^14.2.3",
    terser: "^5.31.3",
    "ts-jest": "^29.2.3",
    "ts-json-schema-generator": "^2.3.0",
    typescript: "~5.5.4",
    "vega-cli": "^5.28.0",
    "vega-datasets": "^2.8.1",
    "vega-embed": "^6.26.0",
    "vega-tooltip": "^0.34.0",
    "yaml-front-matter": "^4.1.1"
  }, Ine = {
    "json-stringify-pretty-compact": "~3.0.0",
    tslib: "~2.6.3",
    "vega-event-selector": "~3.0.1",
    "vega-expression": "~5.1.1",
    "vega-util": "~1.17.2",
    yargs: "~17.7.2"
  }, zne = {
    vega: "^5.24.0"
  }, Bne = {
    node: ">=18"
  }, Une = "yarn@1.22.19", jne = {
    name: vne,
    author: xne,
    version: wne,
    collaborators: Ene,
    homepage: _ne,
    description: Sne,
    keywords: $ne,
    main: kne,
    unpkg: Ane,
    jsdelivr: Cne,
    module: Fne,
    types: Mne,
    bin: Tne,
    files: Dne,
    scripts: Nne,
    repository: One,
    license: Rne,
    bugs: Lne,
    devDependencies: Pne,
    dependencies: Ine,
    peerDependencies: zne,
    engines: Bne,
    packageManager: Une
  };
  function Sw(e) {
    return U(e, "or");
  }
  function $w(e) {
    return U(e, "and");
  }
  function kw(e) {
    return U(e, "not");
  }
  function ah(e, t) {
    if (kw(e))
      ah(e.not, t);
    else if ($w(e))
      for (const n of e.and)
        ah(n, t);
    else if (Sw(e))
      for (const n of e.or)
        ah(n, t);
    else
      t(e);
  }
  function nu(e, t) {
    return kw(e) ? { not: nu(e.not, t) } : $w(e) ? { and: e.and.map((n) => nu(n, t)) } : Sw(e) ? { or: e.or.map((n) => nu(n, t)) } : t(e);
  }
  const ue = structuredClone;
  function zR(e) {
    throw new Error(e);
  }
  function Au(e, t) {
    const n = {};
    for (const i of t)
      J(e, i) && (n[i] = e[i]);
    return n;
  }
  function mn(e, t) {
    const n = { ...e };
    for (const i of t)
      delete n[i];
    return n;
  }
  Set.prototype.toJSON = function() {
    return `Set(${[...this].map((e) => Re(e)).join(",")})`;
  };
  function be(e) {
    if ($e(e))
      return e;
    const t = K(e) ? e : Re(e);
    if (t.length < 250)
      return t;
    let n = 0;
    for (let i = 0; i < t.length; i++) {
      const r = t.charCodeAt(i);
      n = (n << 5) - n + r, n = n & n;
    }
    return n;
  }
  function ob(e) {
    return e === !1 || e === null;
  }
  function ye(e, t) {
    return e.includes(t);
  }
  function Cu(e, t) {
    let n = 0;
    for (const [i, r] of e.entries())
      if (t(r, i, n++))
        return !0;
    return !1;
  }
  function Aw(e, t) {
    let n = 0;
    for (const [i, r] of e.entries())
      if (!t(r, i, n++))
        return !1;
    return !0;
  }
  function BR(e, ...t) {
    for (const n of t)
      qne(e, n ?? {});
    return e;
  }
  function qne(e, t) {
    for (const n of B(t))
      Hu(e, n, t[n], !0);
  }
  function Xi(e, t) {
    const n = [], i = {};
    let r;
    for (const o of e)
      r = t(o), !(r in i) && (i[r] = 1, n.push(o));
    return n;
  }
  function Wne(e, t) {
    const n = B(e), i = B(t);
    if (n.length !== i.length)
      return !1;
    for (const r of n)
      if (e[r] !== t[r])
        return !1;
    return !0;
  }
  function UR(e, t) {
    if (e.size !== t.size)
      return !1;
    for (const n of e)
      if (!t.has(n))
        return !1;
    return !0;
  }
  function Cw(e, t) {
    for (const n of e)
      if (t.has(n))
        return !0;
    return !1;
  }
  function sb(e) {
    const t = /* @__PURE__ */ new Set();
    for (const n of e) {
      const r = fr(n).map((s, a) => a === 0 ? s : `[${s}]`), o = r.map((s, a) => r.slice(0, a + 1).join(""));
      for (const s of o)
        t.add(s);
    }
    return t;
  }
  function Fw(e, t) {
    return e === void 0 || t === void 0 ? !0 : Cw(sb(e), sb(t));
  }
  function Oe(e) {
    return B(e).length === 0;
  }
  const B = Object.keys, Ft = Object.values, Wo = Object.entries;
  function Yc(e) {
    return e === !0 || e === !1;
  }
  function qe(e) {
    const t = e.replace(/\W/g, "_");
    return (e.match(/^\d+/) ? "_" : "") + t;
  }
  function wc(e, t) {
    return kw(e) ? `!(${wc(e.not, t)})` : $w(e) ? `(${e.and.map((n) => wc(n, t)).join(") && (")})` : Sw(e) ? `(${e.or.map((n) => wc(n, t)).join(") || (")})` : t(e);
  }
  function kg(e, t) {
    if (t.length === 0)
      return !0;
    const n = t.shift();
    return n in e && kg(e[n], t) && delete e[n], Oe(e);
  }
  function Nf(e) {
    return e.charAt(0).toUpperCase() + e.substr(1);
  }
  function Mw(e, t = "datum") {
    const n = fr(e), i = [];
    for (let r = 1; r <= n.length; r++) {
      const o = `[${n.slice(0, r).map(H).join("][")}]`;
      i.push(`${t}${o}`);
    }
    return i.join(" && ");
  }
  function jR(e, t = "datum") {
    return `${t}[${H(fr(e).join("."))}]`;
  }
  function Hne(e) {
    return e.replace(/(\[|\]|\.|'|")/g, "\\$1");
  }
  function ti(e) {
    return `${fr(e).map(Hne).join("\\.")}`;
  }
  function na(e, t, n) {
    return e.replace(new RegExp(t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), n);
  }
  function sl(e) {
    return `${fr(e).join(".")}`;
  }
  function Fu(e) {
    return e ? fr(e).length : 0;
  }
  function Ze(...e) {
    return e.find((t) => t !== void 0);
  }
  let qR = 42;
  function WR(e) {
    const t = ++qR;
    return e ? String(e) + t : t;
  }
  function Gne() {
    qR = 42;
  }
  function HR(e) {
    return GR(e) ? e : `__${e}`;
  }
  function GR(e) {
    return e.startsWith("__");
  }
  function Xc(e) {
    if (e !== void 0)
      return (e % 360 + 360) % 360;
  }
  function nm(e) {
    return $e(e) ? !0 : !isNaN(e) && !isNaN(parseFloat(e));
  }
  const Bk = Object.getPrototypeOf(structuredClone({}));
  function Dn(e, t) {
    if (e === t)
      return !0;
    if (e && t && typeof e == "object" && typeof t == "object") {
      if (e.constructor.name !== t.constructor.name)
        return !1;
      let n, i;
      if (Array.isArray(e)) {
        if (n = e.length, n != t.length)
          return !1;
        for (i = n; i-- !== 0; )
          if (!Dn(e[i], t[i]))
            return !1;
        return !0;
      }
      if (e instanceof Map && t instanceof Map) {
        if (e.size !== t.size)
          return !1;
        for (const o of e.entries())
          if (!t.has(o[0]))
            return !1;
        for (const o of e.entries())
          if (!Dn(o[1], t.get(o[0])))
            return !1;
        return !0;
      }
      if (e instanceof Set && t instanceof Set) {
        if (e.size !== t.size)
          return !1;
        for (const o of e.entries())
          if (!t.has(o[0]))
            return !1;
        return !0;
      }
      if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
        if (n = e.length, n != t.length)
          return !1;
        for (i = n; i-- !== 0; )
          if (e[i] !== t[i])
            return !1;
        return !0;
      }
      if (e.constructor === RegExp)
        return e.source === t.source && e.flags === t.flags;
      if (e.valueOf !== Object.prototype.valueOf && e.valueOf !== Bk.valueOf)
        return e.valueOf() === t.valueOf();
      if (e.toString !== Object.prototype.toString && e.toString !== Bk.toString)
        return e.toString() === t.toString();
      const r = Object.keys(e);
      if (n = r.length, n !== Object.keys(t).length)
        return !1;
      for (i = n; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(t, r[i]))
          return !1;
      for (i = n; i-- !== 0; ) {
        const o = r[i];
        if (!Dn(e[o], t[o]))
          return !1;
      }
      return !0;
    }
    return e !== e && t !== t;
  }
  function Re(e) {
    const t = [];
    return function n(i) {
      if (i && i.toJSON && typeof i.toJSON == "function" && (i = i.toJSON()), i === void 0)
        return;
      if (typeof i == "number")
        return isFinite(i) ? "" + i : "null";
      if (typeof i != "object")
        return JSON.stringify(i);
      let r, o;
      if (Array.isArray(i)) {
        for (o = "[", r = 0; r < i.length; r++)
          r && (o += ","), o += n(i[r]) || "null";
        return o + "]";
      }
      if (i === null)
        return "null";
      if (t.includes(i))
        throw new TypeError("Converting circular structure to JSON");
      const s = t.push(i) - 1, a = Object.keys(i).sort();
      for (o = "", r = 0; r < a.length; r++) {
        const u = a[r], l = n(i[u]);
        l && (o && (o += ","), o += JSON.stringify(u) + ":" + l);
      }
      return t.splice(s, 1), `{${o}}`;
    }(e);
  }
  function U(e, t) {
    return Y(e) && J(e, t) && e[t] !== void 0;
  }
  const jr = "row", qr = "column", im = "facet", We = "x", xt = "y", Ti = "x2", br = "y2", is = "xOffset", al = "yOffset", Di = "radius", eo = "radius2", ri = "theta", to = "theta2", Ni = "latitude", Oi = "longitude", Ri = "latitude2", ni = "longitude2", wn = "color", vr = "fill", xr = "stroke", En = "shape", no = "size", xa = "angle", io = "opacity", rs = "fillOpacity", os = "strokeOpacity", ss = "strokeWidth", as = "strokeDash", Of = "text", Mu = "order", Rf = "detail", rm = "key", ia = "tooltip", om = "href", sm = "url", am = "description", Vne = {
    x: 1,
    y: 1,
    x2: 1,
    y2: 1
  }, VR = {
    theta: 1,
    theta2: 1,
    radius: 1,
    radius2: 1
  };
  function YR(e) {
    return J(VR, e);
  }
  const Tw = {
    longitude: 1,
    longitude2: 1,
    latitude: 1,
    latitude2: 1
  };
  function XR(e) {
    switch (e) {
      case Ni:
        return "y";
      case Ri:
        return "y2";
      case Oi:
        return "x";
      case ni:
        return "x2";
    }
  }
  function KR(e) {
    return J(Tw, e);
  }
  const Yne = B(Tw), Dw = {
    ...Vne,
    ...VR,
    ...Tw,
    xOffset: 1,
    yOffset: 1,
    // color
    color: 1,
    fill: 1,
    stroke: 1,
    // other non-position with scale
    opacity: 1,
    fillOpacity: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
    strokeDash: 1,
    size: 1,
    angle: 1,
    shape: 1,
    // channels without scales
    order: 1,
    text: 1,
    detail: 1,
    key: 1,
    tooltip: 1,
    href: 1,
    url: 1,
    description: 1
  };
  function iu(e) {
    return e === wn || e === vr || e === xr;
  }
  const JR = {
    row: 1,
    column: 1,
    facet: 1
  }, Vn = B(JR), Nw = {
    ...Dw,
    ...JR
  }, Xne = B(Nw), { order: Lhe, detail: Phe, tooltip: Ihe, ...Kne } = Nw, { row: zhe, column: Bhe, facet: Uhe, ...Jne } = Kne;
  function Qne(e) {
    return J(Jne, e);
  }
  function QR(e) {
    return J(Nw, e);
  }
  const Zne = [Ti, br, Ri, ni, to, eo];
  function ZR(e) {
    return wa(e) !== e;
  }
  function wa(e) {
    switch (e) {
      case Ti:
        return We;
      case br:
        return xt;
      case Ri:
        return Ni;
      case ni:
        return Oi;
      case to:
        return ri;
      case eo:
        return Di;
    }
    return e;
  }
  function Ho(e) {
    if (YR(e))
      switch (e) {
        case ri:
          return "startAngle";
        case to:
          return "endAngle";
        case Di:
          return "outerRadius";
        case eo:
          return "innerRadius";
      }
    return e;
  }
  function wr(e) {
    switch (e) {
      case We:
        return Ti;
      case xt:
        return br;
      case Ni:
        return Ri;
      case Oi:
        return ni;
      case ri:
        return to;
      case Di:
        return eo;
    }
  }
  function _n(e) {
    switch (e) {
      case We:
      case Ti:
        return "width";
      case xt:
      case br:
        return "height";
    }
  }
  function e5(e) {
    switch (e) {
      case We:
        return "xOffset";
      case xt:
        return "yOffset";
      case Ti:
        return "x2Offset";
      case br:
        return "y2Offset";
      case ri:
        return "thetaOffset";
      case Di:
        return "radiusOffset";
      case to:
        return "theta2Offset";
      case eo:
        return "radius2Offset";
    }
  }
  function Ow(e) {
    switch (e) {
      case We:
        return "xOffset";
      case xt:
        return "yOffset";
    }
  }
  function eie(e) {
    switch (e) {
      case "xOffset":
        return "x";
      case "yOffset":
        return "y";
    }
  }
  const tie = B(Dw), {
    x: jhe,
    y: qhe,
    // x2 and y2 share the same scale as x and y
    x2: Whe,
    y2: Hhe,
    //
    xOffset: Ghe,
    yOffset: Vhe,
    latitude: Yhe,
    longitude: Xhe,
    latitude2: Khe,
    longitude2: Jhe,
    theta: Qhe,
    theta2: Zhe,
    radius: ege,
    radius2: tge,
    // The rest of unit channels then have scale
    ...Rw
  } = Dw, nie = B(Rw), Lw = {
    x: 1,
    y: 1
  }, ro = B(Lw);
  function et(e) {
    return J(Lw, e);
  }
  const Pw = {
    theta: 1,
    radius: 1
  }, iie = B(Pw);
  function um(e) {
    return e === "width" ? We : xt;
  }
  const t5 = { xOffset: 1, yOffset: 1 };
  function Lf(e) {
    return J(t5, e);
  }
  const {
    // x2 and y2 share the same scale as x and y
    // text and tooltip have format instead of scale,
    // href has neither format, nor scale
    text: nge,
    tooltip: ige,
    href: rge,
    url: oge,
    description: sge,
    // detail and order have no scale
    detail: age,
    key: uge,
    order: lge,
    ...n5
  } = Rw, rie = B(n5);
  function oie(e) {
    return J(Rw, e);
  }
  function sie(e) {
    switch (e) {
      case wn:
      case vr:
      case xr:
      case no:
      case En:
      case io:
      case ss:
      case as:
        return !0;
      case rs:
      case os:
      case xa:
        return !1;
    }
  }
  const i5 = {
    ...Lw,
    ...Pw,
    ...t5,
    ...n5
  }, Iw = B(i5);
  function Er(e) {
    return J(i5, e);
  }
  function aie(e, t) {
    return lie(e)[t];
  }
  const r5 = {
    // all marks
    arc: "always",
    area: "always",
    bar: "always",
    circle: "always",
    geoshape: "always",
    image: "always",
    line: "always",
    rule: "always",
    point: "always",
    rect: "always",
    square: "always",
    trail: "always",
    text: "always",
    tick: "always"
  }, { geoshape: cge, ...uie } = r5;
  function lie(e) {
    switch (e) {
      case wn:
      case vr:
      case xr:
      case am:
      case Rf:
      case rm:
      case ia:
      case om:
      case Mu:
      case io:
      case rs:
      case os:
      case ss:
      case im:
      case jr:
      case qr:
        return r5;
      case We:
      case xt:
      case is:
      case al:
      case Ni:
      case Oi:
        return uie;
      case Ti:
      case br:
      case Ri:
      case ni:
        return {
          area: "always",
          bar: "always",
          image: "always",
          rect: "always",
          rule: "always",
          circle: "binned",
          point: "binned",
          square: "binned",
          tick: "binned",
          line: "binned",
          trail: "binned"
        };
      case no:
        return {
          point: "always",
          tick: "always",
          rule: "always",
          circle: "always",
          square: "always",
          bar: "always",
          text: "always",
          line: "always",
          trail: "always"
        };
      case as:
        return {
          line: "always",
          point: "always",
          tick: "always",
          rule: "always",
          circle: "always",
          square: "always",
          bar: "always",
          geoshape: "always"
        };
      case En:
        return { point: "always", geoshape: "always" };
      case Of:
        return { text: "always" };
      case xa:
        return { point: "always", square: "always", text: "always" };
      case sm:
        return { image: "always" };
      case ri:
        return { text: "always", arc: "always" };
      case Di:
        return { text: "always", arc: "always" };
      case to:
      case eo:
        return { arc: "always" };
    }
  }
  function Z0(e) {
    switch (e) {
      case We:
      case xt:
      case ri:
      case Di:
      case is:
      case al:
      case no:
      case xa:
      case ss:
      case io:
      case rs:
      case os:
      case Ti:
      case br:
      case to:
      case eo:
        return;
      case im:
      case jr:
      case qr:
      case En:
      case as:
      case Of:
      case ia:
      case om:
      case sm:
      case am:
        return "discrete";
      case wn:
      case vr:
      case xr:
        return "flexible";
      case Ni:
      case Oi:
      case Ri:
      case ni:
      case Rf:
      case rm:
      case Mu:
        return;
    }
  }
  const cie = {
    argmax: 1,
    argmin: 1,
    average: 1,
    count: 1,
    distinct: 1,
    exponential: 1,
    exponentialb: 1,
    product: 1,
    max: 1,
    mean: 1,
    median: 1,
    min: 1,
    missing: 1,
    q1: 1,
    q3: 1,
    ci0: 1,
    ci1: 1,
    stderr: 1,
    stdev: 1,
    stdevp: 1,
    sum: 1,
    valid: 1,
    values: 1,
    variance: 1,
    variancep: 1
  }, fie = {
    count: 1,
    min: 1,
    max: 1
  };
  function Kr(e) {
    return U(e, "argmin");
  }
  function us(e) {
    return U(e, "argmax");
  }
  function zw(e) {
    return K(e) && J(cie, e);
  }
  const die = /* @__PURE__ */ new Set([
    "count",
    "valid",
    "missing",
    "distinct"
  ]);
  function lm(e) {
    return K(e) && die.has(e);
  }
  function hie(e) {
    return K(e) && ye(["min", "max"], e);
  }
  const gie = /* @__PURE__ */ new Set([
    "count",
    "sum",
    "distinct",
    "valid",
    "missing"
  ]), pie = /* @__PURE__ */ new Set([
    "mean",
    "average",
    "median",
    "q1",
    "q3",
    "min",
    "max"
  ]);
  function o5(e) {
    return Ko(e) && (e = wm(e, void 0)), "bin" + B(e).map((t) => cm(e[t]) ? qe(`_${t}_${Wo(e[t])}`) : qe(`_${t}_${e[t]}`)).join("");
  }
  function ze(e) {
    return e === !0 || Ea(e) && !e.binned;
  }
  function Et(e) {
    return e === "binned" || Ea(e) && e.binned === !0;
  }
  function Ea(e) {
    return Y(e);
  }
  function cm(e) {
    return U(e, "param");
  }
  function Uk(e) {
    switch (e) {
      case jr:
      case qr:
      case no:
      case wn:
      case vr:
      case xr:
      case ss:
      case io:
      case rs:
      case os:
      case En:
        return 6;
      case as:
        return 4;
      default:
        return 10;
    }
  }
  function Pf(e) {
    return U(e, "expr");
  }
  function _t(e, { level: t } = { level: 0 }) {
    const n = B(e || {}), i = {};
    for (const r of n)
      i[r] = t === 0 ? Fn(e[r]) : _t(e[r], { level: t - 1 });
    return i;
  }
  function s5(e) {
    const {
      // These are non-mark title config that need to be hardcoded
      anchor: t,
      frame: n,
      offset: i,
      orient: r,
      angle: o,
      limit: s,
      // color needs to be redirect to fill
      color: a,
      // subtitle properties
      subtitleColor: u,
      subtitleFont: l,
      subtitleFontSize: c,
      subtitleFontStyle: f,
      subtitleFontWeight: d,
      subtitleLineHeight: h,
      subtitlePadding: g,
      // The rest are mark config.
      ...p
    } = e, m = {
      ...p,
      ...a ? { fill: a } : {}
    }, y = {
      ...t ? { anchor: t } : {},
      ...n ? { frame: n } : {},
      ...i ? { offset: i } : {},
      ...r ? { orient: r } : {},
      ...o !== void 0 ? { angle: o } : {},
      ...s !== void 0 ? { limit: s } : {}
    }, b = {
      ...u ? { subtitleColor: u } : {},
      ...l ? { subtitleFont: l } : {},
      ...c ? { subtitleFontSize: c } : {},
      ...f ? { subtitleFontStyle: f } : {},
      ...d ? { subtitleFontWeight: d } : {},
      ...h ? { subtitleLineHeight: h } : {},
      ...g ? { subtitlePadding: g } : {}
    }, v = Au(e, ["align", "baseline", "dx", "dy", "limit"]);
    return { titleMarkConfig: m, subtitleMarkConfig: v, nonMarkTitleProperties: y, subtitle: b };
  }
  function yo(e) {
    return K(e) || P(e) && K(e[0]);
  }
  function ee(e) {
    return U(e, "signal");
  }
  function _a(e) {
    return U(e, "step");
  }
  function mie(e) {
    return P(e) ? !1 : U(e, "fields") && !U(e, "data");
  }
  function yie(e) {
    return P(e) ? !1 : U(e, "fields") && U(e, "data");
  }
  function Ir(e) {
    return P(e) ? !1 : U(e, "field") && U(e, "data");
  }
  const bie = {
    aria: 1,
    description: 1,
    ariaRole: 1,
    ariaRoleDescription: 1,
    blend: 1,
    opacity: 1,
    fill: 1,
    fillOpacity: 1,
    stroke: 1,
    strokeCap: 1,
    strokeWidth: 1,
    strokeOpacity: 1,
    strokeDash: 1,
    strokeDashOffset: 1,
    strokeJoin: 1,
    strokeOffset: 1,
    strokeMiterLimit: 1,
    startAngle: 1,
    endAngle: 1,
    padAngle: 1,
    innerRadius: 1,
    outerRadius: 1,
    size: 1,
    shape: 1,
    interpolate: 1,
    tension: 1,
    orient: 1,
    align: 1,
    baseline: 1,
    text: 1,
    dir: 1,
    dx: 1,
    dy: 1,
    ellipsis: 1,
    limit: 1,
    radius: 1,
    theta: 1,
    angle: 1,
    font: 1,
    fontSize: 1,
    fontWeight: 1,
    fontStyle: 1,
    lineBreak: 1,
    lineHeight: 1,
    cursor: 1,
    href: 1,
    tooltip: 1,
    cornerRadius: 1,
    cornerRadiusTopLeft: 1,
    cornerRadiusTopRight: 1,
    cornerRadiusBottomLeft: 1,
    cornerRadiusBottomRight: 1,
    aspect: 1,
    width: 1,
    height: 1,
    url: 1,
    smooth: 1
    // commented below are vg channel that do not have mark config.
    // x: 1,
    // y: 1,
    // x2: 1,
    // y2: 1,
    // xc'|'yc'
    // clip: 1,
    // path: 1,
    // url: 1,
  }, vie = B(bie), xie = {
    arc: 1,
    area: 1,
    group: 1,
    image: 1,
    line: 1,
    path: 1,
    rect: 1,
    rule: 1,
    shape: 1,
    symbol: 1,
    text: 1,
    trail: 1
  }, ab = [
    "cornerRadius",
    "cornerRadiusTopLeft",
    "cornerRadiusTopRight",
    "cornerRadiusBottomLeft",
    "cornerRadiusBottomRight"
  ];
  function a5(e) {
    const t = P(e.condition) ? e.condition.map(jk) : jk(e.condition);
    return {
      ...Fn(e),
      condition: t
    };
  }
  function Fn(e) {
    if (Pf(e)) {
      const { expr: t, ...n } = e;
      return { signal: t, ...n };
    }
    return e;
  }
  function jk(e) {
    if (Pf(e)) {
      const { expr: t, ...n } = e;
      return { signal: t, ...n };
    }
    return e;
  }
  function Ue(e) {
    if (Pf(e)) {
      const { expr: t, ...n } = e;
      return { signal: t, ...n };
    }
    return ee(e) ? e : e !== void 0 ? { value: e } : void 0;
  }
  function wie(e) {
    return ee(e) ? e.signal : H(e);
  }
  function qk(e) {
    return ee(e) ? e.signal : H(e.value);
  }
  function yi(e) {
    return ee(e) ? e.signal : e == null ? null : H(e);
  }
  function Eie(e, t, n) {
    for (const i of n) {
      const r = ur(i, t.markDef, t.config);
      r !== void 0 && (e[i] = Ue(r));
    }
    return e;
  }
  function u5(e) {
    return [].concat(e.type, e.style ?? []);
  }
  function Ne(e, t, n, i = {}) {
    const { vgChannel: r, ignoreVgConfig: o } = i;
    return r && U(t, r) ? t[r] : t[e] !== void 0 ? t[e] : o && (!r || r === e) ? void 0 : ur(e, t, n, i);
  }
  function ur(e, t, n, { vgChannel: i } = {}) {
    const r = ub(e, t, n.style);
    return Ze(
      // style config has highest precedence
      i ? r : void 0,
      r,
      // then mark-specific config
      i ? n[t.type][i] : void 0,
      n[t.type][e],
      // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine
      // If there is vgChannel, skip vl channel.
      // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.
      i ? n.mark[i] : n.mark[e]
      // Need to cast for the same reason as above
    );
  }
  function ub(e, t, n) {
    return l5(e, u5(t), n);
  }
  function l5(e, t, n) {
    t = X(t);
    let i;
    for (const r of t) {
      const o = n[r];
      U(o, e) && (i = o[e]);
    }
    return i;
  }
  function c5(e, t) {
    return X(e).reduce((n, i) => (n.field.push(V(i, t)), n.order.push(i.sort ?? "ascending"), n), { field: [], order: [] });
  }
  function f5(e, t) {
    const n = [...e];
    return t.forEach((i) => {
      for (const r of n)
        if (Dn(r, i))
          return;
      n.push(i);
    }), n;
  }
  function d5(e, t) {
    return Dn(e, t) || !t ? e : e ? [...X(e), ...X(t)].join(", ") : t;
  }
  function h5(e, t) {
    const n = e.value, i = t.value;
    if (n == null || i === null)
      return {
        explicit: e.explicit,
        value: null
      };
    if ((yo(n) || ee(n)) && (yo(i) || ee(i)))
      return {
        explicit: e.explicit,
        value: d5(n, i)
      };
    if (yo(n) || ee(n))
      return {
        explicit: e.explicit,
        value: n
      };
    if (yo(i) || ee(i))
      return {
        explicit: e.explicit,
        value: i
      };
    if (!yo(n) && !ee(n) && !yo(i) && !ee(i))
      return {
        explicit: e.explicit,
        value: f5(n, i)
      };
    throw new Error("It should never reach here");
  }
  function Bw(e) {
    return `Invalid specification ${Re(e)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`;
  }
  const _ie = 'Autosize "fit" only works for single views and layered views.';
  function Wk(e) {
    return `${e == "width" ? "Width" : "Height"} "container" only works for single views and layered views.`;
  }
  function Hk(e) {
    const t = e == "width" ? "Width" : "Height", n = e == "width" ? "x" : "y";
    return `${t} "container" only works well with autosize "fit" or "fit-${n}".`;
  }
  function Gk(e) {
    return e ? `Dropping "fit-${e}" because spec has discrete ${_n(e)}.` : 'Dropping "fit" because spec has discrete size.';
  }
  function Uw(e) {
    return `Unknown field for ${e}. Cannot calculate view size.`;
  }
  function Vk(e) {
    return `Cannot project a selection on encoding channel "${e}", which has no field.`;
  }
  function Sie(e, t) {
    return `Cannot project a selection on encoding channel "${e}" as it uses an aggregate function ("${t}").`;
  }
  function $ie(e) {
    return `The "nearest" transform is not supported for ${e} marks.`;
  }
  function g5(e) {
    return `Selection not supported for ${e} yet.`;
  }
  function kie(e) {
    return `Cannot find a selection named "${e}".`;
  }
  const Aie = "Scale bindings are currently only supported for scales with unbinned, continuous domains.", Cie = "Sequntial scales are deprecated. The available quantitative scale type values are linear, log, pow, sqrt, symlog, time and utc", Fie = "Legend bindings are only supported for selections over an individual field or encoding channel.";
  function Mie(e) {
    return `Lookups can only be performed on selection parameters. "${e}" is a variable parameter.`;
  }
  function Tie(e) {
    return `Cannot define and lookup the "${e}" selection in the same view. Try moving the lookup into a second, layered view?`;
  }
  const Die = "The same selection must be used to override scale domains in a layered view.", Nie = 'Interval selections should be initialized using "x", "y", "longitude", or "latitude" keys.';
  function Oie(e) {
    return `Unknown repeated value "${e}".`;
  }
  function Yk(e) {
    return `The "columns" property cannot be used when "${e}" has nested row/column.`;
  }
  const Rie = "Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";
  function Lie(e) {
    return `Unrecognized parse "${e}".`;
  }
  function Xk(e, t, n) {
    return `An ancestor parsed field "${e}" as ${n} but a child wants to parse the field as ${t}.`;
  }
  const Pie = "Attempt to add the same child twice.";
  function Iie(e) {
    return `Ignoring an invalid transform: ${Re(e)}.`;
  }
  const zie = 'If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.';
  function Kk(e) {
    return `Config.customFormatTypes is not true, thus custom format type and format for channel ${e} are dropped.`;
  }
  function Bie(e) {
    const { parentProjection: t, projection: n } = e;
    return `Layer's shared projection ${Re(t)} is overridden by a child projection ${Re(n)}.`;
  }
  const Uie = "Arc marks uses theta channel rather than angle, replacing angle with theta.";
  function jie(e) {
    return `${e}Offset dropped because ${e} is continuous`;
  }
  function qie(e, t, n) {
    return `Channel ${e} is a ${t}. Converted to {value: ${Re(n)}}.`;
  }
  function p5(e) {
    return `Invalid field type "${e}".`;
  }
  function Wie(e, t) {
    return `Invalid field type "${e}" for aggregate: "${t}", using "quantitative" instead.`;
  }
  function Hie(e) {
    return `Invalid aggregation operator "${e}".`;
  }
  function m5(e, t) {
    const { fill: n, stroke: i } = t;
    return `Dropping color ${e} as the plot also has ${n && i ? "fill and stroke" : n ? "fill" : "stroke"}.`;
  }
  function Gie(e) {
    return `Position range does not support relative band size for ${e}.`;
  }
  function lb(e, t) {
    return `Dropping ${Re(e)} from channel "${t}" since it does not contain any data field, datum, value, or signal.`;
  }
  const Vie = "Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";
  function fm(e, t, n) {
    return `${e} dropped as it is incompatible with "${t}".`;
  }
  function Yie(e) {
    return `${e}-encoding is dropped as ${e} is not a valid encoding channel.`;
  }
  function Xie(e) {
    return `${e} encoding should be discrete (ordinal / nominal / binned).`;
  }
  function Kie(e) {
    return `${e} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`;
  }
  function Jie(e) {
    return `Facet encoding dropped as ${e.join(" and ")} ${e.length > 1 ? "are" : "is"} also specified.`;
  }
  function e1(e, t) {
    return `Using discrete channel "${e}" to encode "${t}" field can be misleading as it does not encode ${t === "ordinal" ? "order" : "magnitude"}.`;
  }
  function Qie(e) {
    return `The ${e} for range marks cannot be an expression`;
  }
  function Zie(e, t) {
    return `Line mark is for continuous lines and thus cannot be used with ${e && t ? "x2 and y2" : e ? "x2" : "y2"}. We will use the rule mark (line segments) instead.`;
  }
  function ere(e, t) {
    return `Specified orient "${e}" overridden with "${t}".`;
  }
  function tre(e) {
    return `Cannot use the scale property "${e}" with non-color channel.`;
  }
  function nre(e) {
    return `Cannot use the relative band size with ${e} scale.`;
  }
  function ire(e) {
    return `Using unaggregated domain with raw field has no effect (${Re(e)}).`;
  }
  function rre(e) {
    return `Unaggregated domain not applicable for "${e}" since it produces values outside the origin domain of the source data.`;
  }
  function ore(e) {
    return `Unaggregated domain is currently unsupported for log scale (${Re(e)}).`;
  }
  function sre(e) {
    return `Cannot apply size to non-oriented mark "${e}".`;
  }
  function are(e, t, n) {
    return `Channel "${e}" does not work with "${t}" scale. We are using "${n}" scale instead.`;
  }
  function ure(e, t) {
    return `FieldDef does not work with "${e}" scale. We are using "${t}" scale instead.`;
  }
  function y5(e, t, n) {
    return `${n}-scale's "${t}" is dropped as it does not work with ${e} scale.`;
  }
  function b5(e) {
    return `The step for "${e}" is dropped because the ${e === "width" ? "x" : "y"} is continuous.`;
  }
  function lre(e, t, n, i) {
    return `Conflicting ${t.toString()} property "${e.toString()}" (${Re(n)} and ${Re(i)}). Using ${Re(n)}.`;
  }
  function cre(e, t, n, i) {
    return `Conflicting ${t.toString()} property "${e.toString()}" (${Re(n)} and ${Re(i)}). Using the union of the two domains.`;
  }
  function fre(e) {
    return `Setting the scale to be independent for "${e}" means we also have to set the guide (axis or legend) to be independent.`;
  }
  function dre(e) {
    return `Dropping sort property ${Re(e)} as unioned domains only support boolean or op "count", "min", and "max".`;
  }
  const Jk = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.", hre = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.", gre = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.", pre = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
  function mre(e) {
    return `Cannot stack "${e}" if there is already "${e}2".`;
  }
  function yre(e) {
    return `Stack is applied to a non-linear scale (${e}).`;
  }
  function bre(e) {
    return `Stacking is applied even though the aggregate function is non-summative ("${e}").`;
  }
  function Ag(e, t) {
    return `Invalid ${e}: ${Re(t)}.`;
  }
  function vre(e) {
    return `Dropping day from datetime ${Re(e)} as day cannot be combined with other units.`;
  }
  function xre(e, t) {
    return `${t ? "extent " : ""}${t && e ? "and " : ""}${e ? "center " : ""}${t && e ? "are " : "is "}not needed when data are aggregated.`;
  }
  function wre(e, t, n) {
    return `${e} is not usually used with ${t} for ${n}.`;
  }
  function Ere(e, t) {
    return `Continuous axis should not have customized aggregation function ${e}; ${t} already agregates the axis.`;
  }
  function Qk(e) {
    return `1D error band does not support ${e}.`;
  }
  function v5(e) {
    return `Channel ${e} is required for "binned" bin.`;
  }
  function _re(e) {
    return `Channel ${e} should not be used with "binned" bin.`;
  }
  function Sre(e) {
    return `Domain for ${e} is required for threshold scale.`;
  }
  const x5 = Lb(Rb);
  let Tu = x5;
  function $re(e) {
    return Tu = e, Tu;
  }
  function kre() {
    return Tu = x5, Tu;
  }
  function j(...e) {
    Tu.warn(...e);
  }
  function Are(...e) {
    Tu.debug(...e);
  }
  function Sa(e) {
    if (e && Y(e)) {
      for (const t of qw)
        if (U(e, t))
          return !0;
    }
    return !1;
  }
  const w5 = [
    "january",
    "february",
    "march",
    "april",
    "may",
    "june",
    "july",
    "august",
    "september",
    "october",
    "november",
    "december"
  ], Cre = w5.map((e) => e.substr(0, 3)), E5 = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"], Fre = E5.map((e) => e.substr(0, 3));
  function Mre(e) {
    if (nm(e) && (e = +e), $e(e))
      return e > 4 && j(Ag("quarter", e)), e - 1;
    throw new Error(Ag("quarter", e));
  }
  function Tre(e) {
    if (nm(e) && (e = +e), $e(e))
      return e - 1;
    {
      const t = e.toLowerCase(), n = w5.indexOf(t);
      if (n !== -1)
        return n;
      const i = t.substr(0, 3), r = Cre.indexOf(i);
      if (r !== -1)
        return r;
      throw new Error(Ag("month", e));
    }
  }
  function Dre(e) {
    if (nm(e) && (e = +e), $e(e))
      return e % 7;
    {
      const t = e.toLowerCase(), n = E5.indexOf(t);
      if (n !== -1)
        return n;
      const i = t.substr(0, 3), r = Fre.indexOf(i);
      if (r !== -1)
        return r;
      throw new Error(Ag("day", e));
    }
  }
  function jw(e, t) {
    const n = [];
    if (t && e.day !== void 0 && B(e).length > 1 && (j(vre(e)), e = ue(e), delete e.day), e.year !== void 0 ? n.push(e.year) : n.push(2012), e.month !== void 0) {
      const i = t ? Tre(e.month) : e.month;
      n.push(i);
    } else if (e.quarter !== void 0) {
      const i = t ? Mre(e.quarter) : e.quarter;
      n.push($e(i) ? i * 3 : `${i}*3`);
    } else
      n.push(0);
    if (e.date !== void 0)
      n.push(e.date);
    else if (e.day !== void 0) {
      const i = t ? Dre(e.day) : e.day;
      n.push($e(i) ? i + 1 : `${i}+1`);
    } else
      n.push(1);
    for (const i of ["hours", "minutes", "seconds", "milliseconds"]) {
      const r = e[i];
      n.push(typeof r > "u" ? 0 : r);
    }
    return n;
  }
  function ra(e) {
    const n = jw(e, !0).join(", ");
    return e.utc ? `utc(${n})` : `datetime(${n})`;
  }
  function Nre(e) {
    const n = jw(e, !1).join(", ");
    return e.utc ? `utc(${n})` : `datetime(${n})`;
  }
  function Ore(e) {
    const t = jw(e, !0);
    return e.utc ? +new Date(Date.UTC(...t)) : +new Date(...t);
  }
  const _5 = {
    year: 1,
    quarter: 1,
    month: 1,
    week: 1,
    day: 1,
    dayofyear: 1,
    date: 1,
    hours: 1,
    minutes: 1,
    seconds: 1,
    milliseconds: 1
  }, qw = B(_5);
  function Rre(e) {
    return J(_5, e);
  }
  function $a(e) {
    return Y(e) ? e.binned : S5(e);
  }
  function S5(e) {
    return e && e.startsWith("binned");
  }
  function Ww(e) {
    return e.startsWith("utc");
  }
  function Lre(e) {
    return e.substring(3);
  }
  const Pre = {
    "year-month": "%b %Y ",
    "year-month-date": "%b %d, %Y "
  };
  function dm(e) {
    return qw.filter((t) => k5(e, t));
  }
  function $5(e) {
    const t = dm(e);
    return t[t.length - 1];
  }
  function k5(e, t) {
    const n = e.indexOf(t);
    return !(n < 0 || n > 0 && t === "seconds" && e.charAt(n - 1) === "i" || e.length > n + 3 && t === "day" && e.charAt(n + 3) === "o" || n > 0 && t === "year" && e.charAt(n - 1) === "f");
  }
  function Ire(e, t, { end: n } = { end: !1 }) {
    const i = Mw(t), r = Ww(e) ? "utc" : "";
    function o(u) {
      return u === "quarter" ? `(${r}quarter(${i})-1)` : `${r}${u}(${i})`;
    }
    let s;
    const a = {};
    for (const u of qw)
      k5(e, u) && (a[u] = o(u), s = u);
    return n && (a[s] += "+1"), Nre(a);
  }
  function A5(e) {
    if (!e)
      return;
    const t = dm(e);
    return `timeUnitSpecifier(${Re(t)}, ${Re(Pre)})`;
  }
  function zre(e, t, n) {
    if (!e)
      return;
    const i = A5(e);
    return `${n || Ww(e) ? "utc" : "time"}Format(${t}, ${i})`;
  }
  function yt(e) {
    if (!e)
      return;
    let t;
    return K(e) ? S5(e) ? t = {
      unit: e.substring(6),
      binned: !0
    } : t = {
      unit: e
    } : Y(e) && (t = {
      ...e,
      ...e.unit ? { unit: e.unit } : {}
    }), Ww(t.unit) && (t.utc = !0, t.unit = Lre(t.unit)), t;
  }
  function Bre(e) {
    const { utc: t, ...n } = yt(e);
    return n.unit ? (t ? "utc" : "") + B(n).map((i) => qe(`${i === "unit" ? "" : `_${i}_`}${n[i]}`)).join("") : (t ? "utc" : "") + "timeunit" + B(n).map((i) => qe(`_${i}_${n[i]}`)).join("");
  }
  function C5(e, t = (n) => n) {
    const n = yt(e), i = $5(n.unit);
    if (i && i !== "day") {
      const r = {
        year: 2001,
        // pick a non-leap year
        month: 1,
        date: 1,
        hours: 0,
        minutes: 0,
        seconds: 0,
        milliseconds: 0
      }, { step: o, part: s } = F5(i, n.step), a = {
        ...r,
        [s]: +r[s] + o
      };
      return `${t(ra(a))} - ${t(ra(r))}`;
    }
  }
  const Ure = {
    year: 1,
    month: 1,
    date: 1,
    hours: 1,
    minutes: 1,
    seconds: 1,
    milliseconds: 1
  };
  function jre(e) {
    return J(Ure, e);
  }
  function F5(e, t = 1) {
    if (jre(e))
      return { part: e, step: t };
    switch (e) {
      case "day":
      case "dayofyear":
        return { part: "date", step: t };
      case "quarter":
        return { part: "month", step: t * 3 };
      case "week":
        return { part: "date", step: t * 7 };
    }
  }
  function qre(e) {
    return U(e, "param");
  }
  function Hw(e) {
    return !!(e != null && e.field) && e.equal !== void 0;
  }
  function Gw(e) {
    return !!(e != null && e.field) && e.lt !== void 0;
  }
  function Vw(e) {
    return !!(e != null && e.field) && e.lte !== void 0;
  }
  function Yw(e) {
    return !!(e != null && e.field) && e.gt !== void 0;
  }
  function Xw(e) {
    return !!(e != null && e.field) && e.gte !== void 0;
  }
  function Kw(e) {
    if (e != null && e.field) {
      if (P(e.range) && e.range.length === 2)
        return !0;
      if (ee(e.range))
        return !0;
    }
    return !1;
  }
  function Jw(e) {
    return !!(e != null && e.field) && (P(e.oneOf) || P(e.in));
  }
  function Wre(e) {
    return !!(e != null && e.field) && e.valid !== void 0;
  }
  function M5(e) {
    return Jw(e) || Hw(e) || Kw(e) || Gw(e) || Yw(e) || Vw(e) || Xw(e);
  }
  function Bi(e, t) {
    return Em(e, { timeUnit: t, wrapTime: !0 });
  }
  function Hre(e, t) {
    return e.map((n) => Bi(n, t));
  }
  function T5(e, t = !0) {
    const { field: n } = e, i = yt(e.timeUnit), { unit: r, binned: o } = i || {}, s = V(e, { expr: "datum" }), a = r ? (
      // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.
      // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline
      // TODO: support utc
      `time(${o ? s : Ire(r, n)})`
    ) : s;
    if (Hw(e))
      return `${a}===${Bi(e.equal, r)}`;
    if (Gw(e)) {
      const u = e.lt;
      return `${a}<${Bi(u, r)}`;
    } else if (Yw(e)) {
      const u = e.gt;
      return `${a}>${Bi(u, r)}`;
    } else if (Vw(e)) {
      const u = e.lte;
      return `${a}<=${Bi(u, r)}`;
    } else if (Xw(e)) {
      const u = e.gte;
      return `${a}>=${Bi(u, r)}`;
    } else {
      if (Jw(e))
        return `indexof([${Hre(e.oneOf, r).join(",")}], ${a}) !== -1`;
      if (Wre(e))
        return hm(a, e.valid);
      if (Kw(e)) {
        const { range: u } = _t(e), l = ee(u) ? { signal: `${u.signal}[0]` } : u[0], c = ee(u) ? { signal: `${u.signal}[1]` } : u[1];
        if (l !== null && c !== null && t)
          return "inrange(" + a + ", [" + Bi(l, r) + ", " + Bi(c, r) + "])";
        const f = [];
        return l !== null && f.push(`${a} >= ${Bi(l, r)}`), c !== null && f.push(`${a} <= ${Bi(c, r)}`), f.length > 0 ? f.join(" && ") : "true";
      }
    }
    throw new Error(`Invalid field predicate: ${Re(e)}`);
  }
  function hm(e, t = !0) {
    return t ? `isValid(${e}) && isFinite(+${e})` : `!isValid(${e}) || !isFinite(+${e})`;
  }
  function Gre(e) {
    return M5(e) && e.timeUnit ? {
      ...e,
      timeUnit: yt(e.timeUnit)
    } : e;
  }
  const If = {
    quantitative: "quantitative",
    ordinal: "ordinal",
    temporal: "temporal",
    nominal: "nominal",
    geojson: "geojson"
  };
  function Vre(e) {
    return e === "quantitative" || e === "temporal";
  }
  function D5(e) {
    return e === "ordinal" || e === "nominal";
  }
  const oa = If.quantitative, Qw = If.ordinal, Du = If.temporal, Zw = If.nominal, ul = If.geojson;
  function Yre(e) {
    if (e)
      switch (e = e.toLowerCase(), e) {
        case "q":
        case oa:
          return "quantitative";
        case "t":
        case Du:
          return "temporal";
        case "o":
        case Qw:
          return "ordinal";
        case "n":
        case Zw:
          return "nominal";
        case ul:
          return "geojson";
      }
  }
  const St = {
    // Continuous - Quantitative
    LINEAR: "linear",
    LOG: "log",
    POW: "pow",
    SQRT: "sqrt",
    SYMLOG: "symlog",
    IDENTITY: "identity",
    SEQUENTIAL: "sequential",
    // Continuous - Time
    TIME: "time",
    UTC: "utc",
    // Discretizing scales
    QUANTILE: "quantile",
    QUANTIZE: "quantize",
    THRESHOLD: "threshold",
    BIN_ORDINAL: "bin-ordinal",
    // Discrete scales
    ORDINAL: "ordinal",
    POINT: "point",
    BAND: "band"
  }, cb = {
    linear: "numeric",
    log: "numeric",
    pow: "numeric",
    sqrt: "numeric",
    symlog: "numeric",
    identity: "numeric",
    sequential: "numeric",
    time: "time",
    utc: "time",
    ordinal: "ordinal",
    "bin-ordinal": "bin-ordinal",
    // TODO: should bin-ordinal support merging with other
    point: "ordinal-position",
    band: "ordinal-position",
    quantile: "discretizing",
    quantize: "discretizing",
    threshold: "discretizing"
  };
  function Xre(e, t) {
    const n = cb[e], i = cb[t];
    return n === i || n === "ordinal-position" && i === "time" || i === "ordinal-position" && n === "time";
  }
  const Kre = {
    // numeric
    linear: 0,
    log: 1,
    pow: 1,
    sqrt: 1,
    symlog: 1,
    identity: 1,
    sequential: 1,
    // time
    time: 0,
    utc: 0,
    // ordinal-position -- these have higher precedence than continuous scales as they support more types of data
    point: 10,
    band: 11,
    // band has higher precedence as it is better for interaction
    // non grouped types
    ordinal: 0,
    "bin-ordinal": 0,
    quantile: 0,
    quantize: 0,
    threshold: 0
  };
  function Zk(e) {
    return Kre[e];
  }
  const N5 = /* @__PURE__ */ new Set([
    "linear",
    "log",
    "pow",
    "sqrt",
    "symlog"
  ]), O5 = /* @__PURE__ */ new Set([
    ...N5,
    "time",
    "utc"
  ]);
  function R5(e) {
    return N5.has(e);
  }
  const L5 = /* @__PURE__ */ new Set([
    "quantile",
    "quantize",
    "threshold"
  ]), Jre = /* @__PURE__ */ new Set([
    ...O5,
    ...L5,
    "sequential",
    "identity"
  ]), Qre = /* @__PURE__ */ new Set([
    "ordinal",
    "bin-ordinal",
    "point",
    "band"
  ]);
  function bt(e) {
    return Qre.has(e);
  }
  function Si(e) {
    return Jre.has(e);
  }
  function Ki(e) {
    return O5.has(e);
  }
  function Nu(e) {
    return L5.has(e);
  }
  const Zre = {
    pointPadding: 0.5,
    barBandPaddingInner: 0.1,
    rectBandPaddingInner: 0,
    tickBandPaddingInner: 0.25,
    bandWithNestedOffsetPaddingInner: 0.2,
    bandWithNestedOffsetPaddingOuter: 0.2,
    minBandSize: 2,
    minFontSize: 8,
    maxFontSize: 40,
    minOpacity: 0.3,
    maxOpacity: 0.8,
    // FIXME: revise if these *can* become ratios of width/height step
    minSize: 4,
    // Point size is area. For square point, 9 = 3 pixel ^ 2, not too small!
    minStrokeWidth: 1,
    maxStrokeWidth: 4,
    quantileCount: 4,
    quantizeCount: 4,
    zero: !0
  };
  function eoe(e) {
    return !K(e) && U(e, "name");
  }
  function P5(e) {
    return U(e, "param");
  }
  function toe(e) {
    return U(e, "unionWith");
  }
  function noe(e) {
    return Y(e) && "field" in e;
  }
  const ioe = {
    type: 1,
    domain: 1,
    domainMax: 1,
    domainMin: 1,
    domainMid: 1,
    domainRaw: 1,
    align: 1,
    range: 1,
    rangeMax: 1,
    rangeMin: 1,
    scheme: 1,
    bins: 1,
    // Other properties
    reverse: 1,
    round: 1,
    // quantitative / time
    clamp: 1,
    nice: 1,
    // quantitative
    base: 1,
    exponent: 1,
    constant: 1,
    interpolate: 1,
    zero: 1,
    // zero depends on domain
    // band/point
    padding: 1,
    paddingInner: 1,
    paddingOuter: 1
  }, { type: fge, domain: dge, range: hge, rangeMax: gge, rangeMin: pge, scheme: mge, ...roe } = ioe, ooe = B(roe);
  function fb(e, t) {
    switch (t) {
      case "type":
      case "domain":
      case "reverse":
      case "range":
        return !0;
      case "scheme":
      case "interpolate":
        return !["point", "band", "identity"].includes(e);
      case "bins":
        return !["point", "band", "identity", "ordinal"].includes(e);
      case "round":
        return Ki(e) || e === "band" || e === "point";
      case "padding":
      case "rangeMin":
      case "rangeMax":
        return Ki(e) || ["point", "band"].includes(e);
      case "paddingOuter":
      case "align":
        return ["point", "band"].includes(e);
      case "paddingInner":
        return e === "band";
      case "domainMax":
      case "domainMid":
      case "domainMin":
      case "domainRaw":
      case "clamp":
        return Ki(e);
      case "nice":
        return Ki(e) || e === "quantize" || e === "threshold";
      case "exponent":
        return e === "pow";
      case "base":
        return e === "log";
      case "constant":
        return e === "symlog";
      case "zero":
        return Si(e) && !ye([
          "log",
          // log scale cannot have zero value
          "time",
          "utc",
          // zero is not meaningful for time
          "threshold",
          // threshold requires custom domain so zero does not matter
          "quantile"
          // quantile depends on distribution so zero does not matter
        ], e);
    }
  }
  function I5(e, t) {
    switch (t) {
      case "interpolate":
      case "scheme":
      case "domainMid":
        return iu(e) ? void 0 : tre(t);
      case "align":
      case "type":
      case "bins":
      case "domain":
      case "domainMax":
      case "domainMin":
      case "domainRaw":
      case "range":
      case "base":
      case "exponent":
      case "constant":
      case "nice":
      case "padding":
      case "paddingInner":
      case "paddingOuter":
      case "rangeMax":
      case "rangeMin":
      case "reverse":
      case "round":
      case "clamp":
      case "zero":
        return;
    }
  }
  function soe(e, t) {
    return ye([Qw, Zw], t) ? e === void 0 || bt(e) : t === Du ? ye([St.TIME, St.UTC, void 0], e) : t === oa ? R5(e) || Nu(e) || e === void 0 : !0;
  }
  function aoe(e, t, n = !1) {
    if (!Er(e))
      return !1;
    switch (e) {
      case We:
      case xt:
      case is:
      case al:
      case ri:
      case Di:
        return Ki(t) || t === "band" ? !0 : t === "point" ? !n : !1;
      case no:
      case ss:
      case io:
      case rs:
      case os:
      case xa:
        return Ki(t) || Nu(t) || ye(["band", "point", "ordinal"], t);
      case wn:
      case vr:
      case xr:
        return t !== "band";
      case as:
      case En:
        return t === "ordinal" || Nu(t);
    }
  }
  function uoe(e) {
    return Y(e) && "value" in e;
  }
  const cn = {
    arc: "arc",
    area: "area",
    bar: "bar",
    image: "image",
    line: "line",
    point: "point",
    rect: "rect",
    rule: "rule",
    text: "text",
    tick: "tick",
    trail: "trail",
    circle: "circle",
    square: "square",
    geoshape: "geoshape"
  }, z5 = cn.arc, gm = cn.area, pm = cn.bar, loe = cn.image, mm = cn.line, ym = cn.point, coe = cn.rect, Cg = cn.rule, B5 = cn.text, eE = cn.tick, foe = cn.trail, tE = cn.circle, nE = cn.square, U5 = cn.geoshape;
  function ls(e) {
    return ["line", "area", "trail"].includes(e);
  }
  function Kc(e) {
    return [
      "rect",
      "bar",
      "image",
      "arc",
      "tick"
      /* arc is rect/interval in polar coordinate */
    ].includes(e);
  }
  const doe = new Set(B(cn));
  function lr(e) {
    return U(e, "type");
  }
  const hoe = [
    "stroke",
    "strokeWidth",
    "strokeDash",
    "strokeDashOffset",
    "strokeOpacity",
    "strokeJoin",
    "strokeMiterLimit"
  ], goe = ["fill", "fillOpacity"], poe = [...hoe, ...goe], moe = {
    color: 1,
    filled: 1,
    invalid: 1,
    order: 1,
    radius2: 1,
    theta2: 1,
    timeUnitBandSize: 1,
    timeUnitBandPosition: 1
  }, eA = B(moe), t1 = [
    "binSpacing",
    "continuousBandSize",
    "discreteBandSize",
    "minBandSize"
  ], yoe = {
    area: ["line", "point"],
    bar: t1,
    rect: t1,
    line: ["point"],
    tick: ["bandSize", "thickness", ...t1]
  }, boe = {
    color: "#4c78a8",
    invalid: "break-paths-show-path-domains",
    timeUnitBandSize: 1
  }, voe = {
    mark: 1,
    arc: 1,
    area: 1,
    bar: 1,
    circle: 1,
    image: 1,
    line: 1,
    point: 1,
    rect: 1,
    rule: 1,
    square: 1,
    text: 1,
    tick: 1,
    trail: 1,
    geoshape: 1
  }, j5 = B(voe);
  function sa(e) {
    return U(e, "band");
  }
  const xoe = {
    horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
    vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
  }, woe = 5, iE = {
    binSpacing: 0,
    continuousBandSize: woe,
    minBandSize: 0.25,
    timeUnitBandPosition: 0.5
  }, Eoe = {
    ...iE,
    binSpacing: 1
  }, _oe = {
    ...iE,
    thickness: 1
  };
  function Soe(e) {
    return lr(e) ? e.type : e;
  }
  function q5(e, { isPath: t }) {
    return e === void 0 || e === "break-paths-show-path-domains" ? t ? "break-paths-show-domains" : "filter" : e === null ? "show" : e;
  }
  function rE({ markDef: e, config: t, scaleChannel: n, scaleType: i, isCountAggregate: r }) {
    var a, u;
    if (!i || !Si(i) || r)
      return "always-valid";
    const o = q5(Ne("invalid", e, t), {
      isPath: ls(e.type)
    });
    return ((u = (a = t.scale) == null ? void 0 : a.invalid) == null ? void 0 : u[n]) !== void 0 ? "show" : o;
  }
  function $oe(e) {
    return e === "break-paths-filter-domains" || e === "break-paths-show-domains";
  }
  function W5({ scaleName: e, scale: t, mode: n }) {
    const i = `domain('${e}')`;
    if (!t || !e)
      return;
    const r = `${i}[0]`, o = `peek(${i})`, s = t.domainHasZero();
    return s === "definitely" ? {
      scale: e,
      value: 0
    } : s === "maybe" ? { signal: `scale('${e}', inrange(0, ${i}) ? 0 : ${n === "zeroOrMin" ? r : o})` } : { signal: `scale('${e}', ${n === "zeroOrMin" ? r : o})` };
  }
  function H5({ scaleChannel: e, channelDef: t, scale: n, scaleName: i, markDef: r, config: o }) {
    var c;
    const s = n == null ? void 0 : n.get("type"), a = ki(t), u = lm(a == null ? void 0 : a.aggregate), l = rE({
      scaleChannel: e,
      markDef: r,
      config: o,
      scaleType: s,
      isCountAggregate: u
    });
    if (a && l === "show") {
      const f = ((c = o.scale.invalid) == null ? void 0 : c[e]) ?? "zero-or-min";
      return {
        test: hm(V(a, { expr: "datum" }), !1),
        ...koe(f, n, i)
      };
    }
  }
  function koe(e, t, n) {
    if (uoe(e)) {
      const { value: i } = e;
      return ee(i) ? { signal: i.signal } : { value: i };
    }
    return W5({
      scale: t,
      scaleName: n,
      mode: "zeroOrMin"
    });
  }
  function oE(e) {
    const { channel: t, channelDef: n, markDef: i, scale: r, scaleName: o, config: s } = e, a = wa(t), u = sE(e), l = H5({
      scaleChannel: a,
      channelDef: n,
      scale: r,
      scaleName: o,
      markDef: i,
      config: s
    });
    return l !== void 0 ? [l, u] : u;
  }
  function Aoe(e) {
    const { datum: t } = e;
    return Sa(t) ? ra(t) : `${Re(t)}`;
  }
  function Bs(e, t, n, i) {
    const r = {};
    if (t && (r.scale = t), _r(e)) {
      const { datum: o } = e;
      Sa(o) ? r.signal = ra(o) : ee(o) ? r.signal = o.signal : Pf(o) ? r.signal = o.expr : r.value = o;
    } else
      r.field = V(e, n);
    if (i) {
      const { offset: o, band: s } = i;
      o && (r.offset = o), s && (r.band = s);
    }
    return r;
  }
  function Fg({ scaleName: e, fieldOrDatumDef: t, fieldOrDatumDef2: n, offset: i, startSuffix: r, endSuffix: o = "end", bandPosition: s = 0.5 }) {
    const a = !ee(s) && 0 < s && s < 1 ? "datum" : void 0, u = V(t, { expr: a, suffix: r }), l = n !== void 0 ? V(n, { expr: a }) : V(t, { suffix: o, expr: a }), c = {};
    if (s === 0 || s === 1) {
      c.scale = e;
      const f = s === 0 ? u : l;
      c.field = f;
    } else {
      const f = ee(s) ? `(1-${s.signal}) * ${u} + ${s.signal} * ${l}` : `${1 - s} * ${u} + ${s} * ${l}`;
      c.signal = `scale("${e}", ${f})`;
    }
    return i && (c.offset = i), c;
  }
  function Coe({ scaleName: e, fieldDef: t }) {
    const n = V(t, { expr: "datum" }), i = V(t, { expr: "datum", suffix: "end" });
    return `abs(scale("${e}", ${i}) - scale("${e}", ${n}))`;
  }
  function sE({ channel: e, channelDef: t, channel2Def: n, markDef: i, config: r, scaleName: o, scale: s, stack: a, offset: u, defaultRef: l, bandPosition: c }) {
    if (t) {
      if (le(t)) {
        const f = s == null ? void 0 : s.get("type");
        if (un(t)) {
          c ?? (c = Go({
            fieldDef: t,
            fieldDef2: n,
            markDef: i,
            config: r
          }));
          const { bin: d, timeUnit: h, type: g } = t;
          if (ze(d) || c && h && g === Du)
            return a != null && a.impute ? Bs(t, o, { binSuffix: "mid" }, { offset: u }) : c && !bt(f) ? Fg({ scaleName: o, fieldOrDatumDef: t, bandPosition: c, offset: u }) : Bs(t, o, qf(t, e) ? { binSuffix: "range" } : {}, {
              offset: u
            });
          if (Et(d)) {
            if (q(n))
              return Fg({
                scaleName: o,
                fieldOrDatumDef: t,
                fieldOrDatumDef2: n,
                bandPosition: c,
                offset: u
              });
            j(v5(e === We ? Ti : br));
          }
        }
        return Bs(
          t,
          o,
          bt(f) ? { binSuffix: "range" } : {},
          // no need for bin suffix if there is no scale
          {
            offset: u,
            // For band, to get mid point, need to offset by half of the band
            band: f === "band" ? c ?? t.bandPosition ?? 0.5 : void 0
          }
        );
      } else if ($i(t)) {
        const f = t.value, d = u ? { offset: u } : {};
        return { ...Ec(e, f), ...d };
      }
    }
    return fe(l) && (l = l()), l && {
      ...l,
      // only include offset when it is non-zero (zero = no offset)
      ...u ? { offset: u } : {}
    };
  }
  function Ec(e, t) {
    return ye(["x", "x2"], e) && t === "width" ? { field: { group: "width" } } : ye(["y", "y2"], e) && t === "height" ? { field: { group: "height" } } : Ue(t);
  }
  function aa(e) {
    return e && e !== "number" && e !== "time";
  }
  function G5(e, t, n) {
    return `${e}(${t}${n ? `, ${Re(n)}` : ""})`;
  }
  const Foe = " – ";
  function aE({ fieldOrDatumDef: e, format: t, formatType: n, expr: i, normalizeStack: r, config: o }) {
    var u, l;
    if (aa(n))
      return bi({
        fieldOrDatumDef: e,
        format: t,
        formatType: n,
        expr: i,
        config: o
      });
    const s = V5(e, i, r), a = Ou(e);
    if (t === void 0 && n === void 0 && o.customFormatTypes) {
      if (a === "quantitative") {
        if (r && o.normalizedNumberFormatType)
          return bi({
            fieldOrDatumDef: e,
            format: o.normalizedNumberFormat,
            formatType: o.normalizedNumberFormatType,
            expr: i,
            config: o
          });
        if (o.numberFormatType)
          return bi({
            fieldOrDatumDef: e,
            format: o.numberFormat,
            formatType: o.numberFormatType,
            expr: i,
            config: o
          });
      }
      if (a === "temporal" && o.timeFormatType && q(e) && e.timeUnit === void 0)
        return bi({
          fieldOrDatumDef: e,
          format: o.timeFormat,
          formatType: o.timeFormatType,
          expr: i,
          config: o
        });
    }
    if (Lu(e)) {
      const c = Toe({
        field: s,
        timeUnit: q(e) ? (u = yt(e.timeUnit)) == null ? void 0 : u.unit : void 0,
        format: t,
        formatType: o.timeFormatType,
        rawTimeFormat: o.timeFormat,
        isUTCScale: ka(e) && ((l = e.scale) == null ? void 0 : l.type) === St.UTC
      });
      return c ? { signal: c } : void 0;
    }
    if (t = db({ type: a, specifiedFormat: t, config: o, normalizeStack: r }), q(e) && ze(e.bin)) {
      const c = V(e, { expr: i, binSuffix: "end" });
      return {
        signal: zf(s, c, t, n, o)
      };
    } else return t || Ou(e) === "quantitative" ? {
      signal: `${K5(s, t)}`
    } : { signal: `isValid(${s}) ? ${s} : ""+${s}` };
  }
  function V5(e, t, n) {
    return q(e) ? n ? `${V(e, { expr: t, suffix: "end" })}-${V(e, {
      expr: t,
      suffix: "start"
    })}` : V(e, { expr: t }) : Aoe(e);
  }
  function bi({ fieldOrDatumDef: e, format: t, formatType: n, expr: i, normalizeStack: r, config: o, field: s }) {
    if (s ?? (s = V5(e, i, r)), s !== "datum.value" && // For axis/legend, we can't correctly know the end of the bin from `datum`
    q(e) && ze(e.bin)) {
      const a = V(e, { expr: i, binSuffix: "end" });
      return {
        signal: zf(s, a, t, n, o)
      };
    }
    return { signal: G5(n, s, t) };
  }
  function Y5(e, t, n, i, r, o) {
    var s;
    if (!(K(i) && aa(i)) && !(n === void 0 && i === void 0 && r.customFormatTypes && Ou(e) === "quantitative" && (r.normalizedNumberFormatType && Ru(e) && e.stack === "normalize" || r.numberFormatType))) {
      if (Ru(e) && e.stack === "normalize" && r.normalizedNumberFormat)
        return db({
          type: "quantitative",
          config: r,
          normalizeStack: !0
        });
      if (Lu(e)) {
        const a = q(e) ? (s = yt(e.timeUnit)) == null ? void 0 : s.unit : void 0;
        return a === void 0 && r.customFormatTypes && r.timeFormatType ? void 0 : Moe({ specifiedFormat: n, timeUnit: a, config: r, omitTimeFormatConfig: o });
      }
      return db({ type: t, specifiedFormat: n, config: r });
    }
  }
  function X5(e, t, n) {
    var i;
    if (e && (ee(e) || e === "number" || e === "time"))
      return e;
    if (Lu(t) && n !== "time" && n !== "utc")
      return q(t) && ((i = yt(t == null ? void 0 : t.timeUnit)) != null && i.utc) ? "utc" : "time";
  }
  function db({ type: e, specifiedFormat: t, config: n, normalizeStack: i }) {
    if (K(t))
      return t;
    if (e === oa)
      return i ? n.normalizedNumberFormat : n.numberFormat;
  }
  function Moe({ specifiedFormat: e, timeUnit: t, config: n, omitTimeFormatConfig: i }) {
    return e || (t ? {
      signal: A5(t)
    } : i ? void 0 : n.timeFormat);
  }
  function K5(e, t) {
    return `format(${e}, "${t || ""}")`;
  }
  function tA(e, t, n, i) {
    return aa(n) ? G5(n, e, t) : K5(e, (K(t) ? t : void 0) ?? i.numberFormat);
  }
  function zf(e, t, n, i, r) {
    if (n === void 0 && i === void 0 && r.customFormatTypes && r.numberFormatType)
      return zf(e, t, r.numberFormat, r.numberFormatType, r);
    const o = tA(e, n, i, r), s = tA(t, n, i, r);
    return `${hm(e, !1)} ? "null" : ${o} + "${Foe}" + ${s}`;
  }
  function Toe({ field: e, timeUnit: t, format: n, formatType: i, rawTimeFormat: r, isUTCScale: o }) {
    return !t || n ? !t && i ? `${i}(${e}, '${n}')` : (n = K(n) ? n : r, `${o ? "utc" : "time"}Format(${e}, '${n}')`) : zre(t, e, o);
  }
  const bm = "min", Doe = {
    x: 1,
    y: 1,
    color: 1,
    fill: 1,
    stroke: 1,
    strokeWidth: 1,
    size: 1,
    shape: 1,
    fillOpacity: 1,
    strokeOpacity: 1,
    opacity: 1,
    text: 1
  };
  function nA(e) {
    return J(Doe, e);
  }
  function Noe(e) {
    return U(e, "encoding");
  }
  function Wr(e) {
    return e && (e.op === "count" || U(e, "field"));
  }
  function J5(e) {
    return e && P(e);
  }
  function Bf(e) {
    return U(e, "row") || U(e, "column");
  }
  function uE(e) {
    return U(e, "header");
  }
  function vm(e) {
    return U(e, "facet");
  }
  function Ooe(e) {
    return U(e, "param");
  }
  function Roe(e) {
    return !K(e) && U(e, "repeat");
  }
  function iA(e) {
    const { field: t, timeUnit: n, bin: i, aggregate: r } = e;
    return {
      ...n ? { timeUnit: n } : {},
      ...i ? { bin: i } : {},
      ...r ? { aggregate: r } : {},
      field: t
    };
  }
  function lE(e) {
    return U(e, "sort");
  }
  function Go({ fieldDef: e, fieldDef2: t, markDef: n, config: i }) {
    if (le(e) && e.bandPosition !== void 0)
      return e.bandPosition;
    if (q(e)) {
      const { timeUnit: r, bin: o } = e;
      if (r && !t)
        return ur("timeUnitBandPosition", n, i);
      if (ze(o))
        return 0.5;
    }
  }
  function Q5({ channel: e, fieldDef: t, fieldDef2: n, markDef: i, config: r, scaleType: o, useVlSizeChannel: s }) {
    var l, c, f;
    const a = _n(e), u = Ne(s ? "size" : a, i, r, {
      vgChannel: a
    });
    if (u !== void 0)
      return u;
    if (q(t)) {
      const { timeUnit: d, bin: h } = t;
      if (d && !n)
        return { band: ur("timeUnitBandSize", i, r) };
      if (ze(h) && !bt(o))
        return { band: 1 };
    }
    if (Kc(i.type))
      return o ? bt(o) ? ((l = r[i.type]) == null ? void 0 : l.discreteBandSize) || { band: 1 } : (c = r[i.type]) == null ? void 0 : c.continuousBandSize : (f = r[i.type]) == null ? void 0 : f.discreteBandSize;
  }
  function Z5(e, t, n, i) {
    return ze(e.bin) || e.timeUnit && un(e) && e.type === "temporal" ? Go({ fieldDef: e, fieldDef2: t, markDef: n, config: i }) !== void 0 : !1;
  }
  function e6(e) {
    return U(e, "sort") && !U(e, "field");
  }
  function Uf(e) {
    return U(e, "condition");
  }
  function xm(e) {
    const t = e == null ? void 0 : e.condition;
    return !!t && !P(t) && q(t);
  }
  function jf(e) {
    const t = e == null ? void 0 : e.condition;
    return !!t && !P(t) && le(t);
  }
  function Loe(e) {
    const t = e == null ? void 0 : e.condition;
    return !!t && (P(t) || $i(t));
  }
  function q(e) {
    return U(e, "field") || (e == null ? void 0 : e.aggregate) === "count";
  }
  function Ou(e) {
    return e == null ? void 0 : e.type;
  }
  function _r(e) {
    return U(e, "datum");
  }
  function Ao(e) {
    return un(e) && !Tg(e) || Mg(e);
  }
  function rA(e) {
    return un(e) && e.type === "quantitative" && !e.bin || Mg(e);
  }
  function Mg(e) {
    return _r(e) && $e(e.datum);
  }
  function le(e) {
    return q(e) || _r(e);
  }
  function un(e) {
    return e && (U(e, "field") || e.aggregate === "count") && U(e, "type");
  }
  function $i(e) {
    return U(e, "value");
  }
  function ka(e) {
    return U(e, "scale") || U(e, "sort");
  }
  function Ru(e) {
    return U(e, "axis") || U(e, "stack") || U(e, "impute");
  }
  function t6(e) {
    return U(e, "legend");
  }
  function n6(e) {
    return U(e, "format") || U(e, "formatType");
  }
  function Poe(e) {
    return mn(e, ["legend", "axis", "header", "scale"]);
  }
  function Ioe(e) {
    return U(e, "op");
  }
  function V(e, t = {}) {
    let n = e.field;
    const i = t.prefix;
    let r = t.suffix, o = "";
    if (Boe(e))
      n = HR("count");
    else {
      let s;
      if (!t.nofn)
        if (Ioe(e))
          s = e.op;
        else {
          const { bin: a, aggregate: u, timeUnit: l } = e;
          ze(a) ? (s = o5(a), r = (t.binSuffix ?? "") + (t.suffix ?? "")) : u ? us(u) ? (o = `["${n}"]`, n = `argmax_${u.argmax}`) : Kr(u) ? (o = `["${n}"]`, n = `argmin_${u.argmin}`) : s = String(u) : l && !$a(l) && (s = Bre(l), r = (!["range", "mid"].includes(t.binSuffix) && t.binSuffix || "") + (t.suffix ?? ""));
        }
      s && (n = n ? `${s}_${n}` : s);
    }
    return r && (n = `${n}_${r}`), i && (n = `${i}_${n}`), t.forAs ? sl(n) : t.expr ? jR(n, t.expr) + o : ti(n) + o;
  }
  function Tg(e) {
    switch (e.type) {
      case "nominal":
      case "ordinal":
      case "geojson":
        return !0;
      case "quantitative":
        return q(e) && !!e.bin;
      case "temporal":
        return !1;
    }
    throw new Error(p5(e.type));
  }
  function zoe(e) {
    var t;
    return ka(e) && Nu((t = e.scale) == null ? void 0 : t.type);
  }
  function Boe(e) {
    return e.aggregate === "count";
  }
  function Uoe(e, t) {
    var s;
    const { field: n, bin: i, timeUnit: r, aggregate: o } = e;
    if (o === "count")
      return t.countTitle;
    if (ze(i))
      return `${n} (binned)`;
    if (r && !$a(r)) {
      const a = (s = yt(r)) == null ? void 0 : s.unit;
      if (a)
        return `${n} (${dm(a).join("-")})`;
    } else if (o)
      return us(o) ? `${n} for max ${o.argmax}` : Kr(o) ? `${n} for min ${o.argmin}` : `${Nf(o)} of ${n}`;
    return n;
  }
  function joe(e) {
    const { aggregate: t, bin: n, timeUnit: i, field: r } = e;
    if (us(t))
      return `${r} for argmax(${t.argmax})`;
    if (Kr(t))
      return `${r} for argmin(${t.argmin})`;
    const o = i && !$a(i) ? yt(i) : void 0, s = t || (o == null ? void 0 : o.unit) || (o == null ? void 0 : o.maxbins) && "timeunit" || ze(n) && "bin";
    return s ? `${s.toUpperCase()}(${r})` : r;
  }
  const i6 = (e, t) => {
    switch (t.fieldTitle) {
      case "plain":
        return e.field;
      case "functional":
        return joe(e);
      default:
        return Uoe(e, t);
    }
  };
  let r6 = i6;
  function o6(e) {
    r6 = e;
  }
  function qoe() {
    o6(i6);
  }
  function ru(e, t, { allowDisabling: n, includeDefault: i = !0 }) {
    var a;
    const r = (a = cE(e)) == null ? void 0 : a.title;
    if (!q(e))
      return r ?? e.title;
    const o = e, s = i ? fE(o, t) : void 0;
    return n ? Ze(r, o.title, s) : r ?? o.title ?? s;
  }
  function cE(e) {
    if (Ru(e) && e.axis)
      return e.axis;
    if (t6(e) && e.legend)
      return e.legend;
    if (uE(e) && e.header)
      return e.header;
  }
  function fE(e, t) {
    return r6(e, t);
  }
  function Dg(e) {
    if (n6(e)) {
      const { format: t, formatType: n } = e;
      return { format: t, formatType: n };
    } else {
      const t = cE(e) ?? {}, { format: n, formatType: i } = t;
      return { format: n, formatType: i };
    }
  }
  function Woe(e, t) {
    var o;
    switch (t) {
      case "latitude":
      case "longitude":
        return "quantitative";
      case "row":
      case "column":
      case "facet":
      case "shape":
      case "strokeDash":
        return "nominal";
      case "order":
        return "ordinal";
    }
    if (lE(e) && P(e.sort))
      return "ordinal";
    const { aggregate: n, bin: i, timeUnit: r } = e;
    if (r)
      return "temporal";
    if (i || n && !us(n) && !Kr(n))
      return "quantitative";
    if (ka(e) && ((o = e.scale) != null && o.type))
      switch (cb[e.scale.type]) {
        case "numeric":
        case "discretizing":
          return "quantitative";
        case "time":
          return "temporal";
      }
    return "nominal";
  }
  function ki(e) {
    if (q(e))
      return e;
    if (xm(e))
      return e.condition;
  }
  function st(e) {
    if (le(e))
      return e;
    if (jf(e))
      return e.condition;
  }
  function s6(e, t, n, i = {}) {
    if (K(e) || $e(e) || Ko(e)) {
      const r = K(e) ? "string" : $e(e) ? "number" : "boolean";
      return j(qie(t, r, e)), { value: e };
    }
    return le(e) ? Ng(e, t, n, i) : jf(e) ? {
      ...e,
      // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>
      condition: Ng(e.condition, t, n, i)
    } : e;
  }
  function Ng(e, t, n, i) {
    if (n6(e)) {
      const { format: r, formatType: o, ...s } = e;
      if (aa(o) && !n.customFormatTypes)
        return j(Kk(t)), Ng(s, t, n, i);
    } else {
      const r = Ru(e) ? "axis" : t6(e) ? "legend" : uE(e) ? "header" : null;
      if (r && e[r]) {
        const { format: o, formatType: s, ...a } = e[r];
        if (aa(s) && !n.customFormatTypes)
          return j(Kk(t)), Ng({ ...e, [r]: a }, t, n, i);
      }
    }
    return q(e) ? dE(e, t, i) : Hoe(e);
  }
  function Hoe(e) {
    let t = e.type;
    if (t)
      return e;
    const { datum: n } = e;
    return t = $e(n) ? "quantitative" : K(n) ? "nominal" : Sa(n) ? "temporal" : void 0, { ...e, type: t };
  }
  function dE(e, t, { compositeMark: n = !1 } = {}) {
    const { aggregate: i, timeUnit: r, bin: o, field: s } = e, a = { ...e };
    if (!n && i && !zw(i) && !us(i) && !Kr(i) && (j(Hie(i)), delete a.aggregate), r && (a.timeUnit = yt(r)), s && (a.field = `${s}`), ze(o) && (a.bin = wm(o, t)), Et(o) && !et(t) && j(_re(t)), un(a)) {
      const { type: u } = a, l = Yre(u);
      u !== l && (a.type = l), u !== "quantitative" && lm(i) && (j(Wie(u, i)), a.type = "quantitative");
    } else if (!ZR(t)) {
      const u = Woe(a, t);
      a.type = u;
    }
    if (un(a)) {
      const { compatible: u, warning: l } = Goe(a, t) || {};
      u === !1 && j(l);
    }
    if (lE(a) && K(a.sort)) {
      const { sort: u } = a;
      if (nA(u))
        return {
          ...a,
          sort: { encoding: u }
        };
      const l = u.substring(1);
      if (u.charAt(0) === "-" && nA(l))
        return {
          ...a,
          sort: { encoding: l, order: "descending" }
        };
    }
    if (uE(a)) {
      const { header: u } = a;
      if (u) {
        const { orient: l, ...c } = u;
        if (l)
          return {
            ...a,
            header: {
              ...c,
              labelOrient: u.labelOrient || l,
              titleOrient: u.titleOrient || l
            }
          };
      }
    }
    return a;
  }
  function wm(e, t) {
    return Ko(e) ? { maxbins: Uk(t) } : e === "binned" ? {
      binned: !0
    } : !e.maxbins && !e.step ? { ...e, maxbins: Uk(t) } : e;
  }
  const Ia = { compatible: !0 };
  function Goe(e, t) {
    const n = e.type;
    if (n === "geojson" && t !== "shape")
      return {
        compatible: !1,
        warning: `Channel ${t} should not be used with a geojson data.`
      };
    switch (t) {
      case jr:
      case qr:
      case im:
        return Tg(e) ? Ia : {
          compatible: !1,
          warning: Xie(t)
        };
      case We:
      case xt:
      case is:
      case al:
      case wn:
      case vr:
      case xr:
      case Of:
      case Rf:
      case rm:
      case ia:
      case om:
      case sm:
      case xa:
      case ri:
      case Di:
      case am:
        return Ia;
      case Oi:
      case ni:
      case Ni:
      case Ri:
        return n !== oa ? {
          compatible: !1,
          warning: `Channel ${t} should be used with a quantitative field only, not ${e.type} field.`
        } : Ia;
      case io:
      case rs:
      case os:
      case ss:
      case no:
      case to:
      case eo:
      case Ti:
      case br:
        return n === "nominal" && !e.sort ? {
          compatible: !1,
          warning: `Channel ${t} should not be used with an unsorted discrete field.`
        } : Ia;
      case En:
      case as:
        return !Tg(e) && !zoe(e) ? {
          compatible: !1,
          warning: Kie(t)
        } : Ia;
      case Mu:
        return e.type === "nominal" && !("sort" in e) ? {
          compatible: !1,
          warning: "Channel order is inappropriate for nominal field, which has no inherent order."
        } : Ia;
    }
  }
  function Lu(e) {
    const { formatType: t } = Dg(e);
    return t === "time" || !t && Voe(e);
  }
  function Voe(e) {
    return e && (e.type === "temporal" || q(e) && !!e.timeUnit);
  }
  function Em(e, { timeUnit: t, type: n, wrapTime: i, undefinedIfExprNotRequired: r }) {
    var u;
    const o = t && ((u = yt(t)) == null ? void 0 : u.unit);
    let s = o || n === "temporal", a;
    return Pf(e) ? a = e.expr : ee(e) ? a = e.signal : Sa(e) ? (s = !0, a = ra(e)) : (K(e) || $e(e)) && s && (a = `datetime(${Re(e)})`, Rre(o) && ($e(e) && e < 1e4 || K(e) && isNaN(Date.parse(e))) && (a = ra({ [o]: e }))), a ? i && s ? `time(${a})` : a : r ? void 0 : Re(e);
  }
  function a6(e, t) {
    const { type: n } = e;
    return t.map((i) => {
      const r = q(e) && !$a(e.timeUnit) ? e.timeUnit : void 0, o = Em(i, {
        timeUnit: r,
        type: n,
        undefinedIfExprNotRequired: !0
      });
      return o !== void 0 ? { signal: o } : i;
    });
  }
  function qf(e, t) {
    return ze(e.bin) ? Er(t) && ["ordinal", "nominal"].includes(e.type) : (console.warn("Only call this method for binned field defs."), !1);
  }
  const oA = {
    labelAlign: {
      part: "labels",
      vgProp: "align"
    },
    labelBaseline: {
      part: "labels",
      vgProp: "baseline"
    },
    labelColor: {
      part: "labels",
      vgProp: "fill"
    },
    labelFont: {
      part: "labels",
      vgProp: "font"
    },
    labelFontSize: {
      part: "labels",
      vgProp: "fontSize"
    },
    labelFontStyle: {
      part: "labels",
      vgProp: "fontStyle"
    },
    labelFontWeight: {
      part: "labels",
      vgProp: "fontWeight"
    },
    labelOpacity: {
      part: "labels",
      vgProp: "opacity"
    },
    labelOffset: null,
    labelPadding: null,
    // There is no fixed vgProp for tickSize, need to use signal.
    gridColor: {
      part: "grid",
      vgProp: "stroke"
    },
    gridDash: {
      part: "grid",
      vgProp: "strokeDash"
    },
    gridDashOffset: {
      part: "grid",
      vgProp: "strokeDashOffset"
    },
    gridOpacity: {
      part: "grid",
      vgProp: "opacity"
    },
    gridWidth: {
      part: "grid",
      vgProp: "strokeWidth"
    },
    tickColor: {
      part: "ticks",
      vgProp: "stroke"
    },
    tickDash: {
      part: "ticks",
      vgProp: "strokeDash"
    },
    tickDashOffset: {
      part: "ticks",
      vgProp: "strokeDashOffset"
    },
    tickOpacity: {
      part: "ticks",
      vgProp: "opacity"
    },
    tickSize: null,
    // There is no fixed vgProp for tickSize, need to use signal.
    tickWidth: {
      part: "ticks",
      vgProp: "strokeWidth"
    }
  };
  function Wf(e) {
    return e == null ? void 0 : e.condition;
  }
  const u6 = ["domain", "grid", "labels", "ticks", "title"], Yoe = {
    grid: "grid",
    gridCap: "grid",
    gridColor: "grid",
    gridDash: "grid",
    gridDashOffset: "grid",
    gridOpacity: "grid",
    gridScale: "grid",
    gridWidth: "grid",
    orient: "main",
    bandPosition: "both",
    // Need to be applied to grid axis too, so the grid will align with ticks.
    aria: "main",
    description: "main",
    domain: "main",
    domainCap: "main",
    domainColor: "main",
    domainDash: "main",
    domainDashOffset: "main",
    domainOpacity: "main",
    domainWidth: "main",
    format: "main",
    formatType: "main",
    labelAlign: "main",
    labelAngle: "main",
    labelBaseline: "main",
    labelBound: "main",
    labelColor: "main",
    labelFlush: "main",
    labelFlushOffset: "main",
    labelFont: "main",
    labelFontSize: "main",
    labelFontStyle: "main",
    labelFontWeight: "main",
    labelLimit: "main",
    labelLineHeight: "main",
    labelOffset: "main",
    labelOpacity: "main",
    labelOverlap: "main",
    labelPadding: "main",
    labels: "main",
    labelSeparation: "main",
    maxExtent: "main",
    minExtent: "main",
    offset: "both",
    position: "main",
    tickCap: "main",
    tickColor: "main",
    tickDash: "main",
    tickDashOffset: "main",
    tickMinStep: "both",
    tickOffset: "both",
    // Need to be applied to grid axis too, so the grid will align with ticks.
    tickOpacity: "main",
    tickRound: "both",
    // Apply rounding to grid and ticks so they are aligned.
    ticks: "main",
    tickSize: "main",
    tickWidth: "both",
    title: "main",
    titleAlign: "main",
    titleAnchor: "main",
    titleAngle: "main",
    titleBaseline: "main",
    titleColor: "main",
    titleFont: "main",
    titleFontSize: "main",
    titleFontStyle: "main",
    titleFontWeight: "main",
    titleLimit: "main",
    titleLineHeight: "main",
    titleOpacity: "main",
    titlePadding: "main",
    titleX: "main",
    titleY: "main",
    encode: "both",
    // we hide this in Vega-Lite
    scale: "both",
    tickBand: "both",
    tickCount: "both",
    tickExtra: "both",
    translate: "both",
    values: "both",
    zindex: "both"
    // this is actually set afterward, so it doesn't matter
  }, l6 = {
    orient: 1,
    // other things can depend on orient
    aria: 1,
    bandPosition: 1,
    description: 1,
    domain: 1,
    domainCap: 1,
    domainColor: 1,
    domainDash: 1,
    domainDashOffset: 1,
    domainOpacity: 1,
    domainWidth: 1,
    format: 1,
    formatType: 1,
    grid: 1,
    gridCap: 1,
    gridColor: 1,
    gridDash: 1,
    gridDashOffset: 1,
    gridOpacity: 1,
    gridWidth: 1,
    labelAlign: 1,
    labelAngle: 1,
    labelBaseline: 1,
    labelBound: 1,
    labelColor: 1,
    labelFlush: 1,
    labelFlushOffset: 1,
    labelFont: 1,
    labelFontSize: 1,
    labelFontStyle: 1,
    labelFontWeight: 1,
    labelLimit: 1,
    labelLineHeight: 1,
    labelOffset: 1,
    labelOpacity: 1,
    labelOverlap: 1,
    labelPadding: 1,
    labels: 1,
    labelSeparation: 1,
    maxExtent: 1,
    minExtent: 1,
    offset: 1,
    position: 1,
    tickBand: 1,
    tickCap: 1,
    tickColor: 1,
    tickCount: 1,
    tickDash: 1,
    tickDashOffset: 1,
    tickExtra: 1,
    tickMinStep: 1,
    tickOffset: 1,
    tickOpacity: 1,
    tickRound: 1,
    ticks: 1,
    tickSize: 1,
    tickWidth: 1,
    title: 1,
    titleAlign: 1,
    titleAnchor: 1,
    titleAngle: 1,
    titleBaseline: 1,
    titleColor: 1,
    titleFont: 1,
    titleFontSize: 1,
    titleFontStyle: 1,
    titleFontWeight: 1,
    titleLimit: 1,
    titleLineHeight: 1,
    titleOpacity: 1,
    titlePadding: 1,
    titleX: 1,
    titleY: 1,
    translate: 1,
    values: 1,
    zindex: 1
  }, Xoe = {
    ...l6,
    style: 1,
    labelExpr: 1,
    encoding: 1
  };
  function sA(e) {
    return J(Xoe, e);
  }
  const Koe = {
    axis: 1,
    axisBand: 1,
    axisBottom: 1,
    axisDiscrete: 1,
    axisLeft: 1,
    axisPoint: 1,
    axisQuantitative: 1,
    axisRight: 1,
    axisTemporal: 1,
    axisTop: 1,
    axisX: 1,
    axisXBand: 1,
    axisXDiscrete: 1,
    axisXPoint: 1,
    axisXQuantitative: 1,
    axisXTemporal: 1,
    axisY: 1,
    axisYBand: 1,
    axisYDiscrete: 1,
    axisYPoint: 1,
    axisYQuantitative: 1,
    axisYTemporal: 1
  }, c6 = B(Koe);
  function oo(e) {
    return U(e, "mark");
  }
  class _m {
    constructor(t, n) {
      this.name = t, this.run = n;
    }
    hasMatchingType(t) {
      return oo(t) ? Soe(t.mark) === this.name : !1;
    }
  }
  function Us(e, t) {
    const n = e && e[t];
    return n ? P(n) ? Cu(n, (i) => !!i.field) : q(n) || xm(n) : !1;
  }
  function f6(e, t) {
    const n = e && e[t];
    return n ? P(n) ? Cu(n, (i) => !!i.field) : q(n) || _r(n) || jf(n) : !1;
  }
  function d6(e, t) {
    if (et(t)) {
      const n = e[t];
      if ((q(n) || _r(n)) && (D5(n.type) || q(n) && n.timeUnit)) {
        const i = Ow(t);
        return f6(e, i);
      }
    }
    return !1;
  }
  function h6(e) {
    return Cu(Xne, (t) => {
      if (Us(e, t)) {
        const n = e[t];
        if (P(n))
          return Cu(n, (i) => !!i.aggregate);
        {
          const i = ki(n);
          return i && !!i.aggregate;
        }
      }
      return !1;
    });
  }
  function g6(e, t) {
    const n = [], i = [], r = [], o = [], s = {};
    return hE(e, (a, u) => {
      if (q(a)) {
        const { field: l, aggregate: c, bin: f, timeUnit: d, ...h } = a;
        if (c || d || f) {
          const g = cE(a), p = g == null ? void 0 : g.title;
          let m = V(a, { forAs: !0 });
          const y = {
            // Only add title if it doesn't exist
            ...p ? [] : { title: ru(a, t, { allowDisabling: !0 }) },
            ...h,
            // Always overwrite field
            field: m
          };
          if (c) {
            let b;
            if (us(c) ? (b = "argmax", m = V({ op: "argmax", field: c.argmax }, { forAs: !0 }), y.field = `${m}.${l}`) : Kr(c) ? (b = "argmin", m = V({ op: "argmin", field: c.argmin }, { forAs: !0 }), y.field = `${m}.${l}`) : c !== "boxplot" && c !== "errorbar" && c !== "errorband" && (b = c), b) {
              const v = {
                op: b,
                as: m
              };
              l && (v.field = l), o.push(v);
            }
          } else if (n.push(m), un(a) && ze(f)) {
            if (i.push({ bin: f, field: l, as: m }), n.push(V(a, { binSuffix: "end" })), qf(a, u) && n.push(V(a, { binSuffix: "range" })), et(u)) {
              const b = {
                field: `${m}_end`
              };
              s[`${u}2`] = b;
            }
            y.bin = "binned", ZR(u) || (y.type = oa);
          } else if (d && !$a(d)) {
            r.push({
              timeUnit: d,
              field: l,
              as: m
            });
            const b = un(a) && a.type !== Du && "time";
            b && (u === Of || u === ia ? y.formatType = b : oie(u) ? y.legend = {
              formatType: b,
              ...y.legend
            } : et(u) && (y.axis = {
              formatType: b,
              ...y.axis
            }));
          }
          s[u] = y;
        } else
          n.push(l), s[u] = e[u];
      } else
        s[u] = e[u];
    }), {
      bins: i,
      timeUnits: r,
      aggregate: o,
      groupby: n,
      encoding: s
    };
  }
  function Joe(e, t, n) {
    const i = aie(t, n);
    if (i) {
      if (i === "binned") {
        const r = e[t === Ti ? We : xt];
        return !!(q(r) && q(e[t]) && Et(r.bin));
      }
    } else return !1;
    return !0;
  }
  function Qoe(e, t, n, i) {
    const r = {};
    for (const o of B(e))
      QR(o) || j(Yie(o));
    for (let o of tie) {
      if (!e[o])
        continue;
      const s = e[o];
      if (Lf(o)) {
        const a = eie(o), u = r[a];
        if (q(u) && Vre(u.type) && q(s) && !u.timeUnit) {
          j(jie(a));
          continue;
        }
      }
      if (o === "angle" && t === "arc" && !e.theta && (j(Uie), o = ri), !Joe(e, o, t)) {
        j(fm(o, t));
        continue;
      }
      if (o === no && t === "line") {
        const a = ki(e[o]);
        if (a != null && a.aggregate) {
          j(Vie);
          continue;
        }
      }
      if (o === wn && (n ? "fill" in e : "stroke" in e)) {
        j(m5("encoding", { fill: "fill" in e, stroke: "stroke" in e }));
        continue;
      }
      if (o === Rf || o === Mu && !P(s) && !$i(s) || o === ia && P(s)) {
        if (s) {
          if (o === Mu) {
            const a = e[o];
            if (e6(a)) {
              r[o] = a;
              continue;
            }
          }
          r[o] = X(s).reduce((a, u) => (q(u) ? a.push(dE(u, o)) : j(lb(u, o)), a), []);
        }
      } else {
        if (o === ia && s === null)
          r[o] = null;
        else if (!q(s) && !_r(s) && !$i(s) && !Uf(s) && !ee(s)) {
          j(lb(s, o));
          continue;
        }
        r[o] = s6(s, o, i);
      }
    }
    return r;
  }
  function Sm(e, t) {
    const n = {};
    for (const i of B(e)) {
      const r = s6(e[i], i, t, { compositeMark: !0 });
      n[i] = r;
    }
    return n;
  }
  function Zoe(e) {
    const t = [];
    for (const n of B(e))
      if (Us(e, n)) {
        const i = e[n], r = X(i);
        for (const o of r)
          q(o) ? t.push(o) : xm(o) && t.push(o.condition);
      }
    return t;
  }
  function hE(e, t, n) {
    if (e)
      for (const i of B(e)) {
        const r = e[i];
        if (P(r))
          for (const o of r)
            t.call(n, o, i);
        else
          t.call(n, r, i);
      }
  }
  function ese(e, t, n, i) {
    return e ? B(e).reduce((r, o) => {
      const s = e[o];
      return P(s) ? s.reduce((a, u) => t.call(i, a, u, o), r) : t.call(i, r, s, o);
    }, n) : n;
  }
  function p6(e, t) {
    return B(t).reduce((n, i) => {
      switch (i) {
        case We:
        case xt:
        case om:
        case am:
        case sm:
        case Ti:
        case br:
        case is:
        case al:
        case ri:
        case to:
        case Di:
        case eo:
        case Ni:
        case Oi:
        case Ri:
        case ni:
        case Of:
        case En:
        case xa:
        case ia:
          return n;
        case Mu:
          if (e === "line" || e === "trail")
            return n;
        case Rf:
        case rm: {
          const r = t[i];
          if (P(r) || q(r))
            for (const o of X(r))
              o.aggregate || n.push(V(o, {}));
          return n;
        }
        case no:
          if (e === "trail")
            return n;
        case wn:
        case vr:
        case xr:
        case io:
        case rs:
        case os:
        case as:
        case ss: {
          const r = ki(t[i]);
          return r && !r.aggregate && n.push(V(r, {})), n;
        }
      }
    }, []);
  }
  function tse(e) {
    const { tooltip: t, ...n } = e;
    if (!t)
      return { filteredEncoding: n };
    let i, r;
    if (P(t)) {
      for (const o of t)
        o.aggregate ? (i || (i = []), i.push(o)) : (r || (r = []), r.push(o));
      i && (n.tooltip = i);
    } else
      t.aggregate ? n.tooltip = t : r = t;
    return P(r) && r.length === 1 && (r = r[0]), { customTooltipWithoutAggregatedField: r, filteredEncoding: n };
  }
  function hb(e, t, n, i = !0) {
    if ("tooltip" in n)
      return { tooltip: n.tooltip };
    const r = e.map(({ fieldPrefix: s, titlePrefix: a }) => {
      const u = i ? ` of ${gE(t)}` : "";
      return {
        field: s + t.field,
        type: t.type,
        title: ee(a) ? { signal: `${a}"${escape(u)}"` } : a + u
      };
    }), o = Zoe(n).map(Poe);
    return {
      tooltip: [
        ...r,
        // need to cast because TextFieldDef supports fewer types of bin
        ...Xi(o, be)
      ]
    };
  }
  function gE(e) {
    const { title: t, field: n } = e;
    return Ze(t, n);
  }
  function pE(e, t, n, i, r) {
    const { scale: o, axis: s } = n;
    return ({ partName: a, mark: u, positionPrefix: l, endPositionPrefix: c = void 0, extraEncoding: f = {} }) => {
      const d = gE(n);
      return m6(e, a, r, {
        mark: u,
        // TODO better remove this method and just have mark as a parameter of the method
        encoding: {
          [t]: {
            field: `${l}_${n.field}`,
            type: n.type,
            ...d !== void 0 ? { title: d } : {},
            ...o !== void 0 ? { scale: o } : {},
            ...s !== void 0 ? { axis: s } : {}
          },
          ...K(c) ? {
            [`${t}2`]: {
              field: `${c}_${n.field}`
            }
          } : {},
          ...i,
          ...f
        }
      });
    };
  }
  function m6(e, t, n, i) {
    const { clip: r, color: o, opacity: s } = e, a = e.type;
    return e[t] || e[t] === void 0 && n[t] ? [
      {
        ...i,
        mark: {
          ...n[t],
          ...r ? { clip: r } : {},
          ...o ? { color: o } : {},
          ...s ? { opacity: s } : {},
          ...lr(i.mark) ? i.mark : { type: i.mark },
          style: `${a}-${String(t)}`,
          ...Ko(e[t]) ? {} : e[t]
        }
      }
    ] : [];
  }
  function y6(e, t, n) {
    const { encoding: i } = e, r = t === "vertical" ? "y" : "x", o = i[r], s = i[`${r}2`], a = i[`${r}Error`], u = i[`${r}Error2`];
    return {
      continuousAxisChannelDef: Sd(o, n),
      continuousAxisChannelDef2: Sd(s, n),
      continuousAxisChannelDefError: Sd(a, n),
      continuousAxisChannelDefError2: Sd(u, n),
      continuousAxis: r
    };
  }
  function Sd(e, t) {
    if (e != null && e.aggregate) {
      const { aggregate: n, ...i } = e;
      return n !== t && j(Ere(n, t)), i;
    } else
      return e;
  }
  function b6(e, t) {
    const { mark: n, encoding: i } = e, { x: r, y: o } = i;
    if (lr(n) && n.orient)
      return n.orient;
    if (Ao(r)) {
      if (Ao(o)) {
        const s = q(r) && r.aggregate, a = q(o) && o.aggregate;
        if (!s && a === t)
          return "vertical";
        if (!a && s === t)
          return "horizontal";
        if (s === t && a === t)
          throw new Error("Both x and y cannot have aggregate");
        return Lu(o) && !Lu(r) ? "horizontal" : "vertical";
      }
      return "horizontal";
    } else {
      if (Ao(o))
        return "vertical";
      throw new Error(`Need a valid continuous axis for ${t}s`);
    }
  }
  const Og = "boxplot", nse = ["box", "median", "outliers", "rule", "ticks"], ise = new _m(Og, x6);
  function v6(e) {
    return $e(e) ? "tukey" : e;
  }
  function x6(e, { config: t }) {
    e = {
      ...e,
      encoding: Sm(e.encoding, t)
    };
    const { mark: n, encoding: i, params: r, projection: o, ...s } = e, a = lr(n) ? n : { type: n };
    r && j(g5("boxplot"));
    const u = a.extent ?? t.boxplot.extent, l = Ne(
      "size",
      a,
      // TODO: https://github.com/vega/vega-lite/issues/6245
      t
    ), c = a.invalid, f = v6(u), { bins: d, timeUnits: h, transform: g, continuousAxisChannelDef: p, continuousAxis: m, groupby: y, aggregate: b, encodingWithoutContinuousAxis: v, ticksOrient: x, boxOrient: w, customTooltipWithoutAggregatedField: _ } = rse(e, u, t), E = sl(p.field), { color: S, size: $, ...F } = v, A = (Yf) => pE(a, m, p, Yf, t.boxplot), D = A(F), k = A(v), M = (Y(t.boxplot.box) ? t.boxplot.box.color : t.mark.color) || "#4c78a8", C = A({
      ...F,
      ...$ ? { size: $ } : {},
      color: {
        condition: {
          test: `datum['lower_box_${p.field}'] >= datum['upper_box_${p.field}']`,
          ...S || { value: M }
        }
      }
    }), T = hb([
      { fieldPrefix: f === "min-max" ? "upper_whisker_" : "max_", titlePrefix: "Max" },
      { fieldPrefix: "upper_box_", titlePrefix: "Q3" },
      { fieldPrefix: "mid_box_", titlePrefix: "Median" },
      { fieldPrefix: "lower_box_", titlePrefix: "Q1" },
      { fieldPrefix: f === "min-max" ? "lower_whisker_" : "min_", titlePrefix: "Min" }
    ], p, v), L = { type: "tick", color: "black", opacity: 1, orient: x, invalid: c, aria: !1 }, I = f === "min-max" ? T : (
      // for tukey / k-IQR, just show upper/lower-whisker
      hb([
        { fieldPrefix: "upper_whisker_", titlePrefix: "Upper Whisker" },
        { fieldPrefix: "lower_whisker_", titlePrefix: "Lower Whisker" }
      ], p, v)
    ), z = [
      ...D({
        partName: "rule",
        mark: { type: "rule", invalid: c, aria: !1 },
        positionPrefix: "lower_whisker",
        endPositionPrefix: "lower_box",
        extraEncoding: I
      }),
      ...D({
        partName: "rule",
        mark: { type: "rule", invalid: c, aria: !1 },
        positionPrefix: "upper_box",
        endPositionPrefix: "upper_whisker",
        extraEncoding: I
      }),
      ...D({
        partName: "ticks",
        mark: L,
        positionPrefix: "lower_whisker",
        extraEncoding: I
      }),
      ...D({
        partName: "ticks",
        mark: L,
        positionPrefix: "upper_whisker",
        extraEncoding: I
      })
    ], te = [
      ...f !== "tukey" ? z : [],
      ...k({
        partName: "box",
        mark: {
          type: "bar",
          ...l ? { size: l } : {},
          orient: w,
          invalid: c,
          ariaRoleDescription: "box"
        },
        positionPrefix: "lower_box",
        endPositionPrefix: "upper_box",
        extraEncoding: T
      }),
      ...C({
        partName: "median",
        mark: {
          type: "tick",
          invalid: c,
          ...Y(t.boxplot.median) && t.boxplot.median.color ? { color: t.boxplot.median.color } : {},
          ...l ? { size: l } : {},
          orient: x,
          aria: !1
        },
        positionPrefix: "mid_box",
        extraEncoding: T
      })
    ];
    if (f === "min-max")
      return {
        ...s,
        transform: (s.transform ?? []).concat(g),
        layer: te
      };
    const ne = `datum["lower_box_${p.field}"]`, de = `datum["upper_box_${p.field}"]`, _e = `(${de} - ${ne})`, we = `${ne} - ${u} * ${_e}`, Pe = `${de} + ${u} * ${_e}`, Li = `datum["${p.field}"]`, cs = {
      joinaggregate: w6(p.field),
      groupby: y
    }, ao = {
      transform: [
        {
          filter: `(${we} <= ${Li}) && (${Li} <= ${Pe})`
        },
        {
          aggregate: [
            {
              op: "min",
              field: p.field,
              as: `lower_whisker_${E}`
            },
            {
              op: "max",
              field: p.field,
              as: `upper_whisker_${E}`
            },
            // preserve lower_box / upper_box
            {
              op: "min",
              field: `lower_box_${p.field}`,
              as: `lower_box_${E}`
            },
            {
              op: "max",
              field: `upper_box_${p.field}`,
              as: `upper_box_${E}`
            },
            ...b
          ],
          groupby: y
        }
      ],
      layer: z
    }, { tooltip: Q, ...he } = F, { scale: pe, axis: W } = p, wt = gE(p), Me = mn(W, ["title"]), Dt = m6(a, "outliers", t.boxplot, {
      transform: [{ filter: `(${Li} < ${we}) || (${Li} > ${Pe})` }],
      mark: "point",
      encoding: {
        [m]: {
          field: p.field,
          type: p.type,
          ...wt !== void 0 ? { title: wt } : {},
          ...pe !== void 0 ? { scale: pe } : {},
          // add axis without title since we already added the title above
          ...Oe(Me) ? {} : { axis: Me }
        },
        ...he,
        ...S ? { color: S } : {},
        ..._ ? { tooltip: _ } : {}
      }
    })[0];
    let ct;
    const Pi = [...d, ...h, cs];
    return Dt ? ct = {
      transform: Pi,
      layer: [Dt, ao]
    } : (ct = ao, ct.transform.unshift(...Pi)), {
      ...s,
      layer: [
        ct,
        {
          // boxplot
          transform: g,
          layer: te
        }
      ]
    };
  }
  function w6(e) {
    const t = sl(e);
    return [
      {
        op: "q1",
        field: e,
        as: `lower_box_${t}`
      },
      {
        op: "q3",
        field: e,
        as: `upper_box_${t}`
      }
    ];
  }
  function rse(e, t, n) {
    const i = b6(e, Og), { continuousAxisChannelDef: r, continuousAxis: o } = y6(e, i, Og), s = r.field, a = sl(s), u = v6(t), l = [
      ...w6(s),
      {
        op: "median",
        field: s,
        as: `mid_box_${a}`
      },
      {
        op: "min",
        field: s,
        as: (u === "min-max" ? "lower_whisker_" : "min_") + a
      },
      {
        op: "max",
        field: s,
        as: (u === "min-max" ? "upper_whisker_" : "max_") + a
      }
    ], c = u === "min-max" || u === "tukey" ? [] : [
      // This is for the  original k-IQR, which we do not expose
      {
        calculate: `datum["upper_box_${a}"] - datum["lower_box_${a}"]`,
        as: `iqr_${a}`
      },
      {
        calculate: `min(datum["upper_box_${a}"] + datum["iqr_${a}"] * ${t}, datum["max_${a}"])`,
        as: `upper_whisker_${a}`
      },
      {
        calculate: `max(datum["lower_box_${a}"] - datum["iqr_${a}"] * ${t}, datum["min_${a}"])`,
        as: `lower_whisker_${a}`
      }
    ], { [o]: f, ...d } = e.encoding, { customTooltipWithoutAggregatedField: h, filteredEncoding: g } = tse(d), { bins: p, timeUnits: m, aggregate: y, groupby: b, encoding: v } = g6(g, n), x = i === "vertical" ? "horizontal" : "vertical", w = i, _ = [
      ...p,
      ...m,
      {
        aggregate: [...y, ...l],
        groupby: b
      },
      ...c
    ];
    return {
      bins: p,
      timeUnits: m,
      transform: _,
      groupby: b,
      aggregate: y,
      continuousAxisChannelDef: r,
      continuousAxis: o,
      encodingWithoutContinuousAxis: v,
      ticksOrient: x,
      boxOrient: w,
      customTooltipWithoutAggregatedField: h
    };
  }
  const mE = "errorbar", ose = ["ticks", "rule"], sse = new _m(mE, E6);
  function E6(e, { config: t }) {
    e = {
      ...e,
      encoding: Sm(e.encoding, t)
    };
    const { transform: n, continuousAxisChannelDef: i, continuousAxis: r, encodingWithoutContinuousAxis: o, ticksOrient: s, markDef: a, outerSpec: u, tooltipEncoding: l } = _6(e, mE, t);
    delete o.size;
    const c = pE(a, r, i, o, t.errorbar), f = a.thickness, d = a.size, h = {
      type: "tick",
      orient: s,
      aria: !1,
      ...f !== void 0 ? { thickness: f } : {},
      ...d !== void 0 ? { size: d } : {}
    }, g = [
      ...c({
        partName: "ticks",
        mark: h,
        positionPrefix: "lower",
        extraEncoding: l
      }),
      ...c({
        partName: "ticks",
        mark: h,
        positionPrefix: "upper",
        extraEncoding: l
      }),
      ...c({
        partName: "rule",
        mark: {
          type: "rule",
          ariaRoleDescription: "errorbar",
          ...f !== void 0 ? { size: f } : {}
        },
        positionPrefix: "lower",
        endPositionPrefix: "upper",
        extraEncoding: l
      })
    ];
    return {
      ...u,
      transform: n,
      ...g.length > 1 ? { layer: g } : { ...g[0] }
    };
  }
  function ase(e, t) {
    const { encoding: n } = e;
    if (use(n))
      return {
        orient: b6(e, t),
        inputType: "raw"
      };
    const i = lse(n), r = cse(n), o = n.x, s = n.y;
    if (i) {
      if (r)
        throw new Error(`${t} cannot be both type aggregated-upper-lower and aggregated-error`);
      const a = n.x2, u = n.y2;
      if (le(a) && le(u))
        throw new Error(`${t} cannot have both x2 and y2`);
      if (le(a)) {
        if (Ao(o))
          return { orient: "horizontal", inputType: "aggregated-upper-lower" };
        throw new Error(`Both x and x2 have to be quantitative in ${t}`);
      } else if (le(u)) {
        if (Ao(s))
          return { orient: "vertical", inputType: "aggregated-upper-lower" };
        throw new Error(`Both y and y2 have to be quantitative in ${t}`);
      }
      throw new Error("No ranged axis");
    } else {
      const a = n.xError, u = n.xError2, l = n.yError, c = n.yError2;
      if (le(u) && !le(a))
        throw new Error(`${t} cannot have xError2 without xError`);
      if (le(c) && !le(l))
        throw new Error(`${t} cannot have yError2 without yError`);
      if (le(a) && le(l))
        throw new Error(`${t} cannot have both xError and yError with both are quantiative`);
      if (le(a)) {
        if (Ao(o))
          return { orient: "horizontal", inputType: "aggregated-error" };
        throw new Error("All x, xError, and xError2 (if exist) have to be quantitative");
      } else if (le(l)) {
        if (Ao(s))
          return { orient: "vertical", inputType: "aggregated-error" };
        throw new Error("All y, yError, and yError2 (if exist) have to be quantitative");
      }
      throw new Error("No ranged axis");
    }
  }
  function use(e) {
    return (le(e.x) || le(e.y)) && !le(e.x2) && !le(e.y2) && !le(e.xError) && !le(e.xError2) && !le(e.yError) && !le(e.yError2);
  }
  function lse(e) {
    return le(e.x2) || le(e.y2);
  }
  function cse(e) {
    return le(e.xError) || le(e.xError2) || le(e.yError) || le(e.yError2);
  }
  function _6(e, t, n) {
    const { mark: i, encoding: r, params: o, projection: s, ...a } = e, u = lr(i) ? i : { type: i };
    o && j(g5(t));
    const { orient: l, inputType: c } = ase(e, t), { continuousAxisChannelDef: f, continuousAxisChannelDef2: d, continuousAxisChannelDefError: h, continuousAxisChannelDefError2: g, continuousAxis: p } = y6(e, l, t), { errorBarSpecificAggregate: m, postAggregateCalculates: y, tooltipSummary: b, tooltipTitleWithFieldName: v } = fse(u, f, d, h, g, c, t, n), { [p]: x, [p === "x" ? "x2" : "y2"]: w, [p === "x" ? "xError" : "yError"]: _, [p === "x" ? "xError2" : "yError2"]: E, ...S } = r, { bins: $, timeUnits: F, aggregate: A, groupby: D, encoding: k } = g6(S, n), M = [...A, ...m], C = c !== "raw" ? [] : D, T = hb(b, f, k, v);
    return {
      transform: [
        ...a.transform ?? [],
        ...$,
        ...F,
        ...M.length === 0 ? [] : [{ aggregate: M, groupby: C }],
        ...y
      ],
      groupby: C,
      continuousAxisChannelDef: f,
      continuousAxis: p,
      encodingWithoutContinuousAxis: k,
      ticksOrient: l === "vertical" ? "horizontal" : "vertical",
      markDef: u,
      outerSpec: a,
      tooltipEncoding: T
    };
  }
  function fse(e, t, n, i, r, o, s, a) {
    let u = [], l = [];
    const c = t.field;
    let f, d = !1;
    if (o === "raw") {
      const h = e.center ? e.center : e.extent ? e.extent === "iqr" ? "median" : "mean" : a.errorbar.center, g = e.extent ? e.extent : h === "mean" ? "stderr" : "iqr";
      if (h === "median" != (g === "iqr") && j(wre(h, g, s)), g === "stderr" || g === "stdev")
        u = [
          { op: g, field: c, as: `extent_${c}` },
          { op: h, field: c, as: `center_${c}` }
        ], l = [
          {
            calculate: `datum["center_${c}"] + datum["extent_${c}"]`,
            as: `upper_${c}`
          },
          {
            calculate: `datum["center_${c}"] - datum["extent_${c}"]`,
            as: `lower_${c}`
          }
        ], f = [
          { fieldPrefix: "center_", titlePrefix: Nf(h) },
          { fieldPrefix: "upper_", titlePrefix: aA(h, g, "+") },
          { fieldPrefix: "lower_", titlePrefix: aA(h, g, "-") }
        ], d = !0;
      else {
        let p, m, y;
        g === "ci" ? (p = "mean", m = "ci0", y = "ci1") : (p = "median", m = "q1", y = "q3"), u = [
          { op: m, field: c, as: `lower_${c}` },
          { op: y, field: c, as: `upper_${c}` },
          { op: p, field: c, as: `center_${c}` }
        ], f = [
          {
            fieldPrefix: "upper_",
            titlePrefix: ru({ field: c, aggregate: y, type: "quantitative" }, a, {
              allowDisabling: !1
            })
          },
          {
            fieldPrefix: "lower_",
            titlePrefix: ru({ field: c, aggregate: m, type: "quantitative" }, a, {
              allowDisabling: !1
            })
          },
          {
            fieldPrefix: "center_",
            titlePrefix: ru({ field: c, aggregate: p, type: "quantitative" }, a, {
              allowDisabling: !1
            })
          }
        ];
      }
    } else {
      (e.center || e.extent) && j(xre(e.center, e.extent)), o === "aggregated-upper-lower" ? (f = [], l = [
        { calculate: `datum["${n.field}"]`, as: `upper_${c}` },
        { calculate: `datum["${c}"]`, as: `lower_${c}` }
      ]) : o === "aggregated-error" && (f = [{ fieldPrefix: "", titlePrefix: c }], l = [
        {
          calculate: `datum["${c}"] + datum["${i.field}"]`,
          as: `upper_${c}`
        }
      ], r ? l.push({
        calculate: `datum["${c}"] + datum["${r.field}"]`,
        as: `lower_${c}`
      }) : l.push({
        calculate: `datum["${c}"] - datum["${i.field}"]`,
        as: `lower_${c}`
      }));
      for (const h of l)
        f.push({
          fieldPrefix: h.as.substring(0, 6),
          titlePrefix: na(na(h.calculate, 'datum["', ""), '"]', "")
        });
    }
    return { postAggregateCalculates: l, errorBarSpecificAggregate: u, tooltipSummary: f, tooltipTitleWithFieldName: d };
  }
  function aA(e, t, n) {
    return `${Nf(e)} ${n} ${t}`;
  }
  const yE = "errorband", dse = ["band", "borders"], hse = new _m(yE, S6);
  function S6(e, { config: t }) {
    e = {
      ...e,
      encoding: Sm(e.encoding, t)
    };
    const { transform: n, continuousAxisChannelDef: i, continuousAxis: r, encodingWithoutContinuousAxis: o, markDef: s, outerSpec: a, tooltipEncoding: u } = _6(e, yE, t), l = s, c = pE(l, r, i, o, t.errorband), f = e.encoding.x !== void 0 && e.encoding.y !== void 0;
    let d = { type: f ? "area" : "rect" }, h = { type: f ? "line" : "rule" };
    const g = {
      ...l.interpolate ? { interpolate: l.interpolate } : {},
      ...l.tension && l.interpolate ? { tension: l.tension } : {}
    };
    return f ? (d = {
      ...d,
      ...g,
      ariaRoleDescription: "errorband"
    }, h = {
      ...h,
      ...g,
      aria: !1
    }) : l.interpolate ? j(Qk("interpolate")) : l.tension && j(Qk("tension")), {
      ...a,
      transform: n,
      layer: [
        ...c({
          partName: "band",
          mark: d,
          positionPrefix: "lower",
          endPositionPrefix: "upper",
          extraEncoding: u
        }),
        ...c({
          partName: "borders",
          mark: h,
          positionPrefix: "lower",
          extraEncoding: u
        }),
        ...c({
          partName: "borders",
          mark: h,
          positionPrefix: "upper",
          extraEncoding: u
        })
      ]
    };
  }
  const $6 = {};
  function bE(e, t, n) {
    const i = new _m(e, t);
    $6[e] = { normalizer: i, parts: n };
  }
  function gse() {
    return B($6);
  }
  bE(Og, x6, nse);
  bE(mE, E6, ose);
  bE(yE, S6, dse);
  const pse = [
    "gradientHorizontalMaxLength",
    "gradientHorizontalMinLength",
    "gradientVerticalMaxLength",
    "gradientVerticalMinLength",
    "unselectedOpacity"
  ], k6 = {
    titleAlign: "align",
    titleAnchor: "anchor",
    titleAngle: "angle",
    titleBaseline: "baseline",
    titleColor: "color",
    titleFont: "font",
    titleFontSize: "fontSize",
    titleFontStyle: "fontStyle",
    titleFontWeight: "fontWeight",
    titleLimit: "limit",
    titleLineHeight: "lineHeight",
    titleOrient: "orient",
    titlePadding: "offset"
  }, A6 = {
    labelAlign: "align",
    labelAnchor: "anchor",
    labelAngle: "angle",
    labelBaseline: "baseline",
    labelColor: "color",
    labelFont: "font",
    labelFontSize: "fontSize",
    labelFontStyle: "fontStyle",
    labelFontWeight: "fontWeight",
    labelLimit: "limit",
    labelLineHeight: "lineHeight",
    labelOrient: "orient",
    labelPadding: "offset"
  }, mse = B(k6), yse = B(A6), bse = {
    header: 1,
    headerRow: 1,
    headerColumn: 1,
    headerFacet: 1
  }, C6 = B(bse), F6 = [
    "size",
    "shape",
    "fill",
    "stroke",
    "strokeDash",
    "strokeWidth",
    "opacity"
  ], vse = {
    gradientHorizontalMaxLength: 200,
    gradientHorizontalMinLength: 100,
    gradientVerticalMaxLength: 200,
    gradientVerticalMinLength: 64,
    // This is Vega's minimum.
    unselectedOpacity: 0.35
  }, xse = {
    aria: 1,
    clipHeight: 1,
    columnPadding: 1,
    columns: 1,
    cornerRadius: 1,
    description: 1,
    direction: 1,
    fillColor: 1,
    format: 1,
    formatType: 1,
    gradientLength: 1,
    gradientOpacity: 1,
    gradientStrokeColor: 1,
    gradientStrokeWidth: 1,
    gradientThickness: 1,
    gridAlign: 1,
    labelAlign: 1,
    labelBaseline: 1,
    labelColor: 1,
    labelFont: 1,
    labelFontSize: 1,
    labelFontStyle: 1,
    labelFontWeight: 1,
    labelLimit: 1,
    labelOffset: 1,
    labelOpacity: 1,
    labelOverlap: 1,
    labelPadding: 1,
    labelSeparation: 1,
    legendX: 1,
    legendY: 1,
    offset: 1,
    orient: 1,
    padding: 1,
    rowPadding: 1,
    strokeColor: 1,
    symbolDash: 1,
    symbolDashOffset: 1,
    symbolFillColor: 1,
    symbolLimit: 1,
    symbolOffset: 1,
    symbolOpacity: 1,
    symbolSize: 1,
    symbolStrokeColor: 1,
    symbolStrokeWidth: 1,
    symbolType: 1,
    tickCount: 1,
    tickMinStep: 1,
    title: 1,
    titleAlign: 1,
    titleAnchor: 1,
    titleBaseline: 1,
    titleColor: 1,
    titleFont: 1,
    titleFontSize: 1,
    titleFontStyle: 1,
    titleFontWeight: 1,
    titleLimit: 1,
    titleLineHeight: 1,
    titleOpacity: 1,
    titleOrient: 1,
    titlePadding: 1,
    type: 1,
    values: 1,
    zindex: 1
  }, Ai = "_vgsid_", wse = {
    point: {
      on: "click",
      fields: [Ai],
      toggle: "event.shiftKey",
      resolve: "global",
      clear: "dblclick"
    },
    interval: {
      on: "[pointerdown, window:pointerup] > window:pointermove!",
      encodings: ["x", "y"],
      translate: "[pointerdown, window:pointerup] > window:pointermove!",
      zoom: "wheel!",
      mark: { fill: "#333", fillOpacity: 0.125, stroke: "white" },
      resolve: "global",
      clear: "dblclick"
    }
  };
  function vE(e) {
    return e === "legend" || !!(e != null && e.legend);
  }
  function n1(e) {
    return vE(e) && Y(e);
  }
  function xE(e) {
    return !!(e != null && e.select);
  }
  function M6(e) {
    const t = [];
    for (const n of e || []) {
      if (xE(n))
        continue;
      const { expr: i, bind: r, ...o } = n;
      if (r && i) {
        const s = {
          ...o,
          bind: r,
          init: i
        };
        t.push(s);
      } else {
        const s = {
          ...o,
          ...i ? { update: i } : {},
          ...r ? { bind: r } : {}
        };
        t.push(s);
      }
    }
    return t;
  }
  function Ese(e) {
    return $m(e) || EE(e) || wE(e);
  }
  function wE(e) {
    return U(e, "concat");
  }
  function $m(e) {
    return U(e, "vconcat");
  }
  function EE(e) {
    return U(e, "hconcat");
  }
  function T6({ step: e, offsetIsDiscrete: t }) {
    return t ? e.for ?? "offset" : "position";
  }
  function cr(e) {
    return U(e, "step");
  }
  function uA(e) {
    return U(e, "view") || U(e, "width") || U(e, "height");
  }
  const lA = 20, _se = {
    align: 1,
    bounds: 1,
    center: 1,
    columns: 1,
    spacing: 1
  }, Sse = B(_se);
  function $se(e, t, n) {
    const i = n[t], r = {}, { spacing: o, columns: s } = i;
    o !== void 0 && (r.spacing = o), s !== void 0 && (vm(e) && !Bf(e.facet) || wE(e)) && (r.columns = s), $m(e) && (r.columns = 1);
    for (const a of Sse)
      if (e[a] !== void 0)
        if (a === "spacing") {
          const u = e[a];
          r[a] = $e(u) ? u : {
            row: u.row ?? o,
            column: u.column ?? o
          };
        } else
          r[a] = e[a];
    return r;
  }
  function gb(e, t) {
    return e[t] ?? e[t === "width" ? "continuousWidth" : "continuousHeight"];
  }
  function pb(e, t) {
    const n = Rg(e, t);
    return cr(n) ? n.step : D6;
  }
  function Rg(e, t) {
    const n = e[t] ?? e[t === "width" ? "discreteWidth" : "discreteHeight"];
    return Ze(n, { step: e.step });
  }
  const D6 = 20, kse = {
    continuousWidth: 200,
    continuousHeight: 200,
    step: D6
  }, Ase = {
    background: "white",
    padding: 5,
    timeFormat: "%b %d, %Y",
    countTitle: "Count of Records",
    view: kse,
    mark: boe,
    arc: {},
    area: {},
    bar: Eoe,
    circle: {},
    geoshape: {},
    image: {},
    line: {},
    point: {},
    rect: iE,
    rule: { color: "black" },
    // Need this to override default color in mark config
    square: {},
    text: { color: "black" },
    // Need this to override default color in mark config
    tick: _oe,
    trail: {},
    boxplot: {
      size: 14,
      extent: 1.5,
      box: {},
      median: { color: "white" },
      outliers: {},
      rule: {},
      ticks: null
    },
    errorbar: {
      center: "mean",
      rule: !0,
      ticks: !1
    },
    errorband: {
      band: {
        opacity: 0.3
      },
      borders: !1
    },
    scale: Zre,
    projection: {},
    legend: vse,
    header: { titlePadding: 10, labelPadding: 10 },
    headerColumn: {},
    headerRow: {},
    headerFacet: {},
    selection: wse,
    style: {},
    title: {},
    facet: { spacing: lA },
    concat: { spacing: lA },
    normalizedNumberFormat: ".0%"
  }, Ar = [
    "#4c78a8",
    "#f58518",
    "#e45756",
    "#72b7b2",
    "#54a24b",
    "#eeca3b",
    "#b279a2",
    "#ff9da6",
    "#9d755d",
    "#bab0ac"
  ], cA = {
    text: 11,
    guideLabel: 10,
    guideTitle: 11,
    groupTitle: 13,
    groupSubtitle: 12
  }, fA = {
    blue: Ar[0],
    orange: Ar[1],
    red: Ar[2],
    teal: Ar[3],
    green: Ar[4],
    yellow: Ar[5],
    purple: Ar[6],
    pink: Ar[7],
    brown: Ar[8],
    gray0: "#000",
    gray1: "#111",
    gray2: "#222",
    gray3: "#333",
    gray4: "#444",
    gray5: "#555",
    gray6: "#666",
    gray7: "#777",
    gray8: "#888",
    gray9: "#999",
    gray10: "#aaa",
    gray11: "#bbb",
    gray12: "#ccc",
    gray13: "#ddd",
    gray14: "#eee",
    gray15: "#fff"
  };
  function Cse(e = {}) {
    return {
      signals: [
        {
          name: "color",
          value: Y(e) ? { ...fA, ...e } : fA
        }
      ],
      mark: { color: { signal: "color.blue" } },
      rule: { color: { signal: "color.gray0" } },
      text: {
        color: { signal: "color.gray0" }
      },
      style: {
        "guide-label": {
          fill: { signal: "color.gray0" }
        },
        "guide-title": {
          fill: { signal: "color.gray0" }
        },
        "group-title": {
          fill: { signal: "color.gray0" }
        },
        "group-subtitle": {
          fill: { signal: "color.gray0" }
        },
        cell: {
          stroke: { signal: "color.gray8" }
        }
      },
      axis: {
        domainColor: { signal: "color.gray13" },
        gridColor: { signal: "color.gray8" },
        tickColor: { signal: "color.gray13" }
      },
      range: {
        category: [
          { signal: "color.blue" },
          { signal: "color.orange" },
          { signal: "color.red" },
          { signal: "color.teal" },
          { signal: "color.green" },
          { signal: "color.yellow" },
          { signal: "color.purple" },
          { signal: "color.pink" },
          { signal: "color.brown" },
          { signal: "color.grey8" }
        ]
      }
    };
  }
  function Fse(e) {
    return {
      signals: [
        {
          name: "fontSize",
          value: Y(e) ? { ...cA, ...e } : cA
        }
      ],
      text: {
        fontSize: { signal: "fontSize.text" }
      },
      style: {
        "guide-label": {
          fontSize: { signal: "fontSize.guideLabel" }
        },
        "guide-title": {
          fontSize: { signal: "fontSize.guideTitle" }
        },
        "group-title": {
          fontSize: { signal: "fontSize.groupTitle" }
        },
        "group-subtitle": {
          fontSize: { signal: "fontSize.groupSubtitle" }
        }
      }
    };
  }
  function Mse(e) {
    return {
      text: { font: e },
      style: {
        "guide-label": { font: e },
        "guide-title": { font: e },
        "group-title": { font: e },
        "group-subtitle": { font: e }
      }
    };
  }
  function N6(e) {
    const t = B(e || {}), n = {};
    for (const i of t) {
      const r = e[i];
      n[i] = Wf(r) ? a5(r) : Fn(r);
    }
    return n;
  }
  function Tse(e) {
    const t = B(e), n = {};
    for (const i of t)
      n[i] = N6(e[i]);
    return n;
  }
  const Dse = [
    ...j5,
    ...c6,
    ...C6,
    "background",
    "padding",
    "legend",
    "lineBreak",
    "scale",
    "style",
    "title",
    "view"
  ];
  function O6(e = {}) {
    const { color: t, font: n, fontSize: i, selection: r, ...o } = e, s = Wu({}, ue(Ase), n ? Mse(n) : {}, t ? Cse(t) : {}, i ? Fse(i) : {}, o || {});
    r && Hu(s, "selection", r, !0);
    const a = mn(s, Dse);
    for (const u of ["background", "lineBreak", "padding"])
      s[u] && (a[u] = Fn(s[u]));
    for (const u of j5)
      s[u] && (a[u] = _t(s[u]));
    for (const u of c6)
      s[u] && (a[u] = N6(s[u]));
    for (const u of C6)
      s[u] && (a[u] = _t(s[u]));
    if (s.legend && (a.legend = _t(s.legend)), s.scale) {
      const { invalid: u, ...l } = s.scale, c = _t(u, { level: 1 });
      a.scale = {
        ..._t(l),
        ...B(c).length > 0 ? { invalid: c } : {}
      };
    }
    return s.style && (a.style = Tse(s.style)), s.title && (a.title = _t(s.title)), s.view && (a.view = _t(s.view)), a;
  }
  const Nse = /* @__PURE__ */ new Set(["view", ...doe]), Ose = [
    "color",
    "fontSize",
    "background",
    // We apply background to the spec directly.
    "padding",
    "facet",
    "concat",
    "numberFormat",
    "numberFormatType",
    "normalizedNumberFormat",
    "normalizedNumberFormatType",
    "timeFormat",
    "countTitle",
    "header",
    "axisQuantitative",
    "axisTemporal",
    "axisDiscrete",
    "axisPoint",
    "axisXBand",
    "axisXPoint",
    "axisXDiscrete",
    "axisXQuantitative",
    "axisXTemporal",
    "axisYBand",
    "axisYPoint",
    "axisYDiscrete",
    "axisYQuantitative",
    "axisYTemporal",
    "scale",
    "selection",
    "overlay"
    // FIXME: Redesign and unhide this
  ], Rse = {
    view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"],
    ...yoe
  };
  function Lse(e) {
    e = ue(e);
    for (const t of Ose)
      delete e[t];
    if (e.axis)
      for (const t in e.axis)
        Wf(e.axis[t]) && delete e.axis[t];
    if (e.legend)
      for (const t of pse)
        delete e.legend[t];
    if (e.mark) {
      for (const t of eA)
        delete e.mark[t];
      e.mark.tooltip && Y(e.mark.tooltip) && delete e.mark.tooltip;
    }
    e.params && (e.signals = (e.signals || []).concat(M6(e.params)), delete e.params);
    for (const t of Nse) {
      for (const i of eA)
        delete e[t][i];
      const n = Rse[t];
      if (n)
        for (const i of n)
          delete e[t][i];
      Ise(e, t);
    }
    for (const t of gse())
      delete e[t];
    Pse(e);
    for (const t in e)
      Y(e[t]) && Oe(e[t]) && delete e[t];
    return Oe(e) ? void 0 : e;
  }
  function Pse(e) {
    const { titleMarkConfig: t, subtitleMarkConfig: n, subtitle: i } = s5(e.title);
    Oe(t) || (e.style["group-title"] = {
      ...e.style["group-title"],
      ...t
      // config.title has higher precedence than config.style.group-title in Vega
    }), Oe(n) || (e.style["group-subtitle"] = {
      ...e.style["group-subtitle"],
      ...n
    }), Oe(i) ? delete e.title : e.title = i;
  }
  function Ise(e, t, n, i) {
    const r = e[t];
    t === "view" && (n = "cell");
    const o = {
      ...r,
      ...e.style[n ?? t]
    };
    Oe(o) || (e.style[n ?? t] = o), delete e[t];
  }
  function km(e) {
    return U(e, "layer");
  }
  function zse(e) {
    return U(e, "repeat");
  }
  function Bse(e) {
    return !P(e.repeat) && U(e.repeat, "layer");
  }
  class _E {
    map(t, n) {
      return vm(t) ? this.mapFacet(t, n) : zse(t) ? this.mapRepeat(t, n) : EE(t) ? this.mapHConcat(t, n) : $m(t) ? this.mapVConcat(t, n) : wE(t) ? this.mapConcat(t, n) : this.mapLayerOrUnit(t, n);
    }
    mapLayerOrUnit(t, n) {
      if (km(t))
        return this.mapLayer(t, n);
      if (oo(t))
        return this.mapUnit(t, n);
      throw new Error(Bw(t));
    }
    mapLayer(t, n) {
      return {
        ...t,
        layer: t.layer.map((i) => this.mapLayerOrUnit(i, n))
      };
    }
    mapHConcat(t, n) {
      return {
        ...t,
        hconcat: t.hconcat.map((i) => this.map(i, n))
      };
    }
    mapVConcat(t, n) {
      return {
        ...t,
        vconcat: t.vconcat.map((i) => this.map(i, n))
      };
    }
    mapConcat(t, n) {
      const { concat: i, ...r } = t;
      return {
        ...r,
        concat: i.map((o) => this.map(o, n))
      };
    }
    mapFacet(t, n) {
      return {
        // as any is required here since TS cannot infer that FO may only be FieldName or Field, but not RepeatRef
        ...t,
        // TODO: remove "any" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760
        spec: this.map(t.spec, n)
      };
    }
    mapRepeat(t, n) {
      return {
        ...t,
        // as any is required here since TS cannot infer that the output type satisfies the input type
        spec: this.map(t.spec, n)
      };
    }
  }
  const Use = {
    zero: 1,
    center: 1,
    normalize: 1
  };
  function jse(e) {
    return J(Use, e);
  }
  const qse = /* @__PURE__ */ new Set([z5, pm, gm, Cg, ym, tE, nE, mm, B5, eE]), Wse = /* @__PURE__ */ new Set([pm, gm, z5]);
  function za(e) {
    return q(e) && Ou(e) === "quantitative" && !e.bin;
  }
  function dA(e, t, { orient: n, type: i }) {
    const r = t === "x" ? "y" : "radius", o = t === "x" && ["bar", "area"].includes(i), s = e[t], a = e[r];
    if (q(s) && q(a))
      if (za(s) && za(a)) {
        if (s.stack)
          return t;
        if (a.stack)
          return r;
        const u = q(s) && !!s.aggregate, l = q(a) && !!a.aggregate;
        if (u !== l)
          return u ? t : r;
        if (o) {
          if (n === "vertical")
            return r;
          if (n === "horizontal")
            return t;
        }
      } else {
        if (za(s))
          return t;
        if (za(a))
          return r;
      }
    else {
      if (za(s))
        return o && n === "vertical" ? void 0 : t;
      if (za(a))
        return o && n === "horizontal" ? void 0 : r;
    }
  }
  function Hse(e) {
    switch (e) {
      case "x":
        return "y";
      case "y":
        return "x";
      case "theta":
        return "radius";
      case "radius":
        return "theta";
    }
  }
  function R6(e, t) {
    var p, m;
    const n = lr(e) ? e : { type: e }, i = n.type;
    if (!qse.has(i))
      return null;
    const r = dA(t, "x", n) || dA(t, "theta", n);
    if (!r)
      return null;
    const o = t[r], s = q(o) ? V(o, {}) : void 0, a = Hse(r), u = [], l = /* @__PURE__ */ new Set();
    if (t[a]) {
      const y = t[a], b = q(y) ? V(y, {}) : void 0;
      b && b !== s && (u.push(a), l.add(b));
    }
    const c = a === "x" ? "xOffset" : "yOffset", f = t[c], d = q(f) ? V(f, {}) : void 0;
    d && d !== s && (u.push(c), l.add(d));
    const h = nie.reduce((y, b) => {
      if (b !== "tooltip" && Us(t, b)) {
        const v = t[b];
        for (const x of X(v)) {
          const w = ki(x);
          if (w.aggregate)
            continue;
          const _ = V(w, {});
          // if fielddef is a repeat, just include it in the stack by
          (!_ || // otherwise, the field must be different from the groupBy fields.
          !l.has(_)) && y.push({ channel: b, fieldDef: w });
        }
      }
      return y;
    }, []);
    let g;
    return o.stack !== void 0 ? Ko(o.stack) ? g = o.stack ? "zero" : null : g = o.stack : Wse.has(i) && (g = "zero"), !g || !jse(g) || h6(t) && h.length === 0 ? null : ((p = o == null ? void 0 : o.scale) != null && p.type && ((m = o == null ? void 0 : o.scale) == null ? void 0 : m.type) !== St.LINEAR && o != null && o.stack && j(yre(o.scale.type)), le(t[wr(r)]) ? (o.stack !== void 0 && j(mre(r)), null) : (q(o) && o.aggregate && !gie.has(o.aggregate) && j(bre(o.aggregate)), {
      groupbyChannels: u,
      groupbyFields: l,
      fieldChannel: r,
      impute: o.impute === null ? !1 : ls(i),
      stackBy: h,
      offset: g
    }));
  }
  function L6(e, t, n) {
    const i = _t(e), r = Ne("orient", i, n);
    if (i.orient = Xse(i.type, t, r), r !== void 0 && r !== i.orient && j(ere(i.orient, r)), i.type === "bar" && i.orient) {
      const u = Ne("cornerRadiusEnd", i, n);
      if (u !== void 0) {
        const l = i.orient === "horizontal" && t.x2 || i.orient === "vertical" && t.y2 ? ["cornerRadius"] : xoe[i.orient];
        for (const c of l)
          i[c] = u;
        i.cornerRadiusEnd !== void 0 && delete i.cornerRadiusEnd;
      }
    }
    const o = Ne("opacity", i, n), s = Ne("fillOpacity", i, n);
    return o === void 0 && s === void 0 && (i.opacity = Vse(i.type, t)), Ne("cursor", i, n) === void 0 && (i.cursor = Gse(i, t, n)), i;
  }
  function Gse(e, t, n) {
    return t.href || e.href || Ne("href", e, n) ? "pointer" : e.cursor;
  }
  function Vse(e, t) {
    if (ye([ym, eE, tE, nE], e) && !h6(t))
      return 0.7;
  }
  function Yse(e, t, { graticule: n }) {
    if (n)
      return !1;
    const i = ur("filled", e, t), r = e.type;
    return Ze(i, r !== ym && r !== mm && r !== Cg);
  }
  function Xse(e, t, n) {
    switch (e) {
      case ym:
      case tE:
      case nE:
      case B5:
      case coe:
      case loe:
        return;
    }
    const { x: i, y: r, x2: o, y2: s } = t;
    switch (e) {
      case pm:
        if (q(i) && (Et(i.bin) || q(r) && r.aggregate && !i.aggregate))
          return "vertical";
        if (q(r) && (Et(r.bin) || q(i) && i.aggregate && !r.aggregate))
          return "horizontal";
        if (s || o) {
          if (n)
            return n;
          if (!o)
            return (q(i) && i.type === oa && !ze(i.bin) || Mg(i)) && q(r) && Et(r.bin) ? "horizontal" : "vertical";
          if (!s)
            return (q(r) && r.type === oa && !ze(r.bin) || Mg(r)) && q(i) && Et(i.bin) ? "vertical" : "horizontal";
        }
      case Cg:
        if (o && !(q(i) && Et(i.bin)) && s && !(q(r) && Et(r.bin)))
          return;
      case gm:
        if (s)
          return q(r) && Et(r.bin) ? "horizontal" : "vertical";
        if (o)
          return q(i) && Et(i.bin) ? "vertical" : "horizontal";
        if (e === Cg) {
          if (i && !r)
            return "vertical";
          if (r && !i)
            return "horizontal";
        }
      case mm:
      case eE: {
        const a = rA(i), u = rA(r);
        if (n)
          return n;
        if (a && !u)
          return e !== "tick" ? "horizontal" : "vertical";
        if (!a && u)
          return e !== "tick" ? "vertical" : "horizontal";
        if (a && u)
          return "vertical";
        {
          const l = un(i) && i.type === Du, c = un(r) && r.type === Du;
          if (l && !c)
            return "vertical";
          if (!l && c)
            return "horizontal";
        }
        return;
      }
    }
    return "vertical";
  }
  function Kse(e) {
    const { point: t, line: n, ...i } = e;
    return B(i).length > 1 ? i : i.type;
  }
  function Jse(e) {
    for (const t of ["line", "area", "rule", "trail"])
      e[t] && (e = {
        ...e,
        // TODO: remove as any
        [t]: mn(e[t], ["point", "line"])
      });
    return e;
  }
  function i1(e, t = {}, n) {
    return e.point === "transparent" ? { opacity: 0 } : e.point ? Y(e.point) ? e.point : {} : e.point !== void 0 ? null : t.point || n.shape ? Y(t.point) ? t.point : {} : void 0;
  }
  function hA(e, t = {}) {
    return e.line ? e.line === !0 ? {} : e.line : e.line !== void 0 ? null : t.line ? t.line === !0 ? {} : t.line : void 0;
  }
  class Qse {
    constructor() {
      this.name = "path-overlay";
    }
    hasMatchingType(t, n) {
      if (oo(t)) {
        const { mark: i, encoding: r } = t, o = lr(i) ? i : { type: i };
        switch (o.type) {
          case "line":
          case "rule":
          case "trail":
            return !!i1(o, n[o.type], r);
          case "area":
            return (
              // false / null are also included as we want to remove the properties
              !!i1(o, n[o.type], r) || !!hA(o, n[o.type])
            );
        }
      }
      return !1;
    }
    run(t, n, i) {
      const { config: r } = n, { params: o, projection: s, mark: a, name: u, encoding: l, ...c } = t, f = Sm(l, r), d = lr(a) ? a : { type: a }, h = i1(d, r[d.type], f), g = d.type === "area" && hA(d, r[d.type]), p = [
        {
          name: u,
          ...o ? { params: o } : {},
          mark: Kse({
            // TODO: extract this 0.7 to be shared with default opacity for point/tick/...
            ...d.type === "area" && d.opacity === void 0 && d.fillOpacity === void 0 ? { opacity: 0.7 } : {},
            ...d
          }),
          // drop shape from encoding as this might be used to trigger point overlay
          encoding: mn(f, ["shape"])
        }
      ], m = R6(L6(d, f, r), f);
      let y = f;
      if (m) {
        const { fieldChannel: b, offset: v } = m;
        y = {
          ...f,
          [b]: {
            ...f[b],
            ...v ? { stack: v } : {}
          }
        };
      }
      return y = mn(y, ["y2", "x2"]), g && p.push({
        ...s ? { projection: s } : {},
        mark: {
          type: "line",
          ...Au(d, ["clip", "interpolate", "tension", "tooltip"]),
          ...g
        },
        encoding: y
      }), h && p.push({
        ...s ? { projection: s } : {},
        mark: {
          type: "point",
          opacity: 1,
          filled: !0,
          ...Au(d, ["clip", "tooltip"]),
          ...h
        },
        encoding: y
      }), i({
        ...c,
        layer: p
      }, {
        ...n,
        config: Jse(r)
      });
    }
  }
  function Zse(e, t) {
    return t ? Bf(e) ? I6(e, t) : P6(e, t) : e;
  }
  function r1(e, t) {
    return t ? I6(e, t) : e;
  }
  function mb(e, t, n) {
    const i = t[e];
    if (Roe(i)) {
      if (i.repeat in n)
        return { ...t, [e]: n[i.repeat] };
      j(Oie(i.repeat));
      return;
    }
    return t;
  }
  function P6(e, t) {
    if (e = mb("field", e, t), e !== void 0) {
      if (e === null)
        return null;
      if (lE(e) && Wr(e.sort)) {
        const n = mb("field", e.sort, t);
        e = {
          ...e,
          ...n ? { sort: n } : {}
        };
      }
      return e;
    }
  }
  function gA(e, t) {
    if (q(e))
      return P6(e, t);
    {
      const n = mb("datum", e, t);
      return n !== e && !n.type && (n.type = "nominal"), n;
    }
  }
  function pA(e, t) {
    if (le(e)) {
      const n = gA(e, t);
      if (n)
        return n;
      if (Uf(e))
        return { condition: e.condition };
    } else {
      if (jf(e)) {
        const n = gA(e.condition, t);
        if (n)
          return {
            ...e,
            condition: n
          };
        {
          const { condition: i, ...r } = e;
          return r;
        }
      }
      return e;
    }
  }
  function I6(e, t) {
    const n = {};
    for (const i in e)
      if (U(e, i)) {
        const r = e[i];
        if (P(r))
          n[i] = r.map((o) => pA(o, t)).filter((o) => o);
        else {
          const o = pA(r, t);
          o !== void 0 && (n[i] = o);
        }
      }
    return n;
  }
  class eae {
    constructor() {
      this.name = "RuleForRangedLine";
    }
    hasMatchingType(t) {
      if (oo(t)) {
        const { encoding: n, mark: i } = t;
        if (i === "line" || lr(i) && i.type === "line")
          for (const r of Zne) {
            const o = wa(r), s = n[o];
            if (n[r] && (q(s) && !Et(s.bin) || _r(s)))
              return !0;
          }
      }
      return !1;
    }
    run(t, n, i) {
      const { encoding: r, mark: o } = t;
      return j(Zie(!!r.x2, !!r.y2)), i({
        ...t,
        mark: Y(o) ? { ...o, type: "rule" } : "rule"
      }, n);
    }
  }
  class tae extends _E {
    constructor() {
      super(...arguments), this.nonFacetUnitNormalizers = [
        ise,
        sse,
        hse,
        new Qse(),
        new eae()
      ];
    }
    map(t, n) {
      if (oo(t)) {
        const i = Us(t.encoding, jr), r = Us(t.encoding, qr), o = Us(t.encoding, im);
        if (i || r || o)
          return this.mapFacetedUnit(t, n);
      }
      return super.map(t, n);
    }
    // This is for normalizing non-facet unit
    mapUnit(t, n) {
      const { parentEncoding: i, parentProjection: r } = n, o = r1(t.encoding, n.repeater), s = {
        ...t,
        ...t.name ? { name: [n.repeaterPrefix, t.name].filter((u) => u).join("_") } : {},
        ...o ? { encoding: o } : {}
      };
      if (i || r)
        return this.mapUnitWithParentEncodingOrProjection(s, n);
      const a = this.mapLayerOrUnit.bind(this);
      for (const u of this.nonFacetUnitNormalizers)
        if (u.hasMatchingType(s, n.config))
          return u.run(s, n, a);
      return s;
    }
    mapRepeat(t, n) {
      return Bse(t) ? this.mapLayerRepeat(t, n) : this.mapNonLayerRepeat(t, n);
    }
    mapLayerRepeat(t, n) {
      const { repeat: i, spec: r, ...o } = t, { row: s, column: a, layer: u } = i, { repeater: l = {}, repeaterPrefix: c = "" } = n;
      return s || a ? this.mapRepeat({
        ...t,
        repeat: {
          ...s ? { row: s } : {},
          ...a ? { column: a } : {}
        },
        spec: {
          repeat: { layer: u },
          spec: r
        }
      }, n) : {
        ...o,
        layer: u.map((f) => {
          const d = {
            ...l,
            layer: f
          }, h = `${(r.name ? `${r.name}_` : "") + c}child__layer_${qe(f)}`, g = this.mapLayerOrUnit(r, { ...n, repeater: d, repeaterPrefix: h });
          return g.name = h, g;
        })
      };
    }
    mapNonLayerRepeat(t, n) {
      const { repeat: i, spec: r, data: o, ...s } = t;
      !P(i) && t.columns && (t = mn(t, ["columns"]), j(Yk("repeat")));
      const a = [], { repeater: u = {}, repeaterPrefix: l = "" } = n, c = !P(i) && i.row || [u ? u.row : null], f = !P(i) && i.column || [u ? u.column : null], d = P(i) && i || [u ? u.repeat : null];
      for (const g of d)
        for (const p of c)
          for (const m of f) {
            const y = {
              repeat: g,
              row: p,
              column: m,
              layer: u.layer
            }, b = (r.name ? `${r.name}_` : "") + l + "child__" + (P(i) ? `${qe(g)}` : (i.row ? `row_${qe(p)}` : "") + (i.column ? `column_${qe(m)}` : "")), v = this.map(r, { ...n, repeater: y, repeaterPrefix: b });
            v.name = b, a.push(mn(v, ["data"]));
          }
      const h = P(i) ? t.columns : i.column ? i.column.length : 1;
      return {
        data: r.data ?? o,
        // data from child spec should have precedence
        align: "all",
        ...s,
        columns: h,
        concat: a
      };
    }
    mapFacet(t, n) {
      const { facet: i } = t;
      return Bf(i) && t.columns && (t = mn(t, ["columns"]), j(Yk("facet"))), super.mapFacet(t, n);
    }
    mapUnitWithParentEncodingOrProjection(t, n) {
      const { encoding: i, projection: r } = t, { parentEncoding: o, parentProjection: s, config: a } = n, u = yA({ parentProjection: s, projection: r }), l = mA({
        parentEncoding: o,
        encoding: r1(i, n.repeater)
      });
      return this.mapUnit({
        ...t,
        ...u ? { projection: u } : {},
        ...l ? { encoding: l } : {}
      }, { config: a });
    }
    mapFacetedUnit(t, n) {
      const { row: i, column: r, facet: o, ...s } = t.encoding, { mark: a, width: u, projection: l, height: c, view: f, params: d, encoding: h, ...g } = t, { facetMapping: p, layout: m } = this.getFacetMappingAndLayout({ row: i, column: r, facet: o }, n), y = r1(s, n.repeater);
      return this.mapFacet({
        ...g,
        ...m,
        // row / column has higher precedence than facet
        facet: p,
        spec: {
          ...u ? { width: u } : {},
          ...c ? { height: c } : {},
          ...f ? { view: f } : {},
          ...l ? { projection: l } : {},
          mark: a,
          encoding: y,
          ...d ? { params: d } : {}
        }
      }, n);
    }
    getFacetMappingAndLayout(t, n) {
      const { row: i, column: r, facet: o } = t;
      if (i || r) {
        o && j(Jie([...i ? [jr] : [], ...r ? [qr] : []]));
        const s = {}, a = {};
        for (const u of [jr, qr]) {
          const l = t[u];
          if (l) {
            const { align: c, center: f, spacing: d, columns: h, ...g } = l;
            s[u] = g;
            for (const p of ["align", "center", "spacing"])
              l[p] !== void 0 && (a[p] ?? (a[p] = {}), a[p][u] = l[p]);
          }
        }
        return { facetMapping: s, layout: a };
      } else {
        const { align: s, center: a, spacing: u, columns: l, ...c } = o;
        return {
          facetMapping: Zse(c, n.repeater),
          layout: {
            ...s ? { align: s } : {},
            ...a ? { center: a } : {},
            ...u ? { spacing: u } : {},
            ...l ? { columns: l } : {}
          }
        };
      }
    }
    mapLayer(t, { parentEncoding: n, parentProjection: i, ...r }) {
      const { encoding: o, projection: s, ...a } = t, u = {
        ...r,
        parentEncoding: mA({ parentEncoding: n, encoding: o, layer: !0 }),
        parentProjection: yA({ parentProjection: i, projection: s })
      };
      return super.mapLayer({
        ...a,
        ...t.name ? { name: [u.repeaterPrefix, t.name].filter((l) => l).join("_") } : {}
      }, u);
    }
  }
  function mA({ parentEncoding: e, encoding: t = {}, layer: n }) {
    let i = {};
    if (e) {
      const r = /* @__PURE__ */ new Set([...B(e), ...B(t)]);
      for (const o of r) {
        const s = t[o], a = e[o];
        if (le(s)) {
          const u = {
            ...a,
            ...s
          };
          i[o] = u;
        } else jf(s) ? i[o] = {
          ...s,
          condition: {
            ...a,
            ...s.condition
          }
        } : s || s === null ? i[o] = s : (n || $i(a) || ee(a) || le(a) || P(a)) && (i[o] = a);
      }
    } else
      i = t;
    return !i || Oe(i) ? void 0 : i;
  }
  function yA(e) {
    const { parentProjection: t, projection: n } = e;
    return t && n && j(Bie({ parentProjection: t, projection: n })), n ?? t;
  }
  function SE(e) {
    return U(e, "filter");
  }
  function nae(e) {
    return U(e, "stop");
  }
  function z6(e) {
    return U(e, "lookup");
  }
  function iae(e) {
    return U(e, "data");
  }
  function rae(e) {
    return U(e, "param");
  }
  function oae(e) {
    return U(e, "pivot");
  }
  function sae(e) {
    return U(e, "density");
  }
  function aae(e) {
    return U(e, "quantile");
  }
  function uae(e) {
    return U(e, "regression");
  }
  function lae(e) {
    return U(e, "loess");
  }
  function cae(e) {
    return U(e, "sample");
  }
  function fae(e) {
    return U(e, "window");
  }
  function dae(e) {
    return U(e, "joinaggregate");
  }
  function hae(e) {
    return U(e, "flatten");
  }
  function gae(e) {
    return U(e, "calculate");
  }
  function B6(e) {
    return U(e, "bin");
  }
  function pae(e) {
    return U(e, "impute");
  }
  function mae(e) {
    return U(e, "timeUnit");
  }
  function yae(e) {
    return U(e, "aggregate");
  }
  function bae(e) {
    return U(e, "stack");
  }
  function vae(e) {
    return U(e, "fold");
  }
  function xae(e) {
    return U(e, "extent") && !U(e, "density") && !U(e, "regression");
  }
  function wae(e) {
    return e.map((t) => SE(t) ? {
      filter: nu(t.filter, Gre)
    } : t);
  }
  class Eae extends _E {
    map(t, n) {
      return n.emptySelections ?? (n.emptySelections = {}), n.selectionPredicates ?? (n.selectionPredicates = {}), t = bA(t, n), super.map(t, n);
    }
    mapLayerOrUnit(t, n) {
      if (t = bA(t, n), t.encoding) {
        const i = {};
        for (const [r, o] of Wo(t.encoding))
          i[r] = U6(o, n);
        t = { ...t, encoding: i };
      }
      return super.mapLayerOrUnit(t, n);
    }
    mapUnit(t, n) {
      const { selection: i, ...r } = t;
      return i ? {
        ...r,
        params: Wo(i).map(([o, s]) => {
          const { init: a, bind: u, empty: l, ...c } = s;
          c.type === "single" ? (c.type = "point", c.toggle = !1) : c.type === "multi" && (c.type = "point"), n.emptySelections[o] = l !== "none";
          for (const f of Ft(n.selectionPredicates[o] ?? {}))
            f.empty = l !== "none";
          return { name: o, value: a, select: c, bind: u };
        })
      } : t;
    }
  }
  function bA(e, t) {
    const { transform: n, ...i } = e;
    if (n) {
      const r = n.map((o) => {
        if (SE(o))
          return { filter: yb(o, t) };
        if (B6(o) && Ea(o.bin))
          return {
            ...o,
            bin: j6(o.bin)
          };
        if (z6(o)) {
          const { selection: s, ...a } = o.from;
          return s ? {
            ...o,
            from: { param: s, ...a }
          } : o;
        }
        return o;
      });
      return { ...i, transform: r };
    }
    return e;
  }
  function U6(e, t) {
    var i, r;
    const n = ue(e);
    if (q(n) && Ea(n.bin) && (n.bin = j6(n.bin)), ka(n) && ((r = (i = n.scale) == null ? void 0 : i.domain) != null && r.selection)) {
      const { selection: o, ...s } = n.scale.domain;
      n.scale.domain = { ...s, ...o ? { param: o } : {} };
    }
    if (Uf(n))
      if (P(n.condition))
        n.condition = n.condition.map((o) => {
          const { selection: s, param: a, test: u, ...l } = o;
          return a ? o : { ...l, test: yb(o, t) };
        });
      else {
        const { selection: o, param: s, test: a, ...u } = U6(n.condition, t);
        n.condition = s ? n.condition : {
          ...u,
          test: yb(n.condition, t)
        };
      }
    return n;
  }
  function j6(e) {
    const t = e.extent;
    if (t != null && t.selection) {
      const { selection: n, ...i } = t;
      return { ...e, extent: { ...i, param: n } };
    }
    return e;
  }
  function yb(e, t) {
    const n = (i) => nu(i, (r) => {
      var o;
      const s = t.emptySelections[r] ?? !0, a = { param: r, empty: s };
      return (o = t.selectionPredicates)[r] ?? (o[r] = []), t.selectionPredicates[r].push(a), a;
    });
    return e.selection ? n(e.selection) : nu(e.test || e.filter, (i) => i.selection ? n(i.selection) : i);
  }
  class bb extends _E {
    map(t, n) {
      const i = n.selections ?? [];
      if (t.params && !oo(t)) {
        const r = [];
        for (const o of t.params)
          xE(o) ? i.push(o) : r.push(o);
        t.params = r;
      }
      return n.selections = i, super.map(t, n);
    }
    mapUnit(t, n) {
      const i = n.selections;
      if (!i || !i.length)
        return t;
      const r = (n.path ?? []).concat(t.name), o = [];
      for (const s of i)
        if (!s.views || !s.views.length)
          o.push(s);
        else
          for (const a of s.views)
            (K(a) && (a === t.name || r.includes(a)) || P(a) && // logic for backwards compatibility with view paths before we had unique names
            // @ts-ignore
            a.map((u) => r.indexOf(u)).every((u, l, c) => u !== -1 && (l === 0 || u > c[l - 1]))) && o.push(s);
      return o.length && (t.params = o), t;
    }
  }
  for (const e of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {
    const t = bb.prototype[e];
    bb.prototype[e] = function(n, i) {
      return t.call(this, n, _ae(n, i));
    };
  }
  function _ae(e, t) {
    return e.name ? {
      ...t,
      path: (t.path ?? []).concat(e.name)
    } : t;
  }
  function q6(e, t) {
    t === void 0 && (t = O6(e.config));
    const n = Aae(e, t), { width: i, height: r } = e, o = Cae(n, { width: i, height: r, autosize: e.autosize }, t);
    return {
      ...n,
      ...o ? { autosize: o } : {}
    };
  }
  const Sae = new tae(), $ae = new Eae(), kae = new bb();
  function Aae(e, t = {}) {
    const n = { config: t };
    return kae.map(Sae.map($ae.map(e, n), n), n);
  }
  function vA(e) {
    return K(e) ? { type: e } : e ?? {};
  }
  function Cae(e, t, n) {
    let { width: i, height: r } = t;
    const o = oo(e) || km(e), s = {};
    o ? i == "container" && r == "container" ? (s.type = "fit", s.contains = "padding") : i == "container" ? (s.type = "fit-x", s.contains = "padding") : r == "container" && (s.type = "fit-y", s.contains = "padding") : (i == "container" && (j(Wk("width")), i = void 0), r == "container" && (j(Wk("height")), r = void 0));
    const a = {
      type: "pad",
      ...s,
      ...n ? vA(n.autosize) : {},
      ...vA(e.autosize)
    };
    if (a.type === "fit" && !o && (j(_ie), a.type = "pad"), i == "container" && !(a.type == "fit" || a.type == "fit-x") && j(Hk("width")), r == "container" && !(a.type == "fit" || a.type == "fit-y") && j(Hk("height")), !Dn(a, { type: "pad" }))
      return a;
  }
  function Fae(e) {
    return ["fit", "fit-x", "fit-y"].includes(e);
  }
  function Mae(e) {
    return e ? `fit-${um(e)}` : "fit";
  }
  const Tae = [
    "background",
    "padding"
    // We do not include "autosize" here as it is supported by only unit and layer specs and thus need to be normalized
  ];
  function xA(e, t) {
    const n = {};
    for (const i of Tae)
      e && e[i] !== void 0 && (n[i] = Fn(e[i]));
    return t && (n.params = e.params), n;
  }
  class so {
    constructor(t = {}, n = {}) {
      this.explicit = t, this.implicit = n;
    }
    clone() {
      return new so(ue(this.explicit), ue(this.implicit));
    }
    combine() {
      return {
        ...this.explicit,
        // Explicit properties comes first
        ...this.implicit
      };
    }
    get(t) {
      return Ze(this.explicit[t], this.implicit[t]);
    }
    getWithExplicit(t) {
      return this.explicit[t] !== void 0 ? { explicit: !0, value: this.explicit[t] } : this.implicit[t] !== void 0 ? { explicit: !1, value: this.implicit[t] } : { explicit: !1, value: void 0 };
    }
    setWithExplicit(t, { value: n, explicit: i }) {
      n !== void 0 && this.set(t, n, i);
    }
    set(t, n, i) {
      return delete this[i ? "implicit" : "explicit"][t], this[i ? "explicit" : "implicit"][t] = n, this;
    }
    copyKeyFromSplit(t, { explicit: n, implicit: i }) {
      n[t] !== void 0 ? this.set(t, n[t], !0) : i[t] !== void 0 && this.set(t, i[t], !1);
    }
    copyKeyFromObject(t, n) {
      n[t] !== void 0 && this.set(t, n[t], !0);
    }
    /**
     * Merge split object into this split object. Properties from the other split
     * overwrite properties from this split.
     */
    copyAll(t) {
      for (const n of B(t.combine())) {
        const i = t.getWithExplicit(n);
        this.setWithExplicit(n, i);
      }
    }
  }
  function Wi(e) {
    return {
      explicit: !0,
      value: e
    };
  }
  function kn(e) {
    return {
      explicit: !1,
      value: e
    };
  }
  function W6(e) {
    return (t, n, i, r) => {
      const o = e(t.value, n.value);
      return o > 0 ? t : o < 0 ? n : Am(t, n, i, r);
    };
  }
  function Am(e, t, n, i) {
    return e.explicit && t.explicit && j(lre(n, i, e.value, t.value)), e;
  }
  function Vo(e, t, n, i, r = Am) {
    return e === void 0 || e.value === void 0 ? t : e.explicit && !t.explicit ? e : t.explicit && !e.explicit ? t : Dn(e.value, t.value) ? e : r(e, t, n, i);
  }
  class Dae extends so {
    constructor(t = {}, n = {}, i = !1) {
      super(t, n), this.explicit = t, this.implicit = n, this.parseNothing = i;
    }
    clone() {
      const t = super.clone();
      return t.parseNothing = this.parseNothing, t;
    }
  }
  function Pu(e) {
    return U(e, "url");
  }
  function Jc(e) {
    return U(e, "values");
  }
  function H6(e) {
    return U(e, "name") && !Pu(e) && !Jc(e) && !No(e);
  }
  function No(e) {
    return e && (G6(e) || V6(e) || $E(e));
  }
  function G6(e) {
    return U(e, "sequence");
  }
  function V6(e) {
    return U(e, "sphere");
  }
  function $E(e) {
    return U(e, "graticule");
  }
  var Ke;
  (function(e) {
    e[e.Raw = 0] = "Raw", e[e.Main = 1] = "Main", e[e.Row = 2] = "Row", e[e.Column = 3] = "Column", e[e.Lookup = 4] = "Lookup", e[e.PreFilterInvalid = 5] = "PreFilterInvalid", e[e.PostFilterInvalid = 6] = "PostFilterInvalid";
  })(Ke || (Ke = {}));
  function Y6({ invalid: e, isPath: t }) {
    switch (q5(e, { isPath: t })) {
      case "filter":
        return {
          marks: "exclude-invalid-values",
          scales: "exclude-invalid-values"
        };
      case "break-paths-show-domains":
        return {
          // Path-based marks use pre-filter data so we know to skip these invalid points in the path.
          // For non-path based marks, we skip by not showing them at all.
          marks: t ? "include-invalid-values" : "exclude-invalid-values",
          scales: "include-invalid-values"
        };
      case "break-paths-filter-domains":
        return {
          marks: t ? "include-invalid-values" : "exclude-invalid-values",
          // Unlike 'break-paths-show-domains', 'break-paths-filter-domains' uses post-filter data to feed scale.
          scales: "exclude-invalid-values"
        };
      case "show":
        return {
          marks: "include-invalid-values",
          scales: "include-invalid-values"
        };
    }
  }
  function Nae(e) {
    const { marks: t, scales: n } = Y6(e);
    return t === n ? Ke.Main : n === "include-invalid-values" ? Ke.PreFilterInvalid : Ke.PostFilterInvalid;
  }
  function X6(e) {
    const { signals: t, hasLegend: n, index: i, ...r } = e;
    return r.field = ti(r.field), r;
  }
  function ua(e, t = !0, n = Ht) {
    if (P(e)) {
      const i = e.map((r) => ua(r, t, n));
      return t ? `[${i.join(", ")}]` : i;
    } else if (Sa(e))
      return n(t ? ra(e) : Ore(e));
    return t ? n(Re(e)) : e;
  }
  function Oae(e, t) {
    for (const n of Ft(e.component.selection ?? {})) {
      const i = n.name;
      let r = `${i}${Yo}, ${n.resolve === "global" ? "true" : `{unit: ${js(e)}}`}`;
      for (const o of Tm)
        o.defined(n) && (o.signals && (t = o.signals(e, n, t)), o.modifyExpr && (r = o.modifyExpr(e, n, r)));
      t.push({
        name: i + cue,
        on: [
          {
            events: { signal: n.name + Yo },
            update: `modify(${H(n.name + la)}, ${r})`
          }
        ]
      });
    }
    return kE(t);
  }
  function Rae(e, t) {
    if (e.component.selection && B(e.component.selection).length) {
      const n = H(e.getName("cell"));
      t.unshift({
        name: "facet",
        value: {},
        on: [
          {
            events: ns("pointermove", "scope"),
            update: `isTuple(facet) ? facet : group(${n}).datum`
          }
        ]
      });
    }
    return kE(t);
  }
  function Lae(e, t) {
    let n = !1;
    for (const i of Ft(e.component.selection ?? {})) {
      const r = i.name, o = H(r + la);
      if (t.filter((a) => a.name === r).length === 0) {
        const a = i.resolve === "global" ? "union" : i.resolve, u = i.type === "point" ? ", true, true)" : ")";
        t.push({
          name: i.name,
          update: `${h4}(${o}, ${H(a)}${u}`
        });
      }
      n = !0;
      for (const a of Tm)
        a.defined(i) && a.topLevelSignals && (t = a.topLevelSignals(e, i, t));
    }
    return n && t.filter((r) => r.name === "unit").length === 0 && t.unshift({
      name: "unit",
      value: {},
      on: [{ events: "pointermove", update: "isTuple(group()) ? group() : unit" }]
    }), kE(t);
  }
  function Pae(e, t) {
    const n = [...t], i = js(e, { escape: !1 });
    for (const r of Ft(e.component.selection ?? {})) {
      const o = { name: r.name + la };
      if (r.project.hasSelectionId && (o.transform = [{ type: "collect", sort: { field: Ai } }]), r.init) {
        const a = r.project.items.map(X6);
        o.values = r.project.hasSelectionId ? r.init.map((u) => ({ unit: i, [Ai]: ua(u, !1)[0] })) : r.init.map((u) => ({ unit: i, fields: a, values: ua(u, !1) }));
      }
      n.filter((a) => a.name === r.name + la).length || n.push(o);
    }
    return n;
  }
  function K6(e, t) {
    for (const n of Ft(e.component.selection ?? {}))
      for (const i of Tm)
        i.defined(n) && i.marks && (t = i.marks(e, n, t));
    return t;
  }
  function Iae(e, t) {
    for (const n of e.children)
      Ge(n) && (t = K6(n, t));
    return t;
  }
  function zae(e, t, n, i) {
    const r = b4(e, t.param, t);
    return {
      signal: Si(n.get("type")) && P(i) && i[0] > i[1] ? `isValid(${r}) && reverse(${r})` : r
    };
  }
  function kE(e) {
    return e.map((t) => (t.on && !t.on.length && delete t.on, t));
  }
  class De {
    constructor(t, n) {
      this.debugName = n, this._children = [], this._parent = null, t && (this.parent = t);
    }
    /**
     * Clone this node with a deep copy but don't clone links to children or parents.
     */
    clone() {
      throw new Error("Cannot clone node");
    }
    get parent() {
      return this._parent;
    }
    /**
     * Set the parent of the node and also add this node to the parent's children.
     */
    set parent(t) {
      this._parent = t, t && t.addChild(this);
    }
    get children() {
      return this._children;
    }
    numChildren() {
      return this._children.length;
    }
    addChild(t, n) {
      if (this._children.includes(t)) {
        j(Pie);
        return;
      }
      n !== void 0 ? this._children.splice(n, 0, t) : this._children.push(t);
    }
    removeChild(t) {
      const n = this._children.indexOf(t);
      return this._children.splice(n, 1), n;
    }
    /**
     * Remove node from the dataflow.
     */
    remove() {
      let t = this._parent.removeChild(this);
      for (const n of this._children)
        n._parent = this._parent, this._parent.addChild(n, t++);
    }
    /**
     * Insert another node as a parent of this node.
     */
    insertAsParentOf(t) {
      const n = t.parent;
      n.removeChild(this), this.parent = n, t.parent = this;
    }
    swapWithParent() {
      const t = this._parent, n = t.parent;
      for (const r of this._children)
        r.parent = t;
      this._children = [], t.removeChild(this);
      const i = t.parent.removeChild(t);
      this._parent = n, n.addChild(this, i), t.parent = this;
    }
  }
  class yn extends De {
    clone() {
      const t = new this.constructor();
      return t.debugName = `clone_${this.debugName}`, t._source = this._source, t._name = `clone_${this._name}`, t.type = this.type, t.refCounts = this.refCounts, t.refCounts[t._name] = 0, t;
    }
    /**
     * @param source The name of the source. Will change in assemble.
     * @param type The type of the output node.
     * @param refCounts A global ref counter map.
     */
    constructor(t, n, i, r) {
      super(t, n), this.type = i, this.refCounts = r, this._source = this._name = n, this.refCounts && !(this._name in this.refCounts) && (this.refCounts[this._name] = 0);
    }
    dependentFields() {
      return /* @__PURE__ */ new Set();
    }
    producedFields() {
      return /* @__PURE__ */ new Set();
    }
    hash() {
      return this._hash === void 0 && (this._hash = `Output ${WR()}`), this._hash;
    }
    /**
     * Request the datasource name and increase the ref counter.
     *
     * During the parsing phase, this will return the simple name such as 'main' or 'raw'.
     * It is crucial to request the name from an output node to mark it as a required node.
     * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.
     *
     * In the assemble phase, this will return the correct name.
     */
    getSource() {
      return this.refCounts[this._name]++, this._source;
    }
    isRequired() {
      return !!this.refCounts[this._name];
    }
    setSource(t) {
      this._source = t;
    }
  }
  function o1(e) {
    return e.as !== void 0;
  }
  function wA(e) {
    return `${e}_end`;
  }
  class er extends De {
    clone() {
      return new er(null, ue(this.timeUnits));
    }
    constructor(t, n) {
      super(t), this.timeUnits = n;
    }
    static makeFromEncoding(t, n) {
      const i = n.reduceFieldDef((r, o, s) => {
        const { field: a, timeUnit: u } = o;
        if (u) {
          let l;
          if ($a(u)) {
            if (Ge(n)) {
              const { mark: c, markDef: f, config: d } = n, h = Go({ fieldDef: o, markDef: f, config: d });
              (Kc(c) || h) && (l = {
                timeUnit: yt(u),
                field: a
              });
            }
          } else
            l = {
              as: V(o, { forAs: !0 }),
              field: a,
              timeUnit: u
            };
          if (Ge(n)) {
            const { mark: c, markDef: f, config: d } = n, h = Go({ fieldDef: o, markDef: f, config: d });
            Kc(c) && et(s) && h !== 0.5 && (l.rectBandPosition = h);
          }
          l && (r[be(l)] = l);
        }
        return r;
      }, {});
      return Oe(i) ? null : new er(t, i);
    }
    static makeFromTransform(t, n) {
      const { timeUnit: i, ...r } = { ...n }, o = yt(i), s = {
        ...r,
        timeUnit: o
      };
      return new er(t, {
        [be(s)]: s
      });
    }
    /**
     * Merge together TimeUnitNodes assigning the children of `other` to `this`
     * and removing `other`.
     */
    merge(t) {
      this.timeUnits = { ...this.timeUnits };
      for (const n in t.timeUnits)
        this.timeUnits[n] || (this.timeUnits[n] = t.timeUnits[n]);
      for (const n of t.children)
        t.removeChild(n), n.parent = this;
      t.remove();
    }
    /**
     * Remove time units coming from the other node.
     */
    removeFormulas(t) {
      const n = {};
      for (const [i, r] of Wo(this.timeUnits)) {
        const o = o1(r) ? r.as : `${r.field}_end`;
        t.has(o) || (n[i] = r);
      }
      this.timeUnits = n;
    }
    producedFields() {
      return new Set(Ft(this.timeUnits).map((t) => o1(t) ? t.as : wA(t.field)));
    }
    dependentFields() {
      return new Set(Ft(this.timeUnits).map((t) => t.field));
    }
    hash() {
      return `TimeUnit ${be(this.timeUnits)}`;
    }
    assemble() {
      const t = [];
      for (const n of Ft(this.timeUnits)) {
        const { rectBandPosition: i } = n, r = yt(n.timeUnit);
        if (o1(n)) {
          const { field: o, as: s } = n, { unit: a, utc: u, ...l } = r, c = [s, `${s}_end`];
          t.push({
            field: ti(o),
            type: "timeunit",
            ...a ? { units: dm(a) } : {},
            ...u ? { timezone: "utc" } : {},
            ...l,
            as: c
          }), t.push(...EA(c, i, r));
        } else if (n) {
          const { field: o } = n, s = o.replaceAll("\\.", "."), a = J6({ timeUnit: r, field: s }), u = wA(s);
          t.push({
            type: "formula",
            expr: a,
            as: u
          }), t.push(...EA([s, u], i, r));
        }
      }
      return t;
    }
  }
  const Cm = "offsetted_rect_start", Fm = "offsetted_rect_end";
  function J6({ timeUnit: e, field: t, reverse: n }) {
    const { unit: i, utc: r } = e, o = $5(i), { part: s, step: a } = F5(o, e.step);
    return `${r ? "utcOffset" : "timeOffset"}('${s}', datum['${t}'], ${n ? -a : a})`;
  }
  function EA([e, t], n, i) {
    if (n !== void 0 && n !== 0.5) {
      const r = `datum['${e}']`, o = `datum['${t}']`;
      return [
        {
          type: "formula",
          expr: _A([
            J6({
              timeUnit: i,
              field: e,
              reverse: !0
            }),
            r
          ], n + 0.5),
          as: `${e}_${Cm}`
        },
        {
          type: "formula",
          expr: _A([r, o], n + 0.5),
          as: `${e}_${Fm}`
        }
      ];
    }
    return [];
  }
  function _A([e, t], n) {
    return `${1 - n} * ${e} + ${n} * ${t}`;
  }
  const Hf = "_tuple_fields";
  class Bae {
    constructor(...t) {
      this.items = t, this.hasChannel = {}, this.hasField = {}, this.hasSelectionId = !1;
    }
  }
  const Uae = {
    defined: () => !0,
    parse: (e, t, n) => {
      const i = t.name, r = t.project ?? (t.project = new Bae()), o = {}, s = {}, a = /* @__PURE__ */ new Set(), u = (g, p) => {
        const m = p === "visual" ? g.channel : g.field;
        let y = qe(`${i}_${m}`);
        for (let b = 1; a.has(y); b++)
          y = qe(`${i}_${m}_${b}`);
        return a.add(y), { [p]: y };
      }, l = t.type, c = e.config.selection[l], f = n.value !== void 0 ? X(n.value) : null;
      let { fields: d, encodings: h } = Y(n.select) ? n.select : {};
      if (!d && !h && f) {
        for (const g of f)
          if (Y(g))
            for (const p of B(g))
              Qne(p) ? (h || (h = [])).push(p) : l === "interval" ? (j(Nie), h = c.encodings) : (d ?? (d = [])).push(p);
      }
      !d && !h && (h = c.encodings, "fields" in c && (d = c.fields));
      for (const g of h ?? []) {
        const p = e.fieldDef(g);
        if (p) {
          let m = p.field;
          if (p.aggregate) {
            j(Sie(g, p.aggregate));
            continue;
          } else if (!m) {
            j(Vk(g));
            continue;
          }
          if (p.timeUnit && !$a(p.timeUnit)) {
            m = e.vgField(g);
            const y = {
              timeUnit: p.timeUnit,
              as: m,
              field: p.field
            };
            s[be(y)] = y;
          }
          if (!o[m]) {
            const y = l === "interval" && Er(g) && Si(e.getScaleComponent(g).get("type")) ? "R" : p.bin ? "R-RE" : "E", b = { field: m, channel: g, type: y, index: r.items.length };
            b.signals = { ...u(b, "data"), ...u(b, "visual") }, r.items.push(o[m] = b), r.hasField[m] = o[m], r.hasSelectionId = r.hasSelectionId || m === Ai, KR(g) ? (b.geoChannel = g, b.channel = XR(g), r.hasChannel[b.channel] = o[m]) : r.hasChannel[g] = o[m];
          }
        } else
          j(Vk(g));
      }
      for (const g of d ?? []) {
        if (r.hasField[g])
          continue;
        const p = { type: "E", field: g, index: r.items.length };
        p.signals = { ...u(p, "data") }, r.items.push(p), r.hasField[g] = p, r.hasSelectionId = r.hasSelectionId || g === Ai;
      }
      f && (t.init = f.map((g) => r.items.map((p) => Y(g) ? g[p.geoChannel || p.channel] !== void 0 ? g[p.geoChannel || p.channel] : g[p.field] : g))), Oe(s) || (r.timeUnit = new er(null, s));
    },
    signals: (e, t, n) => {
      const i = t.name + Hf;
      return n.filter((o) => o.name === i).length > 0 || t.project.hasSelectionId ? n : n.concat({
        name: i,
        value: t.project.items.map(X6)
      });
    }
  }, Hr = {
    defined: (e) => e.type === "interval" && e.resolve === "global" && e.bind && e.bind === "scales",
    parse: (e, t) => {
      const n = t.scales = [];
      for (const i of t.project.items) {
        const r = i.channel;
        if (!Er(r))
          continue;
        const o = e.getScaleComponent(r), s = o ? o.get("type") : void 0;
        if (s == "sequential" && j(Cie), !o || !Si(s)) {
          j(Aie);
          continue;
        }
        o.set("selectionExtent", { param: t.name, field: i.field }, !0), n.push(i);
      }
    },
    topLevelSignals: (e, t, n) => {
      const i = t.scales.filter((s) => n.filter((a) => a.name === s.signals.data).length === 0);
      if (!e.parent || SA(e) || i.length === 0)
        return n;
      const r = n.find((s) => s.name === t.name);
      let o = r.update;
      if (o.includes(h4))
        r.update = `{${i.map((s) => `${H(ti(s.field))}: ${s.signals.data}`).join(", ")}}`;
      else {
        for (const s of i) {
          const a = `${H(ti(s.field))}: ${s.signals.data}`;
          o.includes(a) || (o = `${o.substring(0, o.length - 1)}, ${a}}`);
        }
        r.update = o;
      }
      return n.concat(i.map((s) => ({ name: s.signals.data })));
    },
    signals: (e, t, n) => {
      if (e.parent && !SA(e))
        for (const i of t.scales) {
          const r = n.find((o) => o.name === i.signals.data);
          r.push = "outer", delete r.value, delete r.update;
        }
      return n;
    }
  };
  function vb(e, t) {
    return `domain(${H(e.scaleName(t))})`;
  }
  function SA(e) {
    return e.parent && hl(e.parent) && !e.parent.parent;
  }
  const ou = "_brush", Q6 = "_scale_trigger", Rl = "geo_interval_init_tick", Z6 = "_init", jae = "_center", qae = {
    defined: (e) => e.type === "interval",
    parse: (e, t, n) => {
      var i;
      if (e.hasProjection) {
        const r = { ...Y(n.select) ? n.select : {} };
        r.fields = [Ai], r.encodings || (r.encodings = n.value ? B(n.value) : [Oi, Ni]), n.select = { type: "interval", ...r };
      }
      if (t.translate && !Hr.defined(t)) {
        const r = `!event.item || event.item.mark.name !== ${H(t.name + ou)}`;
        for (const o of t.events) {
          if (!o.between) {
            j(`${o} is not an ordered event stream for interval selections.`);
            continue;
          }
          const s = X((i = o.between[0]).filter ?? (i.filter = []));
          s.includes(r) || s.push(r);
        }
      }
    },
    signals: (e, t, n) => {
      const i = t.name, r = i + Yo, o = Ft(t.project.hasChannel).filter((a) => a.channel === We || a.channel === xt), s = t.init ? t.init[0] : null;
      if (n.push(...o.reduce((a, u) => a.concat(Wae(e, t, u, s && s[u.index])), [])), e.hasProjection) {
        const a = H(e.projectionName()), u = e.projectionName() + jae, { x: l, y: c } = t.project.hasChannel, f = l && l.signals.visual, d = c && c.signals.visual, h = l ? s && s[l.index] : `${u}[0]`, g = c ? s && s[c.index] : `${u}[1]`, p = (w) => e.getSizeSignalRef(w).signal, m = `[[${f ? f + "[0]" : "0"}, ${d ? d + "[0]" : "0"}],[${f ? f + "[1]" : p("width")}, ${d ? d + "[1]" : p("height")}]]`;
        s && (n.unshift({
          name: i + Z6,
          init: `[scale(${a}, [${l ? h[0] : h}, ${c ? g[0] : g}]), scale(${a}, [${l ? h[1] : h}, ${c ? g[1] : g}])]`
        }), (!l || !c) && (n.find((_) => _.name === u) || n.unshift({
          name: u,
          update: `invert(${a}, [${p("width")}/2, ${p("height")}/2])`
        })));
        const y = `intersect(${m}, {markname: ${H(e.getName("marks"))}}, unit.mark)`, b = `{unit: ${js(e)}}`, v = `vlSelectionTuples(${y}, ${b})`, x = o.map((w) => w.signals.visual);
        return n.concat({
          name: r,
          on: [
            {
              events: [
                ...x.length ? [{ signal: x.join(" || ") }] : [],
                ...s ? [{ signal: Rl }] : []
              ],
              update: v
            }
          ]
        });
      } else {
        if (!Hr.defined(t)) {
          const l = i + Q6, c = o.map((f) => {
            const d = f.channel, { data: h, visual: g } = f.signals, p = H(e.scaleName(d)), m = e.getScaleComponent(d).get("type"), y = Si(m) ? "+" : "";
            return `(!isArray(${h}) || (${y}invert(${p}, ${g})[0] === ${y}${h}[0] && ${y}invert(${p}, ${g})[1] === ${y}${h}[1]))`;
          });
          c.length && n.push({
            name: l,
            value: {},
            on: [
              {
                events: o.map((f) => ({ scale: e.scaleName(f.channel) })),
                update: c.join(" && ") + ` ? ${l} : {}`
              }
            ]
          });
        }
        const a = o.map((l) => l.signals.data), u = `unit: ${js(e)}, fields: ${i + Hf}, values`;
        return n.concat({
          name: r,
          ...s ? { init: `{${u}: ${ua(s)}}` } : {},
          ...a.length ? {
            on: [
              {
                events: [{ signal: a.join(" || ") }],
                // Prevents double invocation, see https://github.com/vega/vega/issues/1672.
                update: `${a.join(" && ")} ? {${u}: [${a}]} : null`
              }
            ]
          } : {}
        });
      }
    },
    topLevelSignals: (e, t, n) => (Ge(e) && e.hasProjection && t.init && (n.filter((r) => r.name === Rl).length || n.unshift({
      name: Rl,
      value: null,
      on: [
        {
          events: "timer{1}",
          update: `${Rl} === null ? {} : ${Rl}`
        }
      ]
    })), n),
    marks: (e, t, n) => {
      const i = t.name, { x: r, y: o } = t.project.hasChannel, s = r == null ? void 0 : r.signals.visual, a = o == null ? void 0 : o.signals.visual, u = `data(${H(t.name + la)})`;
      if (Hr.defined(t) || !r && !o)
        return n;
      const l = {
        x: r !== void 0 ? { signal: `${s}[0]` } : { value: 0 },
        y: o !== void 0 ? { signal: `${a}[0]` } : { value: 0 },
        x2: r !== void 0 ? { signal: `${s}[1]` } : { field: { group: "width" } },
        y2: o !== void 0 ? { signal: `${a}[1]` } : { field: { group: "height" } }
      };
      if (t.resolve === "global")
        for (const m of B(l))
          l[m] = [
            {
              test: `${u}.length && ${u}[0].unit === ${js(e)}`,
              ...l[m]
            },
            { value: 0 }
          ];
      const { fill: c, fillOpacity: f, cursor: d, ...h } = t.mark, g = B(h).reduce((m, y) => (m[y] = [
        {
          test: [
            r !== void 0 && `${s}[0] !== ${s}[1]`,
            o !== void 0 && `${a}[0] !== ${a}[1]`
          ].filter((b) => b).join(" && "),
          value: h[y]
        },
        { value: null }
      ], m), {}), p = d ?? (t.translate ? "move" : null);
      return [
        {
          name: `${i + ou}_bg`,
          type: "rect",
          clip: !0,
          encode: {
            enter: {
              fill: { value: c },
              fillOpacity: { value: f }
            },
            update: l
          }
        },
        ...n,
        {
          name: i + ou,
          type: "rect",
          clip: !0,
          encode: {
            enter: {
              ...p ? { cursor: { value: p } } : {},
              fill: { value: "transparent" }
            },
            update: { ...l, ...g }
          }
        }
      ];
    }
  };
  function Wae(e, t, n, i) {
    const r = !e.hasProjection, o = n.channel, s = n.signals.visual, a = H(r ? e.scaleName(o) : e.projectionName()), u = (d) => `scale(${a}, ${d})`, l = e.getSizeSignalRef(o === We ? "width" : "height").signal, c = `${o}(unit)`, f = t.events.reduce((d, h) => [
      ...d,
      { events: h.between[0], update: `[${c}, ${c}]` },
      // Brush Start
      { events: h, update: `[${s}[0], clamp(${c}, 0, ${l})]` }
      // Brush End
    ], []);
    if (r) {
      const d = n.signals.data, h = Hr.defined(t), g = e.getScaleComponent(o), p = g ? g.get("type") : void 0, m = i ? { init: ua(i, !0, u) } : { value: [] };
      return f.push({
        events: { signal: t.name + Q6 },
        update: Si(p) ? `[${u(`${d}[0]`)}, ${u(`${d}[1]`)}]` : "[0, 0]"
      }), h ? [{ name: d, on: [] }] : [
        { name: s, ...m, on: f },
        {
          name: d,
          ...i ? { init: ua(i) } : {},
          // Cannot be `value` as `init` may require datetime exprs.
          on: [
            {
              events: { signal: s },
              update: `${s}[0] === ${s}[1] ? null : invert(${a}, ${s})`
            }
          ]
        }
      ];
    } else {
      const d = o === We ? 0 : 1, h = t.name + Z6, g = i ? { init: `[${h}[0][${d}], ${h}[1][${d}]]` } : { value: [] };
      return [{ name: s, ...g, on: f }];
    }
  }
  const Hae = {
    defined: (e) => e.type === "point",
    signals: (e, t, n) => {
      const i = t.name, r = i + Hf, o = t.project, s = "(item().isVoronoi ? datum.datum : datum)", a = Ft(e.component.selection ?? {}).reduce((f, d) => d.type === "interval" ? f.concat(d.name + ou) : f, []).map((f) => `indexof(item().mark.name, '${f}') < 0`).join(" && "), u = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${a ? ` && ${a}` : ""}`;
      let l = `unit: ${js(e)}, `;
      if (t.project.hasSelectionId)
        l += `${Ai}: ${s}[${H(Ai)}]`;
      else {
        const f = o.items.map((d) => {
          const h = e.fieldDef(d.channel);
          return h != null && h.bin ? `[${s}[${H(e.vgField(d.channel, {}))}], ${s}[${H(e.vgField(d.channel, { binSuffix: "end" }))}]]` : `${s}[${H(d.field)}]`;
        }).join(", ");
        l += `fields: ${r}, values: [${f}]`;
      }
      const c = t.events;
      return n.concat([
        {
          name: i + Yo,
          on: c ? [
            {
              events: c,
              update: `${u} ? {${l}} : null`,
              force: !0
            }
          ] : []
        }
      ]);
    }
  };
  function ll({ model: e, channelDef: t, vgChannel: n, invalidValueRef: i, mainRefFn: r }) {
    const o = Uf(t) && t.condition;
    let s = [];
    o && (s = X(o).map((l) => {
      const c = r(l);
      if (Ooe(l)) {
        const { param: f, empty: d } = l;
        return { test: y4(e, { param: f, empty: d }), ...c };
      } else
        return { test: Ig(e, l.test), ...c };
    })), i !== void 0 && s.push(i);
    const a = r(t);
    return a !== void 0 && s.push(a), s.length > 1 || s.length === 1 && s[0].test ? { [n]: s } : s.length === 1 ? { [n]: s[0] } : {};
  }
  function AE(e, t = "text") {
    const n = e.encoding[t];
    return ll({
      model: e,
      channelDef: n,
      vgChannel: t,
      mainRefFn: (i) => Mm(i, e.config),
      invalidValueRef: void 0
      // text encoding doesn't have continuous scales and thus can't have invalid values
    });
  }
  function Mm(e, t, n = "datum") {
    if (e) {
      if ($i(e))
        return Ue(e.value);
      if (le(e)) {
        const { format: i, formatType: r } = Dg(e);
        return aE({ fieldOrDatumDef: e, format: i, formatType: r, expr: n, config: t });
      }
    }
  }
  function e4(e, t = {}) {
    const { encoding: n, markDef: i, config: r, stack: o } = e, s = n.tooltip;
    if (P(s))
      return { tooltip: $A({ tooltip: s }, o, r, t) };
    {
      const a = t.reactiveGeom ? "datum.datum" : "datum";
      return ll({
        model: e,
        channelDef: s,
        vgChannel: "tooltip",
        mainRefFn: (l) => {
          const c = Mm(l, r, a);
          if (c)
            return c;
          if (l === null)
            return;
          let f = Ne("tooltip", i, r);
          if (f === !0 && (f = { content: "encoding" }), K(f))
            return { value: f };
          if (Y(f))
            return ee(f) ? f : f.content === "encoding" ? $A(n, o, r, t) : { signal: a };
        },
        invalidValueRef: void 0
        // tooltip encoding doesn't have continuous scales and thus can't have invalid values
      });
    }
  }
  function t4(e, t, n, { reactiveGeom: i } = {}) {
    const r = { ...n, ...n.tooltipFormat }, o = /* @__PURE__ */ new Set(), s = i ? "datum.datum" : "datum", a = [];
    function u(c, f) {
      const d = wa(f), h = un(c) ? c : {
        ...c,
        type: e[d].type
        // for secondary field def, copy type from main channel
      }, g = h.title || fE(h, r), p = X(g).join(", ").replaceAll(/"/g, '\\"');
      let m;
      if (et(f)) {
        const y = f === "x" ? "x2" : "y2", b = ki(e[y]);
        if (Et(h.bin) && b) {
          const v = V(h, { expr: s }), x = V(b, { expr: s }), { format: w, formatType: _ } = Dg(h);
          m = zf(v, x, w, _, r), o.add(y);
        }
      }
      if ((et(f) || f === ri || f === Di) && t && t.fieldChannel === f && t.offset === "normalize") {
        const { format: y, formatType: b } = Dg(h);
        m = aE({
          fieldOrDatumDef: h,
          format: y,
          formatType: b,
          expr: s,
          config: r,
          normalizeStack: !0
        }).signal;
      }
      m ?? (m = Mm(h, r, s).signal), a.push({ channel: f, key: p, value: m });
    }
    hE(e, (c, f) => {
      q(c) ? u(c, f) : xm(c) && u(c.condition, f);
    });
    const l = {};
    for (const { channel: c, key: f, value: d } of a)
      !o.has(c) && !l[f] && (l[f] = d);
    return l;
  }
  function $A(e, t, n, { reactiveGeom: i } = {}) {
    const r = t4(e, t, n, { reactiveGeom: i }), o = Wo(r).map(([s, a]) => `"${s}": ${a}`);
    return o.length > 0 ? { signal: `{${o.join(", ")}}` } : void 0;
  }
  function Gae(e) {
    const { markDef: t, config: n } = e, i = Ne("aria", t, n);
    return i === !1 ? {} : {
      ...i ? { aria: i } : {},
      ...Vae(e),
      ...Yae(e)
    };
  }
  function Vae(e) {
    const { mark: t, markDef: n, config: i } = e;
    if (i.aria === !1)
      return {};
    const r = Ne("ariaRoleDescription", n, i);
    return r != null ? { ariaRoleDescription: { value: r } } : J(xie, t) ? {} : { ariaRoleDescription: { value: t } };
  }
  function Yae(e) {
    const { encoding: t, markDef: n, config: i, stack: r } = e, o = t.description;
    if (o)
      return ll({
        model: e,
        channelDef: o,
        vgChannel: "description",
        mainRefFn: (u) => Mm(u, e.config),
        invalidValueRef: void 0
        // aria encoding doesn't have continuous scales and thus can't have invalid values
      });
    const s = Ne("description", n, i);
    if (s != null)
      return {
        description: Ue(s)
      };
    if (i.aria === !1)
      return {};
    const a = t4(t, r, i);
    if (!Oe(a))
      return {
        description: {
          signal: Wo(a).map(([u, l], c) => `"${c > 0 ? "; " : ""}${u}: " + (${l})`).join(" + ")
        }
      };
  }
  function $t(e, t, n = {}) {
    const { markDef: i, encoding: r, config: o } = t, { vgChannel: s } = n;
    let { defaultRef: a, defaultValue: u } = n;
    const l = r[e];
    a === void 0 && (u ?? (u = Ne(e, i, o, {
      vgChannel: s,
      // If there is no conditonal def, we ignore vgConfig so the output spec is concise.
      // However, if there is a conditional def, we must include vgConfig so the default is respected.
      ignoreVgConfig: !Uf(l)
    })), u !== void 0 && (a = Ue(u)));
    const c = {
      markDef: i,
      config: o,
      scaleName: t.scaleName(e),
      scale: t.getScaleComponent(e)
    }, f = H5({
      ...c,
      scaleChannel: e,
      channelDef: l
    });
    return ll({
      model: t,
      channelDef: l,
      vgChannel: s ?? e,
      invalidValueRef: f,
      mainRefFn: (h) => sE({
        ...c,
        channel: e,
        channelDef: h,
        stack: null,
        // No need to provide stack for non-position as it does not affect mid point
        defaultRef: a
      })
    });
  }
  function n4(e, t = { filled: void 0 }) {
    const { markDef: n, encoding: i, config: r } = e, { type: o } = n, s = t.filled ?? Ne("filled", n, r), a = ye(["bar", "point", "circle", "square", "geoshape"], o) ? "transparent" : void 0, u = Ne(s === !0 ? "color" : void 0, n, r, { vgChannel: "fill" }) ?? // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
    r.mark[s === !0 && "color"] ?? // If there is no fill, always fill symbols, bar, geoshape
    // with transparent fills https://github.com/vega/vega-lite/issues/1316
    a, l = Ne(s === !1 ? "color" : void 0, n, r, { vgChannel: "stroke" }) ?? // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
    r.mark[s === !1 && "color"], c = s ? "fill" : "stroke", f = {
      ...u ? { fill: Ue(u) } : {},
      ...l ? { stroke: Ue(l) } : {}
    };
    return n.color && (s ? n.fill : n.stroke) && j(m5("property", { fill: "fill" in n, stroke: "stroke" in n })), {
      ...f,
      ...$t("color", e, {
        vgChannel: c,
        defaultValue: s ? u : l
      }),
      ...$t("fill", e, {
        // if there is encoding.fill, include default fill just in case we have conditional-only fill encoding
        defaultValue: i.fill ? u : void 0
      }),
      ...$t("stroke", e, {
        // if there is encoding.stroke, include default fill just in case we have conditional-only stroke encoding
        defaultValue: i.stroke ? l : void 0
      })
    };
  }
  function Xae(e) {
    const { encoding: t, mark: n } = e, i = t.order;
    return !ls(n) && $i(i) ? ll({
      model: e,
      channelDef: i,
      vgChannel: "zindex",
      mainRefFn: (r) => Ue(r.value),
      invalidValueRef: void 0
      // zindex encoding doesn't have continuous scales and thus can't have invalid values
    }) : {};
  }
  function Iu({ channel: e, markDef: t, encoding: n = {}, model: i, bandPosition: r }) {
    const o = `${e}Offset`, s = t[o], a = n[o];
    if ((o === "xOffset" || o === "yOffset") && a)
      return { offsetType: "encoding", offset: sE({
        channel: o,
        channelDef: a,
        markDef: t,
        config: i == null ? void 0 : i.config,
        scaleName: i.scaleName(o),
        scale: i.getScaleComponent(o),
        stack: null,
        defaultRef: Ue(s),
        bandPosition: r
      }) };
    const u = t[o];
    return u ? { offsetType: "visual", offset: u } : {};
  }
  function nn(e, t, { defaultPos: n, vgChannel: i }) {
    const { encoding: r, markDef: o, config: s, stack: a } = t, u = r[e], l = r[wr(e)], c = t.scaleName(e), f = t.getScaleComponent(e), { offset: d, offsetType: h } = Iu({
      channel: e,
      markDef: o,
      encoding: r,
      model: t,
      bandPosition: 0.5
    }), g = CE({
      model: t,
      defaultPos: n,
      channel: e,
      scaleName: c,
      scale: f
    }), p = !u && et(e) && (r.latitude || r.longitude) ? (
      // use geopoint output if there are lat/long and there is no point position overriding lat/long.
      { field: t.getName(e) }
    ) : Kae({
      channel: e,
      channelDef: u,
      channel2Def: l,
      markDef: o,
      config: s,
      scaleName: c,
      scale: f,
      stack: a,
      offset: d,
      defaultRef: g,
      bandPosition: h === "encoding" ? 0 : void 0
    });
    return p ? { [i || e]: p } : void 0;
  }
  function Kae(e) {
    const { channel: t, channelDef: n, scaleName: i, stack: r, offset: o, markDef: s } = e;
    if (le(n) && r && t === r.fieldChannel) {
      if (q(n)) {
        let a = n.bandPosition;
        if (a === void 0 && s.type === "text" && (t === "radius" || t === "theta") && (a = 0.5), a !== void 0)
          return Fg({
            scaleName: i,
            fieldOrDatumDef: n,
            // positionRef always have type
            startSuffix: "start",
            bandPosition: a,
            offset: o
          });
      }
      return Bs(n, i, { suffix: "end" }, { offset: o });
    }
    return oE(e);
  }
  function CE({ model: e, defaultPos: t, channel: n, scaleName: i, scale: r }) {
    const { markDef: o, config: s } = e;
    return () => {
      const a = wa(n), u = Ho(n), l = Ne(n, o, s, { vgChannel: u });
      if (l !== void 0)
        return Ec(n, l);
      switch (t) {
        case "zeroOrMin":
          return kA({ scaleName: i, scale: r, mode: "zeroOrMin", mainChannel: a, config: s });
        case "zeroOrMax":
          return kA({
            scaleName: i,
            scale: r,
            mode: { zeroOrMax: { widthSignal: e.width.signal, heightSignal: e.height.signal } },
            mainChannel: a,
            config: s
          });
        case "mid":
          return { ...e[_n(n)], mult: 0.5 };
      }
    };
  }
  function kA({ mainChannel: e, config: t, ...n }) {
    const i = W5(n), { mode: r } = n;
    if (i)
      return i;
    switch (e) {
      case "radius": {
        if (r === "zeroOrMin")
          return { value: 0 };
        const { widthSignal: o, heightSignal: s } = r.zeroOrMax;
        return {
          signal: `min(${o},${s})/2`
        };
      }
      case "theta":
        return r === "zeroOrMin" ? { value: 0 } : { signal: "2*PI" };
      case "x":
        return r === "zeroOrMin" ? { value: 0 } : { field: { group: "width" } };
      case "y":
        return r === "zeroOrMin" ? { field: { group: "height" } } : { value: 0 };
    }
  }
  const Jae = {
    left: "x",
    center: "xc",
    right: "x2"
  }, Qae = {
    top: "y",
    middle: "yc",
    bottom: "y2"
  };
  function i4(e, t, n, i = "middle") {
    if (e === "radius" || e === "theta")
      return Ho(e);
    const r = e === "x" ? "align" : "baseline", o = Ne(r, t, n);
    let s;
    return ee(o) ? (j(Qie(r)), s = void 0) : s = o, e === "x" ? Jae[s || (i === "top" ? "left" : "center")] : Qae[s || i];
  }
  function Lg(e, t, { defaultPos: n, defaultPos2: i, range: r }) {
    return r ? r4(e, t, { defaultPos: n, defaultPos2: i }) : nn(e, t, { defaultPos: n });
  }
  function r4(e, t, { defaultPos: n, defaultPos2: i }) {
    const { markDef: r, config: o } = t, s = wr(e), a = _n(e), u = Zae(t, i, s), l = u[a] ? (
      // If there is width/height, we need to position the marks based on the alignment.
      i4(e, r, o)
    ) : (
      // Otherwise, make sure to apply to the right Vg Channel (for arc mark)
      Ho(e)
    );
    return {
      ...nn(e, t, { defaultPos: n, vgChannel: l }),
      ...u
    };
  }
  function Zae(e, t, n) {
    const { encoding: i, mark: r, markDef: o, stack: s, config: a } = e, u = wa(n), l = _n(n), c = Ho(n), f = i[u], d = e.scaleName(u), h = e.getScaleComponent(u), { offset: g } = n in i || n in o ? Iu({ channel: n, markDef: o, encoding: i, model: e }) : Iu({ channel: u, markDef: o, encoding: i, model: e });
    if (!f && (n === "x2" || n === "y2") && (i.latitude || i.longitude)) {
      const m = _n(n), y = e.markDef[m];
      return y != null ? {
        [m]: { value: y }
      } : {
        [c]: { field: e.getName(n) }
      };
    }
    const p = eue({
      channel: n,
      channelDef: f,
      channel2Def: i[n],
      markDef: o,
      config: a,
      scaleName: d,
      scale: h,
      stack: s,
      offset: g,
      defaultRef: void 0
    });
    return p !== void 0 ? { [c]: p } : $d(n, o) || $d(n, {
      [n]: ub(n, o, a.style),
      [l]: ub(l, o, a.style)
    }) || $d(n, a[r]) || $d(n, a.mark) || {
      [c]: CE({
        model: e,
        defaultPos: t,
        channel: n,
        scaleName: d,
        scale: h
      })()
    };
  }
  function eue({ channel: e, channelDef: t, channel2Def: n, markDef: i, config: r, scaleName: o, scale: s, stack: a, offset: u, defaultRef: l }) {
    return le(t) && a && // If fieldChannel is X and channel is X2 (or Y and Y2)
    e.charAt(0) === a.fieldChannel.charAt(0) ? Bs(t, o, { suffix: "start" }, { offset: u }) : oE({
      channel: e,
      channelDef: n,
      scaleName: o,
      scale: s,
      stack: a,
      markDef: i,
      config: r,
      offset: u,
      defaultRef: l
    });
  }
  function $d(e, t) {
    const n = _n(e), i = Ho(e);
    if (t[i] !== void 0)
      return { [i]: Ec(e, t[i]) };
    if (t[e] !== void 0)
      return { [i]: Ec(e, t[e]) };
    if (t[n]) {
      const r = t[n];
      if (sa(r))
        j(Gie(n));
      else
        return { [n]: Ec(e, r) };
    }
  }
  function Jr(e, t) {
    const { config: n, encoding: i, markDef: r } = e, o = r.type, s = wr(t), a = _n(t), u = i[t], l = i[s], c = e.getScaleComponent(t), f = c ? c.get("type") : void 0, d = r.orient, h = i[a] ?? i.size ?? Ne("size", r, n, { vgChannel: a }), g = e5(t), p = o === "bar" && (t === "x" ? d === "vertical" : d === "horizontal") || o === "tick" && (t === "y" ? d === "vertical" : d === "horizontal");
    return q(u) && (ze(u.bin) || Et(u.bin) || u.timeUnit && !l) && !(h && !sa(h)) && !i[g] && !bt(f) ? iue({
      fieldDef: u,
      fieldDef2: l,
      channel: t,
      model: e
    }) : (le(u) && bt(f) || p) && !l ? nue(u, t, e) : r4(t, e, { defaultPos: "zeroOrMax", defaultPos2: "zeroOrMin" });
  }
  function tue(e, t, n, i, r, o, s) {
    if (sa(r))
      if (n) {
        const u = n.get("type");
        if (u === "band") {
          let l = `bandwidth('${t}')`;
          r.band !== 1 && (l = `${r.band} * ${l}`);
          const c = ur("minBandSize", { type: s }, i);
          return { signal: c ? `max(${yi(c)}, ${l})` : l };
        } else r.band !== 1 && (j(nre(u)), r = void 0);
      } else
        return {
          mult: r.band,
          field: { group: e }
        };
    else {
      if (ee(r))
        return r;
      if (r)
        return { value: r };
    }
    if (n) {
      const u = n.get("range");
      if (_a(u) && $e(u.step))
        return { value: u.step - 2 };
    }
    if (!o) {
      const { bandPaddingInner: u, barBandPaddingInner: l, rectBandPaddingInner: c, tickBandPaddingInner: f } = i.scale, d = Ze(u, s === "tick" ? f : s === "bar" ? l : c);
      if (ee(d))
        return { signal: `(1 - (${d.signal})) * ${e}` };
      if ($e(d))
        return { signal: `${1 - d} * ${e}` };
    }
    return { value: pb(i.view, e) - 2 };
  }
  function nue(e, t, n) {
    var $, F;
    const { markDef: i, encoding: r, config: o, stack: s } = n, a = i.orient, u = n.scaleName(t), l = n.getScaleComponent(t), c = _n(t), f = wr(t), d = e5(t), h = n.scaleName(d), g = n.getScaleComponent(Ow(t)), p = (
      // Always uses size channel for ticks, because tick only calls rectPosition() for the size channel
      i.type === "tick" || // use "size" channel for bars, if there is orient and the channel matches the right orientation
      a === "horizontal" && t === "y" || a === "vertical" && t === "x"
    );
    let m;
    (r.size || i.size) && (p ? m = $t("size", n, {
      vgChannel: c,
      defaultRef: Ue(i.size)
    }) : j(sre(i.type)));
    const y = !!m, b = Q5({
      channel: t,
      fieldDef: e,
      markDef: i,
      config: o,
      scaleType: ($ = l || g) == null ? void 0 : $.get("type"),
      useVlSizeChannel: p
    });
    m = m || {
      [c]: tue(c, h || u, g || l, o, b, !!e, i.type)
    };
    const v = ((F = l || g) == null ? void 0 : F.get("type")) === "band" && sa(b) && !y ? "top" : "middle", x = i4(t, i, o, v), w = x === "xc" || x === "yc", { offset: _, offsetType: E } = Iu({ channel: t, markDef: i, encoding: r, model: n, bandPosition: w ? 0.5 : 0 }), S = oE({
      channel: t,
      channelDef: e,
      markDef: i,
      config: o,
      scaleName: u,
      scale: l,
      stack: s,
      offset: _,
      defaultRef: CE({ model: n, defaultPos: "mid", channel: t, scaleName: u, scale: l }),
      bandPosition: w ? E === "encoding" ? 0 : 0.5 : ee(b) ? { signal: `(1-${b})/2` } : sa(b) ? (1 - b.band) / 2 : 0
    });
    if (c)
      return { [x]: S, ...m };
    {
      const A = Ho(f), D = m[c], k = _ ? { ...D, offset: _ } : D;
      return {
        [x]: S,
        // posRef might be an array that wraps position invalid test
        [A]: P(S) ? [S[0], { ...S[1], offset: k }] : {
          ...S,
          offset: k
        }
      };
    }
  }
  function AA(e, t, n, i, r, o, s) {
    if (YR(e))
      return 0;
    const a = e === "x" || e === "y2", u = a ? -t / 2 : t / 2;
    if (ee(n) || ee(r) || ee(i) || o) {
      const l = yi(n), c = yi(r), f = yi(i), d = yi(o), g = o ? `(${s} < ${d} ? ${a ? "" : "-"}0.5 * (${d} - (${s})) : ${u})` : u, p = f ? `${f} + ` : "", m = l ? `(${l} ? -1 : 1) * ` : "", y = c ? `(${c} + ${g})` : g;
      return {
        signal: p + m + y
      };
    } else
      return r = r || 0, i + (n ? -r - u : +r + u);
  }
  function iue({ fieldDef: e, fieldDef2: t, channel: n, model: i }) {
    var F;
    const { config: r, markDef: o, encoding: s } = i, a = i.getScaleComponent(n), u = i.scaleName(n), l = a ? a.get("type") : void 0, c = a.get("reverse"), f = Q5({ channel: n, fieldDef: e, markDef: o, config: r, scaleType: l }), d = (F = i.component.axes[n]) == null ? void 0 : F[0], h = (d == null ? void 0 : d.get("translate")) ?? 0.5, g = et(n) ? Ne("binSpacing", o, r) ?? 0 : 0, p = wr(n), m = Ho(n), y = Ho(p), b = ur("minBandSize", o, r), { offset: v } = Iu({ channel: n, markDef: o, encoding: s, model: i, bandPosition: 0 }), { offset: x } = Iu({ channel: p, markDef: o, encoding: s, model: i, bandPosition: 0 }), w = Coe({ fieldDef: e, scaleName: u }), _ = AA(n, g, c, h, v, b, w), E = AA(p, g, c, h, x ?? v, b, w), S = ee(f) ? { signal: `(1-${f.signal})/2` } : sa(f) ? (1 - f.band) / 2 : 0.5, $ = Go({ fieldDef: e, fieldDef2: t, markDef: o, config: r });
    if (ze(e.bin) || e.timeUnit) {
      const A = e.timeUnit && $ !== 0.5;
      return {
        [y]: CA({
          fieldDef: e,
          scaleName: u,
          bandPosition: S,
          offset: E,
          useRectOffsetField: A
        }),
        [m]: CA({
          fieldDef: e,
          scaleName: u,
          bandPosition: ee(S) ? { signal: `1-${S.signal}` } : 1 - S,
          offset: _,
          useRectOffsetField: A
        })
      };
    } else if (Et(e.bin)) {
      const A = Bs(e, u, {}, { offset: E });
      if (q(t))
        return {
          [y]: A,
          [m]: Bs(t, u, {}, { offset: _ })
        };
      if (Ea(e.bin) && e.bin.step)
        return {
          [y]: A,
          [m]: {
            signal: `scale("${u}", ${V(e, { expr: "datum" })} + ${e.bin.step})`,
            offset: _
          }
        };
    }
    j(v5(p));
  }
  function CA({ fieldDef: e, scaleName: t, bandPosition: n, offset: i, useRectOffsetField: r }) {
    return Fg({
      scaleName: t,
      fieldOrDatumDef: e,
      bandPosition: n,
      offset: i,
      ...r ? {
        startSuffix: Cm,
        endSuffix: Fm
      } : {}
    });
  }
  const rue = /* @__PURE__ */ new Set(["aria", "width", "height"]);
  function oi(e, t) {
    const { fill: n = void 0, stroke: i = void 0 } = t.color === "include" ? n4(e) : {};
    return {
      ...oue(e.markDef, t),
      ...FA("fill", n),
      ...FA("stroke", i),
      ...$t("opacity", e),
      ...$t("fillOpacity", e),
      ...$t("strokeOpacity", e),
      ...$t("strokeWidth", e),
      ...$t("strokeDash", e),
      ...Xae(e),
      ...e4(e),
      ...AE(e, "href"),
      ...Gae(e)
    };
  }
  function FA(e, t) {
    return t ? { [e]: t } : {};
  }
  function oue(e, t) {
    return vie.reduce((n, i) => (!rue.has(i) && U(e, i) && t[i] !== "ignore" && (n[i] = Ue(e[i])), n), {});
  }
  function FE(e) {
    const { config: t, markDef: n } = e, i = /* @__PURE__ */ new Set();
    if (e.forEachFieldDef((r, o) => {
      var l;
      let s;
      if (!Er(o) || !(s = e.getScaleType(o)))
        return;
      const a = lm(r.aggregate), u = rE({
        scaleChannel: o,
        markDef: n,
        config: t,
        scaleType: s,
        isCountAggregate: a
      });
      if ($oe(u)) {
        const c = e.vgField(o, { expr: "datum", binSuffix: (l = e.stack) != null && l.impute ? "mid" : void 0 });
        c && i.add(c);
      }
    }), i.size > 0)
      return { defined: { signal: [...i].map((o) => hm(o, !0)).join(" && ") } };
  }
  function MA(e, t) {
    if (t !== void 0)
      return { [e]: Ue(t) };
  }
  const s1 = "voronoi", o4 = {
    defined: (e) => e.type === "point" && e.nearest,
    parse: (e, t) => {
      if (t.events)
        for (const n of t.events)
          n.markname = e.getName(s1);
    },
    marks: (e, t, n) => {
      const { x: i, y: r } = t.project.hasChannel, o = e.mark;
      if (ls(o))
        return j($ie(o)), n;
      const s = {
        name: e.getName(s1),
        type: "path",
        interactive: !0,
        from: { data: e.getName("marks") },
        encode: {
          update: {
            fill: { value: "transparent" },
            strokeWidth: { value: 0.35 },
            stroke: { value: "transparent" },
            isVoronoi: { value: !0 },
            ...e4(e, { reactiveGeom: !0 })
          }
        },
        transform: [
          {
            type: "voronoi",
            x: { expr: i || !r ? "datum.datum.x || 0" : "0" },
            y: { expr: r || !i ? "datum.datum.y || 0" : "0" },
            size: [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")]
          }
        ]
      };
      let a = 0, u = !1;
      return n.forEach((l, c) => {
        const f = l.name ?? "";
        f === e.component.mark[0].name ? a = c : f.includes(s1) && (u = !0);
      }), u || n.splice(a + 1, 0, s), n;
    }
  }, s4 = {
    defined: (e) => e.type === "point" && e.resolve === "global" && e.bind && e.bind !== "scales" && !vE(e.bind),
    parse: (e, t, n) => g4(t, n),
    topLevelSignals: (e, t, n) => {
      const i = t.name, r = t.project, o = t.bind, s = t.init && t.init[0], a = o4.defined(t) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
      return r.items.forEach((u, l) => {
        const c = qe(`${i}_${u.field}`);
        n.filter((d) => d.name === c).length || n.unshift({
          name: c,
          ...s ? { init: ua(s[l]) } : { value: null },
          on: t.events ? [
            {
              events: t.events,
              update: `datum && item().mark.marktype !== 'group' ? ${a}[${H(u.field)}] : null`
            }
          ] : [],
          bind: o[u.field] ?? o[u.channel] ?? o
        });
      }), n;
    },
    signals: (e, t, n) => {
      const i = t.name, r = t.project, o = n.find((l) => l.name === i + Yo), s = i + Hf, a = r.items.map((l) => qe(`${i}_${l.field}`)), u = a.map((l) => `${l} !== null`).join(" && ");
      return a.length && (o.update = `${u} ? {fields: ${s}, values: [${a.join(", ")}]} : null`), delete o.value, delete o.on, n;
    }
  }, Pg = "_toggle", a4 = {
    defined: (e) => e.type === "point" && !!e.toggle,
    signals: (e, t, n) => n.concat({
      name: t.name + Pg,
      value: !1,
      on: [{ events: t.events, update: t.toggle }]
    }),
    modifyExpr: (e, t) => {
      const n = t.name + Yo, i = t.name + Pg;
      return `${i} ? null : ${n}, ` + (t.resolve === "global" ? `${i} ? null : true, ` : `${i} ? null : {unit: ${js(e)}}, `) + `${i} ? ${n} : null`;
    }
  }, sue = {
    defined: (e) => e.clear !== void 0 && e.clear !== !1,
    parse: (e, t) => {
      t.clear && (t.clear = K(t.clear) ? ns(t.clear, "view") : t.clear);
    },
    topLevelSignals: (e, t, n) => {
      if (s4.defined(t))
        for (const i of t.project.items) {
          const r = n.findIndex((o) => o.name === qe(`${t.name}_${i.field}`));
          r !== -1 && n[r].on.push({ events: t.clear, update: "null" });
        }
      return n;
    },
    signals: (e, t, n) => {
      function i(r, o) {
        r !== -1 && n[r].on && n[r].on.push({ events: t.clear, update: o });
      }
      if (t.type === "interval")
        for (const r of t.project.items) {
          const o = n.findIndex((s) => s.name === r.signals.visual);
          if (i(o, "[0, 0]"), o === -1) {
            const s = n.findIndex((a) => a.name === r.signals.data);
            i(s, "null");
          }
        }
      else {
        let r = n.findIndex((o) => o.name === t.name + Yo);
        i(r, "null"), a4.defined(t) && (r = n.findIndex((o) => o.name === t.name + Pg), i(r, "false"));
      }
      return n;
    }
  }, u4 = {
    defined: (e) => {
      const t = e.resolve === "global" && e.bind && vE(e.bind), n = e.project.items.length === 1 && e.project.items[0].field !== Ai;
      return t && !n && j(Fie), t && n;
    },
    parse: (e, t, n) => {
      const i = ue(n);
      if (i.select = K(i.select) ? { type: i.select, toggle: t.toggle } : { ...i.select, toggle: t.toggle }, g4(t, i), Y(n.select) && (n.select.on || n.select.clear)) {
        const s = 'event.item && indexof(event.item.mark.role, "legend") < 0';
        for (const a of t.events)
          a.filter = X(a.filter ?? []), a.filter.includes(s) || a.filter.push(s);
      }
      const r = n1(t.bind) ? t.bind.legend : "click", o = K(r) ? ns(r, "view") : X(r);
      t.bind = { legend: { merge: o } };
    },
    topLevelSignals: (e, t, n) => {
      const i = t.name, r = n1(t.bind) && t.bind.legend, o = (s) => (a) => {
        const u = ue(a);
        return u.markname = s, u;
      };
      for (const s of t.project.items) {
        if (!s.hasLegend)
          continue;
        const a = `${qe(s.field)}_legend`, u = `${i}_${a}`;
        if (n.filter((c) => c.name === u).length === 0) {
          const c = r.merge.map(o(`${a}_symbols`)).concat(r.merge.map(o(`${a}_labels`))).concat(r.merge.map(o(`${a}_entries`)));
          n.unshift({
            name: u,
            ...t.init ? {} : { value: null },
            on: [
              // Legend entries do not store values, so we need to walk the scenegraph to the symbol datum.
              {
                events: c,
                update: "isDefined(datum.value) ? datum.value : item().items[0].items[0].datum.value",
                force: !0
              },
              { events: r.merge, update: `!event.item || !datum ? null : ${u}`, force: !0 }
            ]
          });
        }
      }
      return n;
    },
    signals: (e, t, n) => {
      const i = t.name, r = t.project, o = n.find((d) => d.name === i + Yo), s = i + Hf, a = r.items.filter((d) => d.hasLegend).map((d) => qe(`${i}_${qe(d.field)}_legend`)), l = `${a.map((d) => `${d} !== null`).join(" && ")} ? {fields: ${s}, values: [${a.join(", ")}]} : null`;
      t.events && a.length > 0 ? o.on.push({
        events: a.map((d) => ({ signal: d })),
        update: l
      }) : a.length > 0 && (o.update = l, delete o.value, delete o.on);
      const c = n.find((d) => d.name === i + Pg), f = n1(t.bind) && t.bind.legend;
      return c && (t.events ? c.on.push({ ...c.on[0], events: f }) : c.on[0].events = f), n;
    }
  };
  function aue(e, t, n) {
    var r;
    const i = (r = e.fieldDef(t)) == null ? void 0 : r.field;
    for (const o of Ft(e.component.selection ?? {})) {
      const s = o.project.hasField[i] ?? o.project.hasChannel[t];
      if (s && u4.defined(o)) {
        const a = n.get("selections") ?? [];
        a.push(o.name), n.set("selections", a, !1), s.hasLegend = !0;
      }
    }
  }
  const l4 = "_translate_anchor", c4 = "_translate_delta", uue = {
    defined: (e) => e.type === "interval" && e.translate,
    signals: (e, t, n) => {
      const i = t.name, r = Hr.defined(t), o = i + l4, { x: s, y: a } = t.project.hasChannel;
      let u = ns(t.translate, "scope");
      return r || (u = u.map((l) => (l.between[0].markname = i + ou, l))), n.push({
        name: o,
        value: {},
        on: [
          {
            events: u.map((l) => l.between[0]),
            update: "{x: x(unit), y: y(unit)" + (s !== void 0 ? `, extent_x: ${r ? vb(e, We) : `slice(${s.signals.visual})`}` : "") + (a !== void 0 ? `, extent_y: ${r ? vb(e, xt) : `slice(${a.signals.visual})`}` : "") + "}"
          }
        ]
      }, {
        name: i + c4,
        value: {},
        on: [
          {
            events: u,
            update: `{x: ${o}.x - x(unit), y: ${o}.y - y(unit)}`
          }
        ]
      }), s !== void 0 && TA(e, t, s, "width", n), a !== void 0 && TA(e, t, a, "height", n), n;
    }
  };
  function TA(e, t, n, i, r) {
    const o = t.name, s = o + l4, a = o + c4, u = n.channel, l = Hr.defined(t), c = r.find((w) => w.name === n.signals[l ? "data" : "visual"]), f = e.getSizeSignalRef(i).signal, d = e.getScaleComponent(u), h = d && d.get("type"), g = d && d.get("reverse"), p = l ? u === We ? g ? "" : "-" : g ? "-" : "" : "", m = `${s}.extent_${u}`, y = `${p}${a}.${u} / ${l ? `${f}` : `span(${m})`}`, b = !l || !d ? "panLinear" : h === "log" ? "panLog" : h === "symlog" ? "panSymlog" : h === "pow" ? "panPow" : "panLinear", v = l ? h === "pow" ? `, ${d.get("exponent") ?? 1}` : h === "symlog" ? `, ${d.get("constant") ?? 1}` : "" : "", x = `${b}(${m}, ${y}${v})`;
    c.on.push({
      events: { signal: a },
      update: l ? x : `clampRange(${x}, 0, ${f})`
    });
  }
  const f4 = "_zoom_anchor", d4 = "_zoom_delta", lue = {
    defined: (e) => e.type === "interval" && e.zoom,
    signals: (e, t, n) => {
      const i = t.name, r = Hr.defined(t), o = i + d4, { x: s, y: a } = t.project.hasChannel, u = H(e.scaleName(We)), l = H(e.scaleName(xt));
      let c = ns(t.zoom, "scope");
      return r || (c = c.map((f) => (f.markname = i + ou, f))), n.push({
        name: i + f4,
        on: [
          {
            events: c,
            update: r ? "{" + [u ? `x: invert(${u}, x(unit))` : "", l ? `y: invert(${l}, y(unit))` : ""].filter((f) => f).join(", ") + "}" : "{x: x(unit), y: y(unit)}"
          }
        ]
      }, {
        name: o,
        on: [
          {
            events: c,
            force: !0,
            update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
          }
        ]
      }), s !== void 0 && DA(e, t, s, "width", n), a !== void 0 && DA(e, t, a, "height", n), n;
    }
  };
  function DA(e, t, n, i, r) {
    const o = t.name, s = n.channel, a = Hr.defined(t), u = r.find((b) => b.name === n.signals[a ? "data" : "visual"]), l = e.getSizeSignalRef(i).signal, c = e.getScaleComponent(s), f = c && c.get("type"), d = a ? vb(e, s) : u.name, h = o + d4, g = `${o}${f4}.${s}`, p = !a || !c ? "zoomLinear" : f === "log" ? "zoomLog" : f === "symlog" ? "zoomSymlog" : f === "pow" ? "zoomPow" : "zoomLinear", m = a ? f === "pow" ? `, ${c.get("exponent") ?? 1}` : f === "symlog" ? `, ${c.get("constant") ?? 1}` : "" : "", y = `${p}(${d}, ${g}, ${h}${m})`;
    u.on.push({
      events: { signal: h },
      update: a ? y : `clampRange(${y}, 0, ${l})`
    });
  }
  const la = "_store", Yo = "_tuple", cue = "_modify", h4 = "vlSelectionResolve", Tm = [
    Hae,
    qae,
    Uae,
    a4,
    // Bindings may disable direct manipulation.
    s4,
    Hr,
    u4,
    sue,
    uue,
    lue,
    o4
  ];
  function fue(e) {
    let t = e.parent;
    for (; t && !Rn(t); )
      t = t.parent;
    return t;
  }
  function js(e, { escape: t } = { escape: !0 }) {
    let n = t ? H(e.name) : e.name;
    const i = fue(e);
    if (i) {
      const { facet: r } = i;
      for (const o of Vn)
        r[o] && (n += ` + '__facet_${o}_' + (facet[${H(i.vgField(o))}])`);
    }
    return n;
  }
  function ME(e) {
    return Ft(e.component.selection ?? {}).reduce((t, n) => t || n.project.hasSelectionId, !1);
  }
  function g4(e, t) {
    (K(t.select) || !t.select.on) && delete e.events, (K(t.select) || !t.select.clear) && delete e.clear, (K(t.select) || !t.select.toggle) && delete e.toggle;
  }
  function xb(e) {
    const t = [];
    return e.type === "Identifier" ? [e.name] : e.type === "Literal" ? [e.value] : (e.type === "MemberExpression" && (t.push(...xb(e.object)), t.push(...xb(e.property))), t);
  }
  function p4(e) {
    return e.object.type === "MemberExpression" ? p4(e.object) : e.object.name === "datum";
  }
  function m4(e) {
    const t = K2(e), n = /* @__PURE__ */ new Set();
    return t.visit((i) => {
      i.type === "MemberExpression" && p4(i) && n.add(xb(i).slice(1).join("."));
    }), n;
  }
  class cl extends De {
    clone() {
      return new cl(null, this.model, ue(this.filter));
    }
    constructor(t, n, i) {
      super(t), this.model = n, this.filter = i, this.expr = Ig(this.model, this.filter, this), this._dependentFields = m4(this.expr);
    }
    dependentFields() {
      return this._dependentFields;
    }
    producedFields() {
      return /* @__PURE__ */ new Set();
    }
    assemble() {
      return {
        type: "filter",
        expr: this.expr
      };
    }
    hash() {
      return `Filter ${this.expr}`;
    }
  }
  function due(e, t) {
    const n = {}, i = e.config.selection;
    if (!t || !t.length)
      return n;
    for (const r of t) {
      const o = qe(r.name), s = r.select, a = K(s) ? s : s.type, u = Y(s) ? ue(s) : { type: a }, l = i[a];
      for (const d in l)
        d === "fields" || d === "encodings" || (d === "mark" && (u.mark = { ...l.mark, ...u.mark }), (u[d] === void 0 || u[d] === !0) && (u[d] = ue(l[d] ?? u[d])));
      const c = n[o] = {
        ...u,
        name: o,
        type: a,
        init: r.value,
        bind: r.bind,
        events: K(u.on) ? ns(u.on, "scope") : X(ue(u.on))
      }, f = ue(r);
      for (const d of Tm)
        d.defined(c) && d.parse && d.parse(e, c, f);
    }
    return n;
  }
  function y4(e, t, n, i = "datum") {
    const r = K(t) ? t : t.param, o = qe(r), s = H(o + la);
    let a;
    try {
      a = e.getSelectionComponent(o, r);
    } catch {
      return `!!${o}`;
    }
    if (a.project.timeUnit) {
      const d = n ?? e.component.data.raw, h = a.project.timeUnit.clone();
      d.parent ? h.insertAsParentOf(d) : d.parent = h;
    }
    const u = a.project.hasSelectionId ? "vlSelectionIdTest(" : "vlSelectionTest(", l = a.resolve === "global" ? ")" : `, ${H(a.resolve)})`, c = `${u}${s}, ${i}${l}`, f = `length(data(${s}))`;
    return t.empty === !1 ? `${f} && ${c}` : `!${f} || ${c}`;
  }
  function b4(e, t, n) {
    const i = qe(t), r = n.encoding;
    let o = n.field, s;
    try {
      s = e.getSelectionComponent(i, t);
    } catch {
      return i;
    }
    if (!r && !o)
      o = s.project.items[0].field, s.project.items.length > 1 && j(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${H(o)}.`);
    else if (r && !o) {
      const a = s.project.items.filter((u) => u.channel === r);
      !a.length || a.length > 1 ? (o = s.project.items[0].field, j((a.length ? "Multiple " : "No ") + `matching ${H(r)} encoding found for selection ${H(n.param)}. Using "field": ${H(o)}.`)) : o = a[0].field;
    }
    return `${s.name}[${H(ti(o))}]`;
  }
  function hue(e, t) {
    for (const [n, i] of Wo(e.component.selection ?? {})) {
      const r = e.getName(`lookup_${n}`);
      e.component.data.outputNodes[r] = i.materialized = new yn(new cl(t, e, { param: n }), r, Ke.Lookup, e.component.data.outputNodeRefCounts);
    }
  }
  function Ig(e, t, n) {
    return wc(t, (i) => K(i) ? i : qre(i) ? y4(e, i, n) : T5(i));
  }
  function gue(e, t) {
    if (e)
      return P(e) && !yo(e) ? e.map((n) => fE(n, t)).join(", ") : e;
  }
  function a1(e, t, n, i) {
    var r, o;
    e.encode ?? (e.encode = {}), (r = e.encode)[t] ?? (r[t] = {}), (o = e.encode[t]).update ?? (o.update = {}), e.encode[t].update[n] = i;
  }
  function ac(e, t, n, i = { header: !1 }) {
    var f, d;
    const { disable: r, orient: o, scale: s, labelExpr: a, title: u, zindex: l, ...c } = e.combine();
    if (!r) {
      for (const h in c) {
        const g = h, p = Yoe[g], m = c[g];
        if (p && p !== t && p !== "both")
          delete c[g];
        else if (Wf(m)) {
          const { condition: y, ...b } = m, v = X(y), x = oA[g];
          if (x) {
            const { vgProp: w, part: _ } = x, E = [
              ...v.map((S) => {
                const { test: $, ...F } = S;
                return {
                  test: Ig(null, $),
                  ...F
                };
              }),
              b
            ];
            a1(c, _, w, E), delete c[g];
          } else if (x === null) {
            const w = {
              signal: v.map((_) => {
                const { test: E, ...S } = _;
                return `${Ig(null, E)} ? ${qk(S)} : `;
              }).join("") + qk(b)
            };
            c[g] = w;
          }
        } else if (ee(m)) {
          const y = oA[g];
          if (y) {
            const { vgProp: b, part: v } = y;
            a1(c, v, b, m), delete c[g];
          }
        }
        ye(["labelAlign", "labelBaseline"], g) && c[g] === null && delete c[g];
      }
      if (t === "grid") {
        if (!c.grid)
          return;
        if (c.encode) {
          const { grid: h } = c.encode;
          c.encode = {
            ...h ? { grid: h } : {}
          }, Oe(c.encode) && delete c.encode;
        }
        return {
          scale: s,
          orient: o,
          ...c,
          domain: !1,
          labels: !1,
          aria: !1,
          // always hide grid axis
          // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`
          // would not affect gridAxis
          maxExtent: 0,
          minExtent: 0,
          ticks: !1,
          zindex: Ze(l, 0)
          // put grid behind marks by default
        };
      } else {
        if (!i.header && e.mainExtracted)
          return;
        if (a !== void 0) {
          let g = a;
          (d = (f = c.encode) == null ? void 0 : f.labels) != null && d.update && ee(c.encode.labels.update.text) && (g = na(a, "datum.label", c.encode.labels.update.text.signal)), a1(c, "labels", "text", { signal: g });
        }
        if (c.labelAlign === null && delete c.labelAlign, c.encode) {
          for (const g of u6)
            e.hasAxisPart(g) || delete c.encode[g];
          Oe(c.encode) && delete c.encode;
        }
        const h = gue(u, n);
        return {
          scale: s,
          orient: o,
          grid: !1,
          ...h ? { title: h } : {},
          ...c,
          ...n.aria === !1 ? { aria: !1 } : {},
          zindex: Ze(l, 0)
          // put axis line above marks by default
        };
      }
    }
  }
  function v4(e) {
    const { axes: t } = e.component, n = [];
    for (const i of ro)
      if (t[i]) {
        for (const r of t[i])
          if (!r.get("disable") && !r.get("gridScale")) {
            const o = i === "x" ? "height" : "width", s = e.getSizeSignalRef(o).signal;
            o !== s && n.push({
              name: o,
              update: s
            });
          }
      }
    return n;
  }
  function pue(e, t) {
    const { x: n = [], y: i = [] } = e;
    return [
      ...n.map((r) => ac(r, "grid", t)),
      ...i.map((r) => ac(r, "grid", t)),
      ...n.map((r) => ac(r, "main", t)),
      ...i.map((r) => ac(r, "main", t))
    ].filter((r) => r);
  }
  function NA(e, t, n, i) {
    return Object.assign.apply(null, [
      {},
      ...e.map((r) => {
        if (r === "axisOrient") {
          const o = n === "x" ? "bottom" : "left", s = t[n === "x" ? "axisBottom" : "axisLeft"] || {}, a = t[n === "x" ? "axisTop" : "axisRight"] || {}, u = /* @__PURE__ */ new Set([...B(s), ...B(a)]), l = {};
          for (const c of u.values())
            l[c] = {
              // orient is surely signal in this case
              signal: `${i.signal} === "${o}" ? ${yi(s[c])} : ${yi(a[c])}`
            };
          return l;
        }
        return t[r];
      })
    ]);
  }
  function mue(e, t, n, i) {
    const r = t === "band" ? ["axisDiscrete", "axisBand"] : t === "point" ? ["axisDiscrete", "axisPoint"] : R5(t) ? ["axisQuantitative"] : t === "time" || t === "utc" ? ["axisTemporal"] : [], o = e === "x" ? "axisX" : "axisY", s = ee(n) ? "axisOrient" : `axis${Nf(n)}`, a = [
      // technically Vega does have axisBand, but if we make another separation here,
      // it will further introduce complexity in the code
      ...r,
      ...r.map((l) => o + l.substr(4))
    ], u = ["axis", s, o];
    return {
      vlOnlyAxisConfig: NA(a, i, e, n),
      vgAxisConfig: NA(u, i, e, n),
      axisConfigStyle: yue([...u, ...a], i)
    };
  }
  function yue(e, t) {
    var i;
    const n = [{}];
    for (const r of e) {
      let o = (i = t[r]) == null ? void 0 : i.style;
      if (o) {
        o = X(o);
        for (const s of o)
          n.push(t.style[s]);
      }
    }
    return Object.assign.apply(null, n);
  }
  function wb(e, t, n, i = {}) {
    var o;
    const r = l5(e, n, t);
    if (r !== void 0)
      return {
        configFrom: "style",
        configValue: r
      };
    for (const s of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"])
      if (((o = i[s]) == null ? void 0 : o[e]) !== void 0)
        return { configFrom: s, configValue: i[s][e] };
    return {};
  }
  const OA = {
    scale: ({ model: e, channel: t }) => e.scaleName(t),
    format: ({ format: e }) => e,
    // we already calculate this in parse
    formatType: ({ formatType: e }) => e,
    // we already calculate this in parse
    grid: ({ fieldOrDatumDef: e, axis: t, scaleType: n }) => t.grid ?? bue(n, e),
    gridScale: ({ model: e, channel: t }) => vue(e, t),
    labelAlign: ({ axis: e, labelAngle: t, orient: n, channel: i }) => e.labelAlign || w4(t, n, i),
    labelAngle: ({ labelAngle: e }) => e,
    // we already calculate this in parse
    labelBaseline: ({ axis: e, labelAngle: t, orient: n, channel: i }) => e.labelBaseline || x4(t, n, i),
    labelFlush: ({ axis: e, fieldOrDatumDef: t, channel: n }) => e.labelFlush ?? wue(t.type, n),
    labelOverlap: ({ axis: e, fieldOrDatumDef: t, scaleType: n }) => e.labelOverlap ?? Eue(t.type, n, q(t) && !!t.timeUnit, q(t) ? t.sort : void 0),
    // we already calculate orient in parse
    orient: ({ orient: e }) => e,
    // Need to cast until Vega supports signal
    tickCount: ({ channel: e, model: t, axis: n, fieldOrDatumDef: i, scaleType: r }) => {
      const o = e === "x" ? "width" : e === "y" ? "height" : void 0, s = o ? t.getSizeSignalRef(o) : void 0;
      return n.tickCount ?? Sue({ fieldOrDatumDef: i, scaleType: r, size: s, values: n.values });
    },
    tickMinStep: $ue,
    title: ({ axis: e, model: t, channel: n }) => {
      if (e.title !== void 0)
        return e.title;
      const i = E4(t, n);
      if (i !== void 0)
        return i;
      const r = t.typedFieldDef(n), o = n === "x" ? "x2" : "y2", s = t.fieldDef(o);
      return f5(r ? [iA(r)] : [], q(s) ? [iA(s)] : []);
    },
    values: ({ axis: e, fieldOrDatumDef: t }) => kue(e, t),
    zindex: ({ axis: e, fieldOrDatumDef: t, mark: n }) => e.zindex ?? Aue(n, t)
  };
  function bue(e, t) {
    return !bt(e) && q(t) && !ze(t == null ? void 0 : t.bin) && !Et(t == null ? void 0 : t.bin);
  }
  function vue(e, t) {
    const n = t === "x" ? "y" : "x";
    if (e.getScaleComponent(n))
      return e.scaleName(n);
  }
  function xue(e, t, n, i, r) {
    const o = t == null ? void 0 : t.labelAngle;
    if (o !== void 0)
      return ee(o) ? o : Xc(o);
    {
      const { configValue: s } = wb("labelAngle", i, t == null ? void 0 : t.style, r);
      return s !== void 0 ? Xc(s) : n === We && ye([Zw, Qw], e.type) && !(q(e) && e.timeUnit) ? 270 : void 0;
    }
  }
  function Eb(e) {
    return `(((${e.signal} % 360) + 360) % 360)`;
  }
  function x4(e, t, n, i) {
    if (e !== void 0)
      if (n === "x") {
        if (ee(e)) {
          const r = Eb(e), o = ee(t) ? `(${t.signal} === "top")` : t === "top";
          return {
            signal: `(45 < ${r} && ${r} < 135) || (225 < ${r} && ${r} < 315) ? "middle" :(${r} <= 45 || 315 <= ${r}) === ${o} ? "bottom" : "top"`
          };
        }
        if (45 < e && e < 135 || 225 < e && e < 315)
          return "middle";
        if (ee(t)) {
          const r = e <= 45 || 315 <= e ? "===" : "!==";
          return { signal: `${t.signal} ${r} "top" ? "bottom" : "top"` };
        }
        return (e <= 45 || 315 <= e) == (t === "top") ? "bottom" : "top";
      } else {
        if (ee(e)) {
          const r = Eb(e), o = ee(t) ? `(${t.signal} === "left")` : t === "left";
          return {
            signal: `${r} <= 45 || 315 <= ${r} || (135 <= ${r} && ${r} <= 225) ? ${i ? '"middle"' : "null"} : (45 <= ${r} && ${r} <= 135) === ${o} ? "top" : "bottom"`
          };
        }
        if (e <= 45 || 315 <= e || 135 <= e && e <= 225)
          return i ? "middle" : null;
        if (ee(t)) {
          const r = 45 <= e && e <= 135 ? "===" : "!==";
          return { signal: `${t.signal} ${r} "left" ? "top" : "bottom"` };
        }
        return (45 <= e && e <= 135) == (t === "left") ? "top" : "bottom";
      }
  }
  function w4(e, t, n) {
    if (e === void 0)
      return;
    const i = n === "x", r = i ? 0 : 90, o = i ? "bottom" : "left";
    if (ee(e)) {
      const s = Eb(e), a = ee(t) ? `(${t.signal} === "${o}")` : t === o;
      return {
        signal: `(${r ? `(${s} + 90)` : s} % 180 === 0) ? ${i ? null : '"center"'} :(${r} < ${s} && ${s} < ${180 + r}) === ${a} ? "left" : "right"`
      };
    }
    if ((e + r) % 180 === 0)
      return i ? null : "center";
    if (ee(t)) {
      const s = r < e && e < 180 + r ? "===" : "!==";
      return {
        signal: `${`${t.signal} ${s} "${o}"`} ? "left" : "right"`
      };
    }
    return (r < e && e < 180 + r) == (t === o) ? "left" : "right";
  }
  function wue(e, t) {
    if (t === "x" && ye(["quantitative", "temporal"], e))
      return !0;
  }
  function Eue(e, t, n, i) {
    if (n && !Y(i) || e !== "nominal" && e !== "ordinal")
      return t === "log" || t === "symlog" ? "greedy" : !0;
  }
  function _ue(e) {
    return e === "x" ? "bottom" : "left";
  }
  function Sue({ fieldOrDatumDef: e, scaleType: t, size: n, values: i }) {
    var r;
    if (!i && !bt(t) && t !== "log") {
      if (q(e)) {
        if (ze(e.bin))
          return { signal: `ceil(${n.signal}/10)` };
        if (e.timeUnit && ye(["month", "hours", "day", "quarter"], (r = yt(e.timeUnit)) == null ? void 0 : r.unit))
          return;
      }
      return { signal: `ceil(${n.signal}/40)` };
    }
  }
  function $ue({ format: e, fieldOrDatumDef: t }) {
    if (e === "d")
      return 1;
    if (q(t)) {
      const { timeUnit: n } = t;
      if (n) {
        const i = C5(n);
        if (i)
          return { signal: i };
      }
    }
  }
  function E4(e, t) {
    const n = t === "x" ? "x2" : "y2", i = e.fieldDef(t), r = e.fieldDef(n), o = i ? i.title : void 0, s = r ? r.title : void 0;
    if (o && s)
      return d5(o, s);
    if (o)
      return o;
    if (s)
      return s;
    if (o !== void 0)
      return o;
    if (s !== void 0)
      return s;
  }
  function kue(e, t) {
    const n = e.values;
    if (P(n))
      return a6(t, n);
    if (ee(n))
      return n;
  }
  function Aue(e, t) {
    return e === "rect" && Tg(t) ? 1 : 0;
  }
  class zu extends De {
    clone() {
      return new zu(null, ue(this.transform));
    }
    constructor(t, n) {
      super(t), this.transform = n, this._dependentFields = m4(this.transform.calculate);
    }
    static parseAllForSortIndex(t, n) {
      return n.forEachFieldDef((i, r) => {
        if (ka(i) && J5(i.sort)) {
          const { field: o, timeUnit: s } = i, a = i.sort, u = a.map((l, c) => `${T5({ field: o, timeUnit: s, equal: l })} ? ${c} : `).join("") + a.length;
          t = new zu(t, {
            calculate: u,
            as: Bu(i, r, { forAs: !0 })
          });
        }
      }), t;
    }
    producedFields() {
      return /* @__PURE__ */ new Set([this.transform.as]);
    }
    dependentFields() {
      return this._dependentFields;
    }
    assemble() {
      return {
        type: "formula",
        expr: this.transform.calculate,
        as: this.transform.as
      };
    }
    hash() {
      return `Calculate ${be(this.transform)}`;
    }
  }
  function Bu(e, t, n) {
    return V(e, { prefix: t, suffix: "sort_index", ...n });
  }
  function Dm(e, t) {
    return ye(["top", "bottom"], t) ? "column" : ye(["left", "right"], t) || e === "row" ? "row" : "column";
  }
  function Uu(e, t, n, i) {
    const r = i === "row" ? n.headerRow : i === "column" ? n.headerColumn : n.headerFacet;
    return Ze((t || {})[e], r[e], n.header[e]);
  }
  function Nm(e, t, n, i) {
    const r = {};
    for (const o of e) {
      const s = Uu(o, t || {}, n, i);
      s !== void 0 && (r[o] = s);
    }
    return r;
  }
  const TE = ["row", "column"], DE = ["header", "footer"];
  function Cue(e, t) {
    const n = e.component.layoutHeaders[t].title, i = e.config ? e.config : void 0, r = e.component.layoutHeaders[t].facetFieldDef ? e.component.layoutHeaders[t].facetFieldDef : void 0, { titleAnchor: o, titleAngle: s, titleOrient: a } = Nm(["titleAnchor", "titleAngle", "titleOrient"], r.header, i, t), u = Dm(t, a), l = Xc(s);
    return {
      name: `${t}-title`,
      type: "group",
      role: `${u}-title`,
      title: {
        text: n,
        ...t === "row" ? { orient: "left" } : {},
        style: "guide-title",
        ...S4(l, u),
        ..._4(u, l, o),
        ...$4(i, r, t, mse, k6)
      }
    };
  }
  function _4(e, t, n = "middle") {
    switch (n) {
      case "start":
        return { align: "left" };
      case "end":
        return { align: "right" };
    }
    const i = w4(t, e === "row" ? "left" : "top", e === "row" ? "y" : "x");
    return i ? { align: i } : {};
  }
  function S4(e, t) {
    const n = x4(e, t === "row" ? "left" : "top", t === "row" ? "y" : "x", !0);
    return n ? { baseline: n } : {};
  }
  function Fue(e, t) {
    const n = e.component.layoutHeaders[t], i = [];
    for (const r of DE)
      if (n[r])
        for (const o of n[r]) {
          const s = Tue(e, t, r, n, o);
          s != null && i.push(s);
        }
    return i;
  }
  function Mue(e, t) {
    const { sort: n } = e;
    return Wr(n) ? {
      field: V(n, { expr: "datum" }),
      order: n.order ?? "ascending"
    } : P(n) ? {
      field: Bu(e, t, { expr: "datum" }),
      order: "ascending"
    } : {
      field: V(e, { expr: "datum" }),
      order: n ?? "ascending"
    };
  }
  function _b(e, t, n) {
    const { format: i, formatType: r, labelAngle: o, labelAnchor: s, labelOrient: a, labelExpr: u } = Nm(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], e.header, n, t), l = aE({
      fieldOrDatumDef: e,
      format: i,
      formatType: r,
      expr: "parent",
      config: n
    }).signal, c = Dm(t, a);
    return {
      text: {
        signal: u ? na(na(u, "datum.label", l), "datum.value", V(e, { expr: "parent" })) : l
      },
      ...t === "row" ? { orient: "left" } : {},
      style: "guide-label",
      frame: "group",
      ...S4(o, c),
      ..._4(c, o, s),
      ...$4(n, e, t, yse, A6)
    };
  }
  function Tue(e, t, n, i, r) {
    if (r) {
      let o = null;
      const { facetFieldDef: s } = i, a = e.config ? e.config : void 0;
      if (s && r.labels) {
        const { labelOrient: f } = Nm(["labelOrient"], s.header, a, t);
        (t === "row" && !ye(["top", "bottom"], f) || t === "column" && !ye(["left", "right"], f)) && (o = _b(s, t, a));
      }
      const u = Rn(e) && !Bf(e.facet), l = r.axes, c = (l == null ? void 0 : l.length) > 0;
      if (o || c) {
        const f = t === "row" ? "height" : "width";
        return {
          name: e.getName(`${t}_${n}`),
          type: "group",
          role: `${t}-${n}`,
          ...i.facetFieldDef ? {
            from: { data: e.getName(`${t}_domain`) },
            sort: Mue(s, t)
          } : {},
          ...c && u ? {
            from: { data: e.getName(`facet_domain_${t}`) }
          } : {},
          ...o ? { title: o } : {},
          ...r.sizeSignal ? {
            encode: {
              update: {
                [f]: r.sizeSignal
              }
            }
          } : {},
          ...c ? { axes: l } : {}
        };
      }
    }
    return null;
  }
  const Due = {
    column: {
      start: 0,
      end: 1
    },
    row: {
      start: 1,
      end: 0
    }
  };
  function Nue(e, t) {
    return Due[t][e];
  }
  function Oue(e, t) {
    const n = {};
    for (const i of Vn) {
      const r = e[i];
      if (r != null && r.facetFieldDef) {
        const { titleAnchor: o, titleOrient: s } = Nm(["titleAnchor", "titleOrient"], r.facetFieldDef.header, t, i), a = Dm(i, s), u = Nue(o, a);
        u !== void 0 && (n[a] = u);
      }
    }
    return Oe(n) ? void 0 : n;
  }
  function $4(e, t, n, i, r) {
    const o = {};
    for (const s of i) {
      if (!r[s])
        continue;
      const a = Uu(s, t == null ? void 0 : t.header, e, n);
      a !== void 0 && (o[r[s]] = a);
    }
    return o;
  }
  function NE(e) {
    return [
      ...kd(e, "width"),
      ...kd(e, "height"),
      ...kd(e, "childWidth"),
      ...kd(e, "childHeight")
    ];
  }
  function kd(e, t) {
    const n = t === "width" ? "x" : "y", i = e.component.layoutSize.get(t);
    if (!i || i === "merged")
      return [];
    const r = e.getSizeSignalRef(t).signal;
    if (i === "step") {
      const o = e.getScaleComponent(n);
      if (o) {
        const s = o.get("type"), a = o.get("range");
        if (bt(s) && _a(a)) {
          const u = e.scaleName(n);
          return Rn(e.parent) && e.parent.component.resolve.scale[n] === "independent" ? [RA(u, a)] : [
            RA(u, a),
            {
              name: r,
              update: k4(u, o, `domain('${u}').length`)
            }
          ];
        }
      }
      throw new Error("layout size is step although width/height is not step.");
    } else if (i == "container") {
      const o = r.endsWith("width"), s = o ? "containerSize()[0]" : "containerSize()[1]", a = gb(e.config.view, o ? "width" : "height"), u = `isFinite(${s}) ? ${s} : ${a}`;
      return [{ name: r, init: u, on: [{ update: u, events: "window:resize" }] }];
    } else
      return [
        {
          name: r,
          value: i
        }
      ];
  }
  function RA(e, t) {
    const n = `${e}_step`;
    return ee(t.step) ? { name: n, update: t.step.signal } : { name: n, value: t.step };
  }
  function k4(e, t, n) {
    const i = t.get("type"), r = t.get("padding"), o = Ze(t.get("paddingOuter"), r);
    let s = t.get("paddingInner");
    return s = i === "band" ? (
      // only band has real paddingInner
      s !== void 0 ? s : r
    ) : (
      // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,
      // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.
      1
    ), `bandspace(${n}, ${yi(s)}, ${yi(o)}) * ${e}_step`;
  }
  function A4(e) {
    return e === "childWidth" ? "width" : e === "childHeight" ? "height" : e;
  }
  function C4(e, t) {
    return B(e).reduce((n, i) => ({
      ...n,
      ...ll({
        model: t,
        channelDef: e[i],
        vgChannel: i,
        mainRefFn: (r) => Ue(r.value),
        invalidValueRef: void 0
        // guide encoding won't show invalid values for the scale
      })
    }), {});
  }
  function F4(e, t) {
    if (Rn(t))
      return e === "theta" ? "independent" : "shared";
    if (hl(t))
      return "shared";
    if (BE(t))
      return et(e) || e === "theta" || e === "radius" ? "independent" : "shared";
    throw new Error("invalid model type for resolve");
  }
  function OE(e, t) {
    const n = e.scale[t], i = et(t) ? "axis" : "legend";
    return n === "independent" ? (e[i][t] === "shared" && j(fre(t)), "independent") : e[i][t] || "shared";
  }
  const Rue = {
    ...xse,
    disable: 1,
    labelExpr: 1,
    selections: 1,
    // channel scales
    opacity: 1,
    shape: 1,
    stroke: 1,
    fill: 1,
    size: 1,
    strokeWidth: 1,
    strokeDash: 1,
    // encode
    encode: 1
  }, M4 = B(Rue);
  class Lue extends so {
  }
  const LA = {
    symbols: Pue,
    gradient: Iue,
    labels: zue,
    entries: Bue
  };
  function Pue(e, { fieldOrDatumDef: t, model: n, channel: i, legendCmpt: r, legendType: o }) {
    if (o !== "symbol")
      return;
    const { markDef: s, encoding: a, config: u, mark: l } = n, c = s.filled && l !== "trail";
    let f = {
      ...Eie({}, n, poe),
      ...n4(n, { filled: c })
    };
    const d = r.get("symbolOpacity") ?? u.legend.symbolOpacity, h = r.get("symbolFillColor") ?? u.legend.symbolFillColor, g = r.get("symbolStrokeColor") ?? u.legend.symbolStrokeColor, p = d === void 0 ? T4(a.opacity) ?? s.opacity : void 0;
    if (f.fill) {
      if (i === "fill" || c && i === wn)
        delete f.fill;
      else if (U(f.fill, "field"))
        h ? delete f.fill : (f.fill = Ue(u.legend.symbolBaseFillColor ?? "black"), f.fillOpacity = Ue(p ?? 1));
      else if (P(f.fill)) {
        const m = Sb(a.fill ?? a.color) ?? s.fill ?? (c && s.color);
        m && (f.fill = Ue(m));
      }
    }
    if (f.stroke) {
      if (i === "stroke" || !c && i === wn)
        delete f.stroke;
      else if (U(f.stroke, "field") || g)
        delete f.stroke;
      else if (P(f.stroke)) {
        const m = Ze(Sb(a.stroke || a.color), s.stroke, c ? s.color : void 0);
        m && (f.stroke = { value: m });
      }
    }
    if (i !== io) {
      const m = q(t) && N4(n, r, t);
      m ? f.opacity = [
        { test: m, ...Ue(p ?? 1) },
        Ue(u.legend.unselectedOpacity)
      ] : p && (f.opacity = Ue(p));
    }
    return f = { ...f, ...e }, Oe(f) ? void 0 : f;
  }
  function Iue(e, { model: t, legendType: n, legendCmpt: i }) {
    if (n !== "gradient")
      return;
    const { config: r, markDef: o, encoding: s } = t;
    let a = {};
    const l = (i.get("gradientOpacity") ?? r.legend.gradientOpacity) === void 0 ? T4(s.opacity) || o.opacity : void 0;
    return l && (a.opacity = Ue(l)), a = { ...a, ...e }, Oe(a) ? void 0 : a;
  }
  function zue(e, { fieldOrDatumDef: t, model: n, channel: i, legendCmpt: r }) {
    const o = n.legend(i) || {}, s = n.config, a = q(t) ? N4(n, r, t) : void 0, u = a ? [{ test: a, value: 1 }, { value: s.legend.unselectedOpacity }] : void 0, { format: l, formatType: c } = o;
    let f;
    aa(c) ? f = bi({
      fieldOrDatumDef: t,
      field: "datum.value",
      format: l,
      formatType: c,
      config: s
    }) : l === void 0 && c === void 0 && s.customFormatTypes && (t.type === "quantitative" && s.numberFormatType ? f = bi({
      fieldOrDatumDef: t,
      field: "datum.value",
      format: s.numberFormat,
      formatType: s.numberFormatType,
      config: s
    }) : t.type === "temporal" && s.timeFormatType && q(t) && t.timeUnit === void 0 && (f = bi({
      fieldOrDatumDef: t,
      field: "datum.value",
      format: s.timeFormat,
      formatType: s.timeFormatType,
      config: s
    })));
    const d = {
      ...u ? { opacity: u } : {},
      ...f ? { text: f } : {},
      ...e
    };
    return Oe(d) ? void 0 : d;
  }
  function Bue(e, { legendCmpt: t }) {
    const n = t.get("selections");
    return n != null && n.length ? { ...e, fill: { value: "transparent" } } : e;
  }
  function T4(e) {
    return D4(e, (t, n) => Math.max(t, n.value));
  }
  function Sb(e) {
    return D4(e, (t, n) => Ze(t, n.value));
  }
  function D4(e, t) {
    if (Loe(e))
      return X(e.condition).reduce(t, e.value);
    if ($i(e))
      return e.value;
  }
  function N4(e, t, n) {
    const i = t.get("selections");
    if (!(i != null && i.length))
      return;
    const r = H(n.field);
    return i.map((o) => `(!length(data(${H(qe(o) + la)})) || (${o}[${r}] && indexof(${o}[${r}], datum.value) >= 0))`).join(" || ");
  }
  const PA = {
    direction: ({ direction: e }) => e,
    format: ({ fieldOrDatumDef: e, legend: t, config: n }) => {
      const { format: i, formatType: r } = t;
      return Y5(e, e.type, i, r, n, !1);
    },
    formatType: ({ legend: e, fieldOrDatumDef: t, scaleType: n }) => {
      const { formatType: i } = e;
      return X5(i, t, n);
    },
    gradientLength: (e) => {
      const { legend: t, legendConfig: n } = e;
      return t.gradientLength ?? n.gradientLength ?? Vue(e);
    },
    labelOverlap: ({ legend: e, legendConfig: t, scaleType: n }) => e.labelOverlap ?? t.labelOverlap ?? Yue(n),
    symbolType: ({ legend: e, markDef: t, channel: n, encoding: i }) => e.symbolType ?? jue(t.type, n, i.shape, t.shape),
    title: ({ fieldOrDatumDef: e, config: t }) => ru(e, t, { allowDisabling: !0 }),
    type: ({ legendType: e, scaleType: t, channel: n }) => {
      if (iu(n) && Ki(t)) {
        if (e === "gradient")
          return;
      } else if (e === "symbol")
        return;
      return e;
    },
    // depended by other property, let's define upfront
    values: ({ fieldOrDatumDef: e, legend: t }) => Uue(t, e)
  };
  function Uue(e, t) {
    const n = e.values;
    if (P(n))
      return a6(t, n);
    if (ee(n))
      return n;
  }
  function jue(e, t, n, i) {
    if (t !== "shape") {
      const r = Sb(n) ?? i;
      if (r)
        return r;
    }
    switch (e) {
      case "bar":
      case "rect":
      case "image":
      case "square":
        return "square";
      case "line":
      case "trail":
      case "rule":
        return "stroke";
      case "arc":
      case "point":
      case "circle":
      case "tick":
      case "geoshape":
      case "area":
      case "text":
        return "circle";
    }
  }
  function que(e) {
    const { legend: t } = e;
    return Ze(t.type, Wue(e));
  }
  function Wue({ channel: e, timeUnit: t, scaleType: n }) {
    if (iu(e)) {
      if (ye(["quarter", "month", "day"], t))
        return "symbol";
      if (Ki(n))
        return "gradient";
    }
    return "symbol";
  }
  function Hue({ legendConfig: e, legendType: t, orient: n, legend: i }) {
    return i.direction ?? e[t ? "gradientDirection" : "symbolDirection"] ?? Gue(n, t);
  }
  function Gue(e, t) {
    switch (e) {
      case "top":
      case "bottom":
        return "horizontal";
      case "left":
      case "right":
      case "none":
      case void 0:
        return;
      default:
        return t === "gradient" ? "horizontal" : void 0;
    }
  }
  function Vue({ legendConfig: e, model: t, direction: n, orient: i, scaleType: r }) {
    const { gradientHorizontalMaxLength: o, gradientHorizontalMinLength: s, gradientVerticalMaxLength: a, gradientVerticalMinLength: u } = e;
    if (Ki(r))
      return n === "horizontal" ? i === "top" || i === "bottom" ? IA(t, "width", s, o) : s : IA(t, "height", u, a);
  }
  function IA(e, t, n, i) {
    return { signal: `clamp(${e.getSizeSignalRef(t).signal}, ${n}, ${i})` };
  }
  function Yue(e) {
    if (ye(["quantile", "threshold", "log", "symlog"], e))
      return "greedy";
  }
  function O4(e) {
    const t = Ge(e) ? Xue(e) : Zue(e);
    return e.component.legends = t, t;
  }
  function Xue(e) {
    const { encoding: t } = e, n = {};
    for (const i of [wn, ...F6]) {
      const r = st(t[i]);
      !r || !e.getScaleComponent(i) || i === En && q(r) && r.type === ul || (n[i] = Que(e, i));
    }
    return n;
  }
  function Kue(e, t) {
    const n = e.scaleName(t);
    if (e.mark === "trail") {
      if (t === "color")
        return { stroke: n };
      if (t === "size")
        return { strokeWidth: n };
    }
    return t === "color" ? e.markDef.filled ? { fill: n } : { stroke: n } : { [t]: n };
  }
  function Jue(e, t, n, i) {
    switch (t) {
      case "disable":
        return n !== void 0;
      case "values":
        return !!(n != null && n.values);
      case "title":
        if (t === "title" && e === (i == null ? void 0 : i.title))
          return !0;
    }
    return e === (n || {})[t];
  }
  function Que(e, t) {
    var x;
    let n = e.legend(t);
    const { markDef: i, encoding: r, config: o } = e, s = o.legend, a = new Lue({}, Kue(e, t));
    aue(e, t, a);
    const u = n !== void 0 ? !n : s.disable;
    if (a.set("disable", u, n !== void 0), u)
      return a;
    n = n || {};
    const l = e.getScaleComponent(t).get("type"), c = st(r[t]), f = q(c) ? (x = yt(c.timeUnit)) == null ? void 0 : x.unit : void 0, d = n.orient || o.legend.orient || "right", h = que({ legend: n, channel: t, timeUnit: f, scaleType: l }), g = Hue({ legend: n, legendType: h, orient: d, legendConfig: s }), p = {
      legend: n,
      channel: t,
      model: e,
      markDef: i,
      encoding: r,
      fieldOrDatumDef: c,
      legendConfig: s,
      config: o,
      scaleType: l,
      orient: d,
      legendType: h,
      direction: g
    };
    for (const w of M4) {
      if (h === "gradient" && w.startsWith("symbol") || h === "symbol" && w.startsWith("gradient"))
        continue;
      const _ = w in PA ? PA[w](p) : n[w];
      if (_ !== void 0) {
        const E = Jue(_, w, n, e.fieldDef(t));
        (E || o.legend[w] === void 0) && a.set(w, _, E);
      }
    }
    const m = (n == null ? void 0 : n.encoding) ?? {}, y = a.get("selections"), b = {}, v = { fieldOrDatumDef: c, model: e, channel: t, legendCmpt: a, legendType: h };
    for (const w of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
      const _ = C4(m[w] ?? {}, e), E = w in LA ? LA[w](_, v) : _;
      E !== void 0 && !Oe(E) && (b[w] = {
        ...y != null && y.length && q(c) ? { name: `${qe(c.field)}_legend_${w}` } : {},
        ...y != null && y.length ? { interactive: !!y } : {},
        update: E
      });
    }
    return Oe(b) || a.set("encode", b, !!(n != null && n.encoding)), a;
  }
  function Zue(e) {
    const { legends: t, resolve: n } = e.component;
    for (const i of e.children) {
      O4(i);
      for (const r of B(i.component.legends))
        n.legend[r] = OE(e.component.resolve, r), n.legend[r] === "shared" && (t[r] = R4(t[r], i.component.legends[r]), t[r] || (n.legend[r] = "independent", delete t[r]));
    }
    for (const i of B(t))
      for (const r of e.children)
        r.component.legends[i] && n.legend[i] === "shared" && delete r.component.legends[i];
    return t;
  }
  function R4(e, t) {
    var o, s, a, u;
    if (!e)
      return t.clone();
    const n = e.getWithExplicit("orient"), i = t.getWithExplicit("orient");
    if (n.explicit && i.explicit && n.value !== i.value)
      return;
    let r = !1;
    for (const l of M4) {
      const c = Vo(
        e.getWithExplicit(l),
        t.getWithExplicit(l),
        l,
        "legend",
        // Tie breaker function
        (f, d) => {
          switch (l) {
            case "symbolType":
              return ele(f, d);
            case "title":
              return h5(f, d);
            case "type":
              return r = !0, kn("symbol");
          }
          return Am(f, d, l, "legend");
        }
      );
      e.setWithExplicit(l, c);
    }
    return r && ((s = (o = e.implicit) == null ? void 0 : o.encode) != null && s.gradient && kg(e.implicit, ["encode", "gradient"]), (u = (a = e.explicit) == null ? void 0 : a.encode) != null && u.gradient && kg(e.explicit, ["encode", "gradient"])), e;
  }
  function ele(e, t) {
    return t.value === "circle" ? t : e;
  }
  function tle(e, t, n, i) {
    var r, o;
    e.encode ?? (e.encode = {}), (r = e.encode)[t] ?? (r[t] = {}), (o = e.encode[t]).update ?? (o.update = {}), e.encode[t].update[n] = i;
  }
  function L4(e) {
    const t = e.component.legends, n = {};
    for (const r of B(t)) {
      const o = e.getScaleComponent(r), s = Re(o.get("domains"));
      if (n[s])
        for (const a of n[s])
          R4(a, t[r]) || n[s].push(t[r]);
      else
        n[s] = [t[r].clone()];
    }
    return Ft(n).flat().map((r) => nle(r, e.config)).filter((r) => r !== void 0);
  }
  function nle(e, t) {
    var s, a, u;
    const { disable: n, labelExpr: i, selections: r, ...o } = e.combine();
    if (!n) {
      if (t.aria === !1 && o.aria == null && (o.aria = !1), (s = o.encode) != null && s.symbols) {
        const l = o.encode.symbols.update;
        l.fill && l.fill.value !== "transparent" && !l.stroke && !o.stroke && (l.stroke = { value: "transparent" });
        for (const c of F6)
          o[c] && delete l[c];
      }
      if (o.title || delete o.title, i !== void 0) {
        let l = i;
        (u = (a = o.encode) == null ? void 0 : a.labels) != null && u.update && ee(o.encode.labels.update.text) && (l = na(i, "datum.label", o.encode.labels.update.text.signal)), tle(o, "labels", "text", { signal: l });
      }
      return o;
    }
  }
  function ile(e) {
    return hl(e) || BE(e) ? rle(e) : P4(e);
  }
  function rle(e) {
    return e.children.reduce((t, n) => t.concat(n.assembleProjections()), P4(e));
  }
  function P4(e) {
    const t = e.component.projection;
    if (!t || t.merged)
      return [];
    const n = t.combine(), { name: i } = n;
    if (t.data) {
      const r = {
        signal: `[${t.size.map((s) => s.signal).join(", ")}]`
      }, o = t.data.reduce((s, a) => {
        const u = ee(a) ? a.signal : `data('${e.lookupDataSource(a)}')`;
        return ye(s, u) || s.push(u), s;
      }, []);
      if (o.length <= 0)
        throw new Error("Projection's fit didn't find any data sources");
      return [
        {
          name: i,
          size: r,
          fit: {
            signal: o.length > 1 ? `[${o.join(", ")}]` : o[0]
          },
          ...n
        }
      ];
    } else
      return [
        {
          name: i,
          // translate to center by default
          translate: { signal: "[width / 2, height / 2]" },
          // parameters, overwrite default translate if specified
          ...n
        }
      ];
  }
  const ole = [
    "type",
    "clipAngle",
    "clipExtent",
    "center",
    "rotate",
    "precision",
    "reflectX",
    "reflectY",
    "coefficient",
    "distance",
    "fraction",
    "lobes",
    "parallel",
    "radius",
    "ratio",
    "spacing",
    "tilt"
  ];
  class I4 extends so {
    constructor(t, n, i, r) {
      super(
        { ...n },
        // all explicit properties of projection
        { name: t }
        // name as initial implicit property
      ), this.specifiedProjection = n, this.size = i, this.data = r, this.merged = !1;
    }
    /**
     * Whether the projection parameters should fit provided data.
     */
    get isFit() {
      return !!this.data;
    }
  }
  function z4(e) {
    e.component.projection = Ge(e) ? sle(e) : lle(e);
  }
  function sle(e) {
    if (e.hasProjection) {
      const t = _t(e.specifiedProjection), n = !(t && (t.scale != null || t.translate != null)), i = n ? [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")] : void 0, r = n ? ale(e) : void 0, o = new I4(e.projectionName(!0), {
        ..._t(e.config.projection),
        ...t
      }, i, r);
      return o.get("type") || o.set("type", "equalEarth", !1), o;
    }
  }
  function ale(e) {
    const t = [], { encoding: n } = e;
    for (const i of [
      [Oi, Ni],
      [ni, Ri]
    ])
      (st(n[i[0]]) || st(n[i[1]])) && t.push({
        signal: e.getName(`geojson_${t.length}`)
      });
    return e.channelHasField(En) && e.typedFieldDef(En).type === ul && t.push({
      signal: e.getName(`geojson_${t.length}`)
    }), t.length === 0 && t.push(e.requestDataName(Ke.Main)), t;
  }
  function ule(e, t) {
    const n = Aw(ole, (r) => !!(!J(e.explicit, r) && !J(t.explicit, r) || J(e.explicit, r) && J(t.explicit, r) && // some properties might be signals or objects and require hashing for comparison
    Dn(e.get(r), t.get(r))));
    if (Dn(e.size, t.size)) {
      if (n)
        return e;
      if (Dn(e.explicit, {}))
        return t;
      if (Dn(t.explicit, {}))
        return e;
    }
    return null;
  }
  function lle(e) {
    if (e.children.length === 0)
      return;
    let t;
    for (const i of e.children)
      z4(i);
    const n = Aw(e.children, (i) => {
      const r = i.component.projection;
      if (r)
        if (t) {
          const o = ule(t, r);
          return o && (t = o), !!o;
        } else
          return t = r, !0;
      else return !0;
    });
    if (t && n) {
      const i = e.projectionName(!0), r = new I4(i, t.specifiedProjection, t.size, ue(t.data));
      for (const o of e.children) {
        const s = o.component.projection;
        s && (s.isFit && r.data.push(...o.component.projection.data), o.renameProjection(s.get("name"), i), s.merged = !0);
      }
      return r;
    }
  }
  function cle(e, t, n, i) {
    if (qf(t, n)) {
      const r = Ge(e) ? e.axis(n) ?? e.legend(n) ?? {} : {}, o = V(t, { expr: "datum" }), s = V(t, { expr: "datum", binSuffix: "end" });
      return {
        formulaAs: V(t, { binSuffix: "range", forAs: !0 }),
        formula: zf(o, s, r.format, r.formatType, i)
      };
    }
    return {};
  }
  function B4(e, t) {
    return `${o5(e)}_${t}`;
  }
  function fle(e, t) {
    return {
      signal: e.getName(`${t}_bins`),
      extentSignal: e.getName(`${t}_extent`)
    };
  }
  function RE(e, t, n) {
    const i = wm(n, void 0) ?? {}, r = B4(i, t);
    return e.getName(`${r}_bins`);
  }
  function dle(e) {
    return "as" in e;
  }
  function zA(e, t, n) {
    let i, r;
    dle(e) ? i = K(e.as) ? [e.as, `${e.as}_end`] : [e.as[0], e.as[1]] : i = [V(e, { forAs: !0 }), V(e, { binSuffix: "end", forAs: !0 })];
    const o = { ...wm(t, void 0) }, s = B4(o, e.field), { signal: a, extentSignal: u } = fle(n, s);
    if (cm(o.extent)) {
      const c = o.extent;
      r = b4(n, c.param, c), delete o.extent;
    }
    const l = {
      bin: o,
      field: e.field,
      as: [i],
      ...a ? { signal: a } : {},
      ...u ? { extentSignal: u } : {},
      ...r ? { span: r } : {}
    };
    return { key: s, binComponent: l };
  }
  class tr extends De {
    clone() {
      return new tr(null, ue(this.bins));
    }
    constructor(t, n) {
      super(t), this.bins = n;
    }
    static makeFromEncoding(t, n) {
      const i = n.reduceFieldDef((r, o, s) => {
        if (un(o) && ze(o.bin)) {
          const { key: a, binComponent: u } = zA(o, o.bin, n);
          r[a] = {
            ...u,
            ...r[a],
            ...cle(n, o, s, n.config)
          };
        }
        return r;
      }, {});
      return Oe(i) ? null : new tr(t, i);
    }
    /**
     * Creates a bin node from BinTransform.
     * The optional parameter should provide
     */
    static makeFromTransform(t, n, i) {
      const { key: r, binComponent: o } = zA(n, n.bin, i);
      return new tr(t, {
        [r]: o
      });
    }
    /**
     * Merge bin nodes. This method either integrates the bin config from the other node
     * or if this node already has a bin config, renames the corresponding signal in the model.
     */
    merge(t, n) {
      for (const i of B(t.bins))
        i in this.bins ? (n(t.bins[i].signal, this.bins[i].signal), this.bins[i].as = Xi([...this.bins[i].as, ...t.bins[i].as], be)) : this.bins[i] = t.bins[i];
      for (const i of t.children)
        t.removeChild(i), i.parent = this;
      t.remove();
    }
    producedFields() {
      return new Set(Ft(this.bins).map((t) => t.as).flat(2));
    }
    dependentFields() {
      return new Set(Ft(this.bins).map((t) => t.field));
    }
    hash() {
      return `Bin ${be(this.bins)}`;
    }
    assemble() {
      return Ft(this.bins).flatMap((t) => {
        const n = [], [i, ...r] = t.as, { extent: o, ...s } = t.bin, a = {
          type: "bin",
          field: ti(t.field),
          as: i,
          signal: t.signal,
          ...cm(o) ? { extent: null } : { extent: o },
          ...t.span ? { span: { signal: `span(${t.span})` } } : {},
          ...s
        };
        !o && t.extentSignal && (n.push({
          type: "extent",
          field: ti(t.field),
          signal: t.extentSignal
        }), a.extent = { signal: t.extentSignal }), n.push(a);
        for (const u of r)
          for (let l = 0; l < 2; l++)
            n.push({
              type: "formula",
              expr: V({ field: i[l] }, { expr: "datum" }),
              as: u[l]
            });
        return t.formula && n.push({
          type: "formula",
          expr: t.formula,
          as: t.formulaAs
        }), n;
      });
    }
  }
  function hle(e, t, n, i) {
    var o;
    const r = Ge(i) ? i.encoding[wr(t)] : void 0;
    if (un(n) && Ge(i) && Z5(n, r, i.markDef, i.config)) {
      e.add(V(n, {})), e.add(V(n, { suffix: "end" }));
      const { mark: s, markDef: a, config: u } = i, l = Go({ fieldDef: n, markDef: a, config: u });
      Kc(s) && l !== 0.5 && et(t) && (e.add(V(n, { suffix: Cm })), e.add(V(n, { suffix: Fm }))), n.bin && qf(n, t) && e.add(V(n, { binSuffix: "range" }));
    } else if (KR(t)) {
      const s = XR(t);
      e.add(i.getName(s));
    } else
      e.add(V(n));
    return ka(n) && noe((o = n.scale) == null ? void 0 : o.range) && e.add(n.scale.range.field), e;
  }
  function gle(e, t) {
    for (const n of B(t)) {
      const i = t[n];
      for (const r of B(i))
        n in e ? e[n][r] = /* @__PURE__ */ new Set([...e[n][r] ?? [], ...i[r]]) : e[n] = { [r]: i[r] };
    }
  }
  class xi extends De {
    clone() {
      return new xi(null, new Set(this.dimensions), ue(this.measures));
    }
    /**
     * @param dimensions string set for dimensions
     * @param measures dictionary mapping field name => dict of aggregation functions and names to use
     */
    constructor(t, n, i) {
      super(t), this.dimensions = n, this.measures = i;
    }
    get groupBy() {
      return this.dimensions;
    }
    static makeFromEncoding(t, n) {
      let i = !1;
      n.forEachFieldDef((s) => {
        s.aggregate && (i = !0);
      });
      const r = {}, o = /* @__PURE__ */ new Set();
      return !i || (n.forEachFieldDef((s, a) => {
        const { aggregate: u, field: l } = s;
        if (u)
          if (u === "count")
            r["*"] ?? (r["*"] = {}), r["*"].count = /* @__PURE__ */ new Set([V(s, { forAs: !0 })]);
          else {
            if (Kr(u) || us(u)) {
              const c = Kr(u) ? "argmin" : "argmax", f = u[c];
              r[f] ?? (r[f] = {}), r[f][c] = /* @__PURE__ */ new Set([V({ op: c, field: f }, { forAs: !0 })]);
            } else
              r[l] ?? (r[l] = {}), r[l][u] = /* @__PURE__ */ new Set([V(s, { forAs: !0 })]);
            Er(a) && n.scaleDomain(a) === "unaggregated" && (r[l] ?? (r[l] = {}), r[l].min = /* @__PURE__ */ new Set([V({ field: l, aggregate: "min" }, { forAs: !0 })]), r[l].max = /* @__PURE__ */ new Set([V({ field: l, aggregate: "max" }, { forAs: !0 })]));
          }
        else
          hle(o, a, s, n);
      }), o.size + B(r).length === 0) ? null : new xi(t, o, r);
    }
    static makeFromTransform(t, n) {
      var i;
      const r = /* @__PURE__ */ new Set(), o = {};
      for (const s of n.aggregate) {
        const { op: a, field: u, as: l } = s;
        a && (a === "count" ? (o["*"] ?? (o["*"] = {}), o["*"].count = /* @__PURE__ */ new Set([l || V(s, { forAs: !0 })])) : (o[u] ?? (o[u] = {}), (i = o[u])[a] ?? (i[a] = /* @__PURE__ */ new Set()), o[u][a].add(l || V(s, { forAs: !0 }))));
      }
      for (const s of n.groupby ?? [])
        r.add(s);
      return r.size + B(o).length === 0 ? null : new xi(t, r, o);
    }
    merge(t) {
      return UR(this.dimensions, t.dimensions) ? (gle(this.measures, t.measures), !0) : (Are("different dimensions, cannot merge"), !1);
    }
    addDimensions(t) {
      t.forEach(this.dimensions.add, this.dimensions);
    }
    dependentFields() {
      return /* @__PURE__ */ new Set([...this.dimensions, ...B(this.measures)]);
    }
    producedFields() {
      const t = /* @__PURE__ */ new Set();
      for (const n of B(this.measures))
        for (const i of B(this.measures[n])) {
          const r = this.measures[n][i];
          r.size === 0 ? t.add(`${i}_${n}`) : r.forEach(t.add, t);
        }
      return t;
    }
    hash() {
      return `Aggregate ${be({ dimensions: this.dimensions, measures: this.measures })}`;
    }
    assemble() {
      const t = [], n = [], i = [];
      for (const o of B(this.measures))
        for (const s of B(this.measures[o]))
          for (const a of this.measures[o][s])
            i.push(a), t.push(s), n.push(o === "*" ? null : ti(o));
      return {
        type: "aggregate",
        groupby: [...this.dimensions].map(ti),
        ops: t,
        fields: n,
        as: i
      };
    }
  }
  class fl extends De {
    /**
     * @param model The facet model.
     * @param name The name that this facet source will have.
     * @param data The source data for this facet data.
     */
    constructor(t, n, i, r) {
      super(t), this.model = n, this.name = i, this.data = r;
      for (const o of Vn) {
        const s = n.facet[o];
        if (s) {
          const { bin: a, sort: u } = s;
          this[o] = {
            name: n.getName(`${o}_domain`),
            fields: [V(s), ...ze(a) ? [V(s, { binSuffix: "end" })] : []],
            ...Wr(u) ? { sortField: u } : P(u) ? { sortIndexField: Bu(s, o) } : {}
          };
        }
      }
      this.childModel = n.child;
    }
    hash() {
      let t = "Facet";
      for (const n of Vn)
        this[n] && (t += ` ${n.charAt(0)}:${be(this[n])}`);
      return t;
    }
    get fields() {
      var n;
      const t = [];
      for (const i of Vn)
        (n = this[i]) != null && n.fields && t.push(...this[i].fields);
      return t;
    }
    dependentFields() {
      const t = new Set(this.fields);
      for (const n of Vn)
        this[n] && (this[n].sortField && t.add(this[n].sortField.field), this[n].sortIndexField && t.add(this[n].sortIndexField));
      return t;
    }
    producedFields() {
      return /* @__PURE__ */ new Set();
    }
    /**
     * The name to reference this source is its name.
     */
    getSource() {
      return this.name;
    }
    getChildIndependentFieldsWithStep() {
      const t = {};
      for (const n of ro) {
        const i = this.childModel.component.scales[n];
        if (i && !i.merged) {
          const r = i.get("type"), o = i.get("range");
          if (bt(r) && _a(o)) {
            const s = Om(this.childModel, n), a = zE(s);
            a ? t[n] = a : j(Uw(n));
          }
        }
      }
      return t;
    }
    assembleRowColumnHeaderData(t, n, i) {
      const r = { row: "y", column: "x", facet: void 0 }[t], o = [], s = [], a = [];
      r && i && i[r] && (n ? (o.push(`distinct_${i[r]}`), s.push("max")) : (o.push(i[r]), s.push("distinct")), a.push(`distinct_${i[r]}`));
      const { sortField: u, sortIndexField: l } = this[t];
      if (u) {
        const { op: c = bm, field: f } = u;
        o.push(f), s.push(c), a.push(V(u, { forAs: !0 }));
      } else l && (o.push(l), s.push("max"), a.push(l));
      return {
        name: this[t].name,
        // Use data from the crossed one if it exist
        source: n ?? this.data,
        transform: [
          {
            type: "aggregate",
            groupby: this[t].fields,
            ...o.length ? {
              fields: o,
              ops: s,
              as: a
            } : {}
          }
        ]
      };
    }
    assembleFacetHeaderData(t) {
      var u;
      const { columns: n } = this.model.layout, { layoutHeaders: i } = this.model.component, r = [], o = {};
      for (const l of TE) {
        for (const c of DE) {
          const f = (i[l] && i[l][c]) ?? [];
          for (const d of f)
            if (((u = d.axes) == null ? void 0 : u.length) > 0) {
              o[l] = !0;
              break;
            }
        }
        if (o[l]) {
          const c = `length(data("${this.facet.name}"))`, f = l === "row" ? n ? { signal: `ceil(${c} / ${n})` } : 1 : n ? { signal: `min(${c}, ${n})` } : { signal: c };
          r.push({
            name: `${this.facet.name}_${l}`,
            transform: [
              {
                type: "sequence",
                start: 0,
                stop: f
              }
            ]
          });
        }
      }
      const { row: s, column: a } = o;
      return (s || a) && r.unshift(this.assembleRowColumnHeaderData("facet", null, t)), r;
    }
    assemble() {
      const t = [];
      let n = null;
      const i = this.getChildIndependentFieldsWithStep(), { column: r, row: o, facet: s } = this;
      if (r && o && (i.x || i.y)) {
        n = `cross_${this.column.name}_${this.row.name}`;
        const a = [].concat(i.x ?? [], i.y ?? []), u = a.map(() => "distinct");
        t.push({
          name: n,
          source: this.data,
          transform: [
            {
              type: "aggregate",
              groupby: this.fields,
              fields: a,
              ops: u
            }
          ]
        });
      }
      for (const a of [qr, jr])
        this[a] && t.push(this.assembleRowColumnHeaderData(a, n, i));
      if (s) {
        const a = this.assembleFacetHeaderData(i);
        a && t.push(...a);
      }
      return t;
    }
  }
  function BA(e) {
    return e.startsWith("'") && e.endsWith("'") || e.startsWith('"') && e.endsWith('"') ? e.slice(1, -1) : e;
  }
  function ple(e, t) {
    const n = Mw(e);
    if (t === "number")
      return `toNumber(${n})`;
    if (t === "boolean")
      return `toBoolean(${n})`;
    if (t === "string")
      return `toString(${n})`;
    if (t === "date")
      return `toDate(${n})`;
    if (t === "flatten")
      return n;
    if (t.startsWith("date:")) {
      const i = BA(t.slice(5, t.length));
      return `timeParse(${n},'${i}')`;
    } else if (t.startsWith("utc:")) {
      const i = BA(t.slice(4, t.length));
      return `utcParse(${n},'${i}')`;
    } else
      return j(Lie(t)), null;
  }
  function mle(e) {
    const t = {};
    return ah(e.filter, (n) => {
      if (M5(n)) {
        let i = null;
        Hw(n) ? i = Fn(n.equal) : Vw(n) ? i = Fn(n.lte) : Gw(n) ? i = Fn(n.lt) : Yw(n) ? i = Fn(n.gt) : Xw(n) ? i = Fn(n.gte) : Kw(n) ? i = n.range[0] : Jw(n) && (i = (n.oneOf ?? n.in)[0]), i && (Sa(i) ? t[n.field] = "date" : $e(i) ? t[n.field] = "number" : K(i) && (t[n.field] = "string")), n.timeUnit && (t[n.field] = "date");
      }
    }), t;
  }
  function yle(e) {
    const t = {};
    function n(i) {
      Lu(i) ? t[i.field] = "date" : i.type === "quantitative" && hie(i.aggregate) ? t[i.field] = "number" : Fu(i.field) > 1 ? i.field in t || (t[i.field] = "flatten") : ka(i) && Wr(i.sort) && Fu(i.sort.field) > 1 && (i.sort.field in t || (t[i.sort.field] = "flatten"));
    }
    if ((Ge(e) || Rn(e)) && e.forEachFieldDef((i, r) => {
      if (un(i))
        n(i);
      else {
        const o = wa(r), s = e.fieldDef(o);
        n({
          ...i,
          type: s.type
        });
      }
    }), Ge(e)) {
      const { mark: i, markDef: r, encoding: o } = e;
      if (ls(i) && // No need to sort by dimension if we have a connected scatterplot (order channel is present)
      !e.encoding.order) {
        const s = r.orient === "horizontal" ? "y" : "x", a = o[s];
        q(a) && a.type === "quantitative" && !(a.field in t) && (t[a.field] = "number");
      }
    }
    return t;
  }
  function ble(e) {
    const t = {};
    if (Ge(e) && e.component.selection)
      for (const n of B(e.component.selection)) {
        const i = e.component.selection[n];
        for (const r of i.project.items)
          !r.channel && Fu(r.field) > 1 && (t[r.field] = "flatten");
      }
    return t;
  }
  class Bt extends De {
    clone() {
      return new Bt(null, ue(this._parse));
    }
    constructor(t, n) {
      super(t), this._parse = n;
    }
    hash() {
      return `Parse ${be(this._parse)}`;
    }
    /**
     * Creates a parse node from a data.format.parse and updates ancestorParse.
     */
    static makeExplicit(t, n, i) {
      var s;
      let r = {};
      const o = n.data;
      return !No(o) && ((s = o == null ? void 0 : o.format) != null && s.parse) && (r = o.format.parse), this.makeWithAncestors(t, r, {}, i);
    }
    /**
     * Creates a parse node from "explicit" parse and "implicit" parse and updates ancestorParse.
     */
    static makeWithAncestors(t, n, i, r) {
      for (const a of B(i)) {
        const u = r.getWithExplicit(a);
        u.value !== void 0 && (u.explicit || u.value === i[a] || u.value === "derived" || i[a] === "flatten" ? delete i[a] : j(Xk(a, i[a], u.value)));
      }
      for (const a of B(n)) {
        const u = r.get(a);
        u !== void 0 && (u === n[a] ? delete n[a] : j(Xk(a, n[a], u)));
      }
      const o = new so(n, i);
      r.copyAll(o);
      const s = {};
      for (const a of B(o.combine())) {
        const u = o.get(a);
        u !== null && (s[a] = u);
      }
      return B(s).length === 0 || r.parseNothing ? null : new Bt(t, s);
    }
    get parse() {
      return this._parse;
    }
    merge(t) {
      this._parse = { ...this._parse, ...t.parse }, t.remove();
    }
    /**
     * Assemble an object for Vega's format.parse property.
     */
    assembleFormatParse() {
      const t = {};
      for (const n of B(this._parse)) {
        const i = this._parse[n];
        Fu(n) === 1 && (t[n] = i);
      }
      return t;
    }
    // format parse depends and produces all fields in its parse
    producedFields() {
      return new Set(B(this._parse));
    }
    dependentFields() {
      return new Set(B(this._parse));
    }
    assembleTransforms(t = !1) {
      return B(this._parse).filter((n) => t ? Fu(n) > 1 : !0).map((n) => {
        const i = ple(n, this._parse[n]);
        return i ? {
          type: "formula",
          expr: i,
          as: sl(n)
          // Vega output is always flattened
        } : null;
      }).filter((n) => n !== null);
    }
  }
  class Xo extends De {
    clone() {
      return new Xo(null);
    }
    constructor(t) {
      super(t);
    }
    dependentFields() {
      return /* @__PURE__ */ new Set();
    }
    producedFields() {
      return /* @__PURE__ */ new Set([Ai]);
    }
    hash() {
      return "Identifier";
    }
    assemble() {
      return { type: "identifier", as: Ai };
    }
  }
  class Gf extends De {
    clone() {
      return new Gf(null, this.params);
    }
    constructor(t, n) {
      super(t), this.params = n;
    }
    dependentFields() {
      return /* @__PURE__ */ new Set();
    }
    producedFields() {
    }
    hash() {
      return `Graticule ${be(this.params)}`;
    }
    assemble() {
      return {
        type: "graticule",
        ...this.params === !0 ? {} : this.params
      };
    }
  }
  class Vf extends De {
    clone() {
      return new Vf(null, this.params);
    }
    constructor(t, n) {
      super(t), this.params = n;
    }
    dependentFields() {
      return /* @__PURE__ */ new Set();
    }
    producedFields() {
      return /* @__PURE__ */ new Set([this.params.as ?? "data"]);
    }
    hash() {
      return `Hash ${be(this.params)}`;
    }
    assemble() {
      return {
        type: "sequence",
        ...this.params
      };
    }
  }
  class ca extends De {
    constructor(t) {
      super(null), t ?? (t = { name: "source" });
      let n;
      if (No(t) || (n = t.format ? { ...mn(t.format, ["parse"]) } : {}), Jc(t))
        this._data = { values: t.values };
      else if (Pu(t)) {
        if (this._data = { url: t.url }, !n.type) {
          let i = /(?:\.([^.]+))?$/.exec(t.url)[1];
          ye(["json", "csv", "tsv", "dsv", "topojson"], i) || (i = "json"), n.type = i;
        }
      } else V6(t) ? this._data = { values: [{ type: "Sphere" }] } : (H6(t) || No(t)) && (this._data = {});
      this._generator = No(t), t.name && (this._name = t.name), n && !Oe(n) && (this._data.format = n);
    }
    dependentFields() {
      return /* @__PURE__ */ new Set();
    }
    producedFields() {
    }
    get data() {
      return this._data;
    }
    hasName() {
      return !!this._name;
    }
    get isGenerator() {
      return this._generator;
    }
    get dataName() {
      return this._name;
    }
    set dataName(t) {
      this._name = t;
    }
    set parent(t) {
      throw new Error("Source nodes have to be roots.");
    }
    remove() {
      throw new Error("Source nodes are roots and cannot be removed.");
    }
    hash() {
      throw new Error("Cannot hash sources");
    }
    assemble() {
      return {
        name: this._name,
        ...this._data,
        transform: []
      };
    }
  }
  var UA = function(e, t, n, i, r) {
    if (i === "m") throw new TypeError("Private method is not writable");
    if (i === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
    if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return i === "a" ? r.call(e, n) : r ? r.value = n : t.set(e, n), n;
  }, vle = function(e, t, n, i) {
    if (n === "a" && !i) throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return n === "m" ? i : n === "a" ? i.call(e) : i ? i.value : t.get(e);
  }, uc;
  function LE(e) {
    return e instanceof ca || e instanceof Gf || e instanceof Vf;
  }
  class PE {
    constructor() {
      uc.set(this, void 0), UA(this, uc, !1, "f");
    }
    // Once true, #modified is never set to false
    setModified() {
      UA(this, uc, !0, "f");
    }
    get modifiedFlag() {
      return vle(this, uc, "f");
    }
  }
  uc = /* @__PURE__ */ new WeakMap();
  class Aa extends PE {
    /**
     * Compute a map of node depths that we can use to determine a topological sort order.
     */
    getNodeDepths(t, n, i) {
      i.set(t, n);
      for (const r of t.children)
        this.getNodeDepths(r, n + 1, i);
      return i;
    }
    /**
     * Run the optimizer on all nodes starting from the leaves.
     */
    optimize(t) {
      const i = [...this.getNodeDepths(t, 0, /* @__PURE__ */ new Map()).entries()].sort((r, o) => o[1] - r[1]);
      for (const r of i)
        this.run(r[0]);
      return this.modifiedFlag;
    }
  }
  class IE extends PE {
    /**
     * Run the optimizer depth first on all nodes starting from the roots.
     */
    optimize(t) {
      this.run(t);
      for (const n of t.children)
        this.optimize(n);
      return this.modifiedFlag;
    }
  }
  class xle extends IE {
    mergeNodes(t, n) {
      const i = n.shift();
      for (const r of n)
        t.removeChild(r), r.parent = i, r.remove();
    }
    run(t) {
      const n = t.children.map((r) => r.hash()), i = {};
      for (let r = 0; r < n.length; r++)
        i[n[r]] === void 0 ? i[n[r]] = [t.children[r]] : i[n[r]].push(t.children[r]);
      for (const r of B(i))
        i[r].length > 1 && (this.setModified(), this.mergeNodes(t, i[r]));
    }
  }
  class wle extends IE {
    constructor(t) {
      super(), this.requiresSelectionId = t && ME(t);
    }
    run(t) {
      t instanceof Xo && (this.requiresSelectionId && (LE(t.parent) || t.parent instanceof xi || t.parent instanceof Bt) || (this.setModified(), t.remove()));
    }
  }
  class Ele extends PE {
    optimize(t) {
      return this.run(t, /* @__PURE__ */ new Set()), this.modifiedFlag;
    }
    run(t, n) {
      let i = /* @__PURE__ */ new Set();
      t instanceof er && (i = t.producedFields(), Cw(i, n) && (this.setModified(), t.removeFormulas(n), t.producedFields.length === 0 && t.remove()));
      for (const r of t.children)
        this.run(r, /* @__PURE__ */ new Set([...n, ...i]));
    }
  }
  class _le extends IE {
    constructor() {
      super();
    }
    run(t) {
      t instanceof yn && !t.isRequired() && (this.setModified(), t.remove());
    }
  }
  class Sle extends Aa {
    run(t) {
      if (!LE(t) && !(t.numChildren() > 1)) {
        for (const n of t.children)
          if (n instanceof Bt)
            if (t instanceof Bt)
              this.setModified(), t.merge(n);
            else {
              if (Fw(t.producedFields(), n.dependentFields()))
                continue;
              this.setModified(), n.swapWithParent();
            }
      }
    }
  }
  class $le extends Aa {
    run(t) {
      const n = [...t.children], i = t.children.filter((r) => r instanceof Bt);
      if (t.numChildren() > 1 && i.length >= 1) {
        const r = {}, o = /* @__PURE__ */ new Set();
        for (const s of i) {
          const a = s.parse;
          for (const u of B(a))
            u in r ? r[u] !== a[u] && o.add(u) : r[u] = a[u];
        }
        for (const s of o)
          delete r[s];
        if (!Oe(r)) {
          this.setModified();
          const s = new Bt(t, r);
          for (const a of n) {
            if (a instanceof Bt)
              for (const u of B(r))
                delete a.parse[u];
            t.removeChild(a), a.parent = s, a instanceof Bt && B(a.parse).length === 0 && a.remove();
          }
        }
      }
    }
  }
  class kle extends Aa {
    run(t) {
      t instanceof yn || t.numChildren() > 0 || t instanceof fl || t instanceof ca || (this.setModified(), t.remove());
    }
  }
  class Ale extends Aa {
    run(t) {
      const n = t.children.filter((r) => r instanceof er), i = n.pop();
      for (const r of n)
        this.setModified(), i.merge(r);
    }
  }
  class Cle extends Aa {
    run(t) {
      const n = t.children.filter((r) => r instanceof xi), i = {};
      for (const r of n) {
        const o = be(r.groupBy);
        o in i || (i[o] = []), i[o].push(r);
      }
      for (const r of B(i)) {
        const o = i[r];
        if (o.length > 1) {
          const s = o.pop();
          for (const a of o)
            s.merge(a) && (t.removeChild(a), a.parent = s, a.remove(), this.setModified());
        }
      }
    }
  }
  class Fle extends Aa {
    constructor(t) {
      super(), this.model = t;
    }
    run(t) {
      const n = !(LE(t) || t instanceof cl || t instanceof Bt || t instanceof Xo), i = [], r = [];
      for (const o of t.children)
        o instanceof tr && (n && !Fw(t.producedFields(), o.dependentFields()) ? i.push(o) : r.push(o));
      if (i.length > 0) {
        const o = i.pop();
        for (const s of i)
          o.merge(s, this.model.renameSignal.bind(this.model));
        this.setModified(), t instanceof tr ? t.merge(o, this.model.renameSignal.bind(this.model)) : o.swapWithParent();
      }
      if (r.length > 1) {
        const o = r.pop();
        for (const s of r)
          o.merge(s, this.model.renameSignal.bind(this.model));
        this.setModified();
      }
    }
  }
  class Mle extends Aa {
    run(t) {
      const n = [...t.children];
      if (!Cu(n, (s) => s instanceof yn) || t.numChildren() <= 1)
        return;
      const r = [];
      let o;
      for (const s of n)
        if (s instanceof yn) {
          let a = s;
          for (; a.numChildren() === 1; ) {
            const [u] = a.children;
            if (u instanceof yn)
              a = u;
            else
              break;
          }
          r.push(...a.children), o ? (t.removeChild(s), s.parent = o.parent, o.parent.removeChild(o), o.parent = a, this.setModified()) : o = a;
        } else
          r.push(s);
      if (r.length) {
        this.setModified();
        for (const s of r)
          s.parent.removeChild(s), s.parent = o;
      }
    }
  }
  class Ca extends De {
    clone() {
      return new Ca(null, ue(this.transform));
    }
    constructor(t, n) {
      super(t), this.transform = n;
    }
    addDimensions(t) {
      this.transform.groupby = Xi(this.transform.groupby.concat(t), (n) => n);
    }
    dependentFields() {
      const t = /* @__PURE__ */ new Set();
      return this.transform.groupby && this.transform.groupby.forEach(t.add, t), this.transform.joinaggregate.map((n) => n.field).filter((n) => n !== void 0).forEach(t.add, t), t;
    }
    producedFields() {
      return new Set(this.transform.joinaggregate.map(this.getDefaultName));
    }
    getDefaultName(t) {
      return t.as ?? V(t);
    }
    hash() {
      return `JoinAggregateTransform ${be(this.transform)}`;
    }
    assemble() {
      const t = [], n = [], i = [];
      for (const o of this.transform.joinaggregate)
        n.push(o.op), i.push(this.getDefaultName(o)), t.push(o.field === void 0 ? null : o.field);
      const r = this.transform.groupby;
      return {
        type: "joinaggregate",
        as: i,
        ops: n,
        fields: t,
        ...r !== void 0 ? { groupby: r } : {}
      };
    }
  }
  class ju extends De {
    clone() {
      return new ju(null, { ...this.filter });
    }
    constructor(t, n) {
      super(t), this.filter = n;
    }
    static make(t, n, i) {
      const { config: r, markDef: o } = n, { marks: s, scales: a } = i;
      if (s === "include-invalid-values" && a === "include-invalid-values")
        return null;
      const u = n.reduceFieldDef((l, c, f) => {
        const d = Er(f) && n.getScaleComponent(f);
        if (d) {
          const h = d.get("type"), { aggregate: g } = c, p = rE({
            scaleChannel: f,
            markDef: o,
            config: r,
            scaleType: h,
            isCountAggregate: lm(g)
          });
          p !== "show" && p !== "always-valid" && (l[c.field] = c);
        }
        return l;
      }, {});
      return B(u).length ? new ju(t, u) : null;
    }
    dependentFields() {
      return new Set(B(this.filter));
    }
    producedFields() {
      return /* @__PURE__ */ new Set();
    }
    hash() {
      return `FilterInvalid ${be(this.filter)}`;
    }
    /**
     * Create the VgTransforms for each of the filtered fields.
     */
    assemble() {
      const t = B(this.filter).reduce((n, i) => {
        const r = this.filter[i], o = V(r, { expr: "datum" });
        return r !== null && (r.type === "temporal" ? n.push(`(isDate(${o}) || (${$b(o)}))`) : r.type === "quantitative" && n.push($b(o))), n;
      }, []);
      return t.length > 0 ? {
        type: "filter",
        expr: t.join(" && ")
      } : null;
    }
  }
  function $b(e) {
    return `isValid(${e}) && isFinite(+${e})`;
  }
  function Tle(e) {
    return e.stack.stackBy.reduce((t, n) => {
      const i = n.fieldDef, r = V(i);
      return r && t.push(r), t;
    }, []);
  }
  function Dle(e) {
    return P(e) && e.every((t) => K(t)) && e.length > 1;
  }
  class Gr extends De {
    clone() {
      return new Gr(null, ue(this._stack));
    }
    constructor(t, n) {
      super(t), this._stack = n;
    }
    static makeFromTransform(t, n) {
      const { stack: i, groupby: r, as: o, offset: s = "zero" } = n, a = [], u = [];
      if (n.sort !== void 0)
        for (const f of n.sort)
          a.push(f.field), u.push(Ze(f.order, "ascending"));
      const l = {
        field: a,
        order: u
      };
      let c;
      return Dle(o) ? c = o : K(o) ? c = [o, `${o}_end`] : c = [`${n.stack}_start`, `${n.stack}_end`], new Gr(t, {
        dimensionFieldDefs: [],
        stackField: i,
        groupby: r,
        offset: s,
        sort: l,
        facetby: [],
        as: c
      });
    }
    static makeFromEncoding(t, n) {
      const i = n.stack, { encoding: r } = n;
      if (!i)
        return null;
      const { groupbyChannels: o, fieldChannel: s, offset: a, impute: u } = i, l = o.map((h) => {
        const g = r[h];
        return ki(g);
      }).filter((h) => !!h), c = Tle(n), f = n.encoding.order;
      let d;
      if (P(f) || q(f))
        d = c5(f);
      else {
        const h = e6(f) ? f.sort : s === "y" ? "descending" : "ascending";
        d = c.reduce((g, p) => (g.field.includes(p) || (g.field.push(p), g.order.push(h)), g), { field: [], order: [] });
      }
      return new Gr(t, {
        dimensionFieldDefs: l,
        stackField: n.vgField(s),
        facetby: [],
        stackby: c,
        sort: d,
        offset: a,
        impute: u,
        as: [
          n.vgField(s, { suffix: "start", forAs: !0 }),
          n.vgField(s, { suffix: "end", forAs: !0 })
        ]
      });
    }
    get stack() {
      return this._stack;
    }
    addDimensions(t) {
      this._stack.facetby.push(...t);
    }
    dependentFields() {
      const t = /* @__PURE__ */ new Set();
      return t.add(this._stack.stackField), this.getGroupbyFields().forEach(t.add, t), this._stack.facetby.forEach(t.add, t), this._stack.sort.field.forEach(t.add, t), t;
    }
    producedFields() {
      return new Set(this._stack.as);
    }
    hash() {
      return `Stack ${be(this._stack)}`;
    }
    getGroupbyFields() {
      const { dimensionFieldDefs: t, impute: n, groupby: i } = this._stack;
      return t.length > 0 ? t.map((r) => r.bin ? n ? [V(r, { binSuffix: "mid" })] : [
        // For binned group by field without impute, we need both bin (start) and bin_end
        V(r, {}),
        V(r, { binSuffix: "end" })
      ] : [V(r)]).flat() : i ?? [];
    }
    assemble() {
      const t = [], { facetby: n, dimensionFieldDefs: i, stackField: r, stackby: o, sort: s, offset: a, impute: u, as: l } = this._stack;
      if (u)
        for (const c of i) {
          const { bandPosition: f = 0.5, bin: d } = c;
          if (d) {
            const h = V(c, { expr: "datum" }), g = V(c, { expr: "datum", binSuffix: "end" });
            t.push({
              type: "formula",
              expr: `${$b(h)} ? ${f}*${h}+${1 - f}*${g} : ${h}`,
              as: V(c, { binSuffix: "mid", forAs: !0 })
            });
          }
          t.push({
            type: "impute",
            field: r,
            groupby: [...o, ...n],
            key: V(c, { binSuffix: "mid" }),
            method: "value",
            value: 0
          });
        }
      return t.push({
        type: "stack",
        groupby: [...this.getGroupbyFields(), ...n],
        field: r,
        sort: s,
        as: l,
        offset: a
      }), t;
    }
  }
  class dl extends De {
    clone() {
      return new dl(null, ue(this.transform));
    }
    constructor(t, n) {
      super(t), this.transform = n;
    }
    addDimensions(t) {
      this.transform.groupby = Xi(this.transform.groupby.concat(t), (n) => n);
    }
    dependentFields() {
      const t = /* @__PURE__ */ new Set();
      return (this.transform.groupby ?? []).forEach(t.add, t), (this.transform.sort ?? []).forEach((n) => t.add(n.field)), this.transform.window.map((n) => n.field).filter((n) => n !== void 0).forEach(t.add, t), t;
    }
    producedFields() {
      return new Set(this.transform.window.map(this.getDefaultName));
    }
    getDefaultName(t) {
      return t.as ?? V(t);
    }
    hash() {
      return `WindowTransform ${be(this.transform)}`;
    }
    assemble() {
      const t = [], n = [], i = [], r = [];
      for (const f of this.transform.window)
        n.push(f.op), i.push(this.getDefaultName(f)), r.push(f.param === void 0 ? null : f.param), t.push(f.field === void 0 ? null : f.field);
      const o = this.transform.frame, s = this.transform.groupby;
      if (o && o[0] === null && o[1] === null && n.every((f) => zw(f)))
        return {
          type: "joinaggregate",
          as: i,
          ops: n,
          fields: t,
          ...s !== void 0 ? { groupby: s } : {}
        };
      const a = [], u = [];
      if (this.transform.sort !== void 0)
        for (const f of this.transform.sort)
          a.push(f.field), u.push(f.order ?? "ascending");
      const l = {
        field: a,
        order: u
      }, c = this.transform.ignorePeers;
      return {
        type: "window",
        params: r,
        as: i,
        ops: n,
        fields: t,
        sort: l,
        ...c !== void 0 ? { ignorePeers: c } : {},
        ...s !== void 0 ? { groupby: s } : {},
        ...o !== void 0 ? { frame: o } : {}
      };
    }
  }
  function Nle(e) {
    function t(n) {
      if (!(n instanceof fl)) {
        const i = n.clone();
        if (i instanceof yn) {
          const r = Ab + i.getSource();
          i.setSource(r), e.model.component.data.outputNodes[r] = i;
        } else (i instanceof xi || i instanceof Gr || i instanceof dl || i instanceof Ca) && i.addDimensions(e.fields);
        for (const r of n.children.flatMap(t))
          r.parent = i;
        return [i];
      }
      return n.children.flatMap(t);
    }
    return t;
  }
  function kb(e) {
    if (e instanceof fl)
      if (e.numChildren() === 1 && !(e.children[0] instanceof yn)) {
        const t = e.children[0];
        (t instanceof xi || t instanceof Gr || t instanceof dl || t instanceof Ca) && t.addDimensions(e.fields), t.swapWithParent(), kb(e);
      } else {
        const t = e.model.component.data.main;
        U4(t);
        const n = Nle(e), i = e.children.map(n).flat();
        for (const r of i)
          r.parent = t;
      }
    else
      e.children.map(kb);
  }
  function U4(e) {
    if (e instanceof yn && e.type === Ke.Main && e.numChildren() === 1) {
      const t = e.children[0];
      t instanceof fl || (t.swapWithParent(), U4(e));
    }
  }
  const Ab = "scale_", Ad = 5;
  function Cb(e) {
    for (const t of e) {
      for (const n of t.children)
        if (n.parent !== t)
          return !1;
      if (!Cb(t.children))
        return !1;
    }
    return !0;
  }
  function si(e, t) {
    let n = !1;
    for (const i of t)
      n = e.optimize(i) || n;
    return n;
  }
  function jA(e, t, n) {
    let i = e.sources, r = !1;
    return r = si(new _le(), i) || r, r = si(new wle(t), i) || r, i = i.filter((o) => o.numChildren() > 0), r = si(new kle(), i) || r, i = i.filter((o) => o.numChildren() > 0), n || (r = si(new Sle(), i) || r, r = si(new Fle(t), i) || r, r = si(new Ele(), i) || r, r = si(new $le(), i) || r, r = si(new Cle(), i) || r, r = si(new Ale(), i) || r, r = si(new xle(), i) || r, r = si(new Mle(), i) || r), e.sources = i, r;
  }
  function Ole(e, t) {
    Cb(e.sources);
    let n = 0, i = 0;
    for (let r = 0; r < Ad && jA(e, t, !0); r++)
      n++;
    e.sources.map(kb);
    for (let r = 0; r < Ad && jA(e, t, !1); r++)
      i++;
    Cb(e.sources), Math.max(n, i) === Ad && j(`Maximum optimization runs(${Ad}) reached.`);
  }
  class ft {
    constructor(t) {
      Object.defineProperty(this, "signal", {
        enumerable: !0,
        get: t
      });
    }
    static fromName(t, n) {
      return new ft(() => t(n));
    }
  }
  function j4(e) {
    Ge(e) ? Rle(e) : Lle(e);
  }
  function Rle(e) {
    const t = e.component.scales;
    for (const n of B(t)) {
      const i = Ile(e, n);
      if (t[n].setWithExplicit("domains", i), Ble(e, n), e.component.data.isFaceted) {
        let o = e;
        for (; !Rn(o) && o.parent; )
          o = o.parent;
        if (o.component.resolve.scale[n] === "shared")
          for (const a of i.value)
            Ir(a) && (a.data = Ab + a.data.replace(Ab, ""));
      }
    }
  }
  function Lle(e) {
    for (const n of e.children)
      j4(n);
    const t = e.component.scales;
    for (const n of B(t)) {
      let i, r = null;
      for (const o of e.children) {
        const s = o.component.scales[n];
        if (s) {
          i === void 0 ? i = s.getWithExplicit("domains") : i = Vo(i, s.getWithExplicit("domains"), "domains", "scale", Fb);
          const a = s.get("selectionExtent");
          r && a && r.param !== a.param && j(Die), r = a;
        }
      }
      t[n].setWithExplicit("domains", i), r && t[n].set("selectionExtent", r, !0);
    }
  }
  function Ple(e, t, n, i) {
    if (e === "unaggregated") {
      const { valid: r, reason: o } = qA(t, n);
      if (!r) {
        j(o);
        return;
      }
    } else if (e === void 0 && i.useUnaggregatedDomain) {
      const { valid: r } = qA(t, n);
      if (r)
        return "unaggregated";
    }
    return e;
  }
  function Ile(e, t) {
    const n = e.getScaleComponent(t).get("type"), { encoding: i } = e, r = Ple(e.scaleDomain(t), e.typedFieldDef(t), n, e.config.scale);
    return r !== e.scaleDomain(t) && (e.specifiedScales[t] = {
      ...e.specifiedScales[t],
      domain: r
    }), t === "x" && st(i.x2) ? st(i.x) ? Vo(fo(n, r, e, "x"), fo(n, r, e, "x2"), "domain", "scale", Fb) : fo(n, r, e, "x2") : t === "y" && st(i.y2) ? st(i.y) ? Vo(fo(n, r, e, "y"), fo(n, r, e, "y2"), "domain", "scale", Fb) : fo(n, r, e, "y2") : fo(n, r, e, t);
  }
  function zle(e, t, n) {
    return e.map((i) => ({ signal: `{data: ${Em(i, { timeUnit: n, type: t })}}` }));
  }
  function u1(e, t, n) {
    var r;
    const i = (r = yt(n)) == null ? void 0 : r.unit;
    return t === "temporal" || i ? zle(e, t, i) : [e];
  }
  function fo(e, t, n, i) {
    const { encoding: r, markDef: o, mark: s, config: a, stack: u } = n, l = st(r[i]), { type: c } = l, f = l.timeUnit, d = Nae({
      invalid: ur("invalid", o, a),
      isPath: ls(s)
    });
    if (toe(t)) {
      const p = fo(e, void 0, n, i), m = u1(t.unionWith, c, f);
      return Wi([...m, ...p.value]);
    } else {
      if (ee(t))
        return Wi([t]);
      if (t && t !== "unaggregated" && !P5(t))
        return Wi(u1(t, c, f));
    }
    if (u && i === u.fieldChannel) {
      if (u.offset === "normalize")
        return kn([[0, 1]]);
      const p = n.requestDataName(d);
      return kn([
        {
          data: p,
          field: n.vgField(i, { suffix: "start" })
        },
        {
          data: p,
          field: n.vgField(i, { suffix: "end" })
        }
      ]);
    }
    const h = Er(i) && q(l) ? Ule(n, i, e) : void 0;
    if (_r(l)) {
      const p = u1([l.datum], c, f);
      return kn(p);
    }
    const g = l;
    if (t === "unaggregated") {
      const { field: p } = l;
      return kn([
        {
          data: n.requestDataName(d),
          field: V({ field: p, aggregate: "min" })
        },
        {
          data: n.requestDataName(d),
          field: V({ field: p, aggregate: "max" })
        }
      ]);
    } else if (ze(g.bin)) {
      if (bt(e))
        return kn(e === "bin-ordinal" ? [] : [
          {
            // If sort by aggregation of a specified sort field, we need to use RAW table,
            // so we can aggregate values for the scale independently from the main aggregation.
            data: Yc(h) ? n.requestDataName(d) : n.requestDataName(Ke.Raw),
            // Use range if we added it and the scale does not support computing a range as a signal.
            field: n.vgField(i, qf(g, i) ? { binSuffix: "range" } : {}),
            // we have to use a sort object if sort = true to make the sort correct by bin start
            sort: h === !0 || !Y(h) ? {
              field: n.vgField(i, {}),
              op: "min"
              // min or max doesn't matter since we sort by the start of the bin range
            } : h
          }
        ]);
      {
        const { bin: p } = g;
        if (ze(p)) {
          const m = RE(n, g.field, p);
          return kn([
            new ft(() => {
              const y = n.getSignalName(m);
              return `[${y}.start, ${y}.stop]`;
            })
          ]);
        } else
          return kn([
            {
              data: n.requestDataName(d),
              field: n.vgField(i, {})
            }
          ]);
      }
    } else if (g.timeUnit && ye(["time", "utc"], e)) {
      const p = r[wr(i)];
      if (Z5(g, p, o, a)) {
        const m = n.requestDataName(d), y = Go({ fieldDef: g, fieldDef2: p, markDef: o, config: a }), b = Kc(s) && y !== 0.5 && et(i);
        return kn([
          {
            data: m,
            field: n.vgField(i, b ? { suffix: Cm } : {})
          },
          {
            data: m,
            field: n.vgField(i, { suffix: b ? Fm : "end" })
          }
        ]);
      }
    }
    return kn(h ? [
      {
        // If sort by aggregation of a specified sort field, we need to use RAW table,
        // so we can aggregate values for the scale independently from the main aggregation.
        data: Yc(h) ? n.requestDataName(d) : n.requestDataName(Ke.Raw),
        field: n.vgField(i),
        sort: h
      }
    ] : [
      {
        data: n.requestDataName(d),
        field: n.vgField(i)
      }
    ]);
  }
  function l1(e, t) {
    const { op: n, field: i, order: r } = e;
    return {
      // Apply default op
      op: n ?? (t ? "sum" : bm),
      // flatten nested fields
      ...i ? { field: ti(i) } : {},
      ...r ? { order: r } : {}
    };
  }
  function Ble(e, t) {
    var a;
    const n = e.component.scales[t], i = e.specifiedScales[t].domain, r = (a = e.fieldDef(t)) == null ? void 0 : a.bin, o = P5(i) ? i : void 0, s = Ea(r) && cm(r.extent) ? r.extent : void 0;
    (o || s) && n.set("selectionExtent", o ?? s, !0);
  }
  function Ule(e, t, n) {
    if (!bt(n))
      return;
    const i = e.fieldDef(t), r = i.sort;
    if (J5(r))
      return {
        op: "min",
        field: Bu(i, t),
        order: "ascending"
      };
    const { stack: o } = e, s = o ? /* @__PURE__ */ new Set([...o.groupbyFields, ...o.stackBy.map((a) => a.fieldDef.field)]) : void 0;
    if (Wr(r)) {
      const a = o && !s.has(r.field);
      return l1(r, a);
    } else if (Noe(r)) {
      const { encoding: a, order: u } = r, l = e.fieldDef(a), { aggregate: c, field: f } = l, d = o && !s.has(f);
      if (Kr(c) || us(c))
        return l1({
          field: V(l),
          order: u
        }, d);
      if (zw(c) || !c)
        return l1({
          op: c,
          // can't be argmin/argmax since we don't support them in encoding field def
          field: f,
          order: u
        }, d);
    } else {
      if (r === "descending")
        return {
          op: "min",
          field: e.vgField(t),
          order: "descending"
        };
      if (ye([
        "ascending",
        void 0
        /* default =ascending*/
      ], r))
        return !0;
    }
  }
  function qA(e, t) {
    const { aggregate: n, type: i } = e;
    return n ? K(n) && !pie.has(n) ? {
      valid: !1,
      reason: rre(n)
    } : i === "quantitative" && t === "log" ? {
      valid: !1,
      reason: ore(e)
    } : { valid: !0 } : {
      valid: !1,
      reason: ire(e)
    };
  }
  function Fb(e, t, n, i) {
    return e.explicit && t.explicit && j(cre(n, i, e.value, t.value)), { explicit: e.explicit, value: [...e.value, ...t.value] };
  }
  function jle(e) {
    const t = Xi(e.map((s) => {
      if (Ir(s)) {
        const { sort: a, ...u } = s;
        return u;
      }
      return s;
    }), be), n = Xi(e.map((s) => {
      if (Ir(s)) {
        const a = s.sort;
        return a !== void 0 && !Yc(a) && ("op" in a && a.op === "count" && delete a.field, a.order === "ascending" && delete a.order), a;
      }
    }).filter((s) => s !== void 0), be);
    if (t.length === 0)
      return;
    if (t.length === 1) {
      const s = e[0];
      if (Ir(s) && n.length > 0) {
        let a = n[0];
        if (n.length > 1) {
          j(Jk);
          const u = n.filter((l) => Y(l) && "op" in l && l.op !== "min");
          n.every((l) => Y(l) && "op" in l) && u.length === 1 ? a = u[0] : a = !0;
        } else if (Y(a) && "field" in a) {
          const u = a.field;
          s.field === u && (a = a.order ? { order: a.order } : !0);
        }
        return {
          ...s,
          sort: a
        };
      }
      return s;
    }
    const i = Xi(n.map((s) => Yc(s) || !("op" in s) || K(s.op) && J(fie, s.op) ? s : (j(dre(s)), !0)), be);
    let r;
    i.length === 1 ? r = i[0] : i.length > 1 && (j(Jk), r = !0);
    const o = Xi(e.map((s) => Ir(s) ? s.data : null), (s) => s);
    return o.length === 1 && o[0] !== null ? {
      data: o[0],
      fields: t.map((a) => a.field),
      ...r ? { sort: r } : {}
    } : { fields: t, ...r ? { sort: r } : {} };
  }
  function zE(e) {
    if (Ir(e) && K(e.field))
      return e.field;
    if (mie(e)) {
      let t;
      for (const n of e.fields)
        if (Ir(n) && K(n.field)) {
          if (!t)
            t = n.field;
          else if (t !== n.field)
            return j(hre), t;
        }
      return j(gre), t;
    } else if (yie(e)) {
      j(pre);
      const t = e.fields[0];
      return K(t) ? t : void 0;
    }
  }
  function Om(e, t) {
    const i = e.component.scales[t].get("domains").map((r) => (Ir(r) && (r.data = e.lookupDataSource(r.data)), r));
    return jle(i);
  }
  function q4(e) {
    return hl(e) || BE(e) ? e.children.reduce((t, n) => t.concat(q4(n)), WA(e)) : WA(e);
  }
  function WA(e) {
    return B(e.component.scales).reduce((t, n) => {
      const i = e.component.scales[n];
      if (i.merged)
        return t;
      const r = i.combine(), { name: o, type: s, selectionExtent: a, domains: u, range: l, reverse: c, ...f } = r, d = qle(r.range, o, n, e), h = Om(e, n), g = a ? zae(e, a, i, h) : null;
      return t.push({
        name: o,
        type: s,
        ...h ? { domain: h } : {},
        ...g ? { domainRaw: g } : {},
        range: d,
        ...c !== void 0 ? { reverse: c } : {},
        ...f
      }), t;
    }, []);
  }
  function qle(e, t, n, i) {
    if (et(n)) {
      if (_a(e))
        return {
          step: { signal: `${t}_step` }
        };
    } else if (Y(e) && Ir(e))
      return {
        ...e,
        data: i.lookupDataSource(e.data)
      };
    return e;
  }
  class W4 extends so {
    constructor(t, n) {
      super(
        {},
        // no initial explicit property
        { name: t }
        // name as initial implicit property
      ), this.merged = !1, this.setWithExplicit("type", n);
    }
    /**
     * Whether the scale definitely includes or not include zero in the domain
     */
    domainHasZero() {
      const t = this.get("type");
      if (ye([St.LOG, St.TIME, St.UTC], t))
        return "definitely-not";
      const n = this.get("zero");
      if (n === !0 || // If zero is undefined, linear/sqrt/pow scales have zero by default.
      n === void 0 && ye([St.LINEAR, St.SQRT, St.POW], t))
        return "definitely";
      const i = this.get("domains");
      if (i.length > 0) {
        let r = !1, o = !1, s = !1;
        for (const a of i) {
          if (P(a)) {
            const u = a[0], l = a[a.length - 1];
            if ($e(u) && $e(l))
              if (u <= 0 && l >= 0) {
                r = !0;
                continue;
              } else {
                o = !0;
                continue;
              }
          }
          s = !0;
        }
        if (r)
          return "definitely";
        if (o && !s)
          return "definitely-not";
      }
      return "maybe";
    }
  }
  const Wle = ["range", "scheme"];
  function Hle(e) {
    const t = e.component.scales;
    for (const n of Iw) {
      const i = t[n];
      if (!i)
        continue;
      const r = Gle(n, e);
      i.setWithExplicit("range", r);
    }
  }
  function HA(e, t) {
    const n = e.fieldDef(t);
    if (n != null && n.bin) {
      const { bin: i, field: r } = n, o = _n(t), s = e.getName(o);
      if (Y(i) && i.binned && i.step !== void 0)
        return new ft(() => {
          const a = e.scaleName(t), u = `(domain("${a}")[1] - domain("${a}")[0]) / ${i.step}`;
          return `${e.getSignalName(s)} / (${u})`;
        });
      if (ze(i)) {
        const a = RE(e, r, i);
        return new ft(() => {
          const u = e.getSignalName(a), l = `(${u}.stop - ${u}.start) / ${u}.step`;
          return `${e.getSignalName(s)} / (${l})`;
        });
      }
    }
  }
  function Gle(e, t) {
    const n = t.specifiedScales[e], { size: i } = t, o = t.getScaleComponent(e).get("type");
    for (const f of Wle)
      if (n[f] !== void 0) {
        const d = fb(o, f), h = I5(e, f);
        if (!d)
          j(y5(o, f, e));
        else if (h)
          j(h);
        else
          switch (f) {
            case "range": {
              const g = n.range;
              if (P(g)) {
                if (et(e))
                  return Wi(g.map((p) => {
                    if (p === "width" || p === "height") {
                      const m = t.getName(p), y = t.getSignalName.bind(t);
                      return ft.fromName(y, m);
                    }
                    return p;
                  }));
              } else if (Y(g))
                return Wi({
                  data: t.requestDataName(Ke.Main),
                  field: g.field,
                  sort: { op: "min", field: t.vgField(e) }
                });
              return Wi(g);
            }
            case "scheme":
              return Wi(Vle(n[f]));
          }
      }
    const s = e === We || e === "xOffset" ? "width" : "height", a = i[s];
    if (cr(a)) {
      if (et(e))
        if (bt(o)) {
          const f = G4(a, t, e);
          if (f)
            return Wi({ step: f });
        } else
          j(b5(s));
      else if (Lf(e)) {
        const f = e === is ? "x" : "y";
        if (t.getScaleComponent(f).get("type") === "band") {
          const g = V4(a, o);
          if (g)
            return Wi(g);
        }
      }
    }
    const { rangeMin: u, rangeMax: l } = n, c = Yle(e, t);
    return (u !== void 0 || l !== void 0) && // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same
    fb(o, "rangeMin") && P(c) && c.length === 2 ? Wi([u ?? c[0], l ?? c[1]]) : kn(c);
  }
  function Vle(e) {
    return eoe(e) ? {
      scheme: e.name,
      ...mn(e, ["name"])
    } : { scheme: e };
  }
  function H4(e, t, n, { center: i } = {}) {
    const r = _n(e), o = t.getName(r), s = t.getSignalName.bind(t);
    return e === xt && Si(n) ? i ? [
      ft.fromName((a) => `${s(a)}/2`, o),
      ft.fromName((a) => `-${s(a)}/2`, o)
    ] : [ft.fromName(s, o), 0] : i ? [
      ft.fromName((a) => `-${s(a)}/2`, o),
      ft.fromName((a) => `${s(a)}/2`, o)
    ] : [0, ft.fromName(s, o)];
  }
  function Yle(e, t) {
    const { size: n, config: i, mark: r, encoding: o } = t, { type: s } = st(o[e]), u = t.getScaleComponent(e).get("type"), { domain: l, domainMid: c } = t.specifiedScales[e];
    switch (e) {
      case We:
      case xt: {
        if (ye(["point", "band"], u)) {
          const f = Y4(e, n, i.view);
          if (cr(f))
            return { step: G4(f, t, e) };
        }
        return H4(e, t, u);
      }
      case is:
      case al:
        return Xle(e, t, u);
      case no: {
        const f = Qle(r, i), d = Zle(r, n, t, i);
        return Nu(u) ? Jle(f, d, Kle(u, i, l, e)) : [f, d];
      }
      case ri:
        return [0, Math.PI * 2];
      case xa:
        return [0, 360];
      case Di:
        return [
          0,
          new ft(() => {
            const f = t.getSignalName(Rn(t.parent) ? "child_width" : "width"), d = t.getSignalName(Rn(t.parent) ? "child_height" : "height");
            return `min(${f},${d})/2`;
          })
        ];
      case ss:
        return [i.scale.minStrokeWidth, i.scale.maxStrokeWidth];
      case as:
        return [
          // TODO: add this to Vega's config.range?
          [1, 0],
          [4, 2],
          [2, 1],
          [1, 1],
          [1, 2, 4, 2]
        ];
      case En:
        return "symbol";
      case wn:
      case vr:
      case xr:
        return u === "ordinal" ? s === "nominal" ? "category" : "ordinal" : c !== void 0 ? "diverging" : r === "rect" || r === "geoshape" ? "heatmap" : "ramp";
      case io:
      case rs:
      case os:
        return [i.scale.minOpacity, i.scale.maxOpacity];
    }
  }
  function G4(e, t, n) {
    const { encoding: i } = t, r = t.getScaleComponent(n), o = Ow(n), s = i[o];
    if (T6({ step: e, offsetIsDiscrete: le(s) && D5(s.type) }) === "offset" && f6(i, o)) {
      const u = t.getScaleComponent(o);
      let c = `domain('${t.scaleName(o)}').length`;
      if (u.get("type") === "band") {
        const d = u.get("paddingInner") ?? u.get("padding") ?? 0, h = u.get("paddingOuter") ?? u.get("padding") ?? 0;
        c = `bandspace(${c}, ${d}, ${h})`;
      }
      const f = r.get("paddingInner") ?? r.get("padding");
      return {
        signal: `${e.step} * ${c} / (1-${wie(f)})`
      };
    } else
      return e.step;
  }
  function V4(e, t) {
    if (T6({ step: e, offsetIsDiscrete: bt(t) }) === "offset")
      return { step: e.step };
  }
  function Xle(e, t, n) {
    const i = e === is ? "x" : "y", r = t.getScaleComponent(i);
    if (!r)
      return H4(i, t, n, { center: !0 });
    const o = r.get("type"), s = t.scaleName(i), { markDef: a, config: u } = t;
    if (o === "band") {
      const l = Y4(i, t.size, t.config.view);
      if (cr(l)) {
        const c = V4(l, n);
        if (c)
          return c;
      }
      return [0, { signal: `bandwidth('${s}')` }];
    } else {
      const l = t.encoding[i];
      if (q(l) && l.timeUnit) {
        const c = C5(l.timeUnit, (g) => `scale('${s}', ${g})`), f = t.config.scale.bandWithNestedOffsetPaddingInner, d = Go({
          fieldDef: l,
          markDef: a,
          config: u
        }) - 0.5, h = d !== 0 ? ` + ${d}` : "";
        if (f) {
          const g = ee(f) ? `${f.signal}/2` + h : `${f / 2 + d}`, p = ee(f) ? `(1 - ${f.signal}/2)` + h : `${1 - f / 2 + d}`;
          return [{ signal: `${g} * (${c})` }, { signal: `${p} * (${c})` }];
        }
        return [0, { signal: c }];
      }
      return zR(`Cannot use ${e} scale if ${i} scale is not discrete.`);
    }
  }
  function Y4(e, t, n) {
    const i = e === We ? "width" : "height", r = t[i];
    return r || Rg(n, i);
  }
  function Kle(e, t, n, i) {
    switch (e) {
      case "quantile":
        return t.scale.quantileCount;
      case "quantize":
        return t.scale.quantizeCount;
      case "threshold":
        return n !== void 0 && P(n) ? n.length + 1 : (j(Sre(i)), 3);
    }
  }
  function Jle(e, t, n) {
    const i = () => {
      const r = yi(t), o = yi(e), s = `(${r} - ${o}) / (${n} - 1)`;
      return `sequence(${o}, ${r} + ${s}, ${s})`;
    };
    return ee(t) ? new ft(i) : { signal: i() };
  }
  function Qle(e, t) {
    switch (e) {
      case "bar":
      case "tick":
        return t.scale.minBandSize;
      case "line":
      case "trail":
      case "rule":
        return t.scale.minStrokeWidth;
      case "text":
        return t.scale.minFontSize;
      case "point":
      case "square":
      case "circle":
        return t.scale.minSize;
    }
    throw new Error(fm("size", e));
  }
  const GA = 0.95;
  function Zle(e, t, n, i) {
    const r = {
      x: HA(n, "x"),
      y: HA(n, "y")
    };
    switch (e) {
      case "bar":
      case "tick": {
        if (i.scale.maxBandSize !== void 0)
          return i.scale.maxBandSize;
        const o = VA(t, r, i.view);
        return $e(o) ? o - 1 : new ft(() => `${o.signal} - 1`);
      }
      case "line":
      case "trail":
      case "rule":
        return i.scale.maxStrokeWidth;
      case "text":
        return i.scale.maxFontSize;
      case "point":
      case "square":
      case "circle": {
        if (i.scale.maxSize)
          return i.scale.maxSize;
        const o = VA(t, r, i.view);
        return $e(o) ? Math.pow(GA * o, 2) : new ft(() => `pow(${GA} * ${o.signal}, 2)`);
      }
    }
    throw new Error(fm("size", e));
  }
  function VA(e, t, n) {
    const i = cr(e.width) ? e.width.step : pb(n, "width"), r = cr(e.height) ? e.height.step : pb(n, "height");
    return t.x || t.y ? new ft(() => `min(${[
      t.x ? t.x.signal : i,
      t.y ? t.y.signal : r
    ].join(", ")})`) : Math.min(i, r);
  }
  function X4(e, t) {
    Ge(e) ? ece(e, t) : J4(e, t);
  }
  function ece(e, t) {
    const n = e.component.scales, { config: i, encoding: r, markDef: o, specifiedScales: s } = e;
    for (const a of B(n)) {
      const u = s[a], l = n[a], c = e.getScaleComponent(a), f = st(r[a]), d = u[t], h = c.get("type"), g = c.get("padding"), p = c.get("paddingInner"), m = fb(h, t), y = I5(a, t);
      if (d !== void 0 && (m ? y && j(y) : j(y5(h, t, a))), m && y === void 0)
        if (d !== void 0) {
          const b = f.timeUnit, v = f.type;
          switch (t) {
            case "domainMax":
            case "domainMin":
              Sa(u[t]) || v === "temporal" || b ? l.set(t, { signal: Em(u[t], { type: v, timeUnit: b }) }, !0) : l.set(t, u[t], !0);
              break;
            default:
              l.copyKeyFromObject(t, u);
          }
        } else {
          const b = U(YA, t) ? YA[t]({
            model: e,
            channel: a,
            fieldOrDatumDef: f,
            scaleType: h,
            scalePadding: g,
            scalePaddingInner: p,
            domain: u.domain,
            domainMin: u.domainMin,
            domainMax: u.domainMax,
            markDef: o,
            config: i,
            hasNestedOffsetScale: d6(r, a),
            hasSecondaryRangeChannel: !!r[wr(a)]
          }) : i.scale[t];
          b !== void 0 && l.set(t, b, !1);
        }
    }
  }
  const YA = {
    bins: ({ model: e, fieldOrDatumDef: t }) => q(t) ? tce(e, t) : void 0,
    interpolate: ({ channel: e, fieldOrDatumDef: t }) => nce(e, t.type),
    nice: ({ scaleType: e, channel: t, domain: n, domainMin: i, domainMax: r, fieldOrDatumDef: o }) => ice(e, t, n, i, r, o),
    padding: ({ channel: e, scaleType: t, fieldOrDatumDef: n, markDef: i, config: r }) => rce(e, t, r.scale, n, i, r.bar),
    paddingInner: ({ scalePadding: e, channel: t, markDef: n, scaleType: i, config: r, hasNestedOffsetScale: o }) => oce(e, t, n.type, i, r.scale, o),
    paddingOuter: ({ scalePadding: e, channel: t, scaleType: n, scalePaddingInner: i, config: r, hasNestedOffsetScale: o }) => sce(e, t, n, i, r.scale, o),
    reverse: ({ fieldOrDatumDef: e, scaleType: t, channel: n, config: i }) => {
      const r = q(e) ? e.sort : void 0;
      return ace(t, r, n, i.scale);
    },
    zero: ({ channel: e, fieldOrDatumDef: t, domain: n, markDef: i, scaleType: r, config: o, hasSecondaryRangeChannel: s }) => uce(e, t, n, i, r, o.scale, s)
  };
  function K4(e) {
    Ge(e) ? Hle(e) : J4(e, "range");
  }
  function J4(e, t) {
    const n = e.component.scales;
    for (const i of e.children)
      t === "range" ? K4(i) : X4(i, t);
    for (const i of B(n)) {
      let r;
      for (const o of e.children) {
        const s = o.component.scales[i];
        if (s) {
          const a = s.getWithExplicit(t);
          r = Vo(r, a, t, "scale", W6((u, l) => {
            switch (t) {
              case "range":
                return u.step && l.step ? u.step - l.step : 0;
            }
            return 0;
          }));
        }
      }
      n[i].setWithExplicit(t, r);
    }
  }
  function tce(e, t) {
    const n = t.bin;
    if (ze(n)) {
      const i = RE(e, t.field, n);
      return new ft(() => e.getSignalName(i));
    } else if (Et(n) && Ea(n) && n.step !== void 0)
      return {
        step: n.step
      };
  }
  function nce(e, t) {
    if (ye([wn, vr, xr], e) && t !== "nominal")
      return "hcl";
  }
  function ice(e, t, n, i, r, o) {
    var s;
    if (!((s = ki(o)) != null && s.bin || P(n) || r != null || i != null || ye([St.TIME, St.UTC], e)))
      return et(t) ? !0 : void 0;
  }
  function rce(e, t, n, i, r, o) {
    if (et(e)) {
      if (Ki(t)) {
        if (n.continuousPadding !== void 0)
          return n.continuousPadding;
        const { type: s, orient: a } = r;
        if (s === "bar" && !(q(i) && (i.bin || i.timeUnit)) && (a === "vertical" && e === "x" || a === "horizontal" && e === "y"))
          return o.continuousBandSize;
      }
      if (t === St.POINT)
        return n.pointPadding;
    }
  }
  function oce(e, t, n, i, r, o = !1) {
    if (e === void 0) {
      if (et(t)) {
        const { bandPaddingInner: s, barBandPaddingInner: a, rectBandPaddingInner: u, tickBandPaddingInner: l, bandWithNestedOffsetPaddingInner: c } = r;
        return o ? c : Ze(s, n === "bar" ? a : n === "tick" ? l : u);
      } else if (Lf(t) && i === St.BAND)
        return r.offsetBandPaddingInner;
    }
  }
  function sce(e, t, n, i, r, o = !1) {
    if (e === void 0) {
      if (et(t)) {
        const { bandPaddingOuter: s, bandWithNestedOffsetPaddingOuter: a } = r;
        if (o)
          return a;
        if (n === St.BAND)
          return Ze(
            s,
            /* By default, paddingOuter is paddingInner / 2. The reason is that
              size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).
              and we want the width/height to be integer by default.
              Note that step (by default) and cardinality are integers.) */
            ee(i) ? { signal: `${i.signal}/2` } : i / 2
          );
      } else if (Lf(t)) {
        if (n === St.POINT)
          return 0.5;
        if (n === St.BAND)
          return r.offsetBandPaddingOuter;
      }
    }
  }
  function ace(e, t, n, i) {
    if (n === "x" && i.xReverse !== void 0)
      return Si(e) && t === "descending" ? ee(i.xReverse) ? { signal: `!${i.xReverse.signal}` } : !i.xReverse : i.xReverse;
    if (Si(e) && t === "descending")
      return !0;
  }
  function uce(e, t, n, i, r, o, s) {
    if (!!n && n !== "unaggregated" && Si(r)) {
      if (P(n)) {
        const u = n[0], l = n[n.length - 1];
        if ($e(u) && u <= 0 && $e(l) && l >= 0)
          return !0;
      }
      return !1;
    }
    if (e === "size" && t.type === "quantitative" && !Nu(r))
      return !0;
    if (!(q(t) && t.bin) && ye([...ro, ...iie], e)) {
      const { orient: u, type: l } = i;
      return ye(["bar", "area", "line", "trail"], l) && (u === "horizontal" && e === "y" || u === "vertical" && e === "x") ? !1 : ye(["bar", "area"], l) && !s ? !0 : o == null ? void 0 : o.zero;
    }
    return !1;
  }
  function lce(e, t, n, i, r = !1) {
    const o = cce(t, n, i, r), { type: s } = e;
    return Er(t) ? s !== void 0 ? aoe(t, s) ? q(n) && !soe(s, n.type) ? (j(ure(s, o)), o) : s : (j(are(t, s, o)), o) : o : null;
  }
  function cce(e, t, n, i) {
    var r;
    switch (t.type) {
      case "nominal":
      case "ordinal": {
        if (iu(e) || Z0(e) === "discrete")
          return e === "shape" && t.type === "ordinal" && j(e1(e, "ordinal")), "ordinal";
        if (et(e) || Lf(e)) {
          if (ye(["rect", "bar", "image", "rule", "tick"], n.type) || i)
            return "band";
        } else if (n.type === "arc" && e in Pw)
          return "band";
        const o = n[_n(e)];
        return sa(o) || Ru(t) && ((r = t.axis) != null && r.tickBand) ? "band" : "point";
      }
      case "temporal":
        return iu(e) ? "time" : Z0(e) === "discrete" ? (j(e1(e, "temporal")), "ordinal") : q(t) && t.timeUnit && yt(t.timeUnit).utc ? "utc" : "time";
      case "quantitative":
        return iu(e) ? q(t) && ze(t.bin) ? "bin-ordinal" : "linear" : Z0(e) === "discrete" ? (j(e1(e, "quantitative")), "ordinal") : "linear";
      case "geojson":
        return;
    }
    throw new Error(p5(t.type));
  }
  function fce(e, { ignoreRange: t } = {}) {
    Q4(e), j4(e);
    for (const n of ooe)
      X4(e, n);
    t || K4(e);
  }
  function Q4(e) {
    Ge(e) ? e.component.scales = dce(e) : e.component.scales = gce(e);
  }
  function dce(e) {
    const { encoding: t, mark: n, markDef: i } = e, r = {};
    for (const o of Iw) {
      const s = st(t[o]);
      if (s && n === U5 && o === En && s.type === ul)
        continue;
      let a = s && s.scale;
      if (s && a !== null && a !== !1) {
        a ?? (a = {});
        const u = d6(t, o), l = lce(a, o, s, i, u);
        r[o] = new W4(e.scaleName(`${o}`, !0), {
          value: l,
          explicit: a.type === l
        });
      }
    }
    return r;
  }
  const hce = W6((e, t) => Zk(e) - Zk(t));
  function gce(e) {
    var t;
    const n = e.component.scales = {}, i = {}, r = e.component.resolve;
    for (const o of e.children) {
      Q4(o);
      for (const s of B(o.component.scales))
        if ((t = r.scale)[s] ?? (t[s] = F4(s, e)), r.scale[s] === "shared") {
          const a = i[s], u = o.component.scales[s].getWithExplicit("type");
          a ? Xre(a.value, u.value) ? i[s] = Vo(a, u, "type", "scale", hce) : (r.scale[s] = "independent", delete i[s]) : i[s] = u;
        }
    }
    for (const o of B(i)) {
      const s = e.scaleName(o, !0), a = i[o];
      n[o] = new W4(s, a);
      for (const u of e.children) {
        const l = u.component.scales[o];
        l && (u.renameScale(l.get("name"), s), l.merged = !0);
      }
    }
    return n;
  }
  class c1 {
    constructor() {
      this.nameMap = {};
    }
    rename(t, n) {
      this.nameMap[t] = n;
    }
    has(t) {
      return this.nameMap[t] !== void 0;
    }
    get(t) {
      for (; this.nameMap[t] && t !== this.nameMap[t]; )
        t = this.nameMap[t];
      return t;
    }
  }
  function Ge(e) {
    return (e == null ? void 0 : e.type) === "unit";
  }
  function Rn(e) {
    return (e == null ? void 0 : e.type) === "facet";
  }
  function BE(e) {
    return (e == null ? void 0 : e.type) === "concat";
  }
  function hl(e) {
    return (e == null ? void 0 : e.type) === "layer";
  }
  class UE {
    constructor(t, n, i, r, o, s, a) {
      this.type = n, this.parent = i, this.config = o, this.correctDataNames = (u) => {
        var l, c, f;
        return (l = u.from) != null && l.data && (u.from.data = this.lookupDataSource(u.from.data)), (f = (c = u.from) == null ? void 0 : c.facet) != null && f.data && (u.from.facet.data = this.lookupDataSource(u.from.facet.data)), u;
      }, this.parent = i, this.config = o, this.view = _t(a), this.name = t.name ?? r, this.title = yo(t.title) ? { text: t.title } : t.title ? _t(t.title) : void 0, this.scaleNameMap = i ? i.scaleNameMap : new c1(), this.projectionNameMap = i ? i.projectionNameMap : new c1(), this.signalNameMap = i ? i.signalNameMap : new c1(), this.data = t.data, this.description = t.description, this.transforms = wae(t.transform ?? []), this.layout = n === "layer" || n === "unit" ? {} : $se(t, n, o), this.component = {
        data: {
          sources: i ? i.component.data.sources : [],
          outputNodes: i ? i.component.data.outputNodes : {},
          outputNodeRefCounts: i ? i.component.data.outputNodeRefCounts : {},
          // data is faceted if the spec is a facet spec or the parent has faceted data and data is undefined
          isFaceted: vm(t) || (i == null ? void 0 : i.component.data.isFaceted) && t.data === void 0
        },
        layoutSize: new so(),
        layoutHeaders: { row: {}, column: {}, facet: {} },
        mark: null,
        resolve: {
          scale: {},
          axis: {},
          legend: {},
          ...s ? ue(s) : {}
        },
        selection: null,
        scales: null,
        projection: null,
        axes: {},
        legends: {}
      };
    }
    get width() {
      return this.getSizeSignalRef("width");
    }
    get height() {
      return this.getSizeSignalRef("height");
    }
    parse() {
      this.parseScale(), this.parseLayoutSize(), this.renameTopLevelLayoutSizeSignal(), this.parseSelections(), this.parseProjection(), this.parseData(), this.parseAxesAndHeaders(), this.parseLegends(), this.parseMarkGroup();
    }
    parseScale() {
      fce(this);
    }
    parseProjection() {
      z4(this);
    }
    /**
     * Rename top-level spec's size to be just width / height, ignoring model name.
     * This essentially merges the top-level spec's width/height signals with the width/height signals
     * to help us reduce redundant signals declaration.
     */
    renameTopLevelLayoutSizeSignal() {
      this.getName("width") !== "width" && this.renameSignal(this.getName("width"), "width"), this.getName("height") !== "height" && this.renameSignal(this.getName("height"), "height");
    }
    parseLegends() {
      O4(this);
    }
    assembleEncodeFromView(t) {
      const { style: n, ...i } = t, r = {};
      for (const o of B(i)) {
        const s = i[o];
        s !== void 0 && (r[o] = Ue(s));
      }
      return r;
    }
    assembleGroupEncodeEntry(t) {
      let n = {};
      return this.view && (n = this.assembleEncodeFromView(this.view)), !t && (this.description && (n.description = Ue(this.description)), this.type === "unit" || this.type === "layer") ? {
        width: this.getSizeSignalRef("width"),
        height: this.getSizeSignalRef("height"),
        ...n
      } : Oe(n) ? void 0 : n;
    }
    assembleLayout() {
      if (!this.layout)
        return;
      const { spacing: t, ...n } = this.layout, { component: i, config: r } = this, o = Oue(i.layoutHeaders, r);
      return {
        padding: t,
        ...this.assembleDefaultLayout(),
        ...n,
        ...o ? { titleBand: o } : {}
      };
    }
    assembleDefaultLayout() {
      return {};
    }
    assembleHeaderMarks() {
      const { layoutHeaders: t } = this.component;
      let n = [];
      for (const i of Vn)
        t[i].title && n.push(Cue(this, i));
      for (const i of TE)
        n = n.concat(Fue(this, i));
      return n;
    }
    assembleAxes() {
      return pue(this.component.axes, this.config);
    }
    assembleLegends() {
      return L4(this);
    }
    assembleProjections() {
      return ile(this);
    }
    assembleTitle() {
      const { encoding: t, ...n } = this.title ?? {}, i = {
        ...s5(this.config.title).nonMarkTitleProperties,
        ...n,
        ...t ? { encode: { update: t } } : {}
      };
      if (i.text)
        return ye(["unit", "layer"], this.type) ? ye(["middle", void 0], i.anchor) && (i.frame ?? (i.frame = "group")) : i.anchor ?? (i.anchor = "start"), Oe(i) ? void 0 : i;
    }
    /**
     * Assemble the mark group for this model. We accept optional `signals` so that we can include concat top-level signals with the top-level model's local signals.
     */
    assembleGroup(t = []) {
      const n = {};
      t = t.concat(this.assembleSignals()), t.length > 0 && (n.signals = t);
      const i = this.assembleLayout();
      i && (n.layout = i), n.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
      const r = !this.parent || Rn(this.parent) ? q4(this) : [];
      r.length > 0 && (n.scales = r);
      const o = this.assembleAxes();
      o.length > 0 && (n.axes = o);
      const s = this.assembleLegends();
      return s.length > 0 && (n.legends = s), n;
    }
    getName(t) {
      return qe((this.name ? `${this.name}_` : "") + t);
    }
    getDataName(t) {
      return this.getName(Ke[t].toLowerCase());
    }
    /**
     * Request a data source name for the given data source type and mark that data source as required.
     * This method should be called in parse, so that all used data source can be correctly instantiated in assembleData().
     * You can lookup the correct dataset name in assemble with `lookupDataSource`.
     */
    requestDataName(t) {
      const n = this.getDataName(t), i = this.component.data.outputNodeRefCounts;
      return i[n] = (i[n] || 0) + 1, n;
    }
    getSizeSignalRef(t) {
      if (Rn(this.parent)) {
        const n = A4(t), i = um(n), r = this.component.scales[i];
        if (r && !r.merged) {
          const o = r.get("type"), s = r.get("range");
          if (bt(o) && _a(s)) {
            const a = r.get("name"), u = Om(this, i), l = zE(u);
            if (l) {
              const c = V({ aggregate: "distinct", field: l }, { expr: "datum" });
              return {
                signal: k4(a, r, c)
              };
            } else
              return j(Uw(i)), null;
          }
        }
      }
      return {
        signal: this.signalNameMap.get(this.getName(t))
      };
    }
    /**
     * Lookup the name of the datasource for an output node. You probably want to call this in assemble.
     */
    lookupDataSource(t) {
      const n = this.component.data.outputNodes[t];
      return n ? n.getSource() : t;
    }
    getSignalName(t) {
      return this.signalNameMap.get(t);
    }
    renameSignal(t, n) {
      this.signalNameMap.rename(t, n);
    }
    renameScale(t, n) {
      this.scaleNameMap.rename(t, n);
    }
    renameProjection(t, n) {
      this.projectionNameMap.rename(t, n);
    }
    /**
     * @return scale name for a given channel after the scale has been parsed and named.
     */
    scaleName(t, n) {
      if (n)
        return this.getName(t);
      if (
        // If there is a scale for the channel, there should be a local scale component for it
        QR(t) && Er(t) && this.component.scales[t] || // in the scale name map (the scale get merged by its parent)
        this.scaleNameMap.has(this.getName(t))
      )
        return this.scaleNameMap.get(this.getName(t));
    }
    /**
     * @return projection name after the projection has been parsed and named.
     */
    projectionName(t) {
      if (t)
        return this.getName("projection");
      if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection")))
        return this.projectionNameMap.get(this.getName("projection"));
    }
    /**
     * Traverse a model's hierarchy to get the scale component for a particular channel.
     */
    getScaleComponent(t) {
      if (!this.component.scales)
        throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
      const n = this.component.scales[t];
      return n && !n.merged ? n : this.parent ? this.parent.getScaleComponent(t) : void 0;
    }
    getScaleType(t) {
      const n = this.getScaleComponent(t);
      return n ? n.get("type") : void 0;
    }
    /**
     * Traverse a model's hierarchy to get a particular selection component.
     */
    getSelectionComponent(t, n) {
      let i = this.component.selection[t];
      if (!i && this.parent && (i = this.parent.getSelectionComponent(t, n)), !i)
        throw new Error(kie(n));
      return i;
    }
    /**
     * Returns true if the model has a signalRef for an axis orient.
     */
    hasAxisOrientSignalRef() {
      var t, n;
      return ((t = this.component.axes.x) == null ? void 0 : t.some((i) => i.hasOrientSignalRef())) || ((n = this.component.axes.y) == null ? void 0 : n.some((i) => i.hasOrientSignalRef()));
    }
  }
  class Z4 extends UE {
    /** Get "field" reference for Vega */
    vgField(t, n = {}) {
      const i = this.fieldDef(t);
      if (i)
        return V(i, n);
    }
    reduceFieldDef(t, n) {
      return ese(this.getMapping(), (i, r, o) => {
        const s = ki(r);
        return s ? t(i, s, o) : i;
      }, n);
    }
    forEachFieldDef(t, n) {
      hE(this.getMapping(), (i, r) => {
        const o = ki(i);
        o && t(o, r);
      }, n);
    }
  }
  class Rm extends De {
    clone() {
      return new Rm(null, ue(this.transform));
    }
    constructor(t, n) {
      super(t), this.transform = n, this.transform = ue(n);
      const i = this.transform.as ?? [void 0, void 0];
      this.transform.as = [i[0] ?? "value", i[1] ?? "density"];
      const r = this.transform.resolve ?? "shared";
      this.transform.resolve = r;
    }
    dependentFields() {
      return /* @__PURE__ */ new Set([this.transform.density, ...this.transform.groupby ?? []]);
    }
    producedFields() {
      return new Set(this.transform.as);
    }
    hash() {
      return `DensityTransform ${be(this.transform)}`;
    }
    assemble() {
      const { density: t, ...n } = this.transform, i = {
        type: "kde",
        field: t,
        ...n
      };
      return i.resolve = this.transform.resolve, i;
    }
  }
  class Lm extends De {
    clone() {
      return new Lm(null, ue(this.transform));
    }
    constructor(t, n) {
      super(t), this.transform = n, this.transform = ue(n);
    }
    dependentFields() {
      return /* @__PURE__ */ new Set([this.transform.extent]);
    }
    producedFields() {
      return /* @__PURE__ */ new Set([]);
    }
    hash() {
      return `ExtentTransform ${be(this.transform)}`;
    }
    assemble() {
      const { extent: t, param: n } = this.transform;
      return {
        type: "extent",
        field: t,
        signal: n
      };
    }
  }
  class Pm extends De {
    clone() {
      return new Pm(this.parent, ue(this.transform));
    }
    constructor(t, n) {
      super(t), this.transform = n, this.transform = ue(n);
      const { flatten: i, as: r = [] } = this.transform;
      this.transform.as = i.map((o, s) => r[s] ?? o);
    }
    dependentFields() {
      return new Set(this.transform.flatten);
    }
    producedFields() {
      return new Set(this.transform.as);
    }
    hash() {
      return `FlattenTransform ${be(this.transform)}`;
    }
    assemble() {
      const { flatten: t, as: n } = this.transform;
      return {
        type: "flatten",
        fields: t,
        as: n
      };
    }
  }
  class Im extends De {
    clone() {
      return new Im(null, ue(this.transform));
    }
    constructor(t, n) {
      super(t), this.transform = n, this.transform = ue(n);
      const i = this.transform.as ?? [void 0, void 0];
      this.transform.as = [i[0] ?? "key", i[1] ?? "value"];
    }
    dependentFields() {
      return new Set(this.transform.fold);
    }
    producedFields() {
      return new Set(this.transform.as);
    }
    hash() {
      return `FoldTransform ${be(this.transform)}`;
    }
    assemble() {
      const { fold: t, as: n } = this.transform;
      return {
        type: "fold",
        fields: t,
        as: n
      };
    }
  }
  class su extends De {
    clone() {
      return new su(null, ue(this.fields), this.geojson, this.signal);
    }
    static parseAll(t, n) {
      if (n.component.projection && !n.component.projection.isFit)
        return t;
      let i = 0;
      for (const r of [
        [Oi, Ni],
        [ni, Ri]
      ]) {
        const o = r.map((s) => {
          const a = st(n.encoding[s]);
          return q(a) ? a.field : _r(a) ? { expr: `${a.datum}` } : $i(a) ? { expr: `${a.value}` } : void 0;
        });
        (o[0] || o[1]) && (t = new su(t, o, null, n.getName(`geojson_${i++}`)));
      }
      if (n.channelHasField(En)) {
        const r = n.typedFieldDef(En);
        r.type === ul && (t = new su(t, null, r.field, n.getName(`geojson_${i++}`)));
      }
      return t;
    }
    constructor(t, n, i, r) {
      super(t), this.fields = n, this.geojson = i, this.signal = r;
    }
    dependentFields() {
      const t = (this.fields ?? []).filter(K);
      return /* @__PURE__ */ new Set([...this.geojson ? [this.geojson] : [], ...t]);
    }
    producedFields() {
      return /* @__PURE__ */ new Set();
    }
    hash() {
      return `GeoJSON ${this.geojson} ${this.signal} ${be(this.fields)}`;
    }
    assemble() {
      return [
        ...this.geojson ? [
          {
            type: "filter",
            expr: `isValid(datum["${this.geojson}"])`
          }
        ] : [],
        {
          type: "geojson",
          ...this.fields ? { fields: this.fields } : {},
          ...this.geojson ? { geojson: this.geojson } : {},
          signal: this.signal
        }
      ];
    }
  }
  class Qc extends De {
    clone() {
      return new Qc(null, this.projection, ue(this.fields), ue(this.as));
    }
    constructor(t, n, i, r) {
      super(t), this.projection = n, this.fields = i, this.as = r;
    }
    static parseAll(t, n) {
      if (!n.projectionName())
        return t;
      for (const i of [
        [Oi, Ni],
        [ni, Ri]
      ]) {
        const r = i.map((s) => {
          const a = st(n.encoding[s]);
          return q(a) ? a.field : _r(a) ? { expr: `${a.datum}` } : $i(a) ? { expr: `${a.value}` } : void 0;
        }), o = i[0] === ni ? "2" : "";
        (r[0] || r[1]) && (t = new Qc(t, n.projectionName(), r, [
          n.getName(`x${o}`),
          n.getName(`y${o}`)
        ]));
      }
      return t;
    }
    dependentFields() {
      return new Set(this.fields.filter(K));
    }
    producedFields() {
      return new Set(this.as);
    }
    hash() {
      return `Geopoint ${this.projection} ${be(this.fields)} ${be(this.as)}`;
    }
    assemble() {
      return {
        type: "geopoint",
        projection: this.projection,
        fields: this.fields,
        as: this.as
      };
    }
  }
  class qs extends De {
    clone() {
      return new qs(null, ue(this.transform));
    }
    constructor(t, n) {
      super(t), this.transform = n;
    }
    dependentFields() {
      return /* @__PURE__ */ new Set([this.transform.impute, this.transform.key, ...this.transform.groupby ?? []]);
    }
    producedFields() {
      return /* @__PURE__ */ new Set([this.transform.impute]);
    }
    processSequence(t) {
      const { start: n = 0, stop: i, step: r } = t;
      return { signal: `sequence(${[n, i, ...r ? [r] : []].join(",")})` };
    }
    static makeFromTransform(t, n) {
      return new qs(t, n);
    }
    static makeFromEncoding(t, n) {
      const i = n.encoding, r = i.x, o = i.y;
      if (q(r) && q(o)) {
        const s = r.impute ? r : o.impute ? o : void 0;
        if (s === void 0)
          return;
        const a = r.impute ? o : o.impute ? r : void 0, { method: u, value: l, frame: c, keyvals: f } = s.impute, d = p6(n.mark, i);
        return new qs(t, {
          impute: s.field,
          key: a.field,
          ...u ? { method: u } : {},
          ...l !== void 0 ? { value: l } : {},
          ...c ? { frame: c } : {},
          ...f !== void 0 ? { keyvals: f } : {},
          ...d.length ? { groupby: d } : {}
        });
      }
      return null;
    }
    hash() {
      return `Impute ${be(this.transform)}`;
    }
    assemble() {
      const { impute: t, key: n, keyvals: i, method: r, groupby: o, value: s, frame: a = [null, null] } = this.transform, u = {
        type: "impute",
        field: t,
        key: n,
        ...i ? { keyvals: nae(i) ? this.processSequence(i) : i } : {},
        method: "value",
        ...o ? { groupby: o } : {},
        value: !r || r === "value" ? s : null
      };
      if (r && r !== "value") {
        const l = {
          type: "window",
          as: [`imputed_${t}_value`],
          ops: [r],
          fields: [t],
          frame: a,
          ignorePeers: !1,
          ...o ? { groupby: o } : {}
        }, c = {
          type: "formula",
          expr: `datum.${t} === null ? datum.imputed_${t}_value : datum.${t}`,
          as: t
        };
        return [u, l, c];
      } else
        return [u];
    }
  }
  class zm extends De {
    clone() {
      return new zm(null, ue(this.transform));
    }
    constructor(t, n) {
      super(t), this.transform = n, this.transform = ue(n);
      const i = this.transform.as ?? [void 0, void 0];
      this.transform.as = [i[0] ?? n.on, i[1] ?? n.loess];
    }
    dependentFields() {
      return /* @__PURE__ */ new Set([this.transform.loess, this.transform.on, ...this.transform.groupby ?? []]);
    }
    producedFields() {
      return new Set(this.transform.as);
    }
    hash() {
      return `LoessTransform ${be(this.transform)}`;
    }
    assemble() {
      const { loess: t, on: n, ...i } = this.transform;
      return {
        type: "loess",
        x: n,
        y: t,
        ...i
      };
    }
  }
  class Zc extends De {
    clone() {
      return new Zc(null, ue(this.transform), this.secondary);
    }
    constructor(t, n, i) {
      super(t), this.transform = n, this.secondary = i;
    }
    static make(t, n, i, r) {
      const o = n.component.data.sources, { from: s } = i;
      let a = null;
      if (iae(s)) {
        let u = nL(s.data, o);
        u || (u = new ca(s.data), o.push(u));
        const l = n.getName(`lookup_${r}`);
        a = new yn(u, l, Ke.Lookup, n.component.data.outputNodeRefCounts), n.component.data.outputNodes[l] = a;
      } else if (rae(s)) {
        const u = s.param;
        i = { as: u, ...i };
        let l;
        try {
          l = n.getSelectionComponent(qe(u), u);
        } catch {
          throw new Error(Mie(u));
        }
        if (a = l.materialized, !a)
          throw new Error(Tie(u));
      }
      return new Zc(t, i, a.getSource());
    }
    dependentFields() {
      return /* @__PURE__ */ new Set([this.transform.lookup]);
    }
    producedFields() {
      return new Set(this.transform.as ? X(this.transform.as) : this.transform.from.fields);
    }
    hash() {
      return `Lookup ${be({ transform: this.transform, secondary: this.secondary })}`;
    }
    assemble() {
      let t;
      if (this.transform.from.fields)
        t = {
          values: this.transform.from.fields,
          ...this.transform.as ? { as: X(this.transform.as) } : {}
        };
      else {
        let n = this.transform.as;
        K(n) || (j(zie), n = "_lookup"), t = {
          as: [n]
        };
      }
      return {
        type: "lookup",
        from: this.secondary,
        key: this.transform.from.key,
        fields: [this.transform.lookup],
        ...t,
        ...this.transform.default ? { default: this.transform.default } : {}
      };
    }
  }
  class Bm extends De {
    clone() {
      return new Bm(null, ue(this.transform));
    }
    constructor(t, n) {
      super(t), this.transform = n, this.transform = ue(n);
      const i = this.transform.as ?? [void 0, void 0];
      this.transform.as = [i[0] ?? "prob", i[1] ?? "value"];
    }
    dependentFields() {
      return /* @__PURE__ */ new Set([this.transform.quantile, ...this.transform.groupby ?? []]);
    }
    producedFields() {
      return new Set(this.transform.as);
    }
    hash() {
      return `QuantileTransform ${be(this.transform)}`;
    }
    assemble() {
      const { quantile: t, ...n } = this.transform;
      return {
        type: "quantile",
        field: t,
        ...n
      };
    }
  }
  class Um extends De {
    clone() {
      return new Um(null, ue(this.transform));
    }
    constructor(t, n) {
      super(t), this.transform = n, this.transform = ue(n);
      const i = this.transform.as ?? [void 0, void 0];
      this.transform.as = [i[0] ?? n.on, i[1] ?? n.regression];
    }
    dependentFields() {
      return /* @__PURE__ */ new Set([this.transform.regression, this.transform.on, ...this.transform.groupby ?? []]);
    }
    producedFields() {
      return new Set(this.transform.as);
    }
    hash() {
      return `RegressionTransform ${be(this.transform)}`;
    }
    assemble() {
      const { regression: t, on: n, ...i } = this.transform;
      return {
        type: "regression",
        x: n,
        y: t,
        ...i
      };
    }
  }
  class jm extends De {
    clone() {
      return new jm(null, ue(this.transform));
    }
    constructor(t, n) {
      super(t), this.transform = n;
    }
    addDimensions(t) {
      this.transform.groupby = Xi((this.transform.groupby ?? []).concat(t), (n) => n);
    }
    producedFields() {
    }
    dependentFields() {
      return /* @__PURE__ */ new Set([this.transform.pivot, this.transform.value, ...this.transform.groupby ?? []]);
    }
    hash() {
      return `PivotTransform ${be(this.transform)}`;
    }
    assemble() {
      const { pivot: t, value: n, groupby: i, limit: r, op: o } = this.transform;
      return {
        type: "pivot",
        field: t,
        value: n,
        ...r !== void 0 ? { limit: r } : {},
        ...o !== void 0 ? { op: o } : {},
        ...i !== void 0 ? { groupby: i } : {}
      };
    }
  }
  class qm extends De {
    clone() {
      return new qm(null, ue(this.transform));
    }
    constructor(t, n) {
      super(t), this.transform = n;
    }
    dependentFields() {
      return /* @__PURE__ */ new Set();
    }
    producedFields() {
      return /* @__PURE__ */ new Set();
    }
    hash() {
      return `SampleTransform ${be(this.transform)}`;
    }
    assemble() {
      return {
        type: "sample",
        size: this.transform.sample
      };
    }
  }
  function eL(e) {
    let t = 0;
    function n(i, r) {
      if (i instanceof ca && !i.isGenerator && !Pu(i.data) && (e.push(r), r = {
        name: null,
        source: r.name,
        transform: []
      }), i instanceof Bt && (i.parent instanceof ca && !r.source ? (r.format = {
        ...r.format,
        parse: i.assembleFormatParse()
      }, r.transform.push(...i.assembleTransforms(!0))) : r.transform.push(...i.assembleTransforms())), i instanceof fl) {
        r.name || (r.name = `data_${t++}`), !r.source || r.transform.length > 0 ? (e.push(r), i.data = r.name) : i.data = r.source, e.push(...i.assemble());
        return;
      }
      switch ((i instanceof Gf || i instanceof Vf || i instanceof ju || i instanceof cl || i instanceof zu || i instanceof Qc || i instanceof xi || i instanceof Zc || i instanceof dl || i instanceof Ca || i instanceof Im || i instanceof Pm || i instanceof Rm || i instanceof zm || i instanceof Bm || i instanceof Um || i instanceof Xo || i instanceof qm || i instanceof jm || i instanceof Lm) && r.transform.push(i.assemble()), (i instanceof tr || i instanceof er || i instanceof qs || i instanceof Gr || i instanceof su) && r.transform.push(...i.assemble()), i instanceof yn && (r.source && r.transform.length === 0 ? i.setSource(r.source) : i.parent instanceof yn ? i.setSource(r.name) : (r.name || (r.name = `data_${t++}`), i.setSource(r.name), i.numChildren() === 1 && (e.push(r), r = {
        name: null,
        source: r.name,
        transform: []
      }))), i.numChildren()) {
        case 0:
          i instanceof yn && (!r.source || r.transform.length > 0) && e.push(r);
          break;
        case 1:
          n(i.children[0], r);
          break;
        default: {
          r.name || (r.name = `data_${t++}`);
          let o = r.name;
          !r.source || r.transform.length > 0 ? e.push(r) : o = r.source;
          for (const s of i.children)
            n(s, {
              name: null,
              source: o,
              transform: []
            });
          break;
        }
      }
    }
    return n;
  }
  function pce(e) {
    const t = [], n = eL(t);
    for (const i of e.children)
      n(i, {
        source: e.name,
        name: null,
        transform: []
      });
    return t;
  }
  function mce(e, t) {
    const n = [], i = eL(n);
    let r = 0;
    for (const s of e.sources) {
      s.hasName() || (s.dataName = `source_${r++}`);
      const a = s.assemble();
      i(s, a);
    }
    for (const s of n)
      s.transform.length === 0 && delete s.transform;
    let o = 0;
    for (const [s, a] of n.entries())
      (a.transform ?? []).length === 0 && !a.source && n.splice(o++, 0, n.splice(s, 1)[0]);
    for (const s of n)
      for (const a of s.transform ?? [])
        a.type === "lookup" && (a.from = e.outputNodes[a.from].getSource());
    for (const s of n)
      s.name in t && (s.values = t[s.name]);
    return n;
  }
  function yce(e) {
    return e === "top" || e === "left" || ee(e) ? "header" : "footer";
  }
  function bce(e) {
    for (const t of Vn)
      vce(e, t);
    XA(e, "x"), XA(e, "y");
  }
  function vce(e, t) {
    var s;
    const { facet: n, config: i, child: r, component: o } = e;
    if (e.channelHasField(t)) {
      const a = n[t], u = Uu("title", null, i, t);
      let l = ru(a, i, {
        allowDisabling: !0,
        includeDefault: u === void 0 || !!u
      });
      r.component.layoutHeaders[t].title && (l = P(l) ? l.join(", ") : l, l += ` / ${r.component.layoutHeaders[t].title}`, r.component.layoutHeaders[t].title = null);
      const c = Uu("labelOrient", a.header, i, t), f = a.header !== null ? Ze((s = a.header) == null ? void 0 : s.labels, i.header.labels, !0) : !1, d = ye(["bottom", "right"], c) ? "footer" : "header";
      o.layoutHeaders[t] = {
        title: a.header !== null ? l : null,
        facetFieldDef: a,
        [d]: t === "facet" ? [] : [tL(e, t, f)]
      };
    }
  }
  function tL(e, t, n) {
    const i = t === "row" ? "height" : "width";
    return {
      labels: n,
      sizeSignal: e.child.component.layoutSize.get(i) ? e.child.getSizeSignalRef(i) : void 0,
      axes: []
    };
  }
  function XA(e, t) {
    const { child: n } = e;
    if (n.component.axes[t]) {
      const { layoutHeaders: i, resolve: r } = e.component;
      if (r.axis[t] = OE(r, t), r.axis[t] === "shared") {
        const o = t === "x" ? "column" : "row", s = i[o];
        for (const a of n.component.axes[t]) {
          const u = yce(a.get("orient"));
          s[u] ?? (s[u] = [tL(e, o, !1)]);
          const l = ac(a, "main", e.config, { header: !0 });
          l && s[u][0].axes.push(l), a.mainExtracted = !0;
        }
      }
    }
  }
  function xce(e) {
    jE(e), zg(e, "width"), zg(e, "height");
  }
  function wce(e) {
    jE(e);
    const t = e.layout.columns === 1 ? "width" : "childWidth", n = e.layout.columns === void 0 ? "height" : "childHeight";
    zg(e, t), zg(e, n);
  }
  function jE(e) {
    for (const t of e.children)
      t.parseLayoutSize();
  }
  function zg(e, t) {
    const n = A4(t), i = um(n), r = e.component.resolve, o = e.component.layoutSize;
    let s;
    for (const a of e.children) {
      const u = a.component.layoutSize.getWithExplicit(n), l = r.scale[i] ?? F4(i, e);
      if (l === "independent" && u.value === "step") {
        s = void 0;
        break;
      }
      if (s) {
        if (l === "independent" && s.value !== u.value) {
          s = void 0;
          break;
        }
        s = Vo(s, u, n, "");
      } else
        s = u;
    }
    if (s) {
      for (const a of e.children)
        e.renameSignal(a.getName(n), e.getName(t)), a.component.layoutSize.set(n, "merged", !1);
      o.setWithExplicit(t, s);
    } else
      o.setWithExplicit(t, {
        explicit: !1,
        value: void 0
      });
  }
  function Ece(e) {
    const { size: t, component: n } = e;
    for (const i of ro) {
      const r = _n(i);
      if (t[r]) {
        const o = t[r];
        n.layoutSize.set(r, cr(o) ? "step" : o, !0);
      } else {
        const o = _ce(e, r);
        n.layoutSize.set(r, o, !1);
      }
    }
  }
  function _ce(e, t) {
    const n = t === "width" ? "x" : "y", i = e.config, r = e.getScaleComponent(n);
    if (r) {
      const o = r.get("type"), s = r.get("range");
      if (bt(o)) {
        const a = Rg(i.view, t);
        return _a(s) || cr(a) ? "step" : a;
      } else
        return gb(i.view, t);
    } else {
      if (e.hasProjection || e.mark === "arc")
        return gb(i.view, t);
      {
        const o = Rg(i.view, t);
        return cr(o) ? o.step : o;
      }
    }
  }
  function Mb(e, t, n) {
    return V(t, { suffix: `by_${V(e)}`, ...n });
  }
  class _c extends Z4 {
    constructor(t, n, i, r) {
      super(t, "facet", n, i, r, t.resolve), this.child = VE(t.spec, this, this.getName("child"), void 0, r), this.children = [this.child], this.facet = this.initFacet(t.facet);
    }
    initFacet(t) {
      if (!Bf(t))
        return { facet: this.initFacetFieldDef(t, "facet") };
      const n = B(t), i = {};
      for (const r of n) {
        if (![jr, qr].includes(r)) {
          j(fm(r, "facet"));
          break;
        }
        const o = t[r];
        if (o.field === void 0) {
          j(lb(o, r));
          break;
        }
        i[r] = this.initFacetFieldDef(o, r);
      }
      return i;
    }
    initFacetFieldDef(t, n) {
      const i = dE(t, n);
      return i.header ? i.header = _t(i.header) : i.header === null && (i.header = null), i;
    }
    channelHasField(t) {
      return U(this.facet, t);
    }
    fieldDef(t) {
      return this.facet[t];
    }
    parseData() {
      this.component.data = Wm(this), this.child.parseData();
    }
    parseLayoutSize() {
      jE(this);
    }
    parseSelections() {
      this.child.parseSelections(), this.component.selection = this.child.component.selection;
    }
    parseMarkGroup() {
      this.child.parseMarkGroup();
    }
    parseAxesAndHeaders() {
      this.child.parseAxesAndHeaders(), bce(this);
    }
    assembleSelectionTopLevelSignals(t) {
      return this.child.assembleSelectionTopLevelSignals(t);
    }
    assembleSignals() {
      return this.child.assembleSignals(), [];
    }
    assembleSelectionData(t) {
      return this.child.assembleSelectionData(t);
    }
    getHeaderLayoutMixins() {
      const t = {};
      for (const n of Vn)
        for (const i of DE) {
          const r = this.component.layoutHeaders[n], o = r[i], { facetFieldDef: s } = r;
          if (s) {
            const a = Uu("titleOrient", s.header, this.config, n);
            if (["right", "bottom"].includes(a)) {
              const u = Dm(n, a);
              t.titleAnchor ?? (t.titleAnchor = {}), t.titleAnchor[u] = "end";
            }
          }
          if (o != null && o[0]) {
            const a = n === "row" ? "height" : "width", u = i === "header" ? "headerBand" : "footerBand";
            n !== "facet" && !this.child.component.layoutSize.get(a) && (t[u] ?? (t[u] = {}), t[u][n] = 0.5), r.title && (t.offset ?? (t.offset = {}), t.offset[n === "row" ? "rowTitle" : "columnTitle"] = 10);
          }
        }
      return t;
    }
    assembleDefaultLayout() {
      const { column: t, row: n } = this.facet, i = t ? this.columnDistinctSignal() : n ? 1 : void 0;
      let r = "all";
      return (!n && this.component.resolve.scale.x === "independent" || !t && this.component.resolve.scale.y === "independent") && (r = "none"), {
        ...this.getHeaderLayoutMixins(),
        ...i ? { columns: i } : {},
        bounds: "full",
        align: r
      };
    }
    assembleLayoutSignals() {
      return this.child.assembleLayoutSignals();
    }
    columnDistinctSignal() {
      if (!(this.parent && this.parent instanceof _c))
        return { signal: `length(data('${this.getName("column_domain")}'))` };
    }
    assembleGroupStyle() {
    }
    assembleGroup(t) {
      return this.parent && this.parent instanceof _c ? {
        ...this.channelHasField("column") ? {
          encode: {
            update: {
              // TODO(https://github.com/vega/vega-lite/issues/2759):
              // Correct the signal for facet of concat of facet_column
              columns: { field: V(this.facet.column, { prefix: "distinct" }) }
            }
          }
        } : {},
        ...super.assembleGroup(t)
      } : super.assembleGroup(t);
    }
    /**
     * Aggregate cardinality for calculating size
     */
    getCardinalityAggregateForChild() {
      const t = [], n = [], i = [];
      if (this.child instanceof _c) {
        if (this.child.channelHasField("column")) {
          const r = V(this.child.facet.column);
          t.push(r), n.push("distinct"), i.push(`distinct_${r}`);
        }
      } else
        for (const r of ro) {
          const o = this.child.component.scales[r];
          if (o && !o.merged) {
            const s = o.get("type"), a = o.get("range");
            if (bt(s) && _a(a)) {
              const u = Om(this.child, r), l = zE(u);
              l ? (t.push(l), n.push("distinct"), i.push(`distinct_${l}`)) : j(Uw(r));
            }
          }
        }
      return { fields: t, ops: n, as: i };
    }
    assembleFacet() {
      const { name: t, data: n } = this.component.data.facetRoot, { row: i, column: r } = this.facet, { fields: o, ops: s, as: a } = this.getCardinalityAggregateForChild(), u = [];
      for (const c of Vn) {
        const f = this.facet[c];
        if (f) {
          u.push(V(f));
          const { bin: d, sort: h } = f;
          if (ze(d) && u.push(V(f, { binSuffix: "end" })), Wr(h)) {
            const { field: g, op: p = bm } = h, m = Mb(f, h);
            i && r ? (o.push(m), s.push("max"), a.push(m)) : (o.push(g), s.push(p), a.push(m));
          } else if (P(h)) {
            const g = Bu(f, c);
            o.push(g), s.push("max"), a.push(g);
          }
        }
      }
      const l = !!i && !!r;
      return {
        name: t,
        data: n,
        groupby: u,
        ...l || o.length > 0 ? {
          aggregate: {
            ...l ? { cross: l } : {},
            ...o.length ? { fields: o, ops: s, as: a } : {}
          }
        } : {}
      };
    }
    facetSortFields(t) {
      const { facet: n } = this, i = n[t];
      return i ? Wr(i.sort) ? [Mb(i, i.sort, { expr: "datum" })] : P(i.sort) ? [Bu(i, t, { expr: "datum" })] : [V(i, { expr: "datum" })] : [];
    }
    facetSortOrder(t) {
      const { facet: n } = this, i = n[t];
      if (i) {
        const { sort: r } = i;
        return [(Wr(r) ? r.order : !P(r) && r) || "ascending"];
      }
      return [];
    }
    assembleLabelTitle() {
      var r;
      const { facet: t, config: n } = this;
      if (t.facet)
        return _b(t.facet, "facet", n);
      const i = {
        row: ["top", "bottom"],
        column: ["left", "right"]
      };
      for (const o of TE)
        if (t[o]) {
          const s = Uu("labelOrient", (r = t[o]) == null ? void 0 : r.header, n, o);
          if (i[o].includes(s))
            return _b(t[o], o, n);
        }
    }
    assembleMarks() {
      const { child: t } = this, n = this.component.data.facetRoot, i = pce(n), r = t.assembleGroupEncodeEntry(!1), o = this.assembleLabelTitle() || t.assembleTitle(), s = t.assembleGroupStyle();
      return [{
        name: this.getName("cell"),
        type: "group",
        ...o ? { title: o } : {},
        ...s ? { style: s } : {},
        from: {
          facet: this.assembleFacet()
        },
        // TODO: move this to after data
        sort: {
          field: Vn.map((u) => this.facetSortFields(u)).flat(),
          order: Vn.map((u) => this.facetSortOrder(u)).flat()
        },
        ...i.length > 0 ? { data: i } : {},
        ...r ? { encode: { update: r } } : {},
        ...t.assembleGroup(Rae(this, []))
      }];
    }
    getMapping() {
      return this.facet;
    }
  }
  function Sce(e, t) {
    const { row: n, column: i } = t;
    if (n && i) {
      let r = null;
      for (const o of [n, i])
        if (Wr(o.sort)) {
          const { field: s, op: a = bm } = o.sort;
          e = r = new Ca(e, {
            joinaggregate: [
              {
                op: a,
                field: s,
                as: Mb(o, o.sort, { forAs: !0 })
              }
            ],
            groupby: [V(o)]
          });
        }
      return r;
    }
    return null;
  }
  function nL(e, t) {
    var n, i, r, o;
    for (const s of t) {
      const a = s.data;
      if (e.name && s.hasName() && e.name !== s.dataName)
        continue;
      const u = (n = e.format) == null ? void 0 : n.mesh, l = (i = a.format) == null ? void 0 : i.feature;
      if (u && l)
        continue;
      const c = (r = e.format) == null ? void 0 : r.feature;
      if ((c || l) && c !== l)
        continue;
      const f = (o = a.format) == null ? void 0 : o.mesh;
      if (!((u || f) && u !== f)) {
        if (Jc(e) && Jc(a)) {
          if (Dn(e.values, a.values))
            return s;
        } else if (Pu(e) && Pu(a)) {
          if (e.url === a.url)
            return s;
        } else if (H6(e) && e.name === s.dataName)
          return s;
      }
    }
    return null;
  }
  function $ce(e, t) {
    if (e.data || !e.parent) {
      if (e.data === null) {
        const i = new ca({ values: [] });
        return t.push(i), i;
      }
      const n = nL(e.data, t);
      if (n)
        return No(e.data) || (n.data.format = BR({}, e.data.format, n.data.format)), !n.hasName() && e.data.name && (n.dataName = e.data.name), n;
      {
        const i = new ca(e.data);
        return t.push(i), i;
      }
    } else
      return e.parent.component.data.facetRoot ? e.parent.component.data.facetRoot : e.parent.component.data.main;
  }
  function kce(e, t, n) {
    let i = 0;
    for (const r of t.transforms) {
      let o, s;
      if (gae(r))
        s = e = new zu(e, r), o = "derived";
      else if (SE(r)) {
        const a = mle(r);
        s = e = Bt.makeWithAncestors(e, {}, a, n) ?? e, e = new cl(e, t, r.filter);
      } else if (B6(r))
        s = e = tr.makeFromTransform(e, r, t), o = "number";
      else if (mae(r))
        o = "date", n.getWithExplicit(r.field).value === void 0 && (e = new Bt(e, { [r.field]: o }), n.set(r.field, o, !1)), s = e = er.makeFromTransform(e, r);
      else if (yae(r))
        s = e = xi.makeFromTransform(e, r), o = "number", ME(t) && (e = new Xo(e));
      else if (z6(r))
        s = e = Zc.make(e, t, r, i++), o = "derived";
      else if (fae(r))
        s = e = new dl(e, r), o = "number";
      else if (dae(r))
        s = e = new Ca(e, r), o = "number";
      else if (bae(r))
        s = e = Gr.makeFromTransform(e, r), o = "derived";
      else if (vae(r))
        s = e = new Im(e, r), o = "derived";
      else if (xae(r))
        s = e = new Lm(e, r), o = "derived";
      else if (hae(r))
        s = e = new Pm(e, r), o = "derived";
      else if (oae(r))
        s = e = new jm(e, r), o = "derived";
      else if (cae(r))
        e = new qm(e, r);
      else if (pae(r))
        s = e = qs.makeFromTransform(e, r), o = "derived";
      else if (sae(r))
        s = e = new Rm(e, r), o = "derived";
      else if (aae(r))
        s = e = new Bm(e, r), o = "derived";
      else if (uae(r))
        s = e = new Um(e, r), o = "derived";
      else if (lae(r))
        s = e = new zm(e, r), o = "derived";
      else {
        j(Iie(r));
        continue;
      }
      if (s && o !== void 0)
        for (const a of s.producedFields() ?? [])
          n.set(a, o, !1);
    }
    return e;
  }
  function Wm(e) {
    var m;
    let t = $ce(e, e.component.data.sources);
    const { outputNodes: n, outputNodeRefCounts: i } = e.component.data, r = e.data, s = !(r && (No(r) || Pu(r) || Jc(r))) && e.parent ? e.parent.component.data.ancestorParse.clone() : new Dae();
    No(r) ? (G6(r) ? t = new Vf(t, r.sequence) : $E(r) && (t = new Gf(t, r.graticule)), s.parseNothing = !0) : ((m = r == null ? void 0 : r.format) == null ? void 0 : m.parse) === null && (s.parseNothing = !0), t = Bt.makeExplicit(t, e, s) ?? t, t = new Xo(t);
    const a = e.parent && hl(e.parent);
    (Ge(e) || Rn(e)) && a && (t = tr.makeFromEncoding(t, e) ?? t), e.transforms.length > 0 && (t = kce(t, e, s));
    const u = ble(e), l = yle(e);
    t = Bt.makeWithAncestors(t, {}, { ...u, ...l }, s) ?? t, Ge(e) && (t = su.parseAll(t, e), t = Qc.parseAll(t, e)), (Ge(e) || Rn(e)) && (a || (t = tr.makeFromEncoding(t, e) ?? t), t = er.makeFromEncoding(t, e) ?? t, t = zu.parseAllForSortIndex(t, e));
    const c = t = Cd(Ke.Raw, e, t);
    if (Ge(e)) {
      const y = xi.makeFromEncoding(t, e);
      y && (t = y, ME(e) && (t = new Xo(t))), t = qs.makeFromEncoding(t, e) ?? t, t = Gr.makeFromEncoding(t, e) ?? t;
    }
    let f, d;
    if (Ge(e)) {
      const { markDef: y, mark: b, config: v } = e, x = Ne("invalid", y, v), { marks: w, scales: _ } = d = Y6({
        invalid: x,
        isPath: ls(b)
      });
      w !== _ && _ === "include-invalid-values" && (f = t = Cd(Ke.PreFilterInvalid, e, t)), w === "exclude-invalid-values" && (t = ju.make(t, e, d) ?? t);
    }
    const h = t = Cd(Ke.Main, e, t);
    let g;
    if (Ge(e) && d) {
      const { marks: y, scales: b } = d;
      y === "include-invalid-values" && b === "exclude-invalid-values" && (t = ju.make(t, e, d) ?? t, g = t = Cd(Ke.PostFilterInvalid, e, t));
    }
    Ge(e) && hue(e, h);
    let p = null;
    if (Rn(e)) {
      const y = e.getName("facet");
      t = Sce(t, e.facet) ?? t, p = new fl(t, e, y, h.getSource()), n[y] = p;
    }
    return {
      ...e.component.data,
      outputNodes: n,
      outputNodeRefCounts: i,
      raw: c,
      main: h,
      facetRoot: p,
      ancestorParse: s,
      preFilterInvalid: f,
      postFilterInvalid: g
    };
  }
  function Cd(e, t, n) {
    const { outputNodes: i, outputNodeRefCounts: r } = t.component.data, o = t.getDataName(e), s = new yn(n, o, e, r);
    return i[o] = s, s;
  }
  class Ace extends UE {
    constructor(t, n, i, r) {
      var o, s, a, u;
      super(t, "concat", n, i, r, t.resolve), (((s = (o = t.resolve) == null ? void 0 : o.axis) == null ? void 0 : s.x) === "shared" || ((u = (a = t.resolve) == null ? void 0 : a.axis) == null ? void 0 : u.y) === "shared") && j(Rie), this.children = this.getChildren(t).map((l, c) => VE(l, this, this.getName(`concat_${c}`), void 0, r));
    }
    parseData() {
      this.component.data = Wm(this);
      for (const t of this.children)
        t.parseData();
    }
    parseSelections() {
      this.component.selection = {};
      for (const t of this.children) {
        t.parseSelections();
        for (const n of B(t.component.selection))
          this.component.selection[n] = t.component.selection[n];
      }
    }
    parseMarkGroup() {
      for (const t of this.children)
        t.parseMarkGroup();
    }
    parseAxesAndHeaders() {
      for (const t of this.children)
        t.parseAxesAndHeaders();
    }
    getChildren(t) {
      return $m(t) ? t.vconcat : EE(t) ? t.hconcat : t.concat;
    }
    parseLayoutSize() {
      wce(this);
    }
    parseAxisGroup() {
      return null;
    }
    assembleSelectionTopLevelSignals(t) {
      return this.children.reduce((n, i) => i.assembleSelectionTopLevelSignals(n), t);
    }
    assembleSignals() {
      return this.children.forEach((t) => t.assembleSignals()), [];
    }
    assembleLayoutSignals() {
      const t = NE(this);
      for (const n of this.children)
        t.push(...n.assembleLayoutSignals());
      return t;
    }
    assembleSelectionData(t) {
      return this.children.reduce((n, i) => i.assembleSelectionData(n), t);
    }
    assembleMarks() {
      return this.children.map((t) => {
        const n = t.assembleTitle(), i = t.assembleGroupStyle(), r = t.assembleGroupEncodeEntry(!1);
        return {
          type: "group",
          name: t.getName("group"),
          ...n ? { title: n } : {},
          ...i ? { style: i } : {},
          ...r ? { encode: { update: r } } : {},
          ...t.assembleGroup()
        };
      });
    }
    assembleGroupStyle() {
    }
    assembleDefaultLayout() {
      const t = this.layout.columns;
      return {
        ...t != null ? { columns: t } : {},
        bounds: "full",
        // Use align each so it can work with multiple plots with different size
        align: "each"
      };
    }
  }
  function Cce(e) {
    return e === !1 || e === null;
  }
  const Fce = {
    disable: 1,
    gridScale: 1,
    scale: 1,
    ...l6,
    labelExpr: 1,
    encode: 1
  }, iL = B(Fce);
  class qE extends so {
    constructor(t = {}, n = {}, i = !1) {
      super(), this.explicit = t, this.implicit = n, this.mainExtracted = i;
    }
    clone() {
      return new qE(ue(this.explicit), ue(this.implicit), this.mainExtracted);
    }
    hasAxisPart(t) {
      return t === "axis" ? !0 : t === "grid" || t === "title" ? !!this.get(t) : !Cce(this.get(t));
    }
    hasOrientSignalRef() {
      return ee(this.explicit.orient);
    }
  }
  function Mce(e, t, n) {
    const { encoding: i, config: r } = e, o = st(i[t]) ?? st(i[wr(t)]), s = e.axis(t) || {}, { format: a, formatType: u } = s;
    if (aa(u))
      return {
        text: bi({
          fieldOrDatumDef: o,
          field: "datum.value",
          format: a,
          formatType: u,
          config: r
        }),
        ...n
      };
    if (a === void 0 && u === void 0 && r.customFormatTypes) {
      if (Ou(o) === "quantitative") {
        if (Ru(o) && o.stack === "normalize" && r.normalizedNumberFormatType)
          return {
            text: bi({
              fieldOrDatumDef: o,
              field: "datum.value",
              format: r.normalizedNumberFormat,
              formatType: r.normalizedNumberFormatType,
              config: r
            }),
            ...n
          };
        if (r.numberFormatType)
          return {
            text: bi({
              fieldOrDatumDef: o,
              field: "datum.value",
              format: r.numberFormat,
              formatType: r.numberFormatType,
              config: r
            }),
            ...n
          };
      }
      if (Ou(o) === "temporal" && r.timeFormatType && q(o) && !o.timeUnit)
        return {
          text: bi({
            fieldOrDatumDef: o,
            field: "datum.value",
            format: r.timeFormat,
            formatType: r.timeFormatType,
            config: r
          }),
          ...n
        };
    }
    return n;
  }
  function Tce(e) {
    return ro.reduce((t, n) => (e.component.scales[n] && (t[n] = [Ice(n, e)]), t), {});
  }
  const Dce = {
    bottom: "top",
    top: "bottom",
    left: "right",
    right: "left"
  };
  function Nce(e) {
    const { axes: t, resolve: n } = e.component, i = { top: 0, bottom: 0, right: 0, left: 0 };
    for (const r of e.children) {
      r.parseAxesAndHeaders();
      for (const o of B(r.component.axes))
        n.axis[o] = OE(e.component.resolve, o), n.axis[o] === "shared" && (t[o] = Oce(t[o], r.component.axes[o]), t[o] || (n.axis[o] = "independent", delete t[o]));
    }
    for (const r of ro) {
      for (const o of e.children)
        if (o.component.axes[r]) {
          if (n.axis[r] === "independent") {
            t[r] = (t[r] ?? []).concat(o.component.axes[r]);
            for (const s of o.component.axes[r]) {
              const { value: a, explicit: u } = s.getWithExplicit("orient");
              if (!ee(a)) {
                if (i[a] > 0 && !u) {
                  const l = Dce[a];
                  i[a] > i[l] && s.set("orient", l, !1);
                }
                i[a]++;
              }
            }
          }
          delete o.component.axes[r];
        }
      if (n.axis[r] === "independent" && t[r] && t[r].length > 1)
        for (const [o, s] of (t[r] || []).entries())
          o > 0 && s.get("grid") && !s.explicit.grid && (s.implicit.grid = !1);
    }
  }
  function Oce(e, t) {
    if (e) {
      if (e.length !== t.length)
        return;
      const n = e.length;
      for (let i = 0; i < n; i++) {
        const r = e[i], o = t[i];
        if (!!r != !!o)
          return;
        if (r && o) {
          const s = r.getWithExplicit("orient"), a = o.getWithExplicit("orient");
          if (s.explicit && a.explicit && s.value !== a.value)
            return;
          e[i] = Rce(r, o);
        }
      }
    } else
      return t.map((n) => n.clone());
    return e;
  }
  function Rce(e, t) {
    for (const n of iL) {
      const i = Vo(
        e.getWithExplicit(n),
        t.getWithExplicit(n),
        n,
        "axis",
        // Tie breaker function
        (r, o) => {
          switch (n) {
            case "title":
              return h5(r, o);
            case "gridScale":
              return {
                explicit: r.explicit,
                // keep the old explicit
                value: Ze(r.value, o.value)
              };
          }
          return Am(r, o, n, "axis");
        }
      );
      e.setWithExplicit(n, i);
    }
    return e;
  }
  function Lce(e, t, n, i, r) {
    if (t === "disable")
      return n !== void 0;
    switch (n = n || {}, t) {
      case "titleAngle":
      case "labelAngle":
        return e === (ee(n.labelAngle) ? n.labelAngle : Xc(n.labelAngle));
      case "values":
        return !!n.values;
      case "encode":
        return !!n.encoding || !!n.labelAngle;
      case "title":
        if (e === E4(i, r))
          return !0;
    }
    return e === n[t];
  }
  const Pce = /* @__PURE__ */ new Set([
    "grid",
    // Grid is an exception because we need to set grid = true to generate another grid axis
    "translate",
    // translate has dependent logic for bar's bin position and it's 0.5 by default in Vega. If a config overrides this value, we need to know.
    // the rest are not axis configs in Vega, but are in VL, so we need to set too.
    "format",
    "formatType",
    "orient",
    "labelExpr",
    "tickCount",
    "position",
    "tickMinStep"
  ]);
  function Ice(e, t) {
    var y, b;
    let n = t.axis(e);
    const i = new qE(), r = st(t.encoding[e]), { mark: o, config: s } = t, a = (n == null ? void 0 : n.orient) || ((y = s[e === "x" ? "axisX" : "axisY"]) == null ? void 0 : y.orient) || ((b = s.axis) == null ? void 0 : b.orient) || _ue(e), u = t.getScaleComponent(e).get("type"), l = mue(e, u, a, t.config), c = n !== void 0 ? !n : wb("disable", s.style, n == null ? void 0 : n.style, l).configValue;
    if (i.set("disable", c, n !== void 0), c)
      return i;
    n = n || {};
    const f = xue(r, n, e, s.style, l), d = X5(n.formatType, r, u), h = Y5(r, r.type, n.format, n.formatType, s, !0), g = {
      fieldOrDatumDef: r,
      axis: n,
      channel: e,
      model: t,
      scaleType: u,
      orient: a,
      labelAngle: f,
      format: h,
      formatType: d,
      mark: o,
      config: s
    };
    for (const v of iL) {
      const x = v in OA ? OA[v](g) : sA(v) ? n[v] : void 0, w = x !== void 0, _ = Lce(x, v, n, t, e);
      if (w && _)
        i.set(v, x, _);
      else {
        const { configValue: E = void 0, configFrom: S = void 0 } = sA(v) && v !== "values" ? wb(v, s.style, n.style, l) : {}, $ = E !== void 0;
        w && !$ ? i.set(v, x, _) : (
          // Cases need implicit values
          // 1. Axis config that aren't available in Vega
          (S !== "vgAxisConfig" || // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)
          Pce.has(v) && $ || // 3. Conditional axis values and signals
          Wf(E) || ee(E)) && i.set(v, E, !1)
        );
      }
    }
    const p = n.encoding ?? {}, m = u6.reduce((v, x) => {
      if (!i.hasAxisPart(x))
        return v;
      const w = C4(p[x] ?? {}, t), _ = x === "labels" ? Mce(t, e, w) : w;
      return _ !== void 0 && !Oe(_) && (v[x] = { update: _ }), v;
    }, {});
    return Oe(m) || i.set("encode", m, !!n.encoding || n.labelAngle !== void 0), i;
  }
  function zce({ encoding: e, size: t }) {
    for (const n of ro) {
      const i = _n(n);
      cr(t[i]) && Ao(e[n]) && (delete t[i], j(b5(i)));
    }
    return t;
  }
  const Bce = {
    vgMark: "arc",
    encodeEntry: (e) => ({
      ...oi(e, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        size: "ignore",
        orient: "ignore",
        theta: "ignore"
      }),
      ...nn("x", e, { defaultPos: "mid" }),
      ...nn("y", e, { defaultPos: "mid" }),
      // arcs are rectangles in polar coordinates
      ...Jr(e, "radius"),
      ...Jr(e, "theta")
    })
  }, Uce = {
    vgMark: "area",
    encodeEntry: (e) => ({
      ...oi(e, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        orient: "include",
        size: "ignore",
        theta: "ignore"
      }),
      ...Lg("x", e, {
        defaultPos: "zeroOrMin",
        defaultPos2: "zeroOrMin",
        range: e.markDef.orient === "horizontal"
      }),
      ...Lg("y", e, {
        defaultPos: "zeroOrMin",
        defaultPos2: "zeroOrMin",
        range: e.markDef.orient === "vertical"
      }),
      ...FE(e)
    })
  }, jce = {
    vgMark: "rect",
    encodeEntry: (e) => ({
      ...oi(e, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        orient: "ignore",
        size: "ignore",
        theta: "ignore"
      }),
      ...Jr(e, "x"),
      ...Jr(e, "y")
    })
  }, qce = {
    vgMark: "shape",
    encodeEntry: (e) => ({
      ...oi(e, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        size: "ignore",
        orient: "ignore",
        theta: "ignore"
      })
    }),
    postEncodingTransform: (e) => {
      const { encoding: t } = e, n = t.shape;
      return [{
        type: "geoshape",
        projection: e.projectionName(),
        // as: 'shape',
        ...n && q(n) && n.type === ul ? { field: V(n, { expr: "datum" }) } : {}
      }];
    }
  }, Wce = {
    vgMark: "image",
    encodeEntry: (e) => ({
      ...oi(e, {
        align: "ignore",
        baseline: "ignore",
        color: "ignore",
        orient: "ignore",
        size: "ignore",
        theta: "ignore"
      }),
      ...Jr(e, "x"),
      ...Jr(e, "y"),
      ...AE(e, "url")
    })
  }, Hce = {
    vgMark: "line",
    encodeEntry: (e) => ({
      ...oi(e, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        size: "ignore",
        orient: "ignore",
        theta: "ignore"
      }),
      ...nn("x", e, { defaultPos: "mid" }),
      ...nn("y", e, { defaultPos: "mid" }),
      ...$t("size", e, {
        vgChannel: "strokeWidth"
        // VL's line size is strokeWidth
      }),
      ...FE(e)
    })
  }, Gce = {
    vgMark: "trail",
    encodeEntry: (e) => ({
      ...oi(e, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        size: "include",
        orient: "ignore",
        theta: "ignore"
      }),
      ...nn("x", e, { defaultPos: "mid" }),
      ...nn("y", e, { defaultPos: "mid" }),
      ...$t("size", e),
      ...FE(e)
    })
  };
  function WE(e, t) {
    const { config: n } = e;
    return {
      ...oi(e, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        size: "include",
        orient: "ignore",
        theta: "ignore"
      }),
      ...nn("x", e, { defaultPos: "mid" }),
      ...nn("y", e, { defaultPos: "mid" }),
      ...$t("size", e),
      ...$t("angle", e),
      ...Vce(e, n, t)
    };
  }
  function Vce(e, t, n) {
    return n ? { shape: { value: n } } : $t("shape", e);
  }
  const Yce = {
    vgMark: "symbol",
    encodeEntry: (e) => WE(e)
  }, Xce = {
    vgMark: "symbol",
    encodeEntry: (e) => WE(e, "circle")
  }, Kce = {
    vgMark: "symbol",
    encodeEntry: (e) => WE(e, "square")
  }, Jce = {
    vgMark: "rect",
    encodeEntry: (e) => ({
      ...oi(e, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        orient: "ignore",
        size: "ignore",
        theta: "ignore"
      }),
      ...Jr(e, "x"),
      ...Jr(e, "y")
    })
  }, Qce = {
    vgMark: "rule",
    encodeEntry: (e) => {
      const { markDef: t } = e, n = t.orient;
      return !e.encoding.x && !e.encoding.y && !e.encoding.latitude && !e.encoding.longitude ? {} : {
        ...oi(e, {
          align: "ignore",
          baseline: "ignore",
          color: "include",
          orient: "ignore",
          size: "ignore",
          theta: "ignore"
        }),
        ...Lg("x", e, {
          defaultPos: n === "horizontal" ? "zeroOrMax" : "mid",
          defaultPos2: "zeroOrMin",
          range: n !== "vertical"
          // include x2 for horizontal or line segment rule
        }),
        ...Lg("y", e, {
          defaultPos: n === "vertical" ? "zeroOrMax" : "mid",
          defaultPos2: "zeroOrMin",
          range: n !== "horizontal"
          // include y2 for vertical or line segment rule
        }),
        ...$t("size", e, {
          vgChannel: "strokeWidth"
          // VL's rule size is strokeWidth
        })
      };
    }
  }, Zce = {
    vgMark: "text",
    encodeEntry: (e) => {
      const { config: t, encoding: n } = e;
      return {
        ...oi(e, {
          align: "include",
          baseline: "include",
          color: "include",
          size: "ignore",
          orient: "ignore",
          theta: "include"
        }),
        ...nn("x", e, { defaultPos: "mid" }),
        ...nn("y", e, { defaultPos: "mid" }),
        ...AE(e),
        ...$t("size", e, {
          vgChannel: "fontSize"
          // VL's text size is fontSize
        }),
        ...$t("angle", e),
        ...MA("align", efe(e.markDef, n, t)),
        ...MA("baseline", tfe(e.markDef, n, t)),
        ...nn("radius", e, { defaultPos: null }),
        ...nn("theta", e, { defaultPos: null })
      };
    }
  };
  function efe(e, t, n) {
    if (Ne("align", e, n) === void 0)
      return "center";
  }
  function tfe(e, t, n) {
    if (Ne("baseline", e, n) === void 0)
      return "middle";
  }
  const nfe = {
    vgMark: "rect",
    encodeEntry: (e) => {
      const { config: t, markDef: n } = e, i = n.orient, r = i === "horizontal" ? "x" : "y", o = i === "horizontal" ? "y" : "x", s = i === "horizontal" ? "height" : "width";
      return {
        ...oi(e, {
          align: "ignore",
          baseline: "ignore",
          color: "include",
          orient: "ignore",
          size: "ignore",
          theta: "ignore"
        }),
        ...Jr(e, r),
        ...nn(o, e, {
          defaultPos: "mid",
          vgChannel: o === "y" ? "yc" : "xc"
        }),
        [s]: Ue(Ne("thickness", n, t))
      };
    }
  }, Fd = {
    arc: Bce,
    area: Uce,
    bar: jce,
    circle: Xce,
    geoshape: qce,
    image: Wce,
    line: Hce,
    point: Yce,
    rect: Jce,
    rule: Qce,
    square: Kce,
    text: Zce,
    tick: nfe,
    trail: Gce
  };
  function ife(e) {
    if (ye([mm, gm, foe], e.mark)) {
      const t = p6(e.mark, e.encoding);
      if (t.length > 0)
        return rfe(e, t);
    } else if (e.mark === pm) {
      const t = ab.some((n) => Ne(n, e.markDef, e.config));
      if (e.stack && !e.fieldDef("size") && t)
        return ofe(e);
    }
    return HE(e);
  }
  const KA = "faceted_path_";
  function rfe(e, t) {
    return [
      {
        name: e.getName("pathgroup"),
        type: "group",
        from: {
          facet: {
            name: KA + e.requestDataName(Ke.Main),
            data: e.requestDataName(Ke.Main),
            groupby: t
          }
        },
        encode: {
          update: {
            width: { field: { group: "width" } },
            height: { field: { group: "height" } }
          }
        },
        // With subfacet for line/area group, need to use faceted data from above.
        marks: HE(e, { fromPrefix: KA })
      }
    ];
  }
  const JA = "stack_group_";
  function ofe(e) {
    var l;
    const [t] = HE(e, { fromPrefix: JA }), n = e.scaleName(e.stack.fieldChannel), i = (c = {}) => e.vgField(e.stack.fieldChannel, c), r = (c, f) => {
      const d = [
        i({ prefix: "min", suffix: "start", expr: f }),
        i({ prefix: "max", suffix: "start", expr: f }),
        i({ prefix: "min", suffix: "end", expr: f }),
        i({ prefix: "max", suffix: "end", expr: f })
      ];
      return `${c}(${d.map((h) => `scale('${n}',${h})`).join(",")})`;
    };
    let o, s;
    e.stack.fieldChannel === "x" ? (o = {
      ...Au(t.encode.update, ["y", "yc", "y2", "height", ...ab]),
      x: { signal: r("min", "datum") },
      x2: { signal: r("max", "datum") },
      clip: { value: !0 }
    }, s = {
      x: { field: { group: "x" }, mult: -1 },
      height: { field: { group: "height" } }
    }, t.encode.update = {
      ...mn(t.encode.update, ["y", "yc", "y2"]),
      height: { field: { group: "height" } }
    }) : (o = {
      ...Au(t.encode.update, ["x", "xc", "x2", "width"]),
      y: { signal: r("min", "datum") },
      y2: { signal: r("max", "datum") },
      clip: { value: !0 }
    }, s = {
      y: { field: { group: "y" }, mult: -1 },
      width: { field: { group: "width" } }
    }, t.encode.update = {
      ...mn(t.encode.update, ["x", "xc", "x2"]),
      width: { field: { group: "width" } }
    });
    for (const c of ab) {
      const f = ur(c, e.markDef, e.config);
      t.encode.update[c] ? (o[c] = t.encode.update[c], delete t.encode.update[c]) : f && (o[c] = Ue(f)), f && (t.encode.update[c] = { value: 0 });
    }
    const a = [];
    if (((l = e.stack.groupbyChannels) == null ? void 0 : l.length) > 0)
      for (const c of e.stack.groupbyChannels) {
        const f = e.fieldDef(c), d = V(f);
        d && a.push(d), (f != null && f.bin || f != null && f.timeUnit) && a.push(V(f, { binSuffix: "end" }));
      }
    return o = [
      "stroke",
      "strokeWidth",
      "strokeJoin",
      "strokeCap",
      "strokeDash",
      "strokeDashOffset",
      "strokeMiterLimit",
      "strokeOpacity"
    ].reduce((c, f) => {
      if (t.encode.update[f])
        return { ...c, [f]: t.encode.update[f] };
      {
        const d = ur(f, e.markDef, e.config);
        return d !== void 0 ? { ...c, [f]: Ue(d) } : c;
      }
    }, o), o.stroke && (o.strokeForeground = { value: !0 }, o.strokeOffset = { value: 0 }), [
      {
        type: "group",
        from: {
          facet: {
            data: e.requestDataName(Ke.Main),
            name: JA + e.requestDataName(Ke.Main),
            groupby: a,
            aggregate: {
              fields: [
                i({ suffix: "start" }),
                i({ suffix: "start" }),
                i({ suffix: "end" }),
                i({ suffix: "end" })
              ],
              ops: ["min", "max", "min", "max"]
            }
          }
        },
        encode: {
          update: o
        },
        marks: [
          {
            type: "group",
            encode: { update: s },
            marks: [t]
          }
        ]
      }
    ];
  }
  function sfe(e) {
    const { encoding: t, stack: n, mark: i, markDef: r, config: o } = e, s = t.order;
    if (!(!P(s) && $i(s) && ob(s.value) || !s && ob(Ne("order", r, o)))) {
      if ((P(s) || q(s)) && !n)
        return c5(s, { expr: "datum" });
      if (ls(i)) {
        const a = r.orient === "horizontal" ? "y" : "x", u = t[a];
        if (q(u))
          return { field: a };
      }
    }
  }
  function HE(e, t = { fromPrefix: "" }) {
    const { mark: n, markDef: i, encoding: r, config: o } = e, s = Ze(i.clip, afe(e), ufe(e)), a = u5(i), u = r.key, l = sfe(e), c = lfe(e), f = Ne("aria", i, o), d = Fd[n].postEncodingTransform ? Fd[n].postEncodingTransform(e) : null;
    return [
      {
        name: e.getName("marks"),
        type: Fd[n].vgMark,
        ...s ? { clip: s } : {},
        ...a ? { style: a } : {},
        ...u ? { key: u.field } : {},
        ...l ? { sort: l } : {},
        ...c || {},
        ...f === !1 ? { aria: f } : {},
        from: { data: t.fromPrefix + e.requestDataName(Ke.Main) },
        encode: {
          update: Fd[n].encodeEntry(e)
        },
        ...d ? {
          transform: d
        } : {}
      }
    ];
  }
  function afe(e) {
    const t = e.getScaleComponent("x"), n = e.getScaleComponent("y");
    return t != null && t.get("selectionExtent") || n != null && n.get("selectionExtent") ? !0 : void 0;
  }
  function ufe(e) {
    const t = e.component.projection;
    return t && !t.isFit ? !0 : void 0;
  }
  function lfe(e) {
    if (!e.component.selection)
      return null;
    const t = B(e.component.selection).length;
    let n = t, i = e.parent;
    for (; i && n === 0; )
      n = B(i.component.selection).length, i = i.parent;
    return n ? {
      interactive: t > 0 || e.mark === "geoshape" || !!e.encoding.tooltip || !!e.markDef.tooltip
    } : null;
  }
  class rL extends Z4 {
    constructor(t, n, i, r = {}, o) {
      super(t, "unit", n, i, o, void 0, uA(t) ? t.view : void 0), this.specifiedScales = {}, this.specifiedAxes = {}, this.specifiedLegends = {}, this.specifiedProjection = {}, this.selection = [], this.children = [];
      const s = lr(t.mark) ? { ...t.mark } : { type: t.mark }, a = s.type;
      s.filled === void 0 && (s.filled = Yse(s, o, {
        graticule: t.data && $E(t.data)
      }));
      const u = this.encoding = Qoe(t.encoding || {}, a, s.filled, o);
      this.markDef = L6(s, u, o), this.size = zce({
        encoding: u,
        size: uA(t) ? {
          ...r,
          ...t.width ? { width: t.width } : {},
          ...t.height ? { height: t.height } : {}
        } : r
      }), this.stack = R6(this.markDef, u), this.specifiedScales = this.initScales(a, u), this.specifiedAxes = this.initAxes(u), this.specifiedLegends = this.initLegends(u), this.specifiedProjection = t.projection, this.selection = (t.params ?? []).filter((l) => xE(l));
    }
    get hasProjection() {
      const { encoding: t } = this, n = this.mark === U5, i = t && Yne.some((r) => le(t[r]));
      return n || i;
    }
    /**
     * Return specified Vega-Lite scale domain for a particular channel
     * @param channel
     */
    scaleDomain(t) {
      const n = this.specifiedScales[t];
      return n ? n.domain : void 0;
    }
    axis(t) {
      return this.specifiedAxes[t];
    }
    legend(t) {
      return this.specifiedLegends[t];
    }
    initScales(t, n) {
      return Iw.reduce((i, r) => {
        const o = st(n[r]);
        return o && (i[r] = this.initScale(o.scale ?? {})), i;
      }, {});
    }
    initScale(t) {
      const { domain: n, range: i } = t, r = _t(t);
      return P(n) && (r.domain = n.map(Fn)), P(i) && (r.range = i.map(Fn)), r;
    }
    initAxes(t) {
      return ro.reduce((n, i) => {
        const r = t[i];
        if (le(r) || i === We && le(t.x2) || i === xt && le(t.y2)) {
          const o = le(r) ? r.axis : void 0;
          n[i] = o && this.initAxis({ ...o });
        }
        return n;
      }, {});
    }
    initAxis(t) {
      const n = B(t), i = {};
      for (const r of n) {
        const o = t[r];
        i[r] = Wf(o) ? a5(o) : Fn(o);
      }
      return i;
    }
    initLegends(t) {
      return rie.reduce((n, i) => {
        const r = st(t[i]);
        if (r && sie(i)) {
          const o = r.legend;
          n[i] = o && _t(o);
        }
        return n;
      }, {});
    }
    parseData() {
      this.component.data = Wm(this);
    }
    parseLayoutSize() {
      Ece(this);
    }
    parseSelections() {
      this.component.selection = due(this, this.selection);
    }
    parseMarkGroup() {
      this.component.mark = ife(this);
    }
    parseAxesAndHeaders() {
      this.component.axes = Tce(this);
    }
    assembleSelectionTopLevelSignals(t) {
      return Lae(this, t);
    }
    assembleSignals() {
      return [...v4(this), ...Oae(this, [])];
    }
    assembleSelectionData(t) {
      return Pae(this, t);
    }
    assembleLayout() {
      return null;
    }
    assembleLayoutSignals() {
      return NE(this);
    }
    assembleMarks() {
      let t = this.component.mark ?? [];
      return (!this.parent || !hl(this.parent)) && (t = K6(this, t)), t.map(this.correctDataNames);
    }
    assembleGroupStyle() {
      const { style: t } = this.view || {};
      return t !== void 0 ? t : this.encoding.x || this.encoding.y ? "cell" : "view";
    }
    getMapping() {
      return this.encoding;
    }
    get mark() {
      return this.markDef.type;
    }
    channelHasField(t) {
      return Us(this.encoding, t);
    }
    fieldDef(t) {
      const n = this.encoding[t];
      return ki(n);
    }
    typedFieldDef(t) {
      const n = this.fieldDef(t);
      return un(n) ? n : null;
    }
  }
  class GE extends UE {
    constructor(t, n, i, r, o) {
      super(t, "layer", n, i, o, t.resolve, t.view);
      const s = {
        ...r,
        ...t.width ? { width: t.width } : {},
        ...t.height ? { height: t.height } : {}
      };
      this.children = t.layer.map((a, u) => {
        if (km(a))
          return new GE(a, this, this.getName(`layer_${u}`), s, o);
        if (oo(a))
          return new rL(a, this, this.getName(`layer_${u}`), s, o);
        throw new Error(Bw(a));
      });
    }
    parseData() {
      this.component.data = Wm(this);
      for (const t of this.children)
        t.parseData();
    }
    parseLayoutSize() {
      xce(this);
    }
    parseSelections() {
      this.component.selection = {};
      for (const t of this.children) {
        t.parseSelections();
        for (const n of B(t.component.selection))
          this.component.selection[n] = t.component.selection[n];
      }
    }
    parseMarkGroup() {
      for (const t of this.children)
        t.parseMarkGroup();
    }
    parseAxesAndHeaders() {
      Nce(this);
    }
    assembleSelectionTopLevelSignals(t) {
      return this.children.reduce((n, i) => i.assembleSelectionTopLevelSignals(n), t);
    }
    // TODO: Support same named selections across children.
    assembleSignals() {
      return this.children.reduce((t, n) => t.concat(n.assembleSignals()), v4(this));
    }
    assembleLayoutSignals() {
      return this.children.reduce((t, n) => t.concat(n.assembleLayoutSignals()), NE(this));
    }
    assembleSelectionData(t) {
      return this.children.reduce((n, i) => i.assembleSelectionData(n), t);
    }
    assembleGroupStyle() {
      const t = /* @__PURE__ */ new Set();
      for (const i of this.children)
        for (const r of X(i.assembleGroupStyle()))
          t.add(r);
      const n = Array.from(t);
      return n.length > 1 ? n : n.length === 1 ? n[0] : void 0;
    }
    assembleTitle() {
      let t = super.assembleTitle();
      if (t)
        return t;
      for (const n of this.children)
        if (t = n.assembleTitle(), t)
          return t;
    }
    assembleLayout() {
      return null;
    }
    assembleMarks() {
      return Iae(this, this.children.flatMap((t) => t.assembleMarks()));
    }
    assembleLegends() {
      return this.children.reduce((t, n) => t.concat(n.assembleLegends()), L4(this));
    }
  }
  function VE(e, t, n, i, r) {
    if (vm(e))
      return new _c(e, t, n, r);
    if (km(e))
      return new GE(e, t, n, i, r);
    if (oo(e))
      return new rL(e, t, n, i, r);
    if (Ese(e))
      return new Ace(e, t, n, r);
    throw new Error(Bw(e));
  }
  function cfe(e, t = {}) {
    t.logger && $re(t.logger), t.fieldTitle && o6(t.fieldTitle);
    try {
      const n = O6(Wu(t.config, e.config)), i = q6(e, n), r = VE(i, null, "", void 0, n);
      return r.parse(), Ole(r.component.data, r), {
        spec: dfe(r, ffe(e, i.autosize, n, r), e.datasets, e.usermeta),
        normalized: i
      };
    } finally {
      t.logger && kre(), t.fieldTitle && qoe();
    }
  }
  function ffe(e, t, n, i) {
    const r = i.component.layoutSize.get("width"), o = i.component.layoutSize.get("height");
    if (t === void 0 ? (t = { type: "pad" }, i.hasAxisOrientSignalRef() && (t.resize = !0)) : K(t) && (t = { type: t }), r && o && Fae(t.type)) {
      if (r === "step" && o === "step")
        j(Gk()), t.type = "pad";
      else if (r === "step" || o === "step") {
        const s = r === "step" ? "width" : "height";
        j(Gk(um(s)));
        const a = s === "width" ? "height" : "width";
        t.type = Mae(a);
      }
    }
    return {
      ...B(t).length === 1 && t.type ? t.type === "pad" ? {} : { autosize: t.type } : { autosize: t },
      ...xA(n, !1),
      ...xA(e, !0)
    };
  }
  function dfe(e, t, n = {}, i) {
    const r = e.config ? Lse(e.config) : void 0, o = [].concat(
      e.assembleSelectionData([]),
      // only assemble data in the root
      mce(e.component.data, n)
    ), s = e.assembleProjections(), a = e.assembleTitle(), u = e.assembleGroupStyle(), l = e.assembleGroupEncodeEntry(!0);
    let c = e.assembleLayoutSignals();
    c = c.filter((h) => (h.name === "width" || h.name === "height") && h.value !== void 0 ? (t[h.name] = +h.value, !1) : !0);
    const { params: f, ...d } = t;
    return {
      $schema: "https://vega.github.io/schema/vega/v5.json",
      ...e.description ? { description: e.description } : {},
      ...d,
      ...a ? { title: a } : {},
      ...u ? { style: u } : {},
      ...l ? { encode: { update: l } } : {},
      data: o,
      ...s.length > 0 ? { projections: s } : {},
      ...e.assembleGroup([
        ...c,
        ...e.assembleSelectionTopLevelSignals([]),
        ...M6(f)
      ]),
      ...r ? { config: r } : {},
      ...i ? { usermeta: i } : {}
    };
  }
  const hfe = jne.version, gfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    accessPathDepth: Fu,
    accessPathWithDatum: Mw,
    compile: cfe,
    contains: ye,
    deepEqual: Dn,
    deleteNestedProperty: kg,
    duplicate: ue,
    entries: Wo,
    every: Aw,
    fieldIntersection: Fw,
    flatAccessWithDatum: jR,
    getFirstDefined: Ze,
    hasIntersection: Cw,
    hasProperty: U,
    hash: be,
    internalField: HR,
    isBoolean: Yc,
    isEmpty: Oe,
    isEqual: Wne,
    isInternalField: GR,
    isNullOrFalse: ob,
    isNumeric: nm,
    keys: B,
    logicalExpr: wc,
    mergeDeep: BR,
    never: zR,
    normalize: q6,
    normalizeAngle: Xc,
    omit: mn,
    pick: Au,
    prefixGenerator: sb,
    removePathFromField: sl,
    replaceAll: na,
    replacePathInField: ti,
    resetIdCounter: Gne,
    setEqual: UR,
    some: Cu,
    stringify: Re,
    titleCase: Nf,
    unique: Xi,
    uniqueId: WR,
    vals: Ft,
    varName: qe,
    version: hfe
  }, Symbol.toStringTag, { value: "Module" }));
  function oL(e) {
    const [t, n] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e).slice(1, 3);
    return { library: t, version: n };
  }
  var pfe = "vega-themes", mfe = "2.15.0", yfe = "Themes for stylized Vega and Vega-Lite visualizations.", bfe = ["vega", "vega-lite", "themes", "style"], vfe = "BSD-3-Clause", xfe = {
    name: "UW Interactive Data Lab",
    url: "https://idl.cs.washington.edu"
  }, wfe = [{
    name: "Emily Gu",
    url: "https://github.com/emilygu"
  }, {
    name: "Arvind Satyanarayan",
    url: "http://arvindsatya.com"
  }, {
    name: "Jeffrey Heer",
    url: "https://idl.cs.washington.edu"
  }, {
    name: "Dominik Moritz",
    url: "https://www.domoritz.de"
  }], Efe = "build/vega-themes.js", YE = "build/vega-themes.module.js", _fe = "build/vega-themes.min.js", Sfe = "build/vega-themes.min.js", $fe = "build/vega-themes.module.d.ts", kfe = {
    type: "git",
    url: "https://github.com/vega/vega-themes.git"
  }, Afe = ["src", "build"], Cfe = {
    prebuild: "yarn clean",
    build: "rollup -c",
    clean: "rimraf build && rimraf examples/build",
    "copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
    "copy:build": "rsync -r build/* examples/build",
    "deploy:gh": "yarn build && mkdir -p examples/build && rsync -r build/* examples/build && gh-pages -d examples",
    preversion: "yarn lint",
    serve: "browser-sync start -s -f build examples --serveStatic examples",
    start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
    format: "eslint . --fix",
    lint: "eslint .",
    release: "release-it"
  }, Ffe = {
    "@babel/core": "^7.24.6",
    "@babel/plugin-transform-runtime": "^7.24.6",
    "@babel/preset-env": "^7.24.6",
    "@babel/preset-typescript": "^7.24.6",
    "@release-it/conventional-changelog": "^8.0.1",
    "@rollup/plugin-json": "^6.1.0",
    "@rollup/plugin-node-resolve": "^15.2.3",
    "@rollup/plugin-terser": "^0.4.4",
    "@typescript-eslint/eslint-plugin": "^7.11.0",
    "@typescript-eslint/parser": "^7.11.0",
    "browser-sync": "^3.0.2",
    concurrently: "^8.2.2",
    eslint: "^8.45.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "gh-pages": "^6.1.1",
    prettier: "^3.2.5",
    "release-it": "^17.3.0",
    rollup: "^4.18.0",
    "rollup-plugin-bundle-size": "^1.0.3",
    "rollup-plugin-ts": "^3.4.5",
    typescript: "^5.4.5",
    vega: "^5.25.0",
    "vega-lite": "^5.9.3"
  }, Mfe = {
    vega: "*",
    "vega-lite": "*"
  }, Tfe = {}, Dfe = {
    name: pfe,
    version: mfe,
    description: yfe,
    keywords: bfe,
    license: vfe,
    author: xfe,
    contributors: wfe,
    main: Efe,
    module: YE,
    unpkg: _fe,
    jsdelivr: Sfe,
    types: $fe,
    repository: kfe,
    files: Afe,
    scripts: Cfe,
    devDependencies: Ffe,
    peerDependencies: Mfe,
    dependencies: Tfe
  };
  const Ba = "#fff", QA = "#888", Nfe = {
    background: "#333",
    view: {
      stroke: QA
    },
    title: {
      color: Ba,
      subtitleColor: Ba
    },
    style: {
      "guide-label": {
        fill: Ba
      },
      "guide-title": {
        fill: Ba
      }
    },
    axis: {
      domainColor: Ba,
      gridColor: QA,
      tickColor: Ba
    }
  }, ps = "#4572a7", Ofe = {
    background: "#fff",
    arc: {
      fill: ps
    },
    area: {
      fill: ps
    },
    line: {
      stroke: ps,
      strokeWidth: 2
    },
    path: {
      stroke: ps
    },
    rect: {
      fill: ps
    },
    shape: {
      stroke: ps
    },
    symbol: {
      fill: ps,
      strokeWidth: 1.5,
      size: 50
    },
    axis: {
      bandPosition: 0.5,
      grid: !0,
      gridColor: "#000000",
      gridOpacity: 1,
      gridWidth: 0.5,
      labelPadding: 10,
      tickSize: 5,
      tickWidth: 0.5
    },
    axisBand: {
      grid: !1,
      tickExtra: !0
    },
    legend: {
      labelBaseline: "middle",
      labelFontSize: 11,
      symbolSize: 50,
      symbolType: "square"
    },
    range: {
      category: ["#4572a7", "#aa4643", "#8aa453", "#71598e", "#4598ae", "#d98445", "#94aace", "#d09393", "#b9cc98", "#a99cbc"]
    }
  }, ms = "#30a2da", f1 = "#cbcbcb", Rfe = "#999", Lfe = "#333", ZA = "#f0f0f0", eC = "#333", Pfe = {
    arc: {
      fill: ms
    },
    area: {
      fill: ms
    },
    axis: {
      domainColor: f1,
      grid: !0,
      gridColor: f1,
      gridWidth: 1,
      labelColor: Rfe,
      labelFontSize: 10,
      titleColor: Lfe,
      tickColor: f1,
      tickSize: 10,
      titleFontSize: 14,
      titlePadding: 10,
      labelPadding: 4
    },
    axisBand: {
      grid: !1
    },
    background: ZA,
    group: {
      fill: ZA
    },
    legend: {
      labelColor: eC,
      labelFontSize: 11,
      padding: 1,
      symbolSize: 30,
      symbolType: "square",
      titleColor: eC,
      titleFontSize: 14,
      titlePadding: 10
    },
    line: {
      stroke: ms,
      strokeWidth: 2
    },
    path: {
      stroke: ms,
      strokeWidth: 0.5
    },
    rect: {
      fill: ms
    },
    range: {
      category: ["#30a2da", "#fc4f30", "#e5ae38", "#6d904f", "#8b8b8b", "#b96db8", "#ff9e27", "#56cc60", "#52d2ca", "#52689e", "#545454", "#9fe4f8"],
      diverging: ["#cc0020", "#e77866", "#f6e7e1", "#d6e8ed", "#91bfd9", "#1d78b5"],
      heatmap: ["#d6e8ed", "#cee0e5", "#91bfd9", "#549cc6", "#1d78b5"]
    },
    point: {
      filled: !0,
      shape: "circle"
    },
    shape: {
      stroke: ms
    },
    bar: {
      binSpacing: 2,
      fill: ms,
      stroke: null
    },
    title: {
      anchor: "start",
      fontSize: 24,
      fontWeight: 600,
      offset: 20
    }
  }, ys = "#000", Ife = {
    group: {
      fill: "#e5e5e5"
    },
    arc: {
      fill: ys
    },
    area: {
      fill: ys
    },
    line: {
      stroke: ys
    },
    path: {
      stroke: ys
    },
    rect: {
      fill: ys
    },
    shape: {
      stroke: ys
    },
    symbol: {
      fill: ys,
      size: 40
    },
    axis: {
      domain: !1,
      grid: !0,
      gridColor: "#FFFFFF",
      gridOpacity: 1,
      labelColor: "#7F7F7F",
      labelPadding: 4,
      tickColor: "#7F7F7F",
      tickSize: 5.67,
      titleFontSize: 16,
      titleFontWeight: "normal"
    },
    legend: {
      labelBaseline: "middle",
      labelFontSize: 11,
      symbolSize: 40
    },
    range: {
      category: ["#000000", "#7F7F7F", "#1A1A1A", "#999999", "#333333", "#B0B0B0", "#4D4D4D", "#C9C9C9", "#666666", "#DCDCDC"]
    }
  }, zfe = 22, Bfe = "normal", tC = "Benton Gothic, sans-serif", nC = 11.5, Ufe = "normal", bs = "#82c6df", d1 = "Benton Gothic Bold, sans-serif", iC = "normal", rC = 13, Ll = {
    "category-6": ["#ec8431", "#829eb1", "#c89d29", "#3580b1", "#adc839", "#ab7fb4"],
    "fire-7": ["#fbf2c7", "#f9e39c", "#f8d36e", "#f4bb6a", "#e68a4f", "#d15a40", "#ab4232"],
    "fireandice-6": ["#e68a4f", "#f4bb6a", "#f9e39c", "#dadfe2", "#a6b7c6", "#849eae"],
    "ice-7": ["#edefee", "#dadfe2", "#c4ccd2", "#a6b7c6", "#849eae", "#607785", "#47525d"]
  }, jfe = {
    background: "#ffffff",
    title: {
      anchor: "start",
      color: "#000000",
      font: d1,
      fontSize: zfe,
      fontWeight: Bfe
    },
    arc: {
      fill: bs
    },
    area: {
      fill: bs
    },
    line: {
      stroke: bs,
      strokeWidth: 2
    },
    path: {
      stroke: bs
    },
    rect: {
      fill: bs
    },
    shape: {
      stroke: bs
    },
    symbol: {
      fill: bs,
      size: 30
    },
    axis: {
      labelFont: tC,
      labelFontSize: nC,
      labelFontWeight: Ufe,
      titleFont: d1,
      titleFontSize: rC,
      titleFontWeight: iC
    },
    axisX: {
      labelAngle: 0,
      labelPadding: 4,
      tickSize: 3
    },
    axisY: {
      labelBaseline: "middle",
      maxExtent: 45,
      minExtent: 45,
      tickSize: 2,
      titleAlign: "left",
      titleAngle: 0,
      titleX: -45,
      titleY: -11
    },
    legend: {
      labelFont: tC,
      labelFontSize: nC,
      symbolType: "square",
      titleFont: d1,
      titleFontSize: rC,
      titleFontWeight: iC
    },
    range: {
      category: Ll["category-6"],
      diverging: Ll["fireandice-6"],
      heatmap: Ll["fire-7"],
      ordinal: Ll["fire-7"],
      ramp: Ll["fire-7"]
    }
  }, vs = "#ab5787", Md = "#979797", qfe = {
    background: "#f9f9f9",
    arc: {
      fill: vs
    },
    area: {
      fill: vs
    },
    line: {
      stroke: vs
    },
    path: {
      stroke: vs
    },
    rect: {
      fill: vs
    },
    shape: {
      stroke: vs
    },
    symbol: {
      fill: vs,
      size: 30
    },
    axis: {
      domainColor: Md,
      domainWidth: 0.5,
      gridWidth: 0.2,
      labelColor: Md,
      tickColor: Md,
      tickWidth: 0.2,
      titleColor: Md
    },
    axisBand: {
      grid: !1
    },
    axisX: {
      grid: !0,
      tickSize: 10
    },
    axisY: {
      domain: !1,
      grid: !0,
      tickSize: 0
    },
    legend: {
      labelFontSize: 11,
      padding: 1,
      symbolSize: 30,
      symbolType: "square"
    },
    range: {
      category: ["#ab5787", "#51b2e5", "#703c5c", "#168dd9", "#d190b6", "#00609f", "#d365ba", "#154866", "#666666", "#c4c4c4"]
    }
  }, xs = "#3e5c69", Wfe = {
    background: "#fff",
    arc: {
      fill: xs
    },
    area: {
      fill: xs
    },
    line: {
      stroke: xs
    },
    path: {
      stroke: xs
    },
    rect: {
      fill: xs
    },
    shape: {
      stroke: xs
    },
    symbol: {
      fill: xs
    },
    axis: {
      domainWidth: 0.5,
      grid: !0,
      labelPadding: 2,
      tickSize: 5,
      tickWidth: 0.5,
      titleFontWeight: "normal"
    },
    axisBand: {
      grid: !1
    },
    axisX: {
      gridWidth: 0.2
    },
    axisY: {
      gridDash: [3],
      gridWidth: 0.4
    },
    legend: {
      labelFontSize: 11,
      padding: 1,
      symbolType: "square"
    },
    range: {
      category: ["#3e5c69", "#6793a6", "#182429", "#0570b0", "#3690c0", "#74a9cf", "#a6bddb", "#e2ddf2"]
    }
  }, Un = "#1696d2", oC = "#000000", Hfe = "#FFFFFF", Td = "Lato", h1 = "Lato", Gfe = "Lato", Vfe = "#DEDDDD", Yfe = 18, Pl = {
    "main-colors": ["#1696d2", "#d2d2d2", "#000000", "#fdbf11", "#ec008b", "#55b748", "#5c5859", "#db2b27"],
    "shades-blue": ["#CFE8F3", "#A2D4EC", "#73BFE2", "#46ABDB", "#1696D2", "#12719E", "#0A4C6A", "#062635"],
    "shades-gray": ["#F5F5F5", "#ECECEC", "#E3E3E3", "#DCDBDB", "#D2D2D2", "#9D9D9D", "#696969", "#353535"],
    "shades-yellow": ["#FFF2CF", "#FCE39E", "#FDD870", "#FCCB41", "#FDBF11", "#E88E2D", "#CA5800", "#843215"],
    "shades-magenta": ["#F5CBDF", "#EB99C2", "#E46AA7", "#E54096", "#EC008B", "#AF1F6B", "#761548", "#351123"],
    "shades-green": ["#DCEDD9", "#BCDEB4", "#98CF90", "#78C26D", "#55B748", "#408941", "#2C5C2D", "#1A2E19"],
    "shades-black": ["#D5D5D4", "#ADABAC", "#848081", "#5C5859", "#332D2F", "#262223", "#1A1717", "#0E0C0D"],
    "shades-red": ["#F8D5D4", "#F1AAA9", "#E9807D", "#E25552", "#DB2B27", "#A4201D", "#6E1614", "#370B0A"],
    "one-group": ["#1696d2", "#000000"],
    "two-groups-cat-1": ["#1696d2", "#000000"],
    "two-groups-cat-2": ["#1696d2", "#fdbf11"],
    "two-groups-cat-3": ["#1696d2", "#db2b27"],
    "two-groups-seq": ["#a2d4ec", "#1696d2"],
    "three-groups-cat": ["#1696d2", "#fdbf11", "#000000"],
    "three-groups-seq": ["#a2d4ec", "#1696d2", "#0a4c6a"],
    "four-groups-cat-1": ["#000000", "#d2d2d2", "#fdbf11", "#1696d2"],
    "four-groups-cat-2": ["#1696d2", "#ec0008b", "#fdbf11", "#5c5859"],
    "four-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a"],
    "five-groups-cat-1": ["#1696d2", "#fdbf11", "#d2d2d2", "#ec008b", "#000000"],
    "five-groups-cat-2": ["#1696d2", "#0a4c6a", "#d2d2d2", "#fdbf11", "#332d2f"],
    "five-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a", "#000000"],
    "six-groups-cat-1": ["#1696d2", "#ec008b", "#fdbf11", "#000000", "#d2d2d2", "#55b748"],
    "six-groups-cat-2": ["#1696d2", "#d2d2d2", "#ec008b", "#fdbf11", "#332d2f", "#0a4c6a"],
    "six-groups-seq": ["#cfe8f3", "#a2d4ec", "#73bfe2", "#46abdb", "#1696d2", "#12719e"],
    "diverging-colors": ["#ca5800", "#fdbf11", "#fdd870", "#fff2cf", "#cfe8f3", "#73bfe2", "#1696d2", "#0a4c6a"]
  }, Xfe = {
    background: Hfe,
    title: {
      anchor: "start",
      fontSize: Yfe,
      font: Td
    },
    axisX: {
      domain: !0,
      domainColor: oC,
      domainWidth: 1,
      grid: !1,
      labelFontSize: 12,
      labelFont: h1,
      labelAngle: 0,
      tickColor: oC,
      tickSize: 5,
      titleFontSize: 12,
      titlePadding: 10,
      titleFont: Td
    },
    axisY: {
      domain: !1,
      domainWidth: 1,
      grid: !0,
      gridColor: Vfe,
      gridWidth: 1,
      labelFontSize: 12,
      labelFont: h1,
      labelPadding: 8,
      ticks: !1,
      titleFontSize: 12,
      titlePadding: 10,
      titleFont: Td,
      titleAngle: 0,
      titleY: -10,
      titleX: 18
    },
    legend: {
      labelFontSize: 12,
      labelFont: h1,
      symbolSize: 100,
      titleFontSize: 12,
      titlePadding: 10,
      titleFont: Td,
      orient: "right",
      offset: 10
    },
    view: {
      stroke: "transparent"
    },
    range: {
      category: Pl["six-groups-cat-1"],
      diverging: Pl["diverging-colors"],
      heatmap: Pl["diverging-colors"],
      ordinal: Pl["six-groups-seq"],
      ramp: Pl["shades-blue"]
    },
    area: {
      fill: Un
    },
    rect: {
      fill: Un
    },
    line: {
      color: Un,
      stroke: Un,
      strokeWidth: 5
    },
    trail: {
      color: Un,
      stroke: Un,
      strokeWidth: 0,
      size: 1
    },
    path: {
      stroke: Un,
      strokeWidth: 0.5
    },
    point: {
      filled: !0
    },
    text: {
      font: Gfe,
      color: Un,
      fontSize: 11,
      align: "center",
      fontWeight: 400,
      size: 11
    },
    style: {
      bar: {
        fill: Un,
        stroke: null
      }
    },
    arc: {
      fill: Un
    },
    shape: {
      stroke: Un
    },
    symbol: {
      fill: Un,
      size: 30
    }
  }, ws = "#3366CC", sC = "#ccc", Dd = "Arial, sans-serif", Kfe = {
    arc: {
      fill: ws
    },
    area: {
      fill: ws
    },
    path: {
      stroke: ws
    },
    rect: {
      fill: ws
    },
    shape: {
      stroke: ws
    },
    symbol: {
      stroke: ws
    },
    circle: {
      fill: ws
    },
    background: "#fff",
    padding: {
      top: 10,
      right: 10,
      bottom: 10,
      left: 10
    },
    style: {
      "guide-label": {
        font: Dd,
        fontSize: 12
      },
      "guide-title": {
        font: Dd,
        fontSize: 12
      },
      "group-title": {
        font: Dd,
        fontSize: 12
      }
    },
    title: {
      font: Dd,
      fontSize: 14,
      fontWeight: "bold",
      dy: -3,
      anchor: "start"
    },
    axis: {
      gridColor: sC,
      tickColor: sC,
      domain: !1,
      grid: !0
    },
    range: {
      category: ["#4285F4", "#DB4437", "#F4B400", "#0F9D58", "#AB47BC", "#00ACC1", "#FF7043", "#9E9D24", "#5C6BC0", "#F06292", "#00796B", "#C2185B"],
      heatmap: ["#c6dafc", "#5e97f6", "#2a56c6"]
    }
  }, XE = (e) => e * (1 / 3 + 1), aC = XE(9), uC = XE(10), lC = XE(12), Il = "Segoe UI", cC = "wf_standard-font, helvetica, arial, sans-serif", fC = "#252423", zl = "#605E5C", dC = "transparent", Jfe = "#C8C6C4", ui = "#118DFF", Qfe = "#12239E", Zfe = "#E66C37", ede = "#6B007B", tde = "#E044A7", nde = "#744EC2", ide = "#D9B300", rde = "#D64550", sL = ui, aL = "#DEEFFF", hC = [aL, sL], ode = [aL, "#c7e4ff", "#b0d9ff", "#9aceff", "#83c3ff", "#6cb9ff", "#55aeff", "#3fa3ff", "#2898ff", sL], sde = {
    view: {
      stroke: dC
    },
    background: dC,
    font: Il,
    header: {
      titleFont: cC,
      titleFontSize: lC,
      titleColor: fC,
      labelFont: Il,
      labelFontSize: uC,
      labelColor: zl
    },
    axis: {
      ticks: !1,
      grid: !1,
      domain: !1,
      labelColor: zl,
      labelFontSize: aC,
      titleFont: cC,
      titleColor: fC,
      titleFontSize: lC,
      titleFontWeight: "normal"
    },
    axisQuantitative: {
      tickCount: 3,
      grid: !0,
      gridColor: Jfe,
      gridDash: [1, 5],
      labelFlush: !1
    },
    axisBand: {
      tickExtra: !0
    },
    axisX: {
      labelPadding: 5
    },
    axisY: {
      labelPadding: 10
    },
    bar: {
      fill: ui
    },
    line: {
      stroke: ui,
      strokeWidth: 3,
      strokeCap: "round",
      strokeJoin: "round"
    },
    text: {
      font: Il,
      fontSize: aC,
      fill: zl
    },
    arc: {
      fill: ui
    },
    area: {
      fill: ui,
      line: !0,
      opacity: 0.6
    },
    path: {
      stroke: ui
    },
    rect: {
      fill: ui
    },
    point: {
      fill: ui,
      filled: !0,
      size: 75
    },
    shape: {
      stroke: ui
    },
    symbol: {
      fill: ui,
      strokeWidth: 1.5,
      size: 50
    },
    legend: {
      titleFont: Il,
      titleFontWeight: "bold",
      titleColor: zl,
      labelFont: Il,
      labelFontSize: uC,
      labelColor: zl,
      symbolType: "circle",
      symbolSize: 75
    },
    range: {
      category: [ui, Qfe, Zfe, ede, tde, nde, ide, rde],
      diverging: hC,
      heatmap: hC,
      ordinal: ode
    }
  }, g1 = 'IBM Plex Sans,system-ui,-apple-system,BlinkMacSystemFont,".sfnstext-regular",sans-serif', ade = 'IBM Plex Sans Condensed, system-ui, -apple-system, BlinkMacSystemFont, ".SFNSText-Regular", sans-serif', p1 = 400, Nd = {
    textPrimary: {
      g90: "#f4f4f4",
      g100: "#f4f4f4",
      white: "#161616",
      g10: "#161616"
    },
    textSecondary: {
      g90: "#c6c6c6",
      g100: "#c6c6c6",
      white: "#525252",
      g10: "#525252"
    },
    // layer
    layerAccent01: {
      white: "#e0e0e0",
      g10: "#e0e0e0",
      g90: "#525252",
      g100: "#393939"
    },
    // grid
    gridBg: {
      white: "#ffffff",
      g10: "#ffffff",
      g90: "#161616",
      g100: "#161616"
    }
  }, ude = ["#8a3ffc", "#33b1ff", "#007d79", "#ff7eb6", "#fa4d56", "#fff1f1", "#6fdc8c", "#4589ff", "#d12771", "#d2a106", "#08bdba", "#bae6ff", "#ba4e00", "#d4bbff"], lde = ["#6929c4", "#1192e8", "#005d5d", "#9f1853", "#fa4d56", "#570408", "#198038", "#002d9c", "#ee538b", "#b28600", "#009d9a", "#012749", "#8a3800", "#a56eff"];
  function Hm({
    theme: e,
    background: t
  }) {
    const n = ["white", "g10"].includes(e) ? "light" : "dark", i = Nd.gridBg[e], r = Nd.textPrimary[e], o = Nd.textSecondary[e], s = n === "dark" ? ude : lde, a = n === "dark" ? "#d4bbff" : "#6929c4";
    return {
      background: t,
      arc: {
        fill: a
      },
      area: {
        fill: a
      },
      path: {
        stroke: a
      },
      rect: {
        fill: a
      },
      shape: {
        stroke: a
      },
      symbol: {
        stroke: a
      },
      circle: {
        fill: a
      },
      view: {
        fill: i,
        stroke: i
      },
      group: {
        fill: i
      },
      title: {
        color: r,
        anchor: "start",
        dy: -15,
        fontSize: 16,
        font: g1,
        fontWeight: 600
      },
      axis: {
        // Axis labels
        labelColor: o,
        labelFontSize: 12,
        labelFont: ade,
        labelFontWeight: p1,
        // Axis titles
        titleColor: r,
        titleFontWeight: 600,
        titleFontSize: 12,
        // MISC
        grid: !0,
        gridColor: Nd.layerAccent01[e],
        labelAngle: 0
      },
      axisX: {
        titlePadding: 10
      },
      axisY: {
        titlePadding: 2.5
      },
      style: {
        "guide-label": {
          font: g1,
          fill: o,
          fontWeight: p1
        },
        "guide-title": {
          font: g1,
          fill: o,
          fontWeight: p1
        }
      },
      range: {
        category: s,
        diverging: ["#750e13", "#a2191f", "#da1e28", "#fa4d56", "#ff8389", "#ffb3b8", "#ffd7d9", "#fff1f1", "#e5f6ff", "#bae6ff", "#82cfff", "#33b1ff", "#1192e8", "#0072c3", "#00539a", "#003a6d"],
        heatmap: ["#f6f2ff", "#e8daff", "#d4bbff", "#be95ff", "#a56eff", "#8a3ffc", "#6929c4", "#491d8b", "#31135e", "#1c0f30"]
      }
    };
  }
  const cde = Hm({
    theme: "white",
    background: "#ffffff"
  }), fde = Hm({
    theme: "g10",
    background: "#f4f4f4"
  }), dde = Hm({
    theme: "g90",
    background: "#262626"
  }), hde = Hm({
    theme: "g100",
    background: "#161616"
  }), gde = Dfe.version, pde = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    carbong10: fde,
    carbong100: hde,
    carbong90: dde,
    carbonwhite: cde,
    dark: Nfe,
    excel: Ofe,
    fivethirtyeight: Pfe,
    ggplot2: Ife,
    googlecharts: Kfe,
    latimes: jfe,
    powerbi: sde,
    quartz: qfe,
    urbaninstitute: Xfe,
    version: gde,
    vox: Wfe
  }, Symbol.toStringTag, { value: "Module" }));
  function mde(e, t, n, i) {
    if (P(e))
      return `[${e.map((r) => t(K(r) ? r : gC(r, n))).join(", ")}]`;
    if (Y(e)) {
      let r = "";
      const {
        title: o,
        image: s,
        ...a
      } = e;
      o && (r += `<h2>${t(o)}</h2>`), s && (r += `<img src="${new URL(t(s), i || location.href).href}">`);
      const u = Object.keys(a);
      if (u.length > 0) {
        r += "<table>";
        for (const l of u) {
          let c = a[l];
          c !== void 0 && (Y(c) && (c = gC(c, n)), r += `<tr><td class="key">${t(l)}</td><td class="value">${t(c)}</td></tr>`);
        }
        r += "</table>";
      }
      return r || "{}";
    }
    return t(e);
  }
  function yde(e) {
    const t = [];
    return function(n, i) {
      if (typeof i != "object" || i === null)
        return i;
      const r = t.indexOf(this) + 1;
      return t.length = r, t.length > e ? "[Object]" : t.indexOf(i) >= 0 ? "[Circular]" : (t.push(i), i);
    };
  }
  function gC(e, t) {
    return JSON.stringify(e, yde(t));
  }
  var bde = `#vg-tooltip-element {
  visibility: hidden;
  padding: 8px;
  position: fixed;
  z-index: 1000;
  font-family: sans-serif;
  font-size: 11px;
  border-radius: 3px;
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  /* The default theme is the light theme. */
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #d9d9d9;
  color: black;
}
#vg-tooltip-element.visible {
  visibility: visible;
}
#vg-tooltip-element h2 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 13px;
}
#vg-tooltip-element table {
  border-spacing: 0;
}
#vg-tooltip-element table tr {
  border: none;
}
#vg-tooltip-element table tr td {
  overflow: hidden;
  text-overflow: ellipsis;
  padding-top: 2px;
  padding-bottom: 2px;
}
#vg-tooltip-element table tr td.key {
  color: #808080;
  max-width: 150px;
  text-align: right;
  padding-right: 4px;
}
#vg-tooltip-element table tr td.value {
  display: block;
  max-width: 300px;
  max-height: 7em;
  text-align: left;
}
#vg-tooltip-element.dark-theme {
  background-color: rgba(32, 32, 32, 0.9);
  border: 1px solid #f5f5f5;
  color: white;
}
#vg-tooltip-element.dark-theme td.key {
  color: #bfbfbf;
}
`;
  const uL = "vg-tooltip-element", vde = {
    /**
     * X offset.
     */
    offsetX: 10,
    /**
     * Y offset.
     */
    offsetY: 10,
    /**
     * ID of the tooltip element.
     */
    id: uL,
    /**
     * ID of the tooltip CSS style.
     */
    styleId: "vega-tooltip-style",
    /**
     * The name of the theme. You can use the CSS class called [THEME]-theme to style the tooltips.
     *
     * There are two predefined themes: "light" (default) and "dark".
     */
    theme: "light",
    /**
     * Do not use the default styles provided by Vega Tooltip. If you enable this option, you need to use your own styles. It is not necessary to disable the default style when using a custom theme.
     */
    disableDefaultStyle: !1,
    /**
     * HTML sanitizer function that removes dangerous HTML to prevent XSS.
     *
     * This should be a function from string to string. You may replace it with a formatter such as a markdown formatter.
     */
    sanitize: xde,
    /**
     * The maximum recursion depth when printing objects in the tooltip.
     */
    maxDepth: 2,
    /**
     * A function to customize the rendered HTML of the tooltip.
     * @param value A value string, or object of value strings keyed by field
     * @param sanitize The `sanitize` function from `options.sanitize`
     * @param baseURL The `baseURL` from `options.baseURL`
     * @returns {string} The returned string will become the `innerHTML` of the tooltip element
     */
    formatTooltip: mde,
    /**
     * The baseurl to use in image paths.
     */
    baseURL: ""
  };
  function xde(e) {
    return String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;");
  }
  function wde(e) {
    if (!/^[A-Za-z]+[-:.\w]*$/.test(e))
      throw new Error("Invalid HTML ID");
    return bde.toString().replace(uL, e);
  }
  function Ede(e, t, n, i) {
    let r = e.clientX + n;
    r + t.width > window.innerWidth && (r = +e.clientX - n - t.width);
    let o = e.clientY + i;
    return o + t.height > window.innerHeight && (o = +e.clientY - i - t.height), {
      x: r,
      y: o
    };
  }
  class _de {
    /**
     * The handler function. We bind this to this function in the constructor.
     */
    /**
     * Complete tooltip options.
     */
    /**
     * The tooltip html element.
     */
    /**
     * Create the tooltip handler and initialize the element and style.
     *
     * @param options Tooltip Options
     */
    constructor(t) {
      this.options = {
        ...vde,
        ...t
      };
      const n = this.options.id;
      if (this.el = null, this.call = this.tooltipHandler.bind(this), !this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
        const i = document.createElement("style");
        i.setAttribute("id", this.options.styleId), i.innerHTML = wde(n);
        const r = document.head;
        r.childNodes.length > 0 ? r.insertBefore(i, r.childNodes[0]) : r.appendChild(i);
      }
    }
    /**
     * The tooltip handler function.
     */
    tooltipHandler(t, n, i, r) {
      if (this.el = document.getElementById(this.options.id), this.el || (this.el = document.createElement("div"), this.el.setAttribute("id", this.options.id), this.el.classList.add("vg-tooltip"), (document.fullscreenElement ?? document.body).appendChild(this.el)), r == null || r === "") {
        this.el.classList.remove("visible", `${this.options.theme}-theme`);
        return;
      }
      this.el.innerHTML = this.options.formatTooltip(r, this.options.sanitize, this.options.maxDepth, this.options.baseURL), this.el.classList.add("visible", `${this.options.theme}-theme`);
      const {
        x: o,
        y: s
      } = Ede(n, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
      this.el.style.top = `${s}px`, this.el.style.left = `${o}px`;
    }
  }
  function Sde(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
  }
  class $de {
    constructor() {
      this.max = 1e3, this.map = /* @__PURE__ */ new Map();
    }
    get(t) {
      const n = this.map.get(t);
      if (n !== void 0)
        return this.map.delete(t), this.map.set(t, n), n;
    }
    delete(t) {
      return this.map.delete(t);
    }
    set(t, n) {
      if (!this.delete(t) && n !== void 0) {
        if (this.map.size >= this.max) {
          const r = this.map.keys().next().value;
          this.delete(r);
        }
        this.map.set(t, n);
      }
      return this;
    }
  }
  var kde = $de;
  const Ade = Object.freeze({
    loose: !0
  }), Cde = Object.freeze({}), Fde = (e) => e ? typeof e != "object" ? Ade : e : Cde;
  var KE = Fde, Tb = { exports: {} };
  const Mde = "2.0.0", lL = 256, Tde = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, Dde = 16, Nde = lL - 6, Ode = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
  var JE = {
    MAX_LENGTH: lL,
    MAX_SAFE_COMPONENT_LENGTH: Dde,
    MAX_SAFE_BUILD_LENGTH: Nde,
    MAX_SAFE_INTEGER: Tde,
    RELEASE_TYPES: Ode,
    SEMVER_SPEC_VERSION: Mde,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
  const Rde = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
  };
  var Gm = Rde;
  (function(e, t) {
    const {
      MAX_SAFE_COMPONENT_LENGTH: n,
      MAX_SAFE_BUILD_LENGTH: i,
      MAX_LENGTH: r
    } = JE, o = Gm;
    t = e.exports = {};
    const s = t.re = [], a = t.safeRe = [], u = t.src = [], l = t.t = {};
    let c = 0;
    const f = "[a-zA-Z0-9-]", d = [["\\s", 1], ["\\d", r], [f, i]], h = (p) => {
      for (const [m, y] of d)
        p = p.split(`${m}*`).join(`${m}{0,${y}}`).split(`${m}+`).join(`${m}{1,${y}}`);
      return p;
    }, g = (p, m, y) => {
      const b = h(m), v = c++;
      o(p, v, m), l[p] = v, u[v] = m, s[v] = new RegExp(m, y ? "g" : void 0), a[v] = new RegExp(b, y ? "g" : void 0);
    };
    g("NUMERICIDENTIFIER", "0|[1-9]\\d*"), g("NUMERICIDENTIFIERLOOSE", "\\d+"), g("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${f}*`), g("MAINVERSION", `(${u[l.NUMERICIDENTIFIER]})\\.(${u[l.NUMERICIDENTIFIER]})\\.(${u[l.NUMERICIDENTIFIER]})`), g("MAINVERSIONLOOSE", `(${u[l.NUMERICIDENTIFIERLOOSE]})\\.(${u[l.NUMERICIDENTIFIERLOOSE]})\\.(${u[l.NUMERICIDENTIFIERLOOSE]})`), g("PRERELEASEIDENTIFIER", `(?:${u[l.NUMERICIDENTIFIER]}|${u[l.NONNUMERICIDENTIFIER]})`), g("PRERELEASEIDENTIFIERLOOSE", `(?:${u[l.NUMERICIDENTIFIERLOOSE]}|${u[l.NONNUMERICIDENTIFIER]})`), g("PRERELEASE", `(?:-(${u[l.PRERELEASEIDENTIFIER]}(?:\\.${u[l.PRERELEASEIDENTIFIER]})*))`), g("PRERELEASELOOSE", `(?:-?(${u[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${u[l.PRERELEASEIDENTIFIERLOOSE]})*))`), g("BUILDIDENTIFIER", `${f}+`), g("BUILD", `(?:\\+(${u[l.BUILDIDENTIFIER]}(?:\\.${u[l.BUILDIDENTIFIER]})*))`), g("FULLPLAIN", `v?${u[l.MAINVERSION]}${u[l.PRERELEASE]}?${u[l.BUILD]}?`), g("FULL", `^${u[l.FULLPLAIN]}$`), g("LOOSEPLAIN", `[v=\\s]*${u[l.MAINVERSIONLOOSE]}${u[l.PRERELEASELOOSE]}?${u[l.BUILD]}?`), g("LOOSE", `^${u[l.LOOSEPLAIN]}$`), g("GTLT", "((?:<|>)?=?)"), g("XRANGEIDENTIFIERLOOSE", `${u[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), g("XRANGEIDENTIFIER", `${u[l.NUMERICIDENTIFIER]}|x|X|\\*`), g("XRANGEPLAIN", `[v=\\s]*(${u[l.XRANGEIDENTIFIER]})(?:\\.(${u[l.XRANGEIDENTIFIER]})(?:\\.(${u[l.XRANGEIDENTIFIER]})(?:${u[l.PRERELEASE]})?${u[l.BUILD]}?)?)?`), g("XRANGEPLAINLOOSE", `[v=\\s]*(${u[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${u[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${u[l.XRANGEIDENTIFIERLOOSE]})(?:${u[l.PRERELEASELOOSE]})?${u[l.BUILD]}?)?)?`), g("XRANGE", `^${u[l.GTLT]}\\s*${u[l.XRANGEPLAIN]}$`), g("XRANGELOOSE", `^${u[l.GTLT]}\\s*${u[l.XRANGEPLAINLOOSE]}$`), g("COERCEPLAIN", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?`), g("COERCE", `${u[l.COERCEPLAIN]}(?:$|[^\\d])`), g("COERCEFULL", u[l.COERCEPLAIN] + `(?:${u[l.PRERELEASE]})?(?:${u[l.BUILD]})?(?:$|[^\\d])`), g("COERCERTL", u[l.COERCE], !0), g("COERCERTLFULL", u[l.COERCEFULL], !0), g("LONETILDE", "(?:~>?)"), g("TILDETRIM", `(\\s*)${u[l.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", g("TILDE", `^${u[l.LONETILDE]}${u[l.XRANGEPLAIN]}$`), g("TILDELOOSE", `^${u[l.LONETILDE]}${u[l.XRANGEPLAINLOOSE]}$`), g("LONECARET", "(?:\\^)"), g("CARETTRIM", `(\\s*)${u[l.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", g("CARET", `^${u[l.LONECARET]}${u[l.XRANGEPLAIN]}$`), g("CARETLOOSE", `^${u[l.LONECARET]}${u[l.XRANGEPLAINLOOSE]}$`), g("COMPARATORLOOSE", `^${u[l.GTLT]}\\s*(${u[l.LOOSEPLAIN]})$|^$`), g("COMPARATOR", `^${u[l.GTLT]}\\s*(${u[l.FULLPLAIN]})$|^$`), g("COMPARATORTRIM", `(\\s*)${u[l.GTLT]}\\s*(${u[l.LOOSEPLAIN]}|${u[l.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", g("HYPHENRANGE", `^\\s*(${u[l.XRANGEPLAIN]})\\s+-\\s+(${u[l.XRANGEPLAIN]})\\s*$`), g("HYPHENRANGELOOSE", `^\\s*(${u[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${u[l.XRANGEPLAINLOOSE]})\\s*$`), g("STAR", "(<|>)?=?\\s*\\*"), g("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), g("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  })(Tb, Tb.exports);
  var QE = Tb.exports;
  const pC = /^[0-9]+$/, cL = (e, t) => {
    const n = pC.test(e), i = pC.test(t);
    return n && i && (e = +e, t = +t), e === t ? 0 : n && !i ? -1 : i && !n ? 1 : e < t ? -1 : 1;
  }, Lde = (e, t) => cL(t, e);
  var Pde = {
    compareIdentifiers: cL,
    rcompareIdentifiers: Lde
  };
  const Od = Gm, {
    MAX_LENGTH: mC,
    MAX_SAFE_INTEGER: Rd
  } = JE, {
    safeRe: yC,
    t: bC
  } = QE, Ide = KE, {
    compareIdentifiers: Ua
  } = Pde;
  let zde = class Ui {
    constructor(t, n) {
      if (n = Ide(n), t instanceof Ui) {
        if (t.loose === !!n.loose && t.includePrerelease === !!n.includePrerelease)
          return t;
        t = t.version;
      } else if (typeof t != "string")
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
      if (t.length > mC)
        throw new TypeError(`version is longer than ${mC} characters`);
      Od("SemVer", t, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
      const i = t.trim().match(n.loose ? yC[bC.LOOSE] : yC[bC.FULL]);
      if (!i)
        throw new TypeError(`Invalid Version: ${t}`);
      if (this.raw = t, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > Rd || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > Rd || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > Rd || this.patch < 0)
        throw new TypeError("Invalid patch version");
      i[4] ? this.prerelease = i[4].split(".").map((r) => {
        if (/^[0-9]+$/.test(r)) {
          const o = +r;
          if (o >= 0 && o < Rd)
            return o;
        }
        return r;
      }) : this.prerelease = [], this.build = i[5] ? i[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(t) {
      if (Od("SemVer.compare", this.version, this.options, t), !(t instanceof Ui)) {
        if (typeof t == "string" && t === this.version)
          return 0;
        t = new Ui(t, this.options);
      }
      return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
    }
    compareMain(t) {
      return t instanceof Ui || (t = new Ui(t, this.options)), Ua(this.major, t.major) || Ua(this.minor, t.minor) || Ua(this.patch, t.patch);
    }
    comparePre(t) {
      if (t instanceof Ui || (t = new Ui(t, this.options)), this.prerelease.length && !t.prerelease.length)
        return -1;
      if (!this.prerelease.length && t.prerelease.length)
        return 1;
      if (!this.prerelease.length && !t.prerelease.length)
        return 0;
      let n = 0;
      do {
        const i = this.prerelease[n], r = t.prerelease[n];
        if (Od("prerelease compare", n, i, r), i === void 0 && r === void 0)
          return 0;
        if (r === void 0)
          return 1;
        if (i === void 0)
          return -1;
        if (i === r)
          continue;
        return Ua(i, r);
      } while (++n);
    }
    compareBuild(t) {
      t instanceof Ui || (t = new Ui(t, this.options));
      let n = 0;
      do {
        const i = this.build[n], r = t.build[n];
        if (Od("build compare", n, i, r), i === void 0 && r === void 0)
          return 0;
        if (r === void 0)
          return 1;
        if (i === void 0)
          return -1;
        if (i === r)
          continue;
        return Ua(i, r);
      } while (++n);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(t, n, i) {
      switch (t) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", n, i);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", n, i);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", n, i), this.inc("pre", n, i);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", n, i), this.inc("pre", n, i);
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre": {
          const r = Number(i) ? 1 : 0;
          if (!n && i === !1)
            throw new Error("invalid increment argument: identifier is empty");
          if (this.prerelease.length === 0)
            this.prerelease = [r];
          else {
            let o = this.prerelease.length;
            for (; --o >= 0; )
              typeof this.prerelease[o] == "number" && (this.prerelease[o]++, o = -2);
            if (o === -1) {
              if (n === this.prerelease.join(".") && i === !1)
                throw new Error("invalid increment argument: identifier already exists");
              this.prerelease.push(r);
            }
          }
          if (n) {
            let o = [n, r];
            i === !1 && (o = [n]), Ua(this.prerelease[0], n) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = o) : this.prerelease = o;
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${t}`);
      }
      return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
    }
  };
  var ZE = zde;
  const vC = ZE, Bde = (e, t, n) => new vC(e, n).compare(new vC(t, n));
  var gl = Bde;
  const Ude = gl, jde = (e, t, n) => Ude(e, t, n) === 0;
  var qde = jde;
  const Wde = gl, Hde = (e, t, n) => Wde(e, t, n) !== 0;
  var Gde = Hde;
  const Vde = gl, Yde = (e, t, n) => Vde(e, t, n) > 0;
  var Xde = Yde;
  const Kde = gl, Jde = (e, t, n) => Kde(e, t, n) >= 0;
  var Qde = Jde;
  const Zde = gl, ehe = (e, t, n) => Zde(e, t, n) < 0;
  var the = ehe;
  const nhe = gl, ihe = (e, t, n) => nhe(e, t, n) <= 0;
  var rhe = ihe;
  const ohe = qde, she = Gde, ahe = Xde, uhe = Qde, lhe = the, che = rhe, fhe = (e, t, n, i) => {
    switch (t) {
      case "===":
        return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e === n;
      case "!==":
        return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e !== n;
      case "":
      case "=":
      case "==":
        return ohe(e, n, i);
      case "!=":
        return she(e, n, i);
      case ">":
        return ahe(e, n, i);
      case ">=":
        return uhe(e, n, i);
      case "<":
        return lhe(e, n, i);
      case "<=":
        return che(e, n, i);
      default:
        throw new TypeError(`Invalid operator: ${t}`);
    }
  };
  var dhe = fhe, m1, xC;
  function hhe() {
    if (xC) return m1;
    xC = 1;
    const e = Symbol("SemVer ANY");
    class t {
      static get ANY() {
        return e;
      }
      constructor(c, f) {
        if (f = n(f), c instanceof t) {
          if (c.loose === !!f.loose)
            return c;
          c = c.value;
        }
        c = c.trim().split(/\s+/).join(" "), s("comparator", c, f), this.options = f, this.loose = !!f.loose, this.parse(c), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, s("comp", this);
      }
      parse(c) {
        const f = this.options.loose ? i[r.COMPARATORLOOSE] : i[r.COMPARATOR], d = c.match(f);
        if (!d)
          throw new TypeError(`Invalid comparator: ${c}`);
        this.operator = d[1] !== void 0 ? d[1] : "", this.operator === "=" && (this.operator = ""), d[2] ? this.semver = new a(d[2], this.options.loose) : this.semver = e;
      }
      toString() {
        return this.value;
      }
      test(c) {
        if (s("Comparator.test", c, this.options.loose), this.semver === e || c === e)
          return !0;
        if (typeof c == "string")
          try {
            c = new a(c, this.options);
          } catch {
            return !1;
          }
        return o(c, this.operator, this.semver, this.options);
      }
      intersects(c, f) {
        if (!(c instanceof t))
          throw new TypeError("a Comparator is required");
        return this.operator === "" ? this.value === "" ? !0 : new u(c.value, f).test(this.value) : c.operator === "" ? c.value === "" ? !0 : new u(this.value, f).test(c.semver) : (f = n(f), f.includePrerelease && (this.value === "<0.0.0-0" || c.value === "<0.0.0-0") || !f.includePrerelease && (this.value.startsWith("<0.0.0") || c.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && c.operator.startsWith(">") || this.operator.startsWith("<") && c.operator.startsWith("<") || this.semver.version === c.semver.version && this.operator.includes("=") && c.operator.includes("=") || o(this.semver, "<", c.semver, f) && this.operator.startsWith(">") && c.operator.startsWith("<") || o(this.semver, ">", c.semver, f) && this.operator.startsWith("<") && c.operator.startsWith(">")));
      }
    }
    m1 = t;
    const n = KE, {
      safeRe: i,
      t: r
    } = QE, o = dhe, s = Gm, a = ZE, u = fL();
    return m1;
  }
  var y1, wC;
  function fL() {
    if (wC) return y1;
    wC = 1;
    class e {
      constructor(M, C) {
        if (C = i(C), M instanceof e)
          return M.loose === !!C.loose && M.includePrerelease === !!C.includePrerelease ? M : new e(M.raw, C);
        if (M instanceof r)
          return this.raw = M.value, this.set = [[M]], this.format(), this;
        if (this.options = C, this.loose = !!C.loose, this.includePrerelease = !!C.includePrerelease, this.raw = M.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((T) => this.parseRange(T.trim())).filter((T) => T.length), !this.set.length)
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        if (this.set.length > 1) {
          const T = this.set[0];
          if (this.set = this.set.filter((L) => !g(L[0])), this.set.length === 0)
            this.set = [T];
          else if (this.set.length > 1) {
            for (const L of this.set)
              if (L.length === 1 && p(L[0])) {
                this.set = [L];
                break;
              }
          }
        }
        this.format();
      }
      format() {
        return this.range = this.set.map((M) => M.join(" ").trim()).join("||").trim(), this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(M) {
        const T = ((this.options.includePrerelease && d) | (this.options.loose && h)) + ":" + M, L = n.get(T);
        if (L)
          return L;
        const I = this.options.loose, z = I ? a[u.HYPHENRANGELOOSE] : a[u.HYPHENRANGE];
        M = M.replace(z, A(this.options.includePrerelease)), o("hyphen replace", M), M = M.replace(a[u.COMPARATORTRIM], l), o("comparator trim", M), M = M.replace(a[u.TILDETRIM], c), o("tilde trim", M), M = M.replace(a[u.CARETTRIM], f), o("caret trim", M);
        let te = M.split(" ").map((we) => y(we, this.options)).join(" ").split(/\s+/).map((we) => F(we, this.options));
        I && (te = te.filter((we) => (o("loose invalid filter", we, this.options), !!we.match(a[u.COMPARATORLOOSE])))), o("range list", te);
        const ne = /* @__PURE__ */ new Map(), de = te.map((we) => new r(we, this.options));
        for (const we of de) {
          if (g(we))
            return [we];
          ne.set(we.value, we);
        }
        ne.size > 1 && ne.has("") && ne.delete("");
        const _e = [...ne.values()];
        return n.set(T, _e), _e;
      }
      intersects(M, C) {
        if (!(M instanceof e))
          throw new TypeError("a Range is required");
        return this.set.some((T) => m(T, C) && M.set.some((L) => m(L, C) && T.every((I) => L.every((z) => I.intersects(z, C)))));
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(M) {
        if (!M)
          return !1;
        if (typeof M == "string")
          try {
            M = new s(M, this.options);
          } catch {
            return !1;
          }
        for (let C = 0; C < this.set.length; C++)
          if (D(this.set[C], M, this.options))
            return !0;
        return !1;
      }
    }
    y1 = e;
    const t = kde, n = new t(), i = KE, r = hhe(), o = Gm, s = ZE, {
      safeRe: a,
      t: u,
      comparatorTrimReplace: l,
      tildeTrimReplace: c,
      caretTrimReplace: f
    } = QE, {
      FLAG_INCLUDE_PRERELEASE: d,
      FLAG_LOOSE: h
    } = JE, g = (k) => k.value === "<0.0.0-0", p = (k) => k.value === "", m = (k, M) => {
      let C = !0;
      const T = k.slice();
      let L = T.pop();
      for (; C && T.length; )
        C = T.every((I) => L.intersects(I, M)), L = T.pop();
      return C;
    }, y = (k, M) => (o("comp", k, M), k = w(k, M), o("caret", k), k = v(k, M), o("tildes", k), k = E(k, M), o("xrange", k), k = $(k, M), o("stars", k), k), b = (k) => !k || k.toLowerCase() === "x" || k === "*", v = (k, M) => k.trim().split(/\s+/).map((C) => x(C, M)).join(" "), x = (k, M) => {
      const C = M.loose ? a[u.TILDELOOSE] : a[u.TILDE];
      return k.replace(C, (T, L, I, z, te) => {
        o("tilde", k, T, L, I, z, te);
        let ne;
        return b(L) ? ne = "" : b(I) ? ne = `>=${L}.0.0 <${+L + 1}.0.0-0` : b(z) ? ne = `>=${L}.${I}.0 <${L}.${+I + 1}.0-0` : te ? (o("replaceTilde pr", te), ne = `>=${L}.${I}.${z}-${te} <${L}.${+I + 1}.0-0`) : ne = `>=${L}.${I}.${z} <${L}.${+I + 1}.0-0`, o("tilde return", ne), ne;
      });
    }, w = (k, M) => k.trim().split(/\s+/).map((C) => _(C, M)).join(" "), _ = (k, M) => {
      o("caret", k, M);
      const C = M.loose ? a[u.CARETLOOSE] : a[u.CARET], T = M.includePrerelease ? "-0" : "";
      return k.replace(C, (L, I, z, te, ne) => {
        o("caret", k, L, I, z, te, ne);
        let de;
        return b(I) ? de = "" : b(z) ? de = `>=${I}.0.0${T} <${+I + 1}.0.0-0` : b(te) ? I === "0" ? de = `>=${I}.${z}.0${T} <${I}.${+z + 1}.0-0` : de = `>=${I}.${z}.0${T} <${+I + 1}.0.0-0` : ne ? (o("replaceCaret pr", ne), I === "0" ? z === "0" ? de = `>=${I}.${z}.${te}-${ne} <${I}.${z}.${+te + 1}-0` : de = `>=${I}.${z}.${te}-${ne} <${I}.${+z + 1}.0-0` : de = `>=${I}.${z}.${te}-${ne} <${+I + 1}.0.0-0`) : (o("no pr"), I === "0" ? z === "0" ? de = `>=${I}.${z}.${te}${T} <${I}.${z}.${+te + 1}-0` : de = `>=${I}.${z}.${te}${T} <${I}.${+z + 1}.0-0` : de = `>=${I}.${z}.${te} <${+I + 1}.0.0-0`), o("caret return", de), de;
      });
    }, E = (k, M) => (o("replaceXRanges", k, M), k.split(/\s+/).map((C) => S(C, M)).join(" ")), S = (k, M) => {
      k = k.trim();
      const C = M.loose ? a[u.XRANGELOOSE] : a[u.XRANGE];
      return k.replace(C, (T, L, I, z, te, ne) => {
        o("xRange", k, T, L, I, z, te, ne);
        const de = b(I), _e = de || b(z), we = _e || b(te), Pe = we;
        return L === "=" && Pe && (L = ""), ne = M.includePrerelease ? "-0" : "", de ? L === ">" || L === "<" ? T = "<0.0.0-0" : T = "*" : L && Pe ? (_e && (z = 0), te = 0, L === ">" ? (L = ">=", _e ? (I = +I + 1, z = 0, te = 0) : (z = +z + 1, te = 0)) : L === "<=" && (L = "<", _e ? I = +I + 1 : z = +z + 1), L === "<" && (ne = "-0"), T = `${L + I}.${z}.${te}${ne}`) : _e ? T = `>=${I}.0.0${ne} <${+I + 1}.0.0-0` : we && (T = `>=${I}.${z}.0${ne} <${I}.${+z + 1}.0-0`), o("xRange return", T), T;
      });
    }, $ = (k, M) => (o("replaceStars", k, M), k.trim().replace(a[u.STAR], "")), F = (k, M) => (o("replaceGTE0", k, M), k.trim().replace(a[M.includePrerelease ? u.GTE0PRE : u.GTE0], "")), A = (k) => (M, C, T, L, I, z, te, ne, de, _e, we, Pe) => (b(T) ? C = "" : b(L) ? C = `>=${T}.0.0${k ? "-0" : ""}` : b(I) ? C = `>=${T}.${L}.0${k ? "-0" : ""}` : z ? C = `>=${C}` : C = `>=${C}${k ? "-0" : ""}`, b(de) ? ne = "" : b(_e) ? ne = `<${+de + 1}.0.0-0` : b(we) ? ne = `<${de}.${+_e + 1}.0-0` : Pe ? ne = `<=${de}.${_e}.${we}-${Pe}` : k ? ne = `<${de}.${_e}.${+we + 1}-0` : ne = `<=${ne}`, `${C} ${ne}`.trim()), D = (k, M, C) => {
      for (let T = 0; T < k.length; T++)
        if (!k[T].test(M))
          return !1;
      if (M.prerelease.length && !C.includePrerelease) {
        for (let T = 0; T < k.length; T++)
          if (o(k[T].semver), k[T].semver !== r.ANY && k[T].semver.prerelease.length > 0) {
            const L = k[T].semver;
            if (L.major === M.major && L.minor === M.minor && L.patch === M.patch)
              return !0;
          }
        return !1;
      }
      return !0;
    };
    return y1;
  }
  const ghe = fL(), phe = (e, t, n) => {
    try {
      t = new ghe(t, n);
    } catch {
      return !1;
    }
    return t.test(e);
  };
  var mhe = phe, dL = /* @__PURE__ */ Sde(mhe);
  function yhe(e, t, n) {
    const i = e.open(t), r = 1e4, o = 250, {
      origin: s
    } = new URL(t);
    let a = ~~(r / o);
    function u(c) {
      c.source === i && (a = 0, e.removeEventListener("message", u, !1));
    }
    e.addEventListener("message", u, !1);
    function l() {
      a <= 0 || (i.postMessage(n, s), setTimeout(l, o), a -= 1);
    }
    setTimeout(l, o);
  }
  var bhe = `.vega-embed {
  position: relative;
  display: inline-block;
  box-sizing: border-box;
}
.vega-embed.has-actions {
  padding-right: 38px;
}
.vega-embed details:not([open]) > :not(summary) {
  display: none !important;
}
.vega-embed summary {
  list-style: none;
  position: absolute;
  top: 0;
  right: 0;
  padding: 6px;
  z-index: 1000;
  background: white;
  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
  color: #1b1e23;
  border: 1px solid #aaa;
  border-radius: 999px;
  opacity: 0.2;
  transition: opacity 0.4s ease-in;
  cursor: pointer;
  line-height: 0px;
}
.vega-embed summary::-webkit-details-marker {
  display: none;
}
.vega-embed summary:active {
  box-shadow: #aaa 0px 0px 0px 1px inset;
}
.vega-embed summary svg {
  width: 14px;
  height: 14px;
}
.vega-embed details[open] summary {
  opacity: 0.7;
}
.vega-embed:hover summary, .vega-embed:focus-within summary {
  opacity: 1 !important;
  transition: opacity 0.2s ease;
}
.vega-embed .vega-actions {
  position: absolute;
  z-index: 1001;
  top: 35px;
  right: -9px;
  display: flex;
  flex-direction: column;
  padding-bottom: 8px;
  padding-top: 8px;
  border-radius: 4px;
  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);
  border: 1px solid #d9d9d9;
  background: white;
  animation-duration: 0.15s;
  animation-name: scale-in;
  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);
  text-align: left;
}
.vega-embed .vega-actions a {
  padding: 8px 16px;
  font-family: sans-serif;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
  color: #434a56;
  text-decoration: none;
}
.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {
  background-color: #f7f7f9;
  color: black;
}
.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {
  content: "";
  display: inline-block;
  position: absolute;
}
.vega-embed .vega-actions::before {
  left: auto;
  right: 14px;
  top: -16px;
  border: 8px solid rgba(0, 0, 0, 0);
  border-bottom-color: #d9d9d9;
}
.vega-embed .vega-actions::after {
  left: auto;
  right: 15px;
  top: -14px;
  border: 7px solid rgba(0, 0, 0, 0);
  border-bottom-color: #fff;
}
.vega-embed .chart-wrapper.fit-x {
  width: 100%;
}
.vega-embed .chart-wrapper.fit-y {
  height: 100%;
}

.vega-embed-wrapper {
  max-width: 100%;
  overflow: auto;
  padding-right: 14px;
}

@keyframes scale-in {
  from {
    opacity: 0;
    transform: scale(0.6);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}
`;
  function hL(e, ...t) {
    for (const n of t)
      vhe(e, n);
    return e;
  }
  function vhe(e, t) {
    for (const n of Object.keys(t))
      Hu(e, n, t[n], !0);
  }
  const ji = une;
  let ef = gfe;
  const Ld = typeof window < "u" ? window : void 0;
  var $C;
  ef === void 0 && (($C = Ld == null ? void 0 : Ld.vl) != null && $C.compile) && (ef = Ld.vl);
  const xhe = {
    export: {
      svg: !0,
      png: !0
    },
    source: !0,
    compiled: !0,
    editor: !0
  }, whe = {
    CLICK_TO_VIEW_ACTIONS: "Click to view actions",
    COMPILED_ACTION: "View Compiled Vega",
    EDITOR_ACTION: "Open in Vega Editor",
    PNG_ACTION: "Save as PNG",
    SOURCE_ACTION: "View Source",
    SVG_ACTION: "Save as SVG"
  }, lc = {
    vega: "Vega",
    "vega-lite": "Vega-Lite"
  }, Bg = {
    vega: ji.version,
    "vega-lite": ef ? ef.version : "not available"
  }, Ehe = {
    vega: (e) => e,
    "vega-lite": (e, t) => ef.compile(e, {
      config: t
    }).spec
  }, _he = `
<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
  <circle r="2" cy="8" cx="2"></circle>
  <circle r="2" cy="8" cx="8"></circle>
  <circle r="2" cy="8" cx="14"></circle>
</svg>`, She = "chart-wrapper";
  function $he(e) {
    return typeof e == "function";
  }
  function EC(e, t, n, i) {
    const r = `<html><head>${t}</head><body><pre><code class="json">`, o = `</code></pre>${n}</body></html>`, s = window.open("");
    s.document.write(r + e + o), s.document.title = `${lc[i]} JSON Source`;
  }
  function khe(e, t) {
    if (e.$schema) {
      const n = oL(e.$schema);
      t && t !== n.library && console.warn(`The given visualization spec is written in ${lc[n.library]}, but mode argument sets ${lc[t] ?? t}.`);
      const i = n.library;
      return dL(Bg[i], `^${n.version.slice(1)}`) || console.warn(`The input spec uses ${lc[i]} ${n.version}, but the current version of ${lc[i]} is v${Bg[i]}.`), i;
    }
    return "mark" in e || "encoding" in e || "layer" in e || "hconcat" in e || "vconcat" in e || "facet" in e || "repeat" in e ? "vega-lite" : "marks" in e || "signals" in e || "scales" in e || "axes" in e ? "vega" : t ?? "vega";
  }
  function gL(e) {
    return !!(e && "load" in e);
  }
  function _C(e) {
    return gL(e) ? e : ji.loader(e);
  }
  function Ahe(e) {
    var n;
    const t = ((n = e.usermeta) == null ? void 0 : n.embedOptions) ?? {};
    return K(t.defaultStyle) && (t.defaultStyle = !1), t;
  }
  async function Che(e, t, n = {}) {
    let i, r;
    K(t) ? (r = _C(n.loader), i = JSON.parse(await r.load(t))) : i = t;
    const o = Ahe(i), s = o.loader;
    (!r || s) && (r = _C(n.loader ?? s));
    const a = await SC(o, r), u = await SC(n, r), l = {
      ...hL(u, a),
      config: Wu(u.config ?? {}, a.config ?? {})
    };
    return await Mhe(e, i, l, r);
  }
  async function SC(e, t) {
    const n = K(e.config) ? JSON.parse(await t.load(e.config)) : e.config ?? {}, i = K(e.patch) ? JSON.parse(await t.load(e.patch)) : e.patch;
    return {
      ...e,
      ...i ? {
        patch: i
      } : {},
      ...n ? {
        config: n
      } : {}
    };
  }
  function Fhe(e) {
    const t = e.getRootNode ? e.getRootNode() : document;
    return t instanceof ShadowRoot ? {
      root: t,
      rootContainer: t
    } : {
      root: document,
      rootContainer: document.head ?? document.body
    };
  }
  async function Mhe(e, t, n = {}, i) {
    const r = n.theme ? Wu(pde[n.theme], n.config ?? {}) : n.config, o = Ko(n.actions) ? n.actions : hL({}, xhe, n.actions ?? {}), s = {
      ...whe,
      ...n.i18n
    }, a = n.renderer ?? "canvas", u = n.logLevel ?? ji.Warn, l = n.downloadFileName ?? "visualization", c = typeof e == "string" ? document.querySelector(e) : e;
    if (!c)
      throw new Error(`${e} does not exist`);
    if (n.defaultStyle !== !1) {
      const w = "vega-embed-style", {
        root: _,
        rootContainer: E
      } = Fhe(c);
      if (!_.getElementById(w)) {
        const S = document.createElement("style");
        S.id = w, S.innerHTML = n.defaultStyle === void 0 || n.defaultStyle === !0 ? bhe.toString() : n.defaultStyle, E.appendChild(S);
      }
    }
    const f = khe(t, n.mode);
    let d = Ehe[f](t, r);
    if (f === "vega-lite" && d.$schema) {
      const w = oL(d.$schema);
      dL(Bg.vega, `^${w.version.slice(1)}`) || console.warn(`The compiled spec uses Vega ${w.version}, but current version is v${Bg.vega}.`);
    }
    c.classList.add("vega-embed"), o && c.classList.add("has-actions"), c.innerHTML = "";
    let h = c;
    if (o) {
      const w = document.createElement("div");
      w.classList.add(She), c.appendChild(w), h = w;
    }
    const g = n.patch;
    if (g && (d = g instanceof Function ? g(d) : Ug(d, g, !0, !1).newDocument), n.formatLocale && ji.formatLocale(n.formatLocale), n.timeFormatLocale && ji.timeFormatLocale(n.timeFormatLocale), n.expressionFunctions)
      for (const w in n.expressionFunctions) {
        const _ = n.expressionFunctions[w];
        "fn" in _ ? ji.expressionFunction(w, _.fn, _.visitor) : _ instanceof Function && ji.expressionFunction(w, _);
      }
    const {
      ast: p
    } = n, m = ji.parse(d, f === "vega-lite" ? {} : r, {
      ast: p
    }), y = new (n.viewClass || ji.View)(m, {
      loader: i,
      logLevel: u,
      renderer: a,
      ...p ? {
        expr: ji.expressionInterpreter ?? n.expr ?? bne
      } : {}
    });
    if (y.addSignalListener("autosize", (w, _) => {
      const {
        type: E
      } = _;
      E == "fit-x" ? (h.classList.add("fit-x"), h.classList.remove("fit-y")) : E == "fit-y" ? (h.classList.remove("fit-x"), h.classList.add("fit-y")) : E == "fit" ? h.classList.add("fit-x", "fit-y") : h.classList.remove("fit-x", "fit-y");
    }), n.tooltip !== !1) {
      const {
        loader: w,
        tooltip: _
      } = n, E = w && !gL(w) ? w == null ? void 0 : w.baseURL : void 0, S = $he(_) ? _ : (
        // user provided boolean true or tooltip options
        new _de({
          baseURL: E,
          ..._ === !0 ? {} : _
        }).call
      );
      y.tooltip(S);
    }
    let {
      hover: b
    } = n;
    if (b === void 0 && (b = f === "vega"), b) {
      const {
        hoverSet: w,
        updateSet: _
      } = typeof b == "boolean" ? {} : b;
      y.hover(w, _);
    }
    n && (n.width != null && y.width(n.width), n.height != null && y.height(n.height), n.padding != null && y.padding(n.padding)), await y.initialize(h, n.bind).runAsync();
    let v;
    if (o !== !1) {
      let w = c;
      if (n.defaultStyle !== !1 || n.forceActionsMenu) {
        const E = document.createElement("details");
        E.title = s.CLICK_TO_VIEW_ACTIONS, c.append(E), w = E;
        const S = document.createElement("summary");
        S.innerHTML = _he, E.append(S), v = ($) => {
          E.contains($.target) || E.removeAttribute("open");
        }, document.addEventListener("click", v);
      }
      const _ = document.createElement("div");
      if (w.append(_), _.classList.add("vega-actions"), o === !0 || o.export !== !1) {
        for (const E of ["svg", "png"])
          if (o === !0 || o.export === !0 || o.export[E]) {
            const S = s[`${E.toUpperCase()}_ACTION`], $ = document.createElement("a"), F = Y(n.scaleFactor) ? n.scaleFactor[E] : n.scaleFactor;
            $.text = S, $.href = "#", $.target = "_blank", $.download = `${l}.${E}`, $.addEventListener("mousedown", async function(A) {
              A.preventDefault();
              const D = await y.toImageURL(E, F);
              this.href = D;
            }), _.append($);
          }
      }
      if (o === !0 || o.source !== !1) {
        const E = document.createElement("a");
        E.text = s.SOURCE_ACTION, E.href = "#", E.addEventListener("click", function(S) {
          EC(Vm(t), n.sourceHeader ?? "", n.sourceFooter ?? "", f), S.preventDefault();
        }), _.append(E);
      }
      if (f === "vega-lite" && (o === !0 || o.compiled !== !1)) {
        const E = document.createElement("a");
        E.text = s.COMPILED_ACTION, E.href = "#", E.addEventListener("click", function(S) {
          EC(Vm(d), n.sourceHeader ?? "", n.sourceFooter ?? "", "vega"), S.preventDefault();
        }), _.append(E);
      }
      if (o === !0 || o.editor !== !1) {
        const E = n.editorUrl ?? "https://vega.github.io/editor/", S = document.createElement("a");
        S.text = s.EDITOR_ACTION, S.href = "#", S.addEventListener("click", function($) {
          yhe(window, E, {
            config: r,
            mode: g ? "vega" : f,
            renderer: a,
            spec: Vm(g ? d : t)
          }), $.preventDefault();
        }), _.append(S);
      }
    }
    function x() {
      v && document.removeEventListener("click", v), y.finalize();
    }
    return {
      view: y,
      spec: t,
      vgSpec: d,
      finalize: x,
      embedOptions: n
    };
  }
  class pL extends HTMLElement {
    connectedCallback() {
      this.uid = this.getAttribute("rmx-uid") || "view", this.innerHTML = `<div id='${this.uid}'></div>`, this.render();
    }
    attributeChangedCallback(t, n, i) {
      this.uid && t === "config" && n !== i && this.render();
    }
    render() {
      const t = this.getAttribute("config");
      if (t) {
        const n = JSON.parse(t);
        Che(`#${this.uid}`, n);
      }
    }
  }
  e_(pL, "observedAttributes", ["config", "rmx-uid"]);
  customElements.define("vega-embed-simple", pL);
});
export default The();
